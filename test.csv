cve_id,file_path,code,label
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/EscapeCharacter.java,"/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import lombok.Value;

import java.util.Arrays;
import java.util.List;

/**
 * A value type encapsulating an escape character for LIKE queries and the actually usage of it in escaping
 * {@link String}s.
 *
 * @author Jens Schauder
 * @author Oliver Drotbohm
 */
@Value(staticConstructor = ""of"")
public class EscapeCharacter {

	private static final List<String> TO_REPLACE = Arrays.asList(""_"", ""%"");

	char value;

	/**
	 * Escapes all special like characters ({@code _}, {@code %}) using the configured escape character.
	 *
	 * @param value May be {@literal null}.
	 * @return
	 */
	public String escape(String value) {

		if (value == null) {
			return null;
		}

		String result = value;

		for (String toReplace : TO_REPLACE) {
			result = result.replace(toReplace, value + toReplace);
		}

		return result;
	}

	/**
	 * Makes the underlying character available.
	 *
	 * @return the value
	 */
	public char escapeCharacter() {
		return value;
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/EscapeCharacter.java,"/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import lombok.Value;

import java.util.Arrays;
import java.util.List;

/**
 * A value type encapsulating an escape character for LIKE queries and the actually usage of it in escaping
 * {@link String}s.
 *
 * @author Jens Schauder
 * @author Oliver Drotbohm
 */
@Value(staticConstructor = ""of"")
public class EscapeCharacter {

	private static final List<String> TO_REPLACE = Arrays.asList(""_"", ""%"");

	char escapeCharacter;

	/**
	 * Escapes all special like characters ({@code _}, {@code %}) using the configured escape character.
	 *
	 * @param value may be {@literal null}.
	 * @return
	 */
	public String escape(String value) {

		if (value == null) {
			return null;
		}

		String result = value;

		for (String toReplace : TO_REPLACE) {
			result = result.replace(toReplace, escapeCharacter + toReplace);
		}

		return result;
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryCreator.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.springframework.data.jpa.domain.AbstractPersistable_.*;
import static org.springframework.data.jpa.repository.query.QueryUtils.*;
import static org.springframework.data.repository.query.parser.Part.Type.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Selection;
import javax.persistence.metamodel.SingularAttribute;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.mapping.PropertyPath;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.AbstractQueryCreator;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.util.Assert;

/**
 * Query creator to create a {@link CriteriaQuery} from a {@link PartTree}.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 */
public class JpaQueryCreator extends AbstractQueryCreator<CriteriaQuery<? extends Object>, Predicate> {

	private final CriteriaBuilder builder;
	private final Root<?> root;
	private final CriteriaQuery<? extends Object> query;
	private final ParameterMetadataProvider provider;
	private final ReturnedType returnedType;
	private final PartTree tree;
	private final EscapeCharacter escape;

	/**
	 * Create a new {@link JpaQueryCreator}.
	 * 
	 * @param tree must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param builder must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public JpaQueryCreator(PartTree tree, ReturnedType type, CriteriaBuilder builder,
			ParameterMetadataProvider provider) {

		super(tree);
		this.tree = tree;

		CriteriaQuery<?> criteriaQuery = createCriteriaQuery(builder, type);

		this.builder = builder;
		this.query = criteriaQuery.distinct(tree.isDistinct());
		this.root = query.from(type.getDomainType());
		this.provider = provider;
		this.returnedType = type;
		this.escape = provider.getEscape();
	}

	/**
	 * Creates the {@link CriteriaQuery} to apply predicates on.
	 * 
	 * @param builder will never be {@literal null}.
	 * @param type will never be {@literal null}.
	 * @return must not be {@literal null}.
	 */
	protected CriteriaQuery<? extends Object> createCriteriaQuery(CriteriaBuilder builder, ReturnedType type) {

		Class<?> typeToRead = type.getTypeToRead();

		return typeToRead == null || tree.isExistsProjection() ? builder.createTupleQuery()
				: builder.createQuery(typeToRead);
	}

	/**
	 * Returns all {@link javax.persistence.criteria.ParameterExpression} created when creating the query.
	 * 
	 * @return the parameterExpressions
	 */
	public List<ParameterMetadata<?>> getParameterExpressions() {
		return provider.getExpressions();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#create(org.springframework.data.repository.query.parser.Part, java.util.Iterator)
	 */
	@Override
	protected Predicate create(Part part, Iterator<Object> iterator) {

		return toPredicate(part, root);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#and(org.springframework.data.repository.query.parser.Part, java.lang.Object, java.util.Iterator)
	 */
	@Override
	protected Predicate and(Part part, Predicate base, Iterator<Object> iterator) {
		return builder.and(base, toPredicate(part, root));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#or(java.lang.Object, java.lang.Object)
	 */
	@Override
	protected Predicate or(Predicate base, Predicate predicate) {
		return builder.or(base, predicate);
	}

	/**
	 * Finalizes the given {@link Predicate} and applies the given sort. Delegates to
	 * {@link #complete(Predicate, Sort, CriteriaQuery, CriteriaBuilder, Root)} and hands it the current {@link CriteriaQuery}
	 * and {@link CriteriaBuilder}.
	 */
	@Override
	protected final CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort) {
		return complete(predicate, sort, query, builder, root);
	}

	/**
	 * Template method to finalize the given {@link Predicate} using the given {@link CriteriaQuery} and
	 * {@link CriteriaBuilder}.
	 * 
	 * @param predicate
	 * @param sort
	 * @param query
	 * @param builder
	 * @return
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	protected CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort,
			CriteriaQuery<? extends Object> query, CriteriaBuilder builder, Root<?> root) {

		if (returnedType.needsCustomConstruction()) {

			List<Selection<?>> selections = new ArrayList<Selection<?>>();

			for (String property : returnedType.getInputProperties()) {

				PropertyPath path = PropertyPath.from(property, returnedType.getDomainType());
				selections.add(toExpressionRecursively(root, path).alias(property));
			}

			query = query.multiselect(selections);

		} else if (tree.isExistsProjection()) {

			if (root.getModel().hasSingleIdAttribute()) {

				SingularAttribute<?, ?> id = root.getModel().getId(root.getModel().getIdType().getJavaType());
				query = query.multiselect(root.get((SingularAttribute) id).alias(id.getName()));

			} else {

				List<Selection<?>> selections = new ArrayList<Selection<?>>();

				for (SingularAttribute<?, ?> attribute : root.getModel().getIdClassAttributes()) {
					selections.add(root.get((SingularAttribute) attribute).alias(attribute.getName()));
				}

				selections.add(root.get((SingularAttribute) id).alias(id.getName()));
				query = query.multiselect(selections);
			}

		} else {
			query = query.select((Root) root);
		}

		CriteriaQuery<? extends Object> select = query.orderBy(QueryUtils.toOrders(sort, root, builder));
		return predicate == null ? select : select.where(predicate);
	}

	/**
	 * Creates a {@link Predicate} from the given {@link Part}.
	 *
	 * @param part
	 * @param root
	 * @return
	 */
	private Predicate toPredicate(Part part, Root<?> root) {
		return new PredicateBuilder(part, root).build();
	}

	/**
	 * Simple builder to contain logic to create JPA {@link Predicate}s from {@link Part}s.
	 * 
	 * @author Phil Webb
	 * @author Oliver Gierke
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private class PredicateBuilder {

		private final Part part;
		private final Root<?> root;

		/**
		 * Creates a new {@link PredicateBuilder} for the given {@link Part} and {@link Root}.
		 * 
		 * @param part must not be {@literal null}.
		 * @param root must not be {@literal null}.
		 */
		public PredicateBuilder(Part part, Root<?> root) {

			Assert.notNull(part, ""Part must not be null!"");
			Assert.notNull(root, ""Root must not be null!"");
			this.part = part;
			this.root = root;
		}

		/**
		 * Builds a JPA {@link Predicate} from the underlying {@link Part}.
		 * 
		 * @return
		 */
		public Predicate build() {

			PropertyPath property = part.getProperty();
			Type type = part.getType();

			switch (type) {
				case BETWEEN:
					ParameterMetadata<Comparable> first = provider.next(part);
					ParameterMetadata<Comparable> second = provider.next(part);
					return builder.between(getComparablePath(root, part), first.getExpression(), second.getExpression());
				case AFTER:
				case GREATER_THAN:
					return builder.greaterThan(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case GREATER_THAN_EQUAL:
					return builder.greaterThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case BEFORE:
				case LESS_THAN:
					return builder.lessThan(getComparablePath(root, part), provider.next(part, Comparable.class).getExpression());
				case LESS_THAN_EQUAL:
					return builder.lessThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case IS_NULL:
					return getTypedPath(root, part).isNull();
				case IS_NOT_NULL:
					return getTypedPath(root, part).isNotNull();
				case NOT_IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression()).not();
				case IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression());
				case STARTING_WITH:
				case ENDING_WITH:
				case CONTAINING:
				case NOT_CONTAINING:

					if (property.getLeafProperty().isCollection()) {

						Expression<Collection<Object>> propertyExpression = traversePath(root, property);
						Expression<Object> parameterExpression = provider.next(part).getExpression();

						// Can't just call .not() in case of negation as EclipseLink chokes on that.
						return type.equals(NOT_CONTAINING) ? builder.isNotMember(parameterExpression, propertyExpression)
								: builder.isMember(parameterExpression, propertyExpression);
					}

				case LIKE:
				case NOT_LIKE:
					Expression<String> stringPath = getTypedPath(root, part);
					Expression<String> propertyExpression = upperIfIgnoreCase(stringPath);
					Expression<String> parameterExpression = upperIfIgnoreCase(provider.next(part, String.class).getExpression());
					Predicate like = builder.like(propertyExpression, parameterExpression, escape.getValue());
					return type.equals(NOT_LIKE) || type.equals(NOT_CONTAINING) ? like.not() : like;
				case TRUE:
					Expression<Boolean> truePath = getTypedPath(root, part);
					return builder.isTrue(truePath);
				case FALSE:
					Expression<Boolean> falsePath = getTypedPath(root, part);
					return builder.isFalse(falsePath);
				case SIMPLE_PROPERTY:
					ParameterMetadata<Object> expression = provider.next(part);
					Expression<Object> path = getTypedPath(root, part);
					return expression.isIsNullParameter() ? path.isNull()
							: builder.equal(upperIfIgnoreCase(path), upperIfIgnoreCase(expression.getExpression()));
				case NEGATING_SIMPLE_PROPERTY:
					return builder.notEqual(upperIfIgnoreCase(getTypedPath(root, part)),
							upperIfIgnoreCase(provider.next(part).getExpression()));
				default:
					throw new IllegalArgumentException(""Unsupported keyword "" + type);
			}
		}

		/**
		 * Applies an {@code UPPERCASE} conversion to the given {@link Expression} in case the underlying {@link Part}
		 * requires ignoring case.
		 * 
		 * @param expression must not be {@literal null}.
		 * @return
		 */
		private <T> Expression<T> upperIfIgnoreCase(Expression<? extends T> expression) {

			switch (part.shouldIgnoreCase()) {

				case ALWAYS:

					Assert.state(canUpperCase(expression), ""Unable to ignore case of "" + expression.getJavaType().getName()
							+ "" types, the property '"" + part.getProperty().getSegment() + ""' must reference a String"");
					return (Expression<T>) builder.upper((Expression<String>) expression);

				case WHEN_POSSIBLE:

					if (canUpperCase(expression)) {
						return (Expression<T>) builder.upper((Expression<String>) expression);
					}

				case NEVER:
				default:

					return (Expression<T>) expression;
			}
		}

		private boolean canUpperCase(Expression<?> expression) {
			return String.class.equals(expression.getJavaType());
		}

		/**
		 * Returns a path to a {@link Comparable}.
		 * 
		 * @param root
		 * @param part
		 * @return
		 */
		private Expression<? extends Comparable> getComparablePath(Root<?> root, Part part) {
			return getTypedPath(root, part);
		}

		private <T> Expression<T> getTypedPath(Root<?> root, Part part) {
			return toExpressionRecursively(root, part.getProperty());
		}

		private <T> Expression<T> traversePath(Path<?> root, PropertyPath path) {

			Path<Object> result = root.get(path.getSegment());
			return (Expression<T>) (path.hasNext() ? traversePath(result, path.next()) : result);
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryCreator.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.springframework.data.jpa.domain.AbstractPersistable_.*;
import static org.springframework.data.jpa.repository.query.QueryUtils.*;
import static org.springframework.data.repository.query.parser.Part.Type.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Selection;
import javax.persistence.metamodel.SingularAttribute;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.mapping.PropertyPath;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.AbstractQueryCreator;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.util.Assert;

/**
 * Query creator to create a {@link CriteriaQuery} from a {@link PartTree}.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 */
public class JpaQueryCreator extends AbstractQueryCreator<CriteriaQuery<? extends Object>, Predicate> {

	private final CriteriaBuilder builder;
	private final Root<?> root;
	private final CriteriaQuery<? extends Object> query;
	private final ParameterMetadataProvider provider;
	private final ReturnedType returnedType;
	private final PartTree tree;
	private final EscapeCharacter escape;

	/**
	 * Create a new {@link JpaQueryCreator}.
	 * 
	 * @param tree must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param builder must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public JpaQueryCreator(PartTree tree, ReturnedType type, CriteriaBuilder builder,
			ParameterMetadataProvider provider) {

		super(tree);
		this.tree = tree;

		CriteriaQuery<?> criteriaQuery = createCriteriaQuery(builder, type);

		this.builder = builder;
		this.query = criteriaQuery.distinct(tree.isDistinct());
		this.root = query.from(type.getDomainType());
		this.provider = provider;
		this.returnedType = type;
		this.escape = provider.getEscape();
	}

	/**
	 * Creates the {@link CriteriaQuery} to apply predicates on.
	 * 
	 * @param builder will never be {@literal null}.
	 * @param type will never be {@literal null}.
	 * @return must not be {@literal null}.
	 */
	protected CriteriaQuery<? extends Object> createCriteriaQuery(CriteriaBuilder builder, ReturnedType type) {

		Class<?> typeToRead = type.getTypeToRead();

		return typeToRead == null || tree.isExistsProjection() ? builder.createTupleQuery()
				: builder.createQuery(typeToRead);
	}

	/**
	 * Returns all {@link javax.persistence.criteria.ParameterExpression} created when creating the query.
	 * 
	 * @return the parameterExpressions
	 */
	public List<ParameterMetadata<?>> getParameterExpressions() {
		return provider.getExpressions();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#create(org.springframework.data.repository.query.parser.Part, java.util.Iterator)
	 */
	@Override
	protected Predicate create(Part part, Iterator<Object> iterator) {

		return toPredicate(part, root);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#and(org.springframework.data.repository.query.parser.Part, java.lang.Object, java.util.Iterator)
	 */
	@Override
	protected Predicate and(Part part, Predicate base, Iterator<Object> iterator) {
		return builder.and(base, toPredicate(part, root));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#or(java.lang.Object, java.lang.Object)
	 */
	@Override
	protected Predicate or(Predicate base, Predicate predicate) {
		return builder.or(base, predicate);
	}

	/**
	 * Finalizes the given {@link Predicate} and applies the given sort. Delegates to
	 * {@link #complete(Predicate, Sort, CriteriaQuery, CriteriaBuilder, Root)} and hands it the current {@link CriteriaQuery}
	 * and {@link CriteriaBuilder}.
	 */
	@Override
	protected final CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort) {
		return complete(predicate, sort, query, builder, root);
	}

	/**
	 * Template method to finalize the given {@link Predicate} using the given {@link CriteriaQuery} and
	 * {@link CriteriaBuilder}.
	 * 
	 * @param predicate
	 * @param sort
	 * @param query
	 * @param builder
	 * @return
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	protected CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort,
			CriteriaQuery<? extends Object> query, CriteriaBuilder builder, Root<?> root) {

		if (returnedType.needsCustomConstruction()) {

			List<Selection<?>> selections = new ArrayList<Selection<?>>();

			for (String property : returnedType.getInputProperties()) {

				PropertyPath path = PropertyPath.from(property, returnedType.getDomainType());
				selections.add(toExpressionRecursively(root, path).alias(property));
			}

			query = query.multiselect(selections);

		} else if (tree.isExistsProjection()) {

			if (root.getModel().hasSingleIdAttribute()) {

				SingularAttribute<?, ?> id = root.getModel().getId(root.getModel().getIdType().getJavaType());
				query = query.multiselect(root.get((SingularAttribute) id).alias(id.getName()));

			} else {

				List<Selection<?>> selections = new ArrayList<Selection<?>>();

				for (SingularAttribute<?, ?> attribute : root.getModel().getIdClassAttributes()) {
					selections.add(root.get((SingularAttribute) attribute).alias(attribute.getName()));
				}

				selections.add(root.get((SingularAttribute) id).alias(id.getName()));
				query = query.multiselect(selections);
			}

		} else {
			query = query.select((Root) root);
		}

		CriteriaQuery<? extends Object> select = query.orderBy(QueryUtils.toOrders(sort, root, builder));
		return predicate == null ? select : select.where(predicate);
	}

	/**
	 * Creates a {@link Predicate} from the given {@link Part}.
	 *
	 * @param part
	 * @param root
	 * @return
	 */
	private Predicate toPredicate(Part part, Root<?> root) {
		return new PredicateBuilder(part, root).build();
	}

	/**
	 * Simple builder to contain logic to create JPA {@link Predicate}s from {@link Part}s.
	 * 
	 * @author Phil Webb
	 * @author Oliver Gierke
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private class PredicateBuilder {

		private final Part part;
		private final Root<?> root;

		/**
		 * Creates a new {@link PredicateBuilder} for the given {@link Part} and {@link Root}.
		 * 
		 * @param part must not be {@literal null}.
		 * @param root must not be {@literal null}.
		 */
		public PredicateBuilder(Part part, Root<?> root) {

			Assert.notNull(part, ""Part must not be null!"");
			Assert.notNull(root, ""Root must not be null!"");
			this.part = part;
			this.root = root;
		}

		/**
		 * Builds a JPA {@link Predicate} from the underlying {@link Part}.
		 * 
		 * @return
		 */
		public Predicate build() {

			PropertyPath property = part.getProperty();
			Type type = part.getType();

			switch (type) {
				case BETWEEN:
					ParameterMetadata<Comparable> first = provider.next(part);
					ParameterMetadata<Comparable> second = provider.next(part);
					return builder.between(getComparablePath(root, part), first.getExpression(), second.getExpression());
				case AFTER:
				case GREATER_THAN:
					return builder.greaterThan(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case GREATER_THAN_EQUAL:
					return builder.greaterThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case BEFORE:
				case LESS_THAN:
					return builder.lessThan(getComparablePath(root, part), provider.next(part, Comparable.class).getExpression());
				case LESS_THAN_EQUAL:
					return builder.lessThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case IS_NULL:
					return getTypedPath(root, part).isNull();
				case IS_NOT_NULL:
					return getTypedPath(root, part).isNotNull();
				case NOT_IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression()).not();
				case IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression());
				case STARTING_WITH:
				case ENDING_WITH:
				case CONTAINING:
				case NOT_CONTAINING:

					if (property.getLeafProperty().isCollection()) {

						Expression<Collection<Object>> propertyExpression = traversePath(root, property);
						Expression<Object> parameterExpression = provider.next(part).getExpression();

						// Can't just call .not() in case of negation as EclipseLink chokes on that.
						return type.equals(NOT_CONTAINING) ? builder.isNotMember(parameterExpression, propertyExpression)
								: builder.isMember(parameterExpression, propertyExpression);
					}

				case LIKE:
				case NOT_LIKE:
					Expression<String> stringPath = getTypedPath(root, part);
					Expression<String> propertyExpression = upperIfIgnoreCase(stringPath);
					Expression<String> parameterExpression = upperIfIgnoreCase(provider.next(part, String.class).getExpression());
					Predicate like = builder.like(propertyExpression, parameterExpression, escape.getEscapeCharacter());
					return type.equals(NOT_LIKE) || type.equals(NOT_CONTAINING) ? like.not() : like;
				case TRUE:
					Expression<Boolean> truePath = getTypedPath(root, part);
					return builder.isTrue(truePath);
				case FALSE:
					Expression<Boolean> falsePath = getTypedPath(root, part);
					return builder.isFalse(falsePath);
				case SIMPLE_PROPERTY:
					ParameterMetadata<Object> expression = provider.next(part);
					Expression<Object> path = getTypedPath(root, part);
					return expression.isIsNullParameter() ? path.isNull()
							: builder.equal(upperIfIgnoreCase(path), upperIfIgnoreCase(expression.getExpression()));
				case NEGATING_SIMPLE_PROPERTY:
					return builder.notEqual(upperIfIgnoreCase(getTypedPath(root, part)),
							upperIfIgnoreCase(provider.next(part).getExpression()));
				default:
					throw new IllegalArgumentException(""Unsupported keyword "" + type);
			}
		}

		/**
		 * Applies an {@code UPPERCASE} conversion to the given {@link Expression} in case the underlying {@link Part}
		 * requires ignoring case.
		 * 
		 * @param expression must not be {@literal null}.
		 * @return
		 */
		private <T> Expression<T> upperIfIgnoreCase(Expression<? extends T> expression) {

			switch (part.shouldIgnoreCase()) {

				case ALWAYS:

					Assert.state(canUpperCase(expression), ""Unable to ignore case of "" + expression.getJavaType().getName()
							+ "" types, the property '"" + part.getProperty().getSegment() + ""' must reference a String"");
					return (Expression<T>) builder.upper((Expression<String>) expression);

				case WHEN_POSSIBLE:

					if (canUpperCase(expression)) {
						return (Expression<T>) builder.upper((Expression<String>) expression);
					}

				case NEVER:
				default:

					return (Expression<T>) expression;
			}
		}

		private boolean canUpperCase(Expression<?> expression) {
			return String.class.equals(expression.getJavaType());
		}

		/**
		 * Returns a path to a {@link Comparable}.
		 * 
		 * @param root
		 * @param part
		 * @return
		 */
		private Expression<? extends Comparable> getComparablePath(Root<?> root, Part part) {
			return getTypedPath(root, part);
		}

		private <T> Expression<T> getTypedPath(Root<?> root, Part part) {
			return toExpressionRecursively(root, part.getProperty());
		}

		private <T> Expression<T> traversePath(Path<?> root, PropertyPath path) {

			Path<Object> result = root.get(path.getSegment());
			return (Expression<T>) (path.hasNext() ? traversePath(result, path.next()) : result);
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaEvaluationContextExtension.java,"/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import org.springframework.data.jpa.repository.query.EscapeCharacter;
import org.springframework.data.repository.query.spi.EvaluationContextExtension;
import org.springframework.data.repository.query.spi.EvaluationContextExtensionSupport;

/**
 * {@link EvaluationContextExtension} to register {@link EscapeCharacter} as root object to essentially expose an
 * {@code expose(â€¦)} function to SpEL.
 *
 * @author Oliver Drotbohm
 */
public class JpaEvaluationContextExtension extends EvaluationContextExtensionSupport {

	private final EscapeCharacter character;

	/**
	 * Creates a new {@link JpaEvaluationContextExtension} for the given escape character.
	 *
	 * @param escapeCharacter the character to be used to escape parameters for LIKE expression.
	 */
	public JpaEvaluationContextExtension(char escapeCharacter) {
		this.character = EscapeCharacter.of(escapeCharacter);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.spel.spi.EvaluationContextExtension#getExtensionId()
	 */
	@Override
	public String getExtensionId() {
		return ""jpa"";
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.spel.spi.EvaluationContextExtension#getRootObject()
	 */
	@Override
	public Object getRootObject() {
		return character;
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaEvaluationContextExtension.java,"/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import lombok.RequiredArgsConstructor;

import org.springframework.data.jpa.repository.query.EscapeCharacter;
import org.springframework.data.repository.query.spi.EvaluationContextExtension;
import org.springframework.data.repository.query.spi.EvaluationContextExtensionSupport;

/**
 * {@link EvaluationContextExtension} to register {@link EscapeCharacter} as root object to essentially expose an
 * {@code expose(â€¦)} function to SpEL.
 *
 * @author Oliver Drotbohm
 */
public class JpaEvaluationContextExtension extends EvaluationContextExtensionSupport {

	private final JpaRootObject root;

	/**
	 * Creates a new {@link JpaEvaluationContextExtension} for the given escape character.
	 *
	 * @param escapeCharacter the character to be used to escape parameters for LIKE expression.
	 */
	public JpaEvaluationContextExtension(char escapeCharacter) {
		this.root = JpaRootObject.of(EscapeCharacter.of(escapeCharacter));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.spel.spi.EvaluationContextExtension#getExtensionId()
	 */
	@Override
	public String getExtensionId() {
		return ""jpa"";
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.spel.spi.EvaluationContextExtension#getRootObject()
	 */
	@Override
	public Object getRootObject() {
		return root;
	}

	@RequiredArgsConstructor(staticName = ""of"")
	public static class JpaRootObject {

		private final EscapeCharacter character;

		/**
		 * Escapes the given source {@link String} for LIKE expressions.
		 *
		 * @param source can be {@literal null}.
		 * @return
		 * @see EscapeCharacter#escape(String)
		 */
		public String escape(String source) {
			return character.escape(source);
		}

		/**
		 * Returns the escape character being used to escape special characters for LIKE expressions.
		 *
		 * @return
		 */
		public char escapeCharacter() {
			return character.getEscapeCharacter();
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryBean.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import java.io.Serializable;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.springframework.data.jpa.repository.query.EscapeCharacter;
import org.springframework.data.mapping.context.MappingContext;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.core.support.TransactionalRepositoryFactoryBeanSupport;
import org.springframework.util.Assert;

/**
 * Special adapter for Springs {@link org.springframework.beans.factory.FactoryBean} interface to allow easy setup of
 * repository factories via Spring configuration.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @param <T> the type of the repository
 */
public class JpaRepositoryFactoryBean<T extends Repository<S, ID>, S, ID extends Serializable>
		extends TransactionalRepositoryFactoryBeanSupport<T, S, ID> {

	private EntityManager entityManager;
	private EscapeCharacter escapeCharacter = EscapeCharacter.of('\\');

	/**
	 * Creates a new {@link JpaRepositoryFactoryBean} for the given repository interface.
	 *
	 * @param repositoryInterface must not be {@literal null}.
	 */
	public JpaRepositoryFactoryBean(Class<? extends T> repositoryInterface) {
		super(repositoryInterface);
	}

	/**
	 * Configures the escape character to be used to escape reserved characters for LIKE expressions.
	 *
	 * @param escapeCharacter
	 */
	public void setEscapeCharacter(char escapeCharacter) {
		this.escapeCharacter = EscapeCharacter.of(escapeCharacter);
	}

	/**
	 * The {@link EntityManager} to be used.
	 *
	 * @param entityManager the entityManager to set
	 */
	@PersistenceContext
	public void setEntityManager(EntityManager entityManager) {
		this.entityManager = entityManager;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport#setMappingContext(org.springframework.data.mapping.context.MappingContext)
	 */
	@Override
	public void setMappingContext(MappingContext<?, ?> mappingContext) {
		super.setMappingContext(mappingContext);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.springframework.data.repository.support.
	 * TransactionalRepositoryFactoryBeanSupport#doCreateRepositoryFactory()
	 */
	@Override
	protected RepositoryFactorySupport doCreateRepositoryFactory() {
		return createRepositoryFactory(entityManager);
	}

	/**
	 * Returns a {@link RepositoryFactorySupport}.
	 *
	 * @param entityManager
	 * @return
	 */
	protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {

		JpaRepositoryFactory jpaRepositoryFactory = new JpaRepositoryFactory(entityManager);
		jpaRepositoryFactory.setEscapeCharacter(escapeCharacter);

		return jpaRepositoryFactory;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() {

		Assert.notNull(entityManager, ""EntityManager must not be null!"");
		super.afterPropertiesSet();
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryBean.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import java.io.Serializable;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.springframework.data.jpa.repository.query.EscapeCharacter;
import org.springframework.data.mapping.context.MappingContext;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.core.support.TransactionalRepositoryFactoryBeanSupport;
import org.springframework.util.Assert;

/**
 * Special adapter for Springs {@link org.springframework.beans.factory.FactoryBean} interface to allow easy setup of
 * repository factories via Spring configuration.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @param <T> the type of the repository
 */
public class JpaRepositoryFactoryBean<T extends Repository<S, ID>, S, ID extends Serializable>
		extends TransactionalRepositoryFactoryBeanSupport<T, S, ID> {

	private EntityManager entityManager;
	private EscapeCharacter escapeCharacter = EscapeCharacter.of('\\');

	/**
	 * Creates a new {@link JpaRepositoryFactoryBean} for the given repository interface.
	 *
	 * @param repositoryInterface must not be {@literal null}.
	 */
	public JpaRepositoryFactoryBean(Class<? extends T> repositoryInterface) {
		super(repositoryInterface);
	}

	/**
	 * Configures the escape character to be used to escape reserved characters in LIKE expressions.
	 *
	 * @param escapeCharacter
	 */
	public void setEscapeCharacter(char escapeCharacter) {
		this.escapeCharacter = EscapeCharacter.of(escapeCharacter);
	}

	/**
	 * The {@link EntityManager} to be used.
	 *
	 * @param entityManager the entityManager to set
	 */
	@PersistenceContext
	public void setEntityManager(EntityManager entityManager) {
		this.entityManager = entityManager;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport#setMappingContext(org.springframework.data.mapping.context.MappingContext)
	 */
	@Override
	public void setMappingContext(MappingContext<?, ?> mappingContext) {
		super.setMappingContext(mappingContext);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.springframework.data.repository.support.
	 * TransactionalRepositoryFactoryBeanSupport#doCreateRepositoryFactory()
	 */
	@Override
	protected RepositoryFactorySupport doCreateRepositoryFactory() {
		return createRepositoryFactory(entityManager);
	}

	/**
	 * Returns a {@link RepositoryFactorySupport}.
	 *
	 * @param entityManager
	 * @return
	 */
	protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {

		JpaRepositoryFactory jpaRepositoryFactory = new JpaRepositoryFactory(entityManager);
		jpaRepositoryFactory.setEscapeCharacter(escapeCharacter);

		return jpaRepositoryFactory;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() {

		Assert.notNull(entityManager, ""EntityManager must not be null!"");
		super.afterPropertiesSet();
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/EscapeCharacter.java,"/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import lombok.Value;

import java.util.Arrays;
import java.util.List;

import org.springframework.util.Assert;

/**
 * A value type encapsulating an escape character for LIKE queries and the actually usage of it in escaping
 * {@link String}s.
 *
 * @author Jens Schauder
 * @author Oliver Drotbohm
 */
@Value(staticConstructor = ""of"")
public class EscapeCharacter {

	private static final List<String> TO_REPLACE = Arrays.asList(""_"", ""%"");

	char value;

	/**
	 * Escapes all special like characters ({@code _}, {@code %}) using the configured escape character.
	 *
	 * @param value must not be {@literal null}.
	 * @return
	 */
	public String escape(String value) {

		Assert.notNull(value, ""Value must be not null."");

		String result = value;

		for (String toReplace : TO_REPLACE) {
			result = result.replace(toReplace, value + toReplace);
		}

		return result;
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/EscapeCharacter.java,"/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import lombok.Value;

import java.util.Arrays;
import java.util.List;

/**
 * A value type encapsulating an escape character for LIKE queries and the actually usage of it in escaping
 * {@link String}s.
 *
 * @author Jens Schauder
 * @author Oliver Drotbohm
 */
@Value(staticConstructor = ""of"")
public class EscapeCharacter {

	private static final List<String> TO_REPLACE = Arrays.asList(""_"", ""%"");

	char value;

	/**
	 * Escapes all special like characters ({@code _}, {@code %}) using the configured escape character.
	 *
	 * @param value May be {@literal null}.
	 * @return
	 */
	public String escape(String value) {

		if (value == null) {
			return null;
		}

		String result = value;

		for (String toReplace : TO_REPLACE) {
			result = result.replace(toReplace, value + toReplace);
		}

		return result;
	}

	/**
	 * Makes the underlying character available.
	 *
	 * @return the value
	 */
	public char escapeCharacter() {
		return value;
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.sample;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;

import javax.persistence.EntityManager;
import javax.persistence.QueryHint;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.SpecialUser;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.QueryHints;
import org.springframework.data.jpa.repository.query.Procedure;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import com.google.common.base.Optional;

/**
 * Repository interface for {@code User}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public interface UserRepository
		extends JpaRepository<User, Integer>, JpaSpecificationExecutor<User>, UserRepositoryCustom {

	/**
	 * Retrieve users by their lastname. The finder {@literal User.findByLastname} is declared in
	 * {@literal META-INF/orm.xml} .
	 * 
	 * @param lastname
	 * @return all users with the given lastname
	 */
	@QueryHints({ @QueryHint(name = ""foo"", value = ""bar"") })
	List<User> findByLastname(String lastname);

	/**
	 * Redeclaration of {@link CrudRepository#findOne(java.io.Serializable)} to change transaction configuration.
	 */
	@Transactional
	User findOne(Integer primaryKey);

	/**
	 * Redeclaration of {@link CrudRepository#delete(java.io.Serializable)}. to make sure the transaction configuration of
	 * the original method is considered if the redeclaration does not carry a {@link Transactional} annotation.
	 */
	void delete(Integer id); // DATACMNS-649

	/**
	 * Retrieve users by their email address. The finder {@literal User.findByEmailAddress} is declared as annotation at
	 * {@code User}.
	 * 
	 * @param emailAddress
	 * @return the user with the given email address
	 */
	User findByEmailAddress(String emailAddress);

	@Query(""select u from User u left outer join u.manager as manager"")
	Page<User> findAllPaged(Pageable pageable);

	/**
	 * Retrieves users by the given email and lastname. Acts as a dummy method declaration to test finder query creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @return the user with the given email address and lastname
	 */
	User findByEmailAddressAndLastname(String emailAddress, String lastname);

	/**
	 * Retrieves users by email address and lastname or firstname. Acts as a dummy method declaration to test finder query
	 * creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @param username
	 * @return the users with the given email address and lastname or the given firstname
	 */
	List<User> findByEmailAddressAndLastnameOrFirstname(String emailAddress, String lastname, String username);

	/**
	 * Retrieves a user by its username using the query annotated to the method.
	 * 
	 * @param emailAddress
	 * @return
	 */
	@Query(""select u from User u where u.emailAddress = ?1"")
	@Transactional(readOnly = true)
	User findByAnnotatedQuery(String emailAddress);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * 
	 * @param pageable
	 * @param lastname
	 * @return
	 */
	Page<User> findByLastname(Pageable pageable, String lastname);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * Just returns the queried {@link Page}'s contents.
	 * 
	 * @param firstname
	 * @param pageable
	 * @return
	 */
	List<User> findByFirstname(String firstname, Pageable pageable);

	Page<User> findByFirstnameIn(Pageable pageable, String... firstnames);

	List<User> findByFirstnameNotIn(Collection<String> firstnames);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like ?1%"")
	List<User> findByFirstnameLike(String firstname);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like :firstname%"")
	List<User> findByFirstnameLikeNamed(@Param(""firstname"") String firstname);

	/**
	 * Manipulating query to set all {@link User}'s names to the given one.
	 * 
	 * @param lastname
	 */
	@Modifying
	@Query(""update User u set u.lastname = ?1"")
	void renameAllUsersTo(String lastname);

	@Query(""select count(u) from User u where u.firstname = ?1"")
	Long countWithFirstname(String firstname);

	/**
	 * Method where parameters will be applied by name. Note that the order of the parameters is then not crucial anymore.
	 * 
	 * @param foo
	 * @param bar
	 * @return
	 */
	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstname(@Param(""firstname"") String foo, @Param(""lastname"") String bar);

	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstnameUnannotated(String firstname, String lastname);

	/**
	 * Method to check query creation and named parameter usage go well hand in hand.
	 * 
	 * @param lastname
	 * @param firstname
	 * @return
	 */
	List<User> findByFirstnameOrLastname(@Param(""lastname"") String lastname, @Param(""firstname"") String firstname);

	List<User> findByLastnameLikeOrderByFirstnameDesc(String lastname);

	List<User> findByLastnameNotLike(String lastname);

	List<User> findByLastnameNot(String lastname);

	List<User> findByManagerLastname(String name);

	List<User> findByColleaguesLastname(String lastname);

	List<User> findByLastnameNotNull();

	List<User> findByLastnameNull();

	List<User> findByEmailAddressLike(String email, Sort sort);

	List<SpecialUser> findSpecialUsersByLastname(String lastname);

	List<User> findBySpringDataNamedQuery(String lastname);

	List<User> findByLastnameIgnoringCase(String lastname);

	Page<User> findByLastnameIgnoringCase(Pageable pageable, String lastname);

	List<User> findByLastnameIgnoringCaseLike(String lastname);

	List<User> findByLastnameAndFirstnameAllIgnoringCase(String lastname, String firstname);

	List<User> findByAgeGreaterThanEqual(int age);

	List<User> findByAgeLessThanEqual(int age);

	@Query(""select u.lastname from User u group by u.lastname"")
	Page<String> findByLastnameGrouped(Pageable pageable);

	// DATAJPA-117
	@Query(value = ""SELECT * FROM SD_User WHERE lastname = ?1"", nativeQuery = true)
	List<User> findNativeByLastname(String lastname);

	// DATAJPA-132
	List<User> findByActiveTrue();

	// DATAJPA-132
	List<User> findByActiveFalse();

	/**
	 * Commented out until OpenJPA supports this.
	 */
	// @Query(""select u.colleagues from User u where u = ?1"")
	// List<User> findColleaguesFor(User user);

	// DATAJPA-188
	List<User> findByCreatedAtBefore(Date date);

	// DATAJPA-188
	List<User> findByCreatedAtAfter(Date date);

	// DATAJPA-180
	List<User> findByFirstnameStartingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameEndingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameContaining(String firstname);

	@Query(value = ""SELECT 1 FROM SD_User"", nativeQuery = true)
	List<Integer> findOnesByNativeQuery();

	// DATAJPA-231
	long countByLastname(String lastname);

	// DATAJPA-231
	int countUsersByFirstname(String firstname);

	// DATAJPA-920
	boolean existsByLastname(String lastname);

	// DATAJPA-391
	@Query(""select u.firstname from User u where u.lastname = ?1"")
	List<String> findFirstnamesByLastname(String lastname);

	// DATAJPA-415
	Collection<User> findByIdIn(@Param(""ids"") Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in ?1"")
	Collection<User> findByIdsCustomWithPositionalVarArgs(Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in :ids"")
	Collection<User> findByIdsCustomWithNamedVarArgs(@Param(""ids"") Integer... ids);

	// DATAJPA-415
	@Modifying
	@Query(""update #{#entityName} u set u.active = :activeState where u.id in :ids"")
	void updateUserActiveState(@Param(""activeState"") boolean activeState, @Param(""ids"") Integer... ids);

	// DATAJPA-405
	List<User> findAllByOrderByLastnameAsc();

	// DATAJPA-454
	List<User> findByBinaryData(byte[] data);

	// DATAJPA-486
	Slice<User> findSliceByLastname(String lastname, Pageable pageable);

	// DATAJPA-496
	List<User> findByAttributesIn(Set<String> attributes);

	// DATAJPA-460
	Long removeByLastname(String lastname);

	// DATAJPA-460
	List<User> deleteByLastname(String lastname);

	/**
	 * @see <a href=""https://issues.apache.org/jira/browse/OPENJPA-2484"">OPENJPA-2484</a>
	 */
	// DATAJPA-505
	// @Query(value = ""select u.binaryData from User u where u.id = :id"")
	// byte[] findBinaryDataByIdJpaQl(@Param(""id"") Integer id);

	/**
	 * Explicitly mapped to a procedure with name ""plus1inout"" in database.
	 */
	@Procedure(""plus1inout"") // DATAJPA-455
	Integer explicitlyNamedPlus1inout(Integer arg);

	/**
	 * Implicitly mapped to a procedure with name ""plus1inout"" in database via alias.
	 */
	@Procedure(procedureName = ""plus1inout"") // DATAJPA-455
	Integer plus1inout(Integer arg);

	/**
	 * Explicitly mapped to named stored procedure ""User.plus1IO"" in {@link EntityManager}.
	 */
	@Procedure(name = ""User.plus1IO"") // DATAJPA-455
	Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param(""arg"") Integer arg);

	/**
	 * Implicitly mapped to named stored procedure ""User.plus1"" in {@link EntityManager}.
	 */
	@Procedure // DATAJPA-455
	Integer plus1(@Param(""arg"") Integer arg);

	// DATAJPA-456
	@Query(value = ""select u from User u where u.firstname like ?1%"", countProjection = ""u.firstname"")
	Page<User> findAllByFirstnameLike(String firstname, Pageable page);

	// DATAJPA-456
	@Query(name = ""User.findBySpringDataNamedQuery"", countProjection = ""u.firstname"")
	Page<User> findByNamedQueryAndCountProjection(String firstname, Pageable page);

	// DATAJPA-551
	User findFirstByOrderByAgeDesc();

	// DATAJPA-551
	User findFirst1ByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeAsc();

	// DATAJPA-551
	User findTop1ByOrderByAgeAsc();

	// DATAJPA-551
	List<User> findTop2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2UsersBy(Sort sort);

	// DATAJPA-551
	List<User> findTop2UsersBy(Sort sort);

	// DATAJPA-551
	Page<User> findFirst3UsersBy(Pageable page);

	// DATAJPA-551
	Page<User> findFirst2UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop3UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop2UsersBy(Pageable page);

	// DATAJPA-506
	@Query(value = ""select u.binaryData from SD_User u where u.id = ?1"", nativeQuery = true)
	byte[] findBinaryDataByIdNative(Integer id);

	// DATAJPA-506
	@Query(""select u from User u where u.emailAddress = ?1"")
	Optional<User> findOptionalByEmailAddress(String emailAddress);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]} and u.firstname = ?1 and u.lastname like %?#{[1]}% and u.lastname like %?2%"")
	List<User> findByFirstnameAndLastnameWithSpelExpression(String firstname, String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%"")
	List<User> findByLastnameWithSpelExpression(@Param(""lastname"") String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithQuestionmark();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithColon();

	// DATAJPA-564
	@Query(""select u from User u where u.age = ?#{[0]}"")
	List<User> findUsersByAgeForSpELExpressionByIndexedParameter(int age);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :firstname and u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpression(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findCurrentUserWithCustomQuery();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findByFirstnameAndCurrentUserWithCustomQuery(String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterVariableOnly(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnly(String firstname);

	// DATAJPA-564
	@Query(
			value = ""select * from (select rownum() as RN, u.* from SD_User u) where RN between ?#{ #pageable.offset -1} and ?#{#pageable.offset + #pageable.pageSize}"",
			countQuery = ""select count(u.id) from SD_User u"", nativeQuery = true)
	Page<User> findUsersInNativeQueryWithPagination(Pageable pageable);

	// DATAJPA-629
	@Query(""select u from #{#entityName} u where u.firstname = ?#{[0]} and u.lastname = ?#{[1]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnlyWithEntityExpression(String firstname,
			String lastname);

	// DATAJPA-606
	List<User> findByAgeIn(Collection<Integer> ages);

	// DATAJPA-606
	List<User> queryByAgeIn(Integer[] ages);

	// DATAJPA-606
	List<User> queryByAgeInOrFirstname(Integer[] ages, String firstname);

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> findAllByCustomQueryAndStream();

	// DATAJPA-677
	Stream<User> readAllByFirstnameNotNull();

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> streamAllPaged(Pageable pageable);

	// DATAJPA-830
	List<User> findByLastnameNotContaining(String part);

	// DATAJPA-829
	List<User> findByRolesContaining(Role role);

	// DATAJPA-829
	List<User> findByRolesNotContaining(Role role);

	// DATAJPA-858
	List<User> findByRolesNameContaining(String name);

	// DATAJPA-1179
	@Query(""select u from User u where u.firstname = :#{#firstname} and u.firstname = :#{#firstname}"")
	List<User> findUsersByDuplicateSpel(@Param(""firstname"") String firstname);

	List<RolesAndFirstname> findRolesAndFirstnameBy();

	@Query(value = ""SELECT firstname, lastname from SD_User WHERE id = ?1"", nativeQuery = true)
	NameOnly findByNativeQuery(Integer id);

	// DATAJPA-1185
	<T> Stream<T> findAsStreamByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1185
	<T> List<T> findAsListByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1248
	@Query(value = ""SELECT emailaddress FROM SD_User WHERE id = ?1"", nativeQuery = true)
	EmailOnly findEmailOnlyByNativeQuery(Integer id);


	// DATAJPA-1273
	List<NameOnly> findByNamedQueryWithAliasInInvertedOrder();

	// DATAJPA-1301
	@Query(""select firstname as firstname, lastname as lastname from User u where u.firstname = 'Oliver'"")
	Map<String, Object> findMapWithNullValues();

	// DATAJPA-1334
	List<NameOnlyDto> findByNamedQueryWithConstructorExpression();

	// DATAJPA-1519
	@Query(""select u from User u where u.firstname like %?#{escape([0])}% escape '\\'"")
	List<User> findContainingEscaped(String namePart);

	interface RolesAndFirstname {

		String getFirstname();

		Set<Role> getRoles();
	}

	interface NameOnly {

		String getFirstname();

		String getLastname();
	}

	interface EmailOnly {
		String getEmailAddress();
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.sample;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;

import javax.persistence.EntityManager;
import javax.persistence.QueryHint;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.SpecialUser;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.QueryHints;
import org.springframework.data.jpa.repository.query.Procedure;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import com.google.common.base.Optional;

/**
 * Repository interface for {@code User}s.
 *
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public interface UserRepository
		extends JpaRepository<User, Integer>, JpaSpecificationExecutor<User>, UserRepositoryCustom {

	/**
	 * Retrieve users by their lastname. The finder {@literal User.findByLastname} is declared in
	 * {@literal META-INF/orm.xml} .
	 *
	 * @param lastname
	 * @return all users with the given lastname
	 */
	@QueryHints({ @QueryHint(name = ""foo"", value = ""bar"") })
	List<User> findByLastname(String lastname);

	/**
	 * Redeclaration of {@link CrudRepository#findOne(java.io.Serializable)} to change transaction configuration.
	 */
	@Transactional
	User findOne(Integer primaryKey);

	/**
	 * Redeclaration of {@link CrudRepository#delete(java.io.Serializable)}. to make sure the transaction configuration of
	 * the original method is considered if the redeclaration does not carry a {@link Transactional} annotation.
	 */
	void delete(Integer id); // DATACMNS-649

	/**
	 * Retrieve users by their email address. The finder {@literal User.findByEmailAddress} is declared as annotation at
	 * {@code User}.
	 *
	 * @param emailAddress
	 * @return the user with the given email address
	 */
	User findByEmailAddress(String emailAddress);

	@Query(""select u from User u left outer join u.manager as manager"")
	Page<User> findAllPaged(Pageable pageable);

	/**
	 * Retrieves users by the given email and lastname. Acts as a dummy method declaration to test finder query creation.
	 *
	 * @param emailAddress
	 * @param lastname
	 * @return the user with the given email address and lastname
	 */
	User findByEmailAddressAndLastname(String emailAddress, String lastname);

	/**
	 * Retrieves users by email address and lastname or firstname. Acts as a dummy method declaration to test finder query
	 * creation.
	 *
	 * @param emailAddress
	 * @param lastname
	 * @param username
	 * @return the users with the given email address and lastname or the given firstname
	 */
	List<User> findByEmailAddressAndLastnameOrFirstname(String emailAddress, String lastname, String username);

	/**
	 * Retrieves a user by its username using the query annotated to the method.
	 *
	 * @param emailAddress
	 * @return
	 */
	@Query(""select u from User u where u.emailAddress = ?1"")
	@Transactional(readOnly = true)
	User findByAnnotatedQuery(String emailAddress);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 *
	 * @param pageable
	 * @param lastname
	 * @return
	 */
	Page<User> findByLastname(Pageable pageable, String lastname);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * Just returns the queried {@link Page}'s contents.
	 *
	 * @param firstname
	 * @param pageable
	 * @return
	 */
	List<User> findByFirstname(String firstname, Pageable pageable);

	Page<User> findByFirstnameIn(Pageable pageable, String... firstnames);

	List<User> findByFirstnameNotIn(Collection<String> firstnames);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like ?1%"")
	List<User> findByFirstnameLike(String firstname);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like :firstname%"")
	List<User> findByFirstnameLikeNamed(@Param(""firstname"") String firstname);

	/**
	 * Manipulating query to set all {@link User}'s names to the given one.
	 *
	 * @param lastname
	 */
	@Modifying
	@Query(""update User u set u.lastname = ?1"")
	void renameAllUsersTo(String lastname);

	@Query(""select count(u) from User u where u.firstname = ?1"")
	Long countWithFirstname(String firstname);

	/**
	 * Method where parameters will be applied by name. Note that the order of the parameters is then not crucial anymore.
	 *
	 * @param foo
	 * @param bar
	 * @return
	 */
	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstname(@Param(""firstname"") String foo, @Param(""lastname"") String bar);

	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstnameUnannotated(String firstname, String lastname);

	/**
	 * Method to check query creation and named parameter usage go well hand in hand.
	 *
	 * @param lastname
	 * @param firstname
	 * @return
	 */
	List<User> findByFirstnameOrLastname(@Param(""lastname"") String lastname, @Param(""firstname"") String firstname);

	List<User> findByLastnameLikeOrderByFirstnameDesc(String lastname);

	List<User> findByLastnameNotLike(String lastname);

	List<User> findByLastnameNot(String lastname);

	List<User> findByManagerLastname(String name);

	List<User> findByColleaguesLastname(String lastname);

	List<User> findByLastnameNotNull();

	List<User> findByLastnameNull();

	List<User> findByEmailAddressLike(String email, Sort sort);

	List<SpecialUser> findSpecialUsersByLastname(String lastname);

	List<User> findBySpringDataNamedQuery(String lastname);

	List<User> findByLastnameIgnoringCase(String lastname);

	Page<User> findByLastnameIgnoringCase(Pageable pageable, String lastname);

	List<User> findByLastnameIgnoringCaseLike(String lastname);

	List<User> findByLastnameAndFirstnameAllIgnoringCase(String lastname, String firstname);

	List<User> findByAgeGreaterThanEqual(int age);

	List<User> findByAgeLessThanEqual(int age);

	@Query(""select u.lastname from User u group by u.lastname"")
	Page<String> findByLastnameGrouped(Pageable pageable);

	// DATAJPA-117
	@Query(value = ""SELECT * FROM SD_User WHERE lastname = ?1"", nativeQuery = true)
	List<User> findNativeByLastname(String lastname);

	// DATAJPA-132
	List<User> findByActiveTrue();

	// DATAJPA-132
	List<User> findByActiveFalse();

	/**
	 * Commented out until OpenJPA supports this.
	 */
	// @Query(""select u.colleagues from User u where u = ?1"")
	// List<User> findColleaguesFor(User user);

	// DATAJPA-188
	List<User> findByCreatedAtBefore(Date date);

	// DATAJPA-188
	List<User> findByCreatedAtAfter(Date date);

	// DATAJPA-180
	List<User> findByFirstnameStartingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameEndingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameContaining(String firstname);

	@Query(value = ""SELECT 1 FROM SD_User"", nativeQuery = true)
	List<Integer> findOnesByNativeQuery();

	// DATAJPA-231
	long countByLastname(String lastname);

	// DATAJPA-231
	int countUsersByFirstname(String firstname);

	// DATAJPA-920
	boolean existsByLastname(String lastname);

	// DATAJPA-391
	@Query(""select u.firstname from User u where u.lastname = ?1"")
	List<String> findFirstnamesByLastname(String lastname);

	// DATAJPA-415
	Collection<User> findByIdIn(@Param(""ids"") Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in ?1"")
	Collection<User> findByIdsCustomWithPositionalVarArgs(Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in :ids"")
	Collection<User> findByIdsCustomWithNamedVarArgs(@Param(""ids"") Integer... ids);

	// DATAJPA-415
	@Modifying
	@Query(""update #{#entityName} u set u.active = :activeState where u.id in :ids"")
	void updateUserActiveState(@Param(""activeState"") boolean activeState, @Param(""ids"") Integer... ids);

	// DATAJPA-405
	List<User> findAllByOrderByLastnameAsc();

	// DATAJPA-454
	List<User> findByBinaryData(byte[] data);

	// DATAJPA-486
	Slice<User> findSliceByLastname(String lastname, Pageable pageable);

	// DATAJPA-496
	List<User> findByAttributesIn(Set<String> attributes);

	// DATAJPA-460
	Long removeByLastname(String lastname);

	// DATAJPA-460
	List<User> deleteByLastname(String lastname);

	/**
	 * @see <a href=""https://issues.apache.org/jira/browse/OPENJPA-2484"">OPENJPA-2484</a>
	 */
	// DATAJPA-505
	// @Query(value = ""select u.binaryData from User u where u.id = :id"")
	// byte[] findBinaryDataByIdJpaQl(@Param(""id"") Integer id);

	/**
	 * Explicitly mapped to a procedure with name ""plus1inout"" in database.
	 */
	@Procedure(""plus1inout"") // DATAJPA-455
	Integer explicitlyNamedPlus1inout(Integer arg);

	/**
	 * Implicitly mapped to a procedure with name ""plus1inout"" in database via alias.
	 */
	@Procedure(procedureName = ""plus1inout"") // DATAJPA-455
	Integer plus1inout(Integer arg);

	/**
	 * Explicitly mapped to named stored procedure ""User.plus1IO"" in {@link EntityManager}.
	 */
	@Procedure(name = ""User.plus1IO"") // DATAJPA-455
	Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param(""arg"") Integer arg);

	/**
	 * Implicitly mapped to named stored procedure ""User.plus1"" in {@link EntityManager}.
	 */
	@Procedure // DATAJPA-455
	Integer plus1(@Param(""arg"") Integer arg);

	// DATAJPA-456
	@Query(value = ""select u from User u where u.firstname like ?1%"", countProjection = ""u.firstname"")
	Page<User> findAllByFirstnameLike(String firstname, Pageable page);

	// DATAJPA-456
	@Query(name = ""User.findBySpringDataNamedQuery"", countProjection = ""u.firstname"")
	Page<User> findByNamedQueryAndCountProjection(String firstname, Pageable page);

	// DATAJPA-551
	User findFirstByOrderByAgeDesc();

	// DATAJPA-551
	User findFirst1ByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeAsc();

	// DATAJPA-551
	User findTop1ByOrderByAgeAsc();

	// DATAJPA-551
	List<User> findTop2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2UsersBy(Sort sort);

	// DATAJPA-551
	List<User> findTop2UsersBy(Sort sort);

	// DATAJPA-551
	Page<User> findFirst3UsersBy(Pageable page);

	// DATAJPA-551
	Page<User> findFirst2UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop3UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop2UsersBy(Pageable page);

	// DATAJPA-506
	@Query(value = ""select u.binaryData from SD_User u where u.id = ?1"", nativeQuery = true)
	byte[] findBinaryDataByIdNative(Integer id);

	// DATAJPA-506
	@Query(""select u from User u where u.emailAddress = ?1"")
	Optional<User> findOptionalByEmailAddress(String emailAddress);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]} and u.firstname = ?1 and u.lastname like %?#{[1]}% and u.lastname like %?2%"")
	List<User> findByFirstnameAndLastnameWithSpelExpression(String firstname, String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%"")
	List<User> findByLastnameWithSpelExpression(@Param(""lastname"") String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithQuestionmark();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithColon();

	// DATAJPA-564
	@Query(""select u from User u where u.age = ?#{[0]}"")
	List<User> findUsersByAgeForSpELExpressionByIndexedParameter(int age);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :firstname and u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpression(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findCurrentUserWithCustomQuery();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findByFirstnameAndCurrentUserWithCustomQuery(String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterVariableOnly(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnly(String firstname);

	// DATAJPA-564
	@Query(
			value = ""select * from (select rownum() as RN, u.* from SD_User u) where RN between ?#{ #pageable.offset -1} and ?#{#pageable.offset + #pageable.pageSize}"",
			countQuery = ""select count(u.id) from SD_User u"", nativeQuery = true)
	Page<User> findUsersInNativeQueryWithPagination(Pageable pageable);

	// DATAJPA-629
	@Query(""select u from #{#entityName} u where u.firstname = ?#{[0]} and u.lastname = ?#{[1]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnlyWithEntityExpression(String firstname,
			String lastname);

	// DATAJPA-606
	List<User> findByAgeIn(Collection<Integer> ages);

	// DATAJPA-606
	List<User> queryByAgeIn(Integer[] ages);

	// DATAJPA-606
	List<User> queryByAgeInOrFirstname(Integer[] ages, String firstname);

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> findAllByCustomQueryAndStream();

	// DATAJPA-677
	Stream<User> readAllByFirstnameNotNull();

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> streamAllPaged(Pageable pageable);

	// DATAJPA-830
	List<User> findByLastnameNotContaining(String part);

	// DATAJPA-829
	List<User> findByRolesContaining(Role role);

	// DATAJPA-829
	List<User> findByRolesNotContaining(Role role);

	// DATAJPA-858
	List<User> findByRolesNameContaining(String name);

	// DATAJPA-1179
	@Query(""select u from User u where u.firstname = :#{#firstname} and u.firstname = :#{#firstname}"")
	List<User> findUsersByDuplicateSpel(@Param(""firstname"") String firstname);

	List<RolesAndFirstname> findRolesAndFirstnameBy();

	@Query(value = ""SELECT firstname, lastname from SD_User WHERE id = ?1"", nativeQuery = true)
	NameOnly findByNativeQuery(Integer id);

	// DATAJPA-1185
	<T> Stream<T> findAsStreamByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1185
	<T> List<T> findAsListByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1248
	@Query(value = ""SELECT emailaddress FROM SD_User WHERE id = ?1"", nativeQuery = true)
	EmailOnly findEmailOnlyByNativeQuery(Integer id);

	// DATAJPA-1273
	List<NameOnly> findByNamedQueryWithAliasInInvertedOrder();

	// DATAJPA-1301
	@Query(""select firstname as firstname, lastname as lastname from User u where u.firstname = 'Oliver'"")
	Map<String, Object> findMapWithNullValues();

	// DATAJPA-1334
	List<NameOnlyDto> findByNamedQueryWithConstructorExpression();

	// DATAJPA-1519
	@Query(""select u from User u where u.firstname like %?#{escape([0])}% escape '\\'"")
	List<User> findContainingEscaped(String namePart);

	interface RolesAndFirstname {

		String getFirstname();

		Set<Role> getRoles();
	}

	interface NameOnly {

		String getFirstname();

		String getLastname();
	}

	interface EmailOnly {
		String getEmailAddress();
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/config/EnableJpaRepositories.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.config;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import javax.persistence.EntityManagerFactory;

import org.springframework.beans.factory.FactoryBean;
import org.springframework.context.annotation.ComponentScan.Filter;
import org.springframework.context.annotation.Import;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
import org.springframework.data.repository.config.DefaultRepositoryBaseClass;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * Annotation to enable JPA repositories. Will scan the package of the annotated configuration class for Spring Data
 * repositories by default.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(JpaRepositoriesRegistrar.class)
public @interface EnableJpaRepositories {

	/**
	 * Alias for the {@link #basePackages()} attribute. Allows for more concise annotation declarations e.g.:
	 * {@code @EnableJpaRepositories(""org.my.pkg"")} instead of {@code @EnableJpaRepositories(basePackages=""org.my.pkg"")}.
	 */
	String[] value() default {};

	/**
	 * Base packages to scan for annotated components. {@link #value()} is an alias for (and mutually exclusive with) this
	 * attribute. Use {@link #basePackageClasses()} for a type-safe alternative to String-based package names.
	 */
	String[] basePackages() default {};

	/**
	 * Type-safe alternative to {@link #basePackages()} for specifying the packages to scan for annotated components. The
	 * package of each class specified will be scanned. Consider creating a special no-op marker class or interface in
	 * each package that serves no purpose other than being referenced by this attribute.
	 */
	Class<?>[] basePackageClasses() default {};

	/**
	 * Specifies which types are eligible for component scanning. Further narrows the set of candidate components from
	 * everything in {@link #basePackages()} to everything in the base packages that matches the given filter or filters.
	 */
	Filter[] includeFilters() default {};

	/**
	 * Specifies which types are not eligible for component scanning.
	 */
	Filter[] excludeFilters() default {};

	/**
	 * Returns the postfix to be used when looking up custom repository implementations. Defaults to {@literal Impl}. So
	 * for a repository named {@code PersonRepository} the corresponding implementation class will be looked up scanning
	 * for {@code PersonRepositoryImpl}.
	 * 
	 * @return
	 */
	String repositoryImplementationPostfix() default ""Impl"";

	/**
	 * Configures the location of where to find the Spring Data named queries properties file. Will default to
	 * {@code META-INF/jpa-named-queries.properties}.
	 * 
	 * @return
	 */
	String namedQueriesLocation() default """";

	/**
	 * Returns the key of the {@link QueryLookupStrategy} to be used for lookup queries for query methods. Defaults to
	 * {@link Key#CREATE_IF_NOT_FOUND}.
	 * 
	 * @return
	 */
	Key queryLookupStrategy() default Key.CREATE_IF_NOT_FOUND;

	/**
	 * Returns the {@link FactoryBean} class to be used for each repository instance. Defaults to
	 * {@link JpaRepositoryFactoryBean}.
	 * 
	 * @return
	 */
	Class<?> repositoryFactoryBeanClass() default JpaRepositoryFactoryBean.class;

	/**
	 * Configure the repository base class to be used to create repository proxies for this particular configuration.
	 * 
	 * @return
	 * @since 1.9
	 */
	Class<?> repositoryBaseClass() default DefaultRepositoryBaseClass.class;

	// JPA specific configuration

	/**
	 * Configures the name of the {@link EntityManagerFactory} bean definition to be used to create repositories
	 * discovered through this annotation. Defaults to {@code entityManagerFactory}.
	 * 
	 * @return
	 */
	String entityManagerFactoryRef() default ""entityManagerFactory"";

	/**
	 * Configures the name of the {@link PlatformTransactionManager} bean definition to be used to create repositories
	 * discovered through this annotation. Defaults to {@code transactionManager}.
	 * 
	 * @return
	 */
	String transactionManagerRef() default ""transactionManager"";

	/**
	 * Configures whether nested repository-interfaces (e.g. defined as inner classes) should be discovered by the
	 * repositories infrastructure.
	 */
	boolean considerNestedRepositories() default false;

	/**
	 * Configures whether to enable default transactions for Spring Data JPA repositories. Defaults to {@literal true}. If
	 * disabled, repositories must be used behind a facade that's configuring transactions (e.g. using Spring's annotation
	 * driven transaction facilities) or repository methods have to be used to demarcate transactions.
	 * 
	 * @return whether to enable default transactions, defaults to {@literal true}.
	 */
	boolean enableDefaultTransactions() default true;
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/config/EnableJpaRepositories.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.config;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import javax.persistence.EntityManagerFactory;

import org.springframework.beans.factory.FactoryBean;
import org.springframework.context.annotation.ComponentScan.Filter;
import org.springframework.context.annotation.Import;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
import org.springframework.data.repository.config.DefaultRepositoryBaseClass;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * Annotation to enable JPA repositories. Will scan the package of the annotated configuration class for Spring Data
 * repositories by default.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(JpaRepositoriesRegistrar.class)
public @interface EnableJpaRepositories {

	/**
	 * Alias for the {@link #basePackages()} attribute. Allows for more concise annotation declarations e.g.:
	 * {@code @EnableJpaRepositories(""org.my.pkg"")} instead of {@code @EnableJpaRepositories(basePackages=""org.my.pkg"")}.
	 */
	String[] value() default {};

	/**
	 * Base packages to scan for annotated components. {@link #value()} is an alias for (and mutually exclusive with) this
	 * attribute. Use {@link #basePackageClasses()} for a type-safe alternative to String-based package names.
	 */
	String[] basePackages() default {};

	/**
	 * Type-safe alternative to {@link #basePackages()} for specifying the packages to scan for annotated components. The
	 * package of each class specified will be scanned. Consider creating a special no-op marker class or interface in
	 * each package that serves no purpose other than being referenced by this attribute.
	 */
	Class<?>[] basePackageClasses() default {};

	/**
	 * Specifies which types are eligible for component scanning. Further narrows the set of candidate components from
	 * everything in {@link #basePackages()} to everything in the base packages that matches the given filter or filters.
	 */
	Filter[] includeFilters() default {};

	/**
	 * Specifies which types are not eligible for component scanning.
	 */
	Filter[] excludeFilters() default {};

	/**
	 * Returns the postfix to be used when looking up custom repository implementations. Defaults to {@literal Impl}. So
	 * for a repository named {@code PersonRepository} the corresponding implementation class will be looked up scanning
	 * for {@code PersonRepositoryImpl}.
	 * 
	 * @return
	 */
	String repositoryImplementationPostfix() default ""Impl"";

	/**
	 * Configures the location of where to find the Spring Data named queries properties file. Will default to
	 * {@code META-INF/jpa-named-queries.properties}.
	 * 
	 * @return
	 */
	String namedQueriesLocation() default """";

	/**
	 * Returns the key of the {@link QueryLookupStrategy} to be used for lookup queries for query methods. Defaults to
	 * {@link Key#CREATE_IF_NOT_FOUND}.
	 * 
	 * @return
	 */
	Key queryLookupStrategy() default Key.CREATE_IF_NOT_FOUND;

	/**
	 * Returns the {@link FactoryBean} class to be used for each repository instance. Defaults to
	 * {@link JpaRepositoryFactoryBean}.
	 * 
	 * @return
	 */
	Class<?> repositoryFactoryBeanClass() default JpaRepositoryFactoryBean.class;

	/**
	 * Configure the repository base class to be used to create repository proxies for this particular configuration.
	 * 
	 * @return
	 * @since 1.9
	 */
	Class<?> repositoryBaseClass() default DefaultRepositoryBaseClass.class;

	// JPA specific configuration

	/**
	 * Configures the name of the {@link EntityManagerFactory} bean definition to be used to create repositories
	 * discovered through this annotation. Defaults to {@code entityManagerFactory}.
	 * 
	 * @return
	 */
	String entityManagerFactoryRef() default ""entityManagerFactory"";

	/**
	 * Configures the name of the {@link PlatformTransactionManager} bean definition to be used to create repositories
	 * discovered through this annotation. Defaults to {@code transactionManager}.
	 * 
	 * @return
	 */
	String transactionManagerRef() default ""transactionManager"";

	/**
	 * Configures whether nested repository-interfaces (e.g. defined as inner classes) should be discovered by the
	 * repositories infrastructure.
	 */
	boolean considerNestedRepositories() default false;

	/**
	 * Configures whether to enable default transactions for Spring Data JPA repositories. Defaults to {@literal true}. If
	 * disabled, repositories must be used behind a facade that's configuring transactions (e.g. using Spring's annotation
	 * driven transaction facilities) or repository methods have to be used to demarcate transactions.
	 * 
	 * @return whether to enable default transactions, defaults to {@literal true}.
	 */
	boolean enableDefaultTransactions() default true;

	/**
	 * Configures what character is used to escape the wildcards {@literal _} and {@literal %} in derived queries with
	 * {@literal contains}, {@literal startsWith} or {@literal endsWith} clauses.
	 * 
	 * @return a single character used for escaping.
	 */
	char escapeCharacter() default '\\';
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/config/JpaRepositoryConfigExtension.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.config;

import static org.springframework.data.jpa.repository.config.BeanDefinitionNames.*;

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Locale;

import javax.persistence.Entity;
import javax.persistence.MappedSuperclass;
import javax.persistence.PersistenceContext;
import javax.persistence.PersistenceUnit;

import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.core.annotation.AnnotationAttributes;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.support.DefaultJpaContext;
import org.springframework.data.jpa.repository.support.EntityManagerBeanDefinitionRegistrarPostProcessor;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
import org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource;
import org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport;
import org.springframework.data.repository.config.RepositoryConfigurationSource;
import org.springframework.data.repository.config.XmlRepositoryConfigurationSource;
import org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor;
import org.springframework.util.StringUtils;

/**
 * JPA specific configuration extension parsing custom attributes from the XML namespace and
 * {@link EnableJpaRepositories} annotation. Also, it registers bean definitions for a
 * {@link PersistenceAnnotationBeanPostProcessor} (to trigger injection into {@link PersistenceContext}/
 * {@link PersistenceUnit} annotated properties and methods) as well as
 * {@link PersistenceExceptionTranslationPostProcessor} to enable exception translation of persistence specific
 * exceptions into Spring's {@link DataAccessException} hierarchy.
 * 
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Gil Markham
 * @author Thomas Darimont
 */
public class JpaRepositoryConfigExtension extends RepositoryConfigurationExtensionSupport {

	private static final Class<?> PAB_POST_PROCESSOR = PersistenceAnnotationBeanPostProcessor.class;
	private static final String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = ""transactionManager"";
	private static final String ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE = ""enableDefaultTransactions"";

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getModuleName()
	 */
	@Override
	public String getModuleName() {
		return ""JPA"";
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config14.RepositoryConfigurationExtension#getRepositoryInterface()
	 */
	public String getRepositoryFactoryClassName() {
		return JpaRepositoryFactoryBean.class.getName();
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config14.RepositoryConfigurationExtensionSupport#getModulePrefix()
	 */
	@Override
	protected String getModulePrefix() {
		return getModuleName().toLowerCase(Locale.US);
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingAnnotations()
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	protected Collection<Class<? extends Annotation>> getIdentifyingAnnotations() {
		return Arrays.asList(Entity.class, MappedSuperclass.class);
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingTypes()
	 */
	@Override
	protected Collection<Class<?>> getIdentifyingTypes() {
		return Collections.<Class<?>> singleton(JpaRepository.class);
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, RepositoryConfigurationSource source) {

		String transactionManagerRef = source.getAttribute(""transactionManagerRef"");
		builder.addPropertyValue(""transactionManager"",
				transactionManagerRef == null ? DEFAULT_TRANSACTION_MANAGER_BEAN_NAME : transactionManagerRef);
		builder.addPropertyValue(""entityManager"", getEntityManagerBeanDefinitionFor(source, source.getSource()));
		builder.addPropertyReference(""mappingContext"", JPA_MAPPING_CONTEXT_BEAN_NAME);
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, AnnotationRepositoryConfigurationSource config) {

		AnnotationAttributes attributes = config.getAttributes();

		builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE,
				attributes.getBoolean(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE));
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.XmlRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, XmlRepositoryConfigurationSource config) {

		String enableDefaultTransactions = config.getAttribute(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE);

		if (StringUtils.hasText(enableDefaultTransactions)) {
			builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE, enableDefaultTransactions);
		}
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#registerBeansForRoot(org.springframework.beans.factory.support.BeanDefinitionRegistry, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void registerBeansForRoot(BeanDefinitionRegistry registry, RepositoryConfigurationSource config) {

		super.registerBeansForRoot(registry, config);

		Object source = config.getSource();

		registerIfNotAlreadyRegistered(new RootBeanDefinition(EntityManagerBeanDefinitionRegistrarPostProcessor.class),
				registry, EM_BEAN_DEFINITION_REGISTRAR_POST_PROCESSOR_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(JpaMetamodelMappingContextFactoryBean.class), registry,
				JPA_MAPPING_CONTEXT_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(PAB_POST_PROCESSOR), registry,
				AnnotationConfigUtils.PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME, source);

		// Register bean definition for DefaultJpaContext

		RootBeanDefinition contextDefinition = new RootBeanDefinition(DefaultJpaContext.class);
		contextDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);

		registerIfNotAlreadyRegistered(contextDefinition, registry, JPA_CONTEXT_BEAN_NAME, source);
	}

	/**
	 * Creates an anonymous factory to extract the actual {@link javax.persistence.EntityManager} from the
	 * {@link javax.persistence.EntityManagerFactory} bean name reference.
	 * 
	 * @param entityManagerFactoryBeanName
	 * @param source
	 * @return
	 */
	private static AbstractBeanDefinition getEntityManagerBeanDefinitionFor(RepositoryConfigurationSource config,
			Object source) {

		BeanDefinitionBuilder builder = BeanDefinitionBuilder
				.rootBeanDefinition(""org.springframework.orm.jpa.SharedEntityManagerCreator"");
		builder.setFactoryMethod(""createSharedEntityManager"");
		builder.addConstructorArgReference(getEntityManagerBeanRef(config));

		AbstractBeanDefinition bean = builder.getRawBeanDefinition();
		bean.setSource(source);

		return bean;
	}

	private static String getEntityManagerBeanRef(RepositoryConfigurationSource config) {

		String entityManagerFactoryRef = config == null ? null : config.getAttribute(""entityManagerFactoryRef"");
		return entityManagerFactoryRef == null ? ""entityManagerFactory"" : entityManagerFactoryRef;
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/config/JpaRepositoryConfigExtension.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.config;

import static org.springframework.data.jpa.repository.config.BeanDefinitionNames.*;

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Locale;

import javax.persistence.Entity;
import javax.persistence.MappedSuperclass;
import javax.persistence.PersistenceContext;
import javax.persistence.PersistenceUnit;

import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.core.annotation.AnnotationAttributes;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.support.DefaultJpaContext;
import org.springframework.data.jpa.repository.support.EntityManagerBeanDefinitionRegistrarPostProcessor;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
import org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource;
import org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport;
import org.springframework.data.repository.config.RepositoryConfigurationSource;
import org.springframework.data.repository.config.XmlRepositoryConfigurationSource;
import org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor;
import org.springframework.util.StringUtils;

/**
 * JPA specific configuration extension parsing custom attributes from the XML namespace and
 * {@link EnableJpaRepositories} annotation. Also, it registers bean definitions for a
 * {@link PersistenceAnnotationBeanPostProcessor} (to trigger injection into {@link PersistenceContext}/
 * {@link PersistenceUnit} annotated properties and methods) as well as
 * {@link PersistenceExceptionTranslationPostProcessor} to enable exception translation of persistence specific
 * exceptions into Spring's {@link DataAccessException} hierarchy.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Gil Markham
 * @author Thomas Darimont
 */
public class JpaRepositoryConfigExtension extends RepositoryConfigurationExtensionSupport {

	private static final Class<?> PAB_POST_PROCESSOR = PersistenceAnnotationBeanPostProcessor.class;
	private static final String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = ""transactionManager"";
	private static final String ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE = ""enableDefaultTransactions"";

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getModuleName()
	 */
	@Override
	public String getModuleName() {
		return ""JPA"";
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config14.RepositoryConfigurationExtension#getRepositoryInterface()
	 */
	public String getRepositoryFactoryClassName() {
		return JpaRepositoryFactoryBean.class.getName();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config14.RepositoryConfigurationExtensionSupport#getModulePrefix()
	 */
	@Override
	protected String getModulePrefix() {
		return getModuleName().toLowerCase(Locale.US);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingAnnotations()
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	protected Collection<Class<? extends Annotation>> getIdentifyingAnnotations() {
		return Arrays.asList(Entity.class, MappedSuperclass.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingTypes()
	 */
	@Override
	protected Collection<Class<?>> getIdentifyingTypes() {
		return Collections.<Class<?>> singleton(JpaRepository.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, RepositoryConfigurationSource source) {

		Character escapeCharacter = getEscapeCharacter(source);

		String transactionManagerRef = source.getAttribute(""transactionManagerRef"");
		builder.addPropertyValue(""transactionManager"",
				transactionManagerRef == null ? DEFAULT_TRANSACTION_MANAGER_BEAN_NAME : transactionManagerRef);
		builder.addPropertyValue(""entityManager"", getEntityManagerBeanDefinitionFor(source, source.getSource()));
		builder.addPropertyValue(""escapeCharacter"", escapeCharacter == null ? '\\' : escapeCharacter);
		builder.addPropertyReference(""mappingContext"", JPA_MAPPING_CONTEXT_BEAN_NAME);
	}

	/**
	 * XML configurations do not support {@link Character} values. This method catches the exception thrown and returns an
	 * {@link Optional#empty()} instead.
	 */
	private static Character getEscapeCharacter(RepositoryConfigurationSource source) {

		try {

			return AnnotationRepositoryConfigurationSource.class.isInstance(source) //
					? (Character) AnnotationRepositoryConfigurationSource.class.cast(source).getAttributes()
							.get(""escapeCharacter"") //
					: source.getAttribute(""escapeCharacter"").toCharArray()[0];

		} catch (IllegalArgumentException ___) {
			return null;
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, AnnotationRepositoryConfigurationSource config) {

		AnnotationAttributes attributes = config.getAttributes();

		builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE,
				attributes.getBoolean(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.XmlRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, XmlRepositoryConfigurationSource config) {

		String enableDefaultTransactions = config.getAttribute(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE);

		if (StringUtils.hasText(enableDefaultTransactions)) {
			builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE, enableDefaultTransactions);
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#registerBeansForRoot(org.springframework.beans.factory.support.BeanDefinitionRegistry, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void registerBeansForRoot(BeanDefinitionRegistry registry, RepositoryConfigurationSource config) {

		super.registerBeansForRoot(registry, config);

		Object source = config.getSource();

		registerIfNotAlreadyRegistered(new RootBeanDefinition(EntityManagerBeanDefinitionRegistrarPostProcessor.class),
				registry, EM_BEAN_DEFINITION_REGISTRAR_POST_PROCESSOR_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(JpaMetamodelMappingContextFactoryBean.class), registry,
				JPA_MAPPING_CONTEXT_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(PAB_POST_PROCESSOR), registry,
				AnnotationConfigUtils.PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME, source);

		// Register bean definition for DefaultJpaContext

		RootBeanDefinition contextDefinition = new RootBeanDefinition(DefaultJpaContext.class);
		contextDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);

		registerIfNotAlreadyRegistered(contextDefinition, registry, JPA_CONTEXT_BEAN_NAME, source);
	}

	/**
	 * Creates an anonymous factory to extract the actual {@link javax.persistence.EntityManager} from the
	 * {@link javax.persistence.EntityManagerFactory} bean name reference.
	 *
	 * @param entityManagerFactoryBeanName
	 * @param source
	 * @return
	 */
	private static AbstractBeanDefinition getEntityManagerBeanDefinitionFor(RepositoryConfigurationSource config,
			Object source) {

		BeanDefinitionBuilder builder = BeanDefinitionBuilder
				.rootBeanDefinition(""org.springframework.orm.jpa.SharedEntityManagerCreator"");
		builder.setFactoryMethod(""createSharedEntityManager"");
		builder.addConstructorArgReference(getEntityManagerBeanRef(config));

		AbstractBeanDefinition bean = builder.getRawBeanDefinition();
		bean.setSource(source);

		return bean;
	}

	private static String getEntityManagerBeanRef(RepositoryConfigurationSource config) {

		String entityManagerFactoryRef = config == null ? null : config.getAttribute(""entityManagerFactoryRef"");
		return entityManagerFactoryRef == null ? ""entityManagerFactory"" : entityManagerFactoryRef;
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryCreator.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.springframework.data.jpa.domain.AbstractPersistable_.*;
import static org.springframework.data.jpa.repository.query.QueryUtils.*;
import static org.springframework.data.repository.query.parser.Part.Type.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Selection;
import javax.persistence.metamodel.SingularAttribute;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.mapping.PropertyPath;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.AbstractQueryCreator;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.util.Assert;

/**
 * Query creator to create a {@link CriteriaQuery} from a {@link PartTree}.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 */
public class JpaQueryCreator extends AbstractQueryCreator<CriteriaQuery<? extends Object>, Predicate> {

	private final CriteriaBuilder builder;
	private final Root<?> root;
	private final CriteriaQuery<? extends Object> query;
	private final ParameterMetadataProvider provider;
	private final ReturnedType returnedType;
	private final PartTree tree;

	/**
	 * Create a new {@link JpaQueryCreator}.
	 * 
	 * @param tree must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param builder must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public JpaQueryCreator(PartTree tree, ReturnedType type, CriteriaBuilder builder,
			ParameterMetadataProvider provider) {

		super(tree);
		this.tree = tree;

		CriteriaQuery<? extends Object> criteriaQuery = createCriteriaQuery(builder, type);

		this.builder = builder;
		this.query = criteriaQuery.distinct(tree.isDistinct());
		this.root = query.from(type.getDomainType());
		this.provider = provider;
		this.returnedType = type;
	}

	/**
	 * Creates the {@link CriteriaQuery} to apply predicates on.
	 * 
	 * @param builder will never be {@literal null}.
	 * @param type will never be {@literal null}.
	 * @return must not be {@literal null}.
	 */
	protected CriteriaQuery<? extends Object> createCriteriaQuery(CriteriaBuilder builder, ReturnedType type) {

		Class<?> typeToRead = type.getTypeToRead();

		return typeToRead == null || tree.isExistsProjection() ? builder.createTupleQuery()
				: builder.createQuery(typeToRead);
	}

	/**
	 * Returns all {@link javax.persistence.criteria.ParameterExpression} created when creating the query.
	 * 
	 * @return the parameterExpressions
	 */
	public List<ParameterMetadata<?>> getParameterExpressions() {
		return provider.getExpressions();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#create(org.springframework.data.repository.query.parser.Part, java.util.Iterator)
	 */
	@Override
	protected Predicate create(Part part, Iterator<Object> iterator) {

		return toPredicate(part, root);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#and(org.springframework.data.repository.query.parser.Part, java.lang.Object, java.util.Iterator)
	 */
	@Override
	protected Predicate and(Part part, Predicate base, Iterator<Object> iterator) {
		return builder.and(base, toPredicate(part, root));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#or(java.lang.Object, java.lang.Object)
	 */
	@Override
	protected Predicate or(Predicate base, Predicate predicate) {
		return builder.or(base, predicate);
	}

	/**
	 * Finalizes the given {@link Predicate} and applies the given sort. Delegates to
	 * {@link #complete(Predicate, Sort, CriteriaQuery, CriteriaBuilder, Root)} and hands it the current {@link CriteriaQuery}
	 * and {@link CriteriaBuilder}.
	 */
	@Override
	protected final CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort) {
		return complete(predicate, sort, query, builder, root);
	}

	/**
	 * Template method to finalize the given {@link Predicate} using the given {@link CriteriaQuery} and
	 * {@link CriteriaBuilder}.
	 * 
	 * @param predicate
	 * @param sort
	 * @param query
	 * @param builder
	 * @return
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	protected CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort,
			CriteriaQuery<? extends Object> query, CriteriaBuilder builder, Root<?> root) {

		if (returnedType.needsCustomConstruction()) {

			List<Selection<?>> selections = new ArrayList<Selection<?>>();

			for (String property : returnedType.getInputProperties()) {

				PropertyPath path = PropertyPath.from(property, returnedType.getDomainType());
				selections.add(toExpressionRecursively(root, path).alias(property));
			}

			query = query.multiselect(selections);

		} else if (tree.isExistsProjection()) {

			if (root.getModel().hasSingleIdAttribute()) {

				SingularAttribute<?, ?> id = root.getModel().getId(root.getModel().getIdType().getJavaType());
				query = query.multiselect(root.get((SingularAttribute) id).alias(id.getName()));

			} else {

				List<Selection<?>> selections = new ArrayList<Selection<?>>();

				for (SingularAttribute<?, ?> attribute : root.getModel().getIdClassAttributes()) {
					selections.add(root.get((SingularAttribute) attribute).alias(attribute.getName()));
				}

				selections.add(root.get((SingularAttribute) id).alias(id.getName()));
				query = query.multiselect(selections);
			}

		} else {
			query = query.select((Root) root);
		}

		CriteriaQuery<? extends Object> select = query.orderBy(QueryUtils.toOrders(sort, root, builder));
		return predicate == null ? select : select.where(predicate);
	}

	/**
	 * Creates a {@link Predicate} from the given {@link Part}.
	 *
	 * @param part
	 * @param root
	 * @return
	 */
	private Predicate toPredicate(Part part, Root<?> root) {
		return new PredicateBuilder(part, root).build();
	}

	/**
	 * Simple builder to contain logic to create JPA {@link Predicate}s from {@link Part}s.
	 * 
	 * @author Phil Webb
	 * @author Oliver Gierke
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private class PredicateBuilder {

		private final Part part;
		private final Root<?> root;

		/**
		 * Creates a new {@link PredicateBuilder} for the given {@link Part} and {@link Root}.
		 * 
		 * @param part must not be {@literal null}.
		 * @param root must not be {@literal null}.
		 */
		public PredicateBuilder(Part part, Root<?> root) {

			Assert.notNull(part, ""Part must not be null!"");
			Assert.notNull(root, ""Root must not be null!"");
			this.part = part;
			this.root = root;
		}

		/**
		 * Builds a JPA {@link Predicate} from the underlying {@link Part}.
		 * 
		 * @return
		 */
		public Predicate build() {

			PropertyPath property = part.getProperty();
			Type type = part.getType();

			switch (type) {
				case BETWEEN:
					ParameterMetadata<Comparable> first = provider.next(part);
					ParameterMetadata<Comparable> second = provider.next(part);
					return builder.between(getComparablePath(root, part), first.getExpression(), second.getExpression());
				case AFTER:
				case GREATER_THAN:
					return builder.greaterThan(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case GREATER_THAN_EQUAL:
					return builder.greaterThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case BEFORE:
				case LESS_THAN:
					return builder.lessThan(getComparablePath(root, part), provider.next(part, Comparable.class).getExpression());
				case LESS_THAN_EQUAL:
					return builder.lessThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case IS_NULL:
					return getTypedPath(root, part).isNull();
				case IS_NOT_NULL:
					return getTypedPath(root, part).isNotNull();
				case NOT_IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression()).not();
				case IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression());
				case STARTING_WITH:
				case ENDING_WITH:
				case CONTAINING:
				case NOT_CONTAINING:

					if (property.getLeafProperty().isCollection()) {

						Expression<Collection<Object>> propertyExpression = traversePath(root, property);
						Expression<Object> parameterExpression = provider.next(part).getExpression();

						// Can't just call .not() in case of negation as EclipseLink chokes on that.
						return type.equals(NOT_CONTAINING) ? builder.isNotMember(parameterExpression, propertyExpression)
								: builder.isMember(parameterExpression, propertyExpression);
					}

				case LIKE:
				case NOT_LIKE:
					Expression<String> stringPath = getTypedPath(root, part);
					Expression<String> propertyExpression = upperIfIgnoreCase(stringPath);
					Expression<String> parameterExpression = upperIfIgnoreCase(provider.next(part, String.class).getExpression());
					Predicate like = builder.like(propertyExpression, parameterExpression);
					return type.equals(NOT_LIKE) || type.equals(NOT_CONTAINING) ? like.not() : like;
				case TRUE:
					Expression<Boolean> truePath = getTypedPath(root, part);
					return builder.isTrue(truePath);
				case FALSE:
					Expression<Boolean> falsePath = getTypedPath(root, part);
					return builder.isFalse(falsePath);
				case SIMPLE_PROPERTY:
					ParameterMetadata<Object> expression = provider.next(part);
					Expression<Object> path = getTypedPath(root, part);
					return expression.isIsNullParameter() ? path.isNull()
							: builder.equal(upperIfIgnoreCase(path), upperIfIgnoreCase(expression.getExpression()));
				case NEGATING_SIMPLE_PROPERTY:
					return builder.notEqual(upperIfIgnoreCase(getTypedPath(root, part)),
							upperIfIgnoreCase(provider.next(part).getExpression()));
				default:
					throw new IllegalArgumentException(""Unsupported keyword "" + type);
			}
		}

		/**
		 * Applies an {@code UPPERCASE} conversion to the given {@link Expression} in case the underlying {@link Part}
		 * requires ignoring case.
		 * 
		 * @param expression must not be {@literal null}.
		 * @return
		 */
		private <T> Expression<T> upperIfIgnoreCase(Expression<? extends T> expression) {

			switch (part.shouldIgnoreCase()) {

				case ALWAYS:

					Assert.state(canUpperCase(expression), ""Unable to ignore case of "" + expression.getJavaType().getName()
							+ "" types, the property '"" + part.getProperty().getSegment() + ""' must reference a String"");
					return (Expression<T>) builder.upper((Expression<String>) expression);

				case WHEN_POSSIBLE:

					if (canUpperCase(expression)) {
						return (Expression<T>) builder.upper((Expression<String>) expression);
					}

				case NEVER:
				default:

					return (Expression<T>) expression;
			}
		}

		private boolean canUpperCase(Expression<?> expression) {
			return String.class.equals(expression.getJavaType());
		}

		/**
		 * Returns a path to a {@link Comparable}.
		 * 
		 * @param root
		 * @param part
		 * @return
		 */
		private Expression<? extends Comparable> getComparablePath(Root<?> root, Part part) {
			return getTypedPath(root, part);
		}

		private <T> Expression<T> getTypedPath(Root<?> root, Part part) {
			return toExpressionRecursively(root, part.getProperty());
		}

		private <T> Expression<T> traversePath(Path<?> root, PropertyPath path) {

			Path<Object> result = root.get(path.getSegment());
			return (Expression<T>) (path.hasNext() ? traversePath(result, path.next()) : result);
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryCreator.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.springframework.data.jpa.domain.AbstractPersistable_.*;
import static org.springframework.data.jpa.repository.query.QueryUtils.*;
import static org.springframework.data.repository.query.parser.Part.Type.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Selection;
import javax.persistence.metamodel.SingularAttribute;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.mapping.PropertyPath;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.AbstractQueryCreator;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.util.Assert;

/**
 * Query creator to create a {@link CriteriaQuery} from a {@link PartTree}.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 */
public class JpaQueryCreator extends AbstractQueryCreator<CriteriaQuery<? extends Object>, Predicate> {

	private final CriteriaBuilder builder;
	private final Root<?> root;
	private final CriteriaQuery<? extends Object> query;
	private final ParameterMetadataProvider provider;
	private final ReturnedType returnedType;
	private final PartTree tree;
	private final EscapeCharacter escape;

	/**
	 * Create a new {@link JpaQueryCreator}.
	 * 
	 * @param tree must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param builder must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public JpaQueryCreator(PartTree tree, ReturnedType type, CriteriaBuilder builder,
			ParameterMetadataProvider provider) {

		super(tree);
		this.tree = tree;

		CriteriaQuery<?> criteriaQuery = createCriteriaQuery(builder, type);

		this.builder = builder;
		this.query = criteriaQuery.distinct(tree.isDistinct());
		this.root = query.from(type.getDomainType());
		this.provider = provider;
		this.returnedType = type;
		this.escape = provider.getEscape();
	}

	/**
	 * Creates the {@link CriteriaQuery} to apply predicates on.
	 * 
	 * @param builder will never be {@literal null}.
	 * @param type will never be {@literal null}.
	 * @return must not be {@literal null}.
	 */
	protected CriteriaQuery<? extends Object> createCriteriaQuery(CriteriaBuilder builder, ReturnedType type) {

		Class<?> typeToRead = type.getTypeToRead();

		return typeToRead == null || tree.isExistsProjection() ? builder.createTupleQuery()
				: builder.createQuery(typeToRead);
	}

	/**
	 * Returns all {@link javax.persistence.criteria.ParameterExpression} created when creating the query.
	 * 
	 * @return the parameterExpressions
	 */
	public List<ParameterMetadata<?>> getParameterExpressions() {
		return provider.getExpressions();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#create(org.springframework.data.repository.query.parser.Part, java.util.Iterator)
	 */
	@Override
	protected Predicate create(Part part, Iterator<Object> iterator) {

		return toPredicate(part, root);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#and(org.springframework.data.repository.query.parser.Part, java.lang.Object, java.util.Iterator)
	 */
	@Override
	protected Predicate and(Part part, Predicate base, Iterator<Object> iterator) {
		return builder.and(base, toPredicate(part, root));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#or(java.lang.Object, java.lang.Object)
	 */
	@Override
	protected Predicate or(Predicate base, Predicate predicate) {
		return builder.or(base, predicate);
	}

	/**
	 * Finalizes the given {@link Predicate} and applies the given sort. Delegates to
	 * {@link #complete(Predicate, Sort, CriteriaQuery, CriteriaBuilder, Root)} and hands it the current {@link CriteriaQuery}
	 * and {@link CriteriaBuilder}.
	 */
	@Override
	protected final CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort) {
		return complete(predicate, sort, query, builder, root);
	}

	/**
	 * Template method to finalize the given {@link Predicate} using the given {@link CriteriaQuery} and
	 * {@link CriteriaBuilder}.
	 * 
	 * @param predicate
	 * @param sort
	 * @param query
	 * @param builder
	 * @return
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	protected CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort,
			CriteriaQuery<? extends Object> query, CriteriaBuilder builder, Root<?> root) {

		if (returnedType.needsCustomConstruction()) {

			List<Selection<?>> selections = new ArrayList<Selection<?>>();

			for (String property : returnedType.getInputProperties()) {

				PropertyPath path = PropertyPath.from(property, returnedType.getDomainType());
				selections.add(toExpressionRecursively(root, path).alias(property));
			}

			query = query.multiselect(selections);

		} else if (tree.isExistsProjection()) {

			if (root.getModel().hasSingleIdAttribute()) {

				SingularAttribute<?, ?> id = root.getModel().getId(root.getModel().getIdType().getJavaType());
				query = query.multiselect(root.get((SingularAttribute) id).alias(id.getName()));

			} else {

				List<Selection<?>> selections = new ArrayList<Selection<?>>();

				for (SingularAttribute<?, ?> attribute : root.getModel().getIdClassAttributes()) {
					selections.add(root.get((SingularAttribute) attribute).alias(attribute.getName()));
				}

				selections.add(root.get((SingularAttribute) id).alias(id.getName()));
				query = query.multiselect(selections);
			}

		} else {
			query = query.select((Root) root);
		}

		CriteriaQuery<? extends Object> select = query.orderBy(QueryUtils.toOrders(sort, root, builder));
		return predicate == null ? select : select.where(predicate);
	}

	/**
	 * Creates a {@link Predicate} from the given {@link Part}.
	 *
	 * @param part
	 * @param root
	 * @return
	 */
	private Predicate toPredicate(Part part, Root<?> root) {
		return new PredicateBuilder(part, root).build();
	}

	/**
	 * Simple builder to contain logic to create JPA {@link Predicate}s from {@link Part}s.
	 * 
	 * @author Phil Webb
	 * @author Oliver Gierke
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private class PredicateBuilder {

		private final Part part;
		private final Root<?> root;

		/**
		 * Creates a new {@link PredicateBuilder} for the given {@link Part} and {@link Root}.
		 * 
		 * @param part must not be {@literal null}.
		 * @param root must not be {@literal null}.
		 */
		public PredicateBuilder(Part part, Root<?> root) {

			Assert.notNull(part, ""Part must not be null!"");
			Assert.notNull(root, ""Root must not be null!"");
			this.part = part;
			this.root = root;
		}

		/**
		 * Builds a JPA {@link Predicate} from the underlying {@link Part}.
		 * 
		 * @return
		 */
		public Predicate build() {

			PropertyPath property = part.getProperty();
			Type type = part.getType();

			switch (type) {
				case BETWEEN:
					ParameterMetadata<Comparable> first = provider.next(part);
					ParameterMetadata<Comparable> second = provider.next(part);
					return builder.between(getComparablePath(root, part), first.getExpression(), second.getExpression());
				case AFTER:
				case GREATER_THAN:
					return builder.greaterThan(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case GREATER_THAN_EQUAL:
					return builder.greaterThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case BEFORE:
				case LESS_THAN:
					return builder.lessThan(getComparablePath(root, part), provider.next(part, Comparable.class).getExpression());
				case LESS_THAN_EQUAL:
					return builder.lessThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case IS_NULL:
					return getTypedPath(root, part).isNull();
				case IS_NOT_NULL:
					return getTypedPath(root, part).isNotNull();
				case NOT_IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression()).not();
				case IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression());
				case STARTING_WITH:
				case ENDING_WITH:
				case CONTAINING:
				case NOT_CONTAINING:

					if (property.getLeafProperty().isCollection()) {

						Expression<Collection<Object>> propertyExpression = traversePath(root, property);
						Expression<Object> parameterExpression = provider.next(part).getExpression();

						// Can't just call .not() in case of negation as EclipseLink chokes on that.
						return type.equals(NOT_CONTAINING) ? builder.isNotMember(parameterExpression, propertyExpression)
								: builder.isMember(parameterExpression, propertyExpression);
					}

				case LIKE:
				case NOT_LIKE:
					Expression<String> stringPath = getTypedPath(root, part);
					Expression<String> propertyExpression = upperIfIgnoreCase(stringPath);
					Expression<String> parameterExpression = upperIfIgnoreCase(provider.next(part, String.class).getExpression());
					Predicate like = builder.like(propertyExpression, parameterExpression, escape.getValue());
					return type.equals(NOT_LIKE) || type.equals(NOT_CONTAINING) ? like.not() : like;
				case TRUE:
					Expression<Boolean> truePath = getTypedPath(root, part);
					return builder.isTrue(truePath);
				case FALSE:
					Expression<Boolean> falsePath = getTypedPath(root, part);
					return builder.isFalse(falsePath);
				case SIMPLE_PROPERTY:
					ParameterMetadata<Object> expression = provider.next(part);
					Expression<Object> path = getTypedPath(root, part);
					return expression.isIsNullParameter() ? path.isNull()
							: builder.equal(upperIfIgnoreCase(path), upperIfIgnoreCase(expression.getExpression()));
				case NEGATING_SIMPLE_PROPERTY:
					return builder.notEqual(upperIfIgnoreCase(getTypedPath(root, part)),
							upperIfIgnoreCase(provider.next(part).getExpression()));
				default:
					throw new IllegalArgumentException(""Unsupported keyword "" + type);
			}
		}

		/**
		 * Applies an {@code UPPERCASE} conversion to the given {@link Expression} in case the underlying {@link Part}
		 * requires ignoring case.
		 * 
		 * @param expression must not be {@literal null}.
		 * @return
		 */
		private <T> Expression<T> upperIfIgnoreCase(Expression<? extends T> expression) {

			switch (part.shouldIgnoreCase()) {

				case ALWAYS:

					Assert.state(canUpperCase(expression), ""Unable to ignore case of "" + expression.getJavaType().getName()
							+ "" types, the property '"" + part.getProperty().getSegment() + ""' must reference a String"");
					return (Expression<T>) builder.upper((Expression<String>) expression);

				case WHEN_POSSIBLE:

					if (canUpperCase(expression)) {
						return (Expression<T>) builder.upper((Expression<String>) expression);
					}

				case NEVER:
				default:

					return (Expression<T>) expression;
			}
		}

		private boolean canUpperCase(Expression<?> expression) {
			return String.class.equals(expression.getJavaType());
		}

		/**
		 * Returns a path to a {@link Comparable}.
		 * 
		 * @param root
		 * @param part
		 * @return
		 */
		private Expression<? extends Comparable> getComparablePath(Root<?> root, Part part) {
			return getTypedPath(root, part);
		}

		private <T> Expression<T> getTypedPath(Root<?> root, Part part) {
			return toExpressionRecursively(root, part.getProperty());
		}

		private <T> Expression<T> traversePath(Path<?> root, PropertyPath path) {

			Path<Object> result = root.get(path.getSegment());
			return (Expression<T>) (path.hasNext() ? traversePath(result, path.next()) : result);
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.RepositoryQuery;
import org.springframework.util.Assert;

/**
 * Query lookup strategy to execute finders.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public final class JpaQueryLookupStrategy {

	/**
	 * Private constructor to prevent instantiation.
	 */
	private JpaQueryLookupStrategy() {}

	/**
	 * Base class for {@link QueryLookupStrategy} implementations that need access to an {@link EntityManager}.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private abstract static class AbstractQueryLookupStrategy implements QueryLookupStrategy {

		private final EntityManager em;
		private final QueryExtractor provider;

		/**
		 * Creates a new {@link AbstractQueryLookupStrategy}.
		 * 
		 * @param em
		 * @param extractor
		 */
		public AbstractQueryLookupStrategy(EntityManager em, QueryExtractor extractor) {

			this.em = em;
			this.provider = extractor;
		}

		/* 
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.query.QueryLookupStrategy#resolveQuery(java.lang.reflect.Method, org.springframework.data.repository.core.RepositoryMetadata, org.springframework.data.projection.ProjectionFactory, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		public final RepositoryQuery resolveQuery(Method method, RepositoryMetadata metadata, ProjectionFactory factory,
				NamedQueries namedQueries) {
			return resolveQuery(new JpaQueryMethod(method, metadata, factory, provider), em, namedQueries);
		}

		protected abstract RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries);
	}

	/**
	 * {@link QueryLookupStrategy} to create a query from the method name.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final PersistenceProvider persistenceProvider;

		public CreateQueryLookupStrategy(EntityManager em, QueryExtractor extractor) {

			super(em, extractor);
			this.persistenceProvider = PersistenceProvider.fromEntityManager(em);
		}

		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {
			return new PartTreeJpaQuery(method, em, persistenceProvider);
		}

	}

	/**
	 * {@link QueryLookupStrategy} that tries to detect a declared query declared via {@link Query} annotation followed by
	 * a JPA named query lookup.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class DeclaredQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final EvaluationContextProvider evaluationContextProvider;

		/**
		 * Creates a new {@link DeclaredQueryLookupStrategy}.
		 * 
		 * @param em
		 * @param extractor
		 * @param evaluationContextProvider
		 */
		public DeclaredQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				EvaluationContextProvider evaluationContextProvider) {

			super(em, extractor);
			this.evaluationContextProvider = evaluationContextProvider;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			RepositoryQuery query = JpaQueryFactory.INSTANCE.fromQueryAnnotation(method, em, evaluationContextProvider);

			if (null != query) {
				return query;
			}

			query = JpaQueryFactory.INSTANCE.fromProcedureAnnotation(method, em);

			if (null != query) {
				return query;
			}

			String name = method.getNamedQueryName();
			if (namedQueries.hasQuery(name)) {
				return JpaQueryFactory.INSTANCE.fromMethodWithQueryString(method, em, namedQueries.getQuery(name),
						evaluationContextProvider);
			}

			query = NamedQuery.lookupFrom(method, em);

			if (null != query) {
				return query;
			}

			throw new IllegalStateException(
					String.format(""Did neither find a NamedQuery nor an annotated query for method %s!"", method));
		}
	}

	/**
	 * {@link QueryLookupStrategy} to try to detect a declared query first (
	 * {@link org.springframework.data.jpa.repository.Query}, JPA named query). In case none is found we fall back on
	 * query creation.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateIfNotFoundQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final DeclaredQueryLookupStrategy lookupStrategy;
		private final CreateQueryLookupStrategy createStrategy;

		/**
		 * Creates a new {@link CreateIfNotFoundQueryLookupStrategy}.
		 * 
		 * @param em
		 * @param extractor
		 * @param createStrategy
		 * @param lookupStrategy
		 */
		public CreateIfNotFoundQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				CreateQueryLookupStrategy createStrategy, DeclaredQueryLookupStrategy lookupStrategy) {

			super(em, extractor);

			this.createStrategy = createStrategy;
			this.lookupStrategy = lookupStrategy;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			try {
				return lookupStrategy.resolveQuery(method, em, namedQueries);
			} catch (IllegalStateException e) {
				return createStrategy.resolveQuery(method, em, namedQueries);
			}
		}
	}

	/**
	 * Creates a {@link QueryLookupStrategy} for the given {@link EntityManager} and {@link Key}.
	 * 
	 * @param em must not be {@literal null}.
	 * @param key may be {@literal null}.
	 * @param extractor must not be {@literal null}.
	 * @param evaluationContextProvider must not be {@literal null}.
	 * @return
	 */
	public static QueryLookupStrategy create(EntityManager em, Key key, QueryExtractor extractor,
			EvaluationContextProvider evaluationContextProvider) {

		Assert.notNull(em, ""EntityManager must not be null!"");
		Assert.notNull(extractor, ""QueryExtractor must not be null!"");
		Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");

		switch (key != null ? key : Key.CREATE_IF_NOT_FOUND) {
			case CREATE:
				return new CreateQueryLookupStrategy(em, extractor);
			case USE_DECLARED_QUERY:
				return new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider);
			case CREATE_IF_NOT_FOUND:
				return new CreateIfNotFoundQueryLookupStrategy(em, extractor, new CreateQueryLookupStrategy(em, extractor),
						new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider));
			default:
				throw new IllegalArgumentException(String.format(""Unsupported query lookup strategy %s!"", key));
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.RepositoryQuery;
import org.springframework.util.Assert;

/**
 * Query lookup strategy to execute finders.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public final class JpaQueryLookupStrategy {

	/**
	 * Private constructor to prevent instantiation.
	 */
	private JpaQueryLookupStrategy() {}

	/**
	 * Base class for {@link QueryLookupStrategy} implementations that need access to an {@link EntityManager}.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private abstract static class AbstractQueryLookupStrategy implements QueryLookupStrategy {

		private final EntityManager em;
		private final QueryExtractor provider;

		/**
		 * Creates a new {@link AbstractQueryLookupStrategy}.
		 * 
		 * @param em
		 * @param extractor
		 */
		public AbstractQueryLookupStrategy(EntityManager em, QueryExtractor extractor) {

			this.em = em;
			this.provider = extractor;
		}

		/* 
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.query.QueryLookupStrategy#resolveQuery(java.lang.reflect.Method, org.springframework.data.repository.core.RepositoryMetadata, org.springframework.data.projection.ProjectionFactory, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		public final RepositoryQuery resolveQuery(Method method, RepositoryMetadata metadata, ProjectionFactory factory,
				NamedQueries namedQueries) {
			return resolveQuery(new JpaQueryMethod(method, metadata, factory, provider), em, namedQueries);
		}

		protected abstract RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries);
	}

	/**
	 * {@link QueryLookupStrategy} to create a query from the method name.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final PersistenceProvider persistenceProvider;
		private final EscapeCharacter escape;

		public CreateQueryLookupStrategy(EntityManager em, QueryExtractor extractor, EscapeCharacter escape) {

			super(em, extractor);

			this.persistenceProvider = PersistenceProvider.fromEntityManager(em);
			this.escape = escape;
		}

		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {
			return new PartTreeJpaQuery(method, em, persistenceProvider, escape);
		}

	}

	/**
	 * {@link QueryLookupStrategy} that tries to detect a declared query declared via {@link Query} annotation followed by
	 * a JPA named query lookup.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class DeclaredQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final EvaluationContextProvider evaluationContextProvider;

		/**
		 * Creates a new {@link DeclaredQueryLookupStrategy}.
		 * 
		 * @param em
		 * @param extractor
		 * @param evaluationContextProvider
		 */
		public DeclaredQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				EvaluationContextProvider evaluationContextProvider) {

			super(em, extractor);
			this.evaluationContextProvider = evaluationContextProvider;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			RepositoryQuery query = JpaQueryFactory.INSTANCE.fromQueryAnnotation(method, em, evaluationContextProvider);

			if (null != query) {
				return query;
			}

			query = JpaQueryFactory.INSTANCE.fromProcedureAnnotation(method, em);

			if (null != query) {
				return query;
			}

			String name = method.getNamedQueryName();
			if (namedQueries.hasQuery(name)) {
				return JpaQueryFactory.INSTANCE.fromMethodWithQueryString(method, em, namedQueries.getQuery(name),
						evaluationContextProvider);
			}

			query = NamedQuery.lookupFrom(method, em);

			if (null != query) {
				return query;
			}

			throw new IllegalStateException(
					String.format(""Did neither find a NamedQuery nor an annotated query for method %s!"", method));
		}
	}

	/**
	 * {@link QueryLookupStrategy} to try to detect a declared query first (
	 * {@link org.springframework.data.jpa.repository.Query}, JPA named query). In case none is found we fall back on
	 * query creation.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateIfNotFoundQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final DeclaredQueryLookupStrategy lookupStrategy;
		private final CreateQueryLookupStrategy createStrategy;

		/**
		 * Creates a new {@link CreateIfNotFoundQueryLookupStrategy}.
		 * 
		 * @param em
		 * @param extractor
		 * @param createStrategy
		 * @param lookupStrategy
		 */
		public CreateIfNotFoundQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				CreateQueryLookupStrategy createStrategy, DeclaredQueryLookupStrategy lookupStrategy) {

			super(em, extractor);

			this.createStrategy = createStrategy;
			this.lookupStrategy = lookupStrategy;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			try {
				return lookupStrategy.resolveQuery(method, em, namedQueries);
			} catch (IllegalStateException e) {
				return createStrategy.resolveQuery(method, em, namedQueries);
			}
		}
	}

	/**
	 * Creates a {@link QueryLookupStrategy} for the given {@link EntityManager} and {@link Key}.
	 * 
	 * @param em must not be {@literal null}.
	 * @param key may be {@literal null}.
	 * @param extractor must not be {@literal null}.
	 * @param evaluationContextProvider must not be {@literal null}.
	 * @param escape
	 * @return
	 */
	public static QueryLookupStrategy create(EntityManager em, Key key, QueryExtractor extractor,
			EvaluationContextProvider evaluationContextProvider, EscapeCharacter escape) {

		Assert.notNull(em, ""EntityManager must not be null!"");
		Assert.notNull(extractor, ""QueryExtractor must not be null!"");
		Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");

		switch (key != null ? key : Key.CREATE_IF_NOT_FOUND) {
			case CREATE:
				return new CreateQueryLookupStrategy(em, extractor, escape);
			case USE_DECLARED_QUERY:
				return new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider);
			case CREATE_IF_NOT_FOUND:
				return new CreateIfNotFoundQueryLookupStrategy(em, extractor,
						new CreateQueryLookupStrategy(em, extractor, escape),
						new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider));
			default:
				throw new IllegalArgumentException(String.format(""Unsupported query lookup strategy %s!"", key));
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/ParameterMetadataProvider.java,"/*
 * Copyright 2011-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.repository.query.Parameter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.expression.Expression;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;

/**
 * Helper class to allow easy creation of {@link ParameterMetadata}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Mark Paluch
 */
class ParameterMetadataProvider {

	private final CriteriaBuilder builder;
	private final Iterator<? extends Parameter> parameters;
	private final List<ParameterMetadata<?>> expressions;
	private final Iterator<Object> bindableParameterValues;
	private final PersistenceProvider persistenceProvider;

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and
	 * {@link ParametersParameterAccessor} with support for parameter value customizations via {@link PersistenceProvider}
	 * .
	 * 
	 * @param builder must not be {@literal null}.
	 * @param accessor must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, ParametersParameterAccessor accessor,
			PersistenceProvider provider) {
		this(builder, accessor.iterator(), accessor.getParameters(), provider);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and {@link Parameters} with
	 * support for parameter value customizations via {@link PersistenceProvider}.
	 * 
	 * @param builder must not be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, Parameters<?, ?> parameters, PersistenceProvider provider) {
		this(builder, null, parameters, provider);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} an {@link Iterable} of all
	 * bindable parameter values, and {@link Parameters} with support for parameter value customizations via
	 * {@link PersistenceProvider}.
	 * 
	 * @param builder must not be {@literal null}.
	 * @param bindableParameterValues may be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	private ParameterMetadataProvider(CriteriaBuilder builder, Iterator<Object> bindableParameterValues,
			Parameters<?, ?> parameters, PersistenceProvider provider) {

		Assert.notNull(builder, ""CriteriaBuilder must not be null!"");
		Assert.notNull(parameters, ""Parameters must not be null!"");
		Assert.notNull(provider, ""PesistenceProvider must not be null!"");

		this.builder = builder;
		this.parameters = parameters.getBindableParameters().iterator();
		this.expressions = new ArrayList<ParameterMetadata<?>>();
		this.bindableParameterValues = bindableParameterValues;
		this.persistenceProvider = provider;
	}

	/**
	 * Returns all {@link ParameterMetadata}s built.
	 * 
	 * @return the expressions
	 */
	public List<ParameterMetadata<?>> getExpressions() {
		return Collections.unmodifiableList(expressions);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for given {@link Part} and the next {@link Parameter}.
	 * 
	 * @param <T>
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<T> next(Part part) {

		Assert.isTrue(parameters.hasNext(), String.format(""No parameter available for part %s."", part));

		Parameter parameter = parameters.next();
		return (ParameterMetadata<T>) next(part, parameter.getType(), parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} of the given {@link Part} and type. Forwards the underlying
	 * {@link Parameters} as well.
	 * 
	 * @param <T>
	 * @param type must not be {@literal null}.
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<? extends T> next(Part part, Class<T> type) {

		Parameter parameter = parameters.next();
		Class<?> typeToUse = ClassUtils.isAssignable(type, parameter.getType()) ? parameter.getType() : type;
		return (ParameterMetadata<? extends T>) next(part, typeToUse, parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for the given type and name.
	 * 
	 * @param <T>
	 * @param part must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param parameter
	 * @return
	 */
	private <T> ParameterMetadata<T> next(Part part, Class<T> type, Parameter parameter) {

		Assert.notNull(type, ""Type must not be null!"");

		/*
		 * We treat Expression types as Object vales since the real value to be bound as a parameter is determined at query time.
		 */
		@SuppressWarnings(""unchecked"")
		Class<T> reifiedType = Expression.class.equals(type) ? (Class<T>) Object.class : type;

		ParameterExpression<T> expression = parameter.isExplicitlyNamed()
				? builder.parameter(reifiedType, parameter.getName())
				: builder.parameter(reifiedType);
		ParameterMetadata<T> value = new ParameterMetadata<T>(expression, part.getType(),
				bindableParameterValues == null ? ParameterMetadata.PLACEHOLDER : bindableParameterValues.next(),
				this.persistenceProvider);
		expressions.add(value);

		return value;
	}

	/**
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 * @param <T>
	 */
	static class ParameterMetadata<T> {

		static final Object PLACEHOLDER = new Object();

		private final Type type;
		private final ParameterExpression<T> expression;
		private final PersistenceProvider persistenceProvider;

		/**
		 * Creates a new {@link ParameterMetadata}.
		 * 
		 * @param expression
		 * @param type
		 * @param value
		 * @param provider
		 */
		public ParameterMetadata(ParameterExpression<T> expression, Type type, Object value, PersistenceProvider provider) {

			this.expression = expression;
			this.persistenceProvider = provider;
			this.type = value == null && Type.SIMPLE_PROPERTY.equals(type) ? Type.IS_NULL : type;
		}

		/**
		 * Returns the {@link ParameterExpression}.
		 * 
		 * @return the expression
		 */
		public ParameterExpression<T> getExpression() {
			return expression;
		}

		/**
		 * Returns whether the parameter shall be considered an {@literal IS NULL} parameter.
		 * 
		 * @return
		 */
		public boolean isIsNullParameter() {
			return Type.IS_NULL.equals(type);
		}

		/**
		 * Prepares the object before it's actually bound to the {@link javax.persistence.Query;}.
		 * 
		 * @param value must not be {@literal null}.
		 * @return
		 */
		public Object prepare(Object value) {

			Assert.notNull(value, ""Value must not be null!"");

			Class<? extends T> expressionType = expression.getJavaType();

			if (String.class.equals(expressionType)) {

				switch (type) {
					case STARTING_WITH:
						return String.format(""%s%%"", value.toString());
					case ENDING_WITH:
						return String.format(""%%%s"", value.toString());
					case CONTAINING:
					case NOT_CONTAINING:
						return String.format(""%%%s%%"", value.toString());
					default:
						return value;
				}
			}

			return Collection.class.isAssignableFrom(expressionType)
					? persistenceProvider.potentiallyConvertEmptyCollection(toCollection(value))
					: value;
		}

		/**
		 * Returns the given argument as {@link Collection} which means it will return it as is if it's a
		 * {@link Collections}, turn an array into an {@link ArrayList} or simply wrap any other value into a single element
		 * {@link Collections}.
		 * 
		 * @param value
		 * @return
		 */
		private static Collection<?> toCollection(Object value) {

			if (value == null) {
				return null;
			}

			if (value instanceof Collection) {
				return (Collection<?>) value;
			}

			if (ObjectUtils.isArray(value)) {
				return Arrays.asList(ObjectUtils.toObjectArray(value));
			}

			return Collections.singleton(value);
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/ParameterMetadataProvider.java,"/*
 * Copyright 2011-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.Parameter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.expression.Expression;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;

/**
 * Helper class to allow easy creation of {@link ParameterMetadata}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Mark Paluch
 */
class ParameterMetadataProvider {

	private final CriteriaBuilder builder;
	private final Iterator<? extends Parameter> parameters;
	private final List<ParameterMetadata<?>> expressions;
	private final Iterator<Object> bindableParameterValues;
	private final PersistenceProvider persistenceProvider;
	private final EscapeCharacter escape;

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and
	 * {@link ParametersParameterAccessor} with support for parameter value customizations via {@link PersistenceProvider}
	 * .
	 * 
	 * @param builder must not be {@literal null}.
	 * @param accessor must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, ParametersParameterAccessor accessor,
									 PersistenceProvider provider, EscapeCharacter escape) {
		this(builder, accessor.iterator(), accessor.getParameters(), provider, escape);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and {@link Parameters} with
	 * support for parameter value customizations via {@link PersistenceProvider}.
	 * 
	 *  @param builder must not be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, Parameters<?, ?> parameters, PersistenceProvider provider, EscapeCharacter escape) {
		this(builder, null, parameters, provider, escape);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} an {@link Iterable} of all
	 * bindable parameter values, and {@link Parameters} with support for parameter value customizations via
	 * {@link PersistenceProvider}.
	 * 
	 * @param builder must not be {@literal null}.
	 * @param bindableParameterValues may be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	private ParameterMetadataProvider(CriteriaBuilder builder, Iterator<Object> bindableParameterValues,
									  Parameters<?, ?> parameters, PersistenceProvider provider, EscapeCharacter escape) {

		Assert.notNull(builder, ""CriteriaBuilder must not be null!"");
		Assert.notNull(parameters, ""Parameters must not be null!"");
		Assert.notNull(provider, ""PesistenceProvider must not be null!"");

		this.builder = builder;
		this.parameters = parameters.getBindableParameters().iterator();
		this.expressions = new ArrayList<ParameterMetadata<?>>();
		this.bindableParameterValues = bindableParameterValues;
		this.persistenceProvider = provider;
		this.escape = escape;
	}

	/**
	 * Returns all {@link ParameterMetadata}s built.
	 * 
	 * @return the expressions
	 */
	public List<ParameterMetadata<?>> getExpressions() {
		return Collections.unmodifiableList(expressions);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for given {@link Part} and the next {@link Parameter}.
	 * 
	 * @param <T>
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<T> next(Part part) {

		Assert.isTrue(parameters.hasNext(), String.format(""No parameter available for part %s."", part));

		Parameter parameter = parameters.next();
		return (ParameterMetadata<T>) next(part, parameter.getType(), parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} of the given {@link Part} and type. Forwards the underlying
	 * {@link Parameters} as well.
	 * 
	 * @param <T>
	 * @param type must not be {@literal null}.
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<? extends T> next(Part part, Class<T> type) {

		Parameter parameter = parameters.next();
		Class<?> typeToUse = ClassUtils.isAssignable(type, parameter.getType()) ? parameter.getType() : type;
		return (ParameterMetadata<? extends T>) next(part, typeToUse, parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for the given type and name.
	 * 
	 * @param <T>
	 * @param part must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param parameter
	 * @return
	 */
	private <T> ParameterMetadata<T> next(Part part, Class<T> type, Parameter parameter) {

		Assert.notNull(type, ""Type must not be null!"");

		/*
		 * We treat Expression types as Object vales since the real value to be bound as a parameter is determined at query time.
		 */
		@SuppressWarnings(""unchecked"")
		Class<T> reifiedType = Expression.class.equals(type) ? (Class<T>) Object.class : type;

		ParameterExpression<T> expression = parameter.isExplicitlyNamed()
				? builder.parameter(reifiedType, parameter.getName())
				: builder.parameter(reifiedType);
		ParameterMetadata<T> value = new ParameterMetadata<T>(expression, part.getType(),
				bindableParameterValues == null ? ParameterMetadata.PLACEHOLDER : bindableParameterValues.next(),
				this.persistenceProvider, escape);
		expressions.add(value);

		return value;
	}

	EscapeCharacter getEscape() {
		return escape;
	}

	/**
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 * @param <T>
	 */
	static class ParameterMetadata<T> {

		static final Object PLACEHOLDER = new Object();

		private final Type type;
		private final ParameterExpression<T> expression;
		private final PersistenceProvider persistenceProvider;
		private final EscapeCharacter escape;

		/**
		 * Creates a new {@link ParameterMetadata}.
		 * 
		 * @param expression
		 * @param type
		 * @param value
		 * @param provider
		 * @param escape
		 */
		public ParameterMetadata(ParameterExpression<T> expression, Type type, Object value, PersistenceProvider provider, EscapeCharacter escape) {

			this.expression = expression;
			this.persistenceProvider = provider;
			this.type = value == null && Type.SIMPLE_PROPERTY.equals(type) ? Type.IS_NULL : type;
			this.escape = escape;
		}

		/**
		 * Returns the {@link ParameterExpression}.
		 * 
		 * @return the expression
		 */
		public ParameterExpression<T> getExpression() {
			return expression;
		}

		/**
		 * Returns whether the parameter shall be considered an {@literal IS NULL} parameter.
		 * 
		 * @return
		 */
		public boolean isIsNullParameter() {
			return Type.IS_NULL.equals(type);
		}

		/**
		 * Prepares the object before it's actually bound to the {@link javax.persistence.Query;}.
		 * 
		 * @param value must not be {@literal null}.
		 * @return
		 */
		public Object prepare(Object value) {

			Assert.notNull(value, ""Value must not be null!"");

			Class<? extends T> expressionType = expression.getJavaType();

			if (String.class.equals(expressionType)) {

				switch (type) {
					case STARTING_WITH:
						return String.format(""%s%%"", escape.escape(value.toString()));
					case ENDING_WITH:
						return String.format(""%%%s"", escape.escape(value.toString()));
					case CONTAINING:
					case NOT_CONTAINING:
						return String.format(""%%%s%%"", escape.escape(value.toString()));
					default:
						return value;
				}
			}

			return Collection.class.isAssignableFrom(expressionType)
					? persistenceProvider.potentiallyConvertEmptyCollection(toCollection(value))
					: value;
		}

		/**
		 * Returns the given argument as {@link Collection} which means it will return it as is if it's a
		 * {@link Collections}, turn an array into an {@link ArrayList} or simply wrap any other value into a single element
		 * {@link Collections}.
		 * 
		 * @param value
		 * @return
		 */
		private static Collection<?> toCollection(Object value) {

			if (value == null) {
				return null;
			}

			if (value instanceof Collection) {
				return (Collection<?>) value;
			}

			if (ObjectUtils.isArray(value)) {
				return Arrays.asList(ObjectUtils.toObjectArray(value));
			}

			return Collections.singleton(value);
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/PartTreeJpaQuery.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.DeleteExecution;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.ExistsExecution;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.ResultProcessor;
import org.springframework.data.repository.query.parser.PartTree;

/**
 * A {@link AbstractJpaQuery} implementation based on a {@link PartTree}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public class PartTreeJpaQuery extends AbstractJpaQuery {

	private final Class<?> domainClass;
	private final PartTree tree;
	private final JpaParameters parameters;

	private final QueryPreparer query;
	private final QueryPreparer countQuery;
	private final EntityManager em;

	/**
	 * Creates a new {@link PartTreeJpaQuery}.
	 * 
	 * @param method must not be {@literal null}.
	 * @param factory must not be {@literal null}.
	 * @param em must not be {@literal null}.
	 */
	public PartTreeJpaQuery(JpaQueryMethod method, EntityManager em, PersistenceProvider persistenceProvider) {

		super(method, em);

		this.em = em;
		this.domainClass = method.getEntityInformation().getJavaType();
		this.parameters = method.getParameters();

		boolean recreationRequired = parameters.hasDynamicProjection() || parameters.potentiallySortsDynamically();

		try {

			this.tree = new PartTree(method.getName(), domainClass);
			this.countQuery = new CountQueryPreparer(persistenceProvider, recreationRequired);
			this.query = tree.isCountProjection() ? countQuery : new QueryPreparer(persistenceProvider, recreationRequired);

		} catch (Exception o_O) {
			throw new IllegalArgumentException(
					String.format(""Failed to create query method %s! %s"", method, o_O.getMessage()), o_O);
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateQuery(java.lang.Object[])
	 */
	@Override
	public Query doCreateQuery(Object[] values) {
		return query.createQuery(values);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateCountQuery(java.lang.Object[])
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public TypedQuery<Long> doCreateCountQuery(Object[] values) {
		return (TypedQuery<Long>) countQuery.createQuery(values);
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#getExecution()
	 */
	@Override
	protected JpaQueryExecution getExecution() {

		if (this.tree.isDelete()) {
			return new DeleteExecution(em);
		} else if (this.tree.isExistsProjection()) {
			return new ExistsExecution();
		}

		return super.getExecution();
	}

	/**
	 * Query preparer to create {@link CriteriaQuery} instances and potentially cache them.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class QueryPreparer {

		private final CriteriaQuery<?> cachedCriteriaQuery;
		private final List<ParameterMetadata<?>> expressions;
		private final PersistenceProvider persistenceProvider;

		public QueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {

			this.persistenceProvider = persistenceProvider;

			JpaQueryCreator creator = createCreator(null, persistenceProvider);

			this.cachedCriteriaQuery = recreateQueries ? null : creator.createQuery();
			this.expressions = recreateQueries ? null : creator.getParameterExpressions();
		}

		/**
		 * Creates a new {@link Query} for the given parameter values.
		 * 
		 * @param values
		 * @return
		 */
		public Query createQuery(Object[] values) {

			CriteriaQuery<?> criteriaQuery = cachedCriteriaQuery;
			List<ParameterMetadata<?>> expressions = this.expressions;
			ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, values);

			if (cachedCriteriaQuery == null || accessor.hasBindableNullValue()) {
				JpaQueryCreator creator = createCreator(accessor, persistenceProvider);
				criteriaQuery = creator.createQuery(getDynamicSort(values));
				expressions = creator.getParameterExpressions();
			}

			TypedQuery<?> jpaQuery = createQuery(criteriaQuery);

			return restrictMaxResultsIfNecessary(invokeBinding(getBinder(values, expressions), jpaQuery));
		}

		/**
		 * Restricts the max results of the given {@link Query} if the current {@code tree} marks this {@code query} as
		 * limited.
		 * 
		 * @param query
		 * @return
		 */
		private Query restrictMaxResultsIfNecessary(Query query) {

			if (tree.isLimiting()) {

				if (query.getMaxResults() != Integer.MAX_VALUE) {
					/*
					 * In order to return the correct results, we have to adjust the first result offset to be returned if:
					 * - a Pageable parameter is present 
					 * - AND the requested page number > 0
					 * - AND the requested page size was bigger than the derived result limitation via the First/Top keyword.
					 */
					if (query.getMaxResults() > tree.getMaxResults() && query.getFirstResult() > 0) {
						query.setFirstResult(query.getFirstResult() - (query.getMaxResults() - tree.getMaxResults()));
					}
				}

				query.setMaxResults(tree.getMaxResults());
			}

			if (tree.isExistsProjection()) {
				query.setMaxResults(1);
			}

			return query;
		}

		/**
		 * Checks whether we are working with a cached {@link CriteriaQuery} and synchronizes the creation of a
		 * {@link TypedQuery} instance from it. This is due to non-thread-safety in the {@link CriteriaQuery} implementation
		 * of some persistence providers (i.e. Hibernate in this case), see DATAJPA-396.
		 * 
		 * @param criteriaQuery must not be {@literal null}.
		 * @return
		 */
		private TypedQuery<?> createQuery(CriteriaQuery<?> criteriaQuery) {

			if (this.cachedCriteriaQuery != null) {
				synchronized (this.cachedCriteriaQuery) {
					return getEntityManager().createQuery(criteriaQuery);
				}
			}

			return getEntityManager().createQuery(criteriaQuery);
		}

		protected JpaQueryCreator createCreator(ParametersParameterAccessor accessor,
				PersistenceProvider persistenceProvider) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor == null
					? new ParameterMetadataProvider(builder, parameters, persistenceProvider)
					: new ParameterMetadataProvider(builder, accessor, persistenceProvider);

			ResultProcessor resultFactory = getQueryMethod().getResultProcessor().withDynamicProjection(accessor);

			return new JpaQueryCreator(tree, resultFactory.getReturnedType(), builder, provider);
		}

		/**
		 * Invokes parameter binding on the given {@link TypedQuery}.
		 * 
		 * @param binder
		 * @param query
		 * @return
		 */
		protected Query invokeBinding(ParameterBinder binder, TypedQuery<?> query) {

			return binder.bindAndPrepare(query);
		}

		private ParameterBinder getBinder(Object[] values, List<ParameterMetadata<?>> expressions) {
			return new CriteriaQueryParameterBinder(parameters, values, expressions);
		}

		private Sort getDynamicSort(Object[] values) {

			return parameters.potentiallySortsDynamically() ? new ParametersParameterAccessor(parameters, values).getSort()
					: null;
		}
	}

	/**
	 * Special {@link QueryPreparer} to create count queries.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class CountQueryPreparer extends QueryPreparer {

		public CountQueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {
			super(persistenceProvider, recreateQueries);
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#createCreator(org.springframework.data.repository.query.ParametersParameterAccessor, org.springframework.data.jpa.provider.PersistenceProvider)
		 */
		@Override
		protected JpaQueryCreator createCreator(ParametersParameterAccessor accessor,
				PersistenceProvider persistenceProvider) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor == null
					? new ParameterMetadataProvider(builder, parameters, persistenceProvider)
					: new ParameterMetadataProvider(builder, accessor, persistenceProvider);

			return new JpaCountQueryCreator(tree, getQueryMethod().getResultProcessor().getReturnedType(), builder, provider);
		}

		/**
		 * Customizes binding by skipping the pagination.
		 * 
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#invokeBinding(org.springframework.data.jpa.repository.query.ParameterBinder,
		 *      javax.persistence.TypedQuery)
		 */
		@Override
		protected Query invokeBinding(ParameterBinder binder, javax.persistence.TypedQuery<?> query) {
			return binder.bind(query);
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/PartTreeJpaQuery.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.DeleteExecution;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.ExistsExecution;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.ResultProcessor;
import org.springframework.data.repository.query.parser.PartTree;

/**
 * A {@link AbstractJpaQuery} implementation based on a {@link PartTree}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public class PartTreeJpaQuery extends AbstractJpaQuery {

	private final Class<?> domainClass;
	private final PartTree tree;
	private final JpaParameters parameters;

	private final QueryPreparer query;
	private final QueryPreparer countQuery;
	private final EntityManager em;
	private final EscapeCharacter escape;

	/**
	 * Creates a new {@link PartTreeJpaQuery}.
	 * 
	 * @param method must not be {@literal null}.
	 * @param factory must not be {@literal null}.
	 * @param em must not be {@literal null}.
	 * @param persistenceProvider must not be {@literal null}.
	 * @param escape
	 */
	public PartTreeJpaQuery(JpaQueryMethod method, EntityManager em, PersistenceProvider persistenceProvider, EscapeCharacter escape) {

		super(method, em);

		this.em = em;
		this.escape = escape;
		this.domainClass = method.getEntityInformation().getJavaType();
		this.parameters = method.getParameters();

		boolean recreationRequired = parameters.hasDynamicProjection() || parameters.potentiallySortsDynamically();

		try {

			this.tree = new PartTree(method.getName(), domainClass);
			this.countQuery = new CountQueryPreparer(persistenceProvider, recreationRequired);
			this.query = tree.isCountProjection() ? countQuery : new QueryPreparer(persistenceProvider, recreationRequired);

		} catch (Exception o_O) {
			throw new IllegalArgumentException(
					String.format(""Failed to create query method %s! %s"", method, o_O.getMessage()), o_O);
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateQuery(java.lang.Object[])
	 */
	@Override
	public Query doCreateQuery(Object[] values) {
		return query.createQuery(values);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateCountQuery(java.lang.Object[])
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public TypedQuery<Long> doCreateCountQuery(Object[] values) {
		return (TypedQuery<Long>) countQuery.createQuery(values);
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#getExecution()
	 */
	@Override
	protected JpaQueryExecution getExecution() {

		if (this.tree.isDelete()) {
			return new DeleteExecution(em);
		} else if (this.tree.isExistsProjection()) {
			return new ExistsExecution();
		}

		return super.getExecution();
	}

	/**
	 * Query preparer to create {@link CriteriaQuery} instances and potentially cache them.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class QueryPreparer {

		private final CriteriaQuery<?> cachedCriteriaQuery;
		private final List<ParameterMetadata<?>> expressions;
		private final PersistenceProvider persistenceProvider;

		public QueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {

			this.persistenceProvider = persistenceProvider;

			JpaQueryCreator creator = createCreator(null, persistenceProvider);

			this.cachedCriteriaQuery = recreateQueries ? null : creator.createQuery();
			this.expressions = recreateQueries ? null : creator.getParameterExpressions();
		}

		/**
		 * Creates a new {@link Query} for the given parameter values.
		 * 
		 * @param values
		 * @return
		 */
		public Query createQuery(Object[] values) {

			CriteriaQuery<?> criteriaQuery = cachedCriteriaQuery;
			List<ParameterMetadata<?>> expressions = this.expressions;
			ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, values);

			if (cachedCriteriaQuery == null || accessor.hasBindableNullValue()) {
				JpaQueryCreator creator = createCreator(accessor, persistenceProvider);
				criteriaQuery = creator.createQuery(getDynamicSort(values));
				expressions = creator.getParameterExpressions();
			}

			TypedQuery<?> jpaQuery = createQuery(criteriaQuery);

			return restrictMaxResultsIfNecessary(invokeBinding(getBinder(values, expressions), jpaQuery));
		}

		/**
		 * Restricts the max results of the given {@link Query} if the current {@code tree} marks this {@code query} as
		 * limited.
		 * 
		 * @param query
		 * @return
		 */
		private Query restrictMaxResultsIfNecessary(Query query) {

			if (tree.isLimiting()) {

				if (query.getMaxResults() != Integer.MAX_VALUE) {
					/*
					 * In order to return the correct results, we have to adjust the first result offset to be returned if:
					 * - a Pageable parameter is present 
					 * - AND the requested page number > 0
					 * - AND the requested page size was bigger than the derived result limitation via the First/Top keyword.
					 */
					if (query.getMaxResults() > tree.getMaxResults() && query.getFirstResult() > 0) {
						query.setFirstResult(query.getFirstResult() - (query.getMaxResults() - tree.getMaxResults()));
					}
				}

				query.setMaxResults(tree.getMaxResults());
			}

			if (tree.isExistsProjection()) {
				query.setMaxResults(1);
			}

			return query;
		}

		/**
		 * Checks whether we are working with a cached {@link CriteriaQuery} and synchronizes the creation of a
		 * {@link TypedQuery} instance from it. This is due to non-thread-safety in the {@link CriteriaQuery} implementation
		 * of some persistence providers (i.e. Hibernate in this case), see DATAJPA-396.
		 * 
		 * @param criteriaQuery must not be {@literal null}.
		 * @return
		 */
		private TypedQuery<?> createQuery(CriteriaQuery<?> criteriaQuery) {

			if (this.cachedCriteriaQuery != null) {
				synchronized (this.cachedCriteriaQuery) {
					return getEntityManager().createQuery(criteriaQuery);
				}
			}

			return getEntityManager().createQuery(criteriaQuery);
		}

		protected JpaQueryCreator createCreator(ParametersParameterAccessor accessor,
				PersistenceProvider persistenceProvider) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor == null
					? new ParameterMetadataProvider(builder, parameters, persistenceProvider, escape)
					: new ParameterMetadataProvider(builder, accessor, persistenceProvider, escape);

			ResultProcessor resultFactory = getQueryMethod().getResultProcessor().withDynamicProjection(accessor);

			return new JpaQueryCreator(tree, resultFactory.getReturnedType(), builder, provider);
		}

		/**
		 * Invokes parameter binding on the given {@link TypedQuery}.
		 * 
		 * @param binder
		 * @param query
		 * @return
		 */
		protected Query invokeBinding(ParameterBinder binder, TypedQuery<?> query) {

			return binder.bindAndPrepare(query);
		}

		private ParameterBinder getBinder(Object[] values, List<ParameterMetadata<?>> expressions) {
			return new CriteriaQueryParameterBinder(parameters, values, expressions);
		}

		private Sort getDynamicSort(Object[] values) {

			return parameters.potentiallySortsDynamically() ? new ParametersParameterAccessor(parameters, values).getSort()
					: null;
		}
	}

	/**
	 * Special {@link QueryPreparer} to create count queries.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class CountQueryPreparer extends QueryPreparer {

		public CountQueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {
			super(persistenceProvider, recreateQueries);
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#createCreator(org.springframework.data.repository.query.ParametersParameterAccessor, org.springframework.data.jpa.provider.PersistenceProvider)
		 */
		@Override
		protected JpaQueryCreator createCreator(ParametersParameterAccessor accessor,
				PersistenceProvider persistenceProvider) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor == null
					? new ParameterMetadataProvider(builder, parameters, persistenceProvider, escape)
					: new ParameterMetadataProvider(builder, accessor, persistenceProvider, escape);

			return new JpaCountQueryCreator(tree, getQueryMethod().getResultProcessor().getReturnedType(), builder, provider);
		}

		/**
		 * Customizes binding by skipping the pagination.
		 * 
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#invokeBinding(org.springframework.data.jpa.repository.query.ParameterBinder,
		 *      javax.persistence.TypedQuery)
		 */
		@Override
		protected Query invokeBinding(ParameterBinder binder, javax.persistence.TypedQuery<?> query) {
			return binder.bind(query);
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactory.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import static org.springframework.data.querydsl.QueryDslUtils.*;

import lombok.extern.slf4j.Slf4j;

import java.io.Serializable;

import javax.persistence.EntityManager;
import javax.persistence.Tuple;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.data.jpa.projection.CollectionAwareProjectionFactory;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.query.AbstractJpaQuery;
import org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy;
import org.springframework.data.jpa.repository.query.JpaQueryMethod;
import org.springframework.data.jpa.util.JpaMetamodel;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.querydsl.QueryDslPredicateExecutor;
import org.springframework.data.repository.core.RepositoryInformation;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.QueryCreationListener;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.util.Assert;

/**
 * JPA specific generic repository factory.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Jens Schauder
 */
public class JpaRepositoryFactory extends RepositoryFactorySupport {

	private final EntityManager entityManager;
	private final QueryExtractor extractor;
	private final CrudMethodMetadataPostProcessor crudMethodMetadataPostProcessor;

	/**
	 * Creates a new {@link JpaRepositoryFactory}.
	 * 
	 * @param entityManager must not be {@literal null}
	 */
	public JpaRepositoryFactory(EntityManager entityManager) {

		Assert.notNull(entityManager, ""EntityManager must not be null!"");

		this.entityManager = entityManager;
		this.extractor = PersistenceProvider.fromEntityManager(entityManager);
		this.crudMethodMetadataPostProcessor = new CrudMethodMetadataPostProcessor();

		addRepositoryProxyPostProcessor(crudMethodMetadataPostProcessor);

		if (extractor.equals(PersistenceProvider.ECLIPSELINK)) {
			addQueryCreationListener(new EclipseLinkProjectionQueryCreationListener(entityManager));
		}
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#setBeanClassLoader(java.lang.ClassLoader)
	 */
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {

		super.setBeanClassLoader(classLoader);
		this.crudMethodMetadataPostProcessor.setBeanClassLoader(classLoader);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getTargetRepository(org.springframework.data.repository.core.RepositoryMetadata)
	 */
	@Override
	protected Object getTargetRepository(RepositoryInformation information) {

		SimpleJpaRepository<?, ?> repository = getTargetRepository(information, entityManager);
		repository.setRepositoryMethodMetadata(crudMethodMetadataPostProcessor.getCrudMethodMetadata());

		return repository;
	}

	/**
	 * Callback to create a {@link JpaRepository} instance with the given {@link EntityManager}
	 * 
	 * @param <T>
	 * @param <ID>
	 * @param entityManager
	 * @see #getTargetRepository(RepositoryMetadata)
	 * @return
	 */
	protected <T, ID extends Serializable> SimpleJpaRepository<?, ?> getTargetRepository(
			RepositoryInformation information, EntityManager entityManager) {

		JpaEntityInformation<?, Serializable> entityInformation = getEntityInformation(information.getDomainType());

		return getTargetRepositoryViaReflection(information, entityInformation, entityManager);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.springframework.data.repository.support.RepositoryFactorySupport#
	 * getRepositoryBaseClass()
	 */
	@Override
	protected Class<?> getRepositoryBaseClass(RepositoryMetadata metadata) {

		if (isQueryDslExecutor(metadata.getRepositoryInterface())) {
			return QueryDslJpaRepository.class;
		} else {
			return SimpleJpaRepository.class;
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getProjectionFactory(java.lang.ClassLoader, org.springframework.beans.factory.BeanFactory)
	 */
	@Override
	protected ProjectionFactory getProjectionFactory(ClassLoader classLoader, BeanFactory beanFactory) {

		CollectionAwareProjectionFactory factory = new CollectionAwareProjectionFactory();
		factory.setBeanClassLoader(classLoader);
		factory.setBeanFactory(beanFactory);

		return factory;
	}

	/**
	 * Returns whether the given repository interface requires a QueryDsl specific implementation to be chosen.
	 * 
	 * @param repositoryInterface
	 * @return
	 */
	private boolean isQueryDslExecutor(Class<?> repositoryInterface) {

		return QUERY_DSL_PRESENT && QueryDslPredicateExecutor.class.isAssignableFrom(repositoryInterface);
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getQueryLookupStrategy(org.springframework.data.repository.query.QueryLookupStrategy.Key, org.springframework.data.repository.query.EvaluationContextProvider)
	 */
	@Override
	protected QueryLookupStrategy getQueryLookupStrategy(Key key, EvaluationContextProvider evaluationContextProvider) {
		return JpaQueryLookupStrategy.create(entityManager, key, extractor, evaluationContextProvider);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.springframework.data.repository.support.RepositoryFactorySupport#
	 * getEntityInformation(java.lang.Class)
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public <T, ID extends Serializable> JpaEntityInformation<T, ID> getEntityInformation(Class<T> domainClass) {

		return (JpaEntityInformation<T, ID>) JpaEntityInformationSupport.getEntityInformation(domainClass, entityManager);
	}

	/**
	 * Query creation listener that informs EclipseLink users that they have to be extra careful when defining repository
	 * query methods using projections as we have to rely on the declaration order of the accessors in projection
	 * interfaces matching the order in columns. Alias-based mapping doesn't work with EclipseLink as it doesn't support
	 * {@link Tuple} based queries yet.
	 *
	 * @author Oliver Gierke
	 * @since 2.0.5
	 * @see https://bugs.eclipse.org/bugs/show_bug.cgi?id=289141
	 */
	@Slf4j
	private static class EclipseLinkProjectionQueryCreationListener implements QueryCreationListener<AbstractJpaQuery> {

		private static final String ECLIPSELINK_PROJECTIONS = ""Usage of Spring Data projections detected on persistence provider EclipseLink. Make sure the following query methods declare result columns in exactly the order the accessors are declared in the projecting interface or the order of parameters for DTOs:"";

		private final JpaMetamodel metamodel;

		private boolean warningLogged = false;

		/**
		 * Creates a new {@link EclipseLinkProjectionQueryCreationListener} for the given {@link EntityManager}.
		 * 
		 * @param em must not be {@literal null}.
		 */
		public EclipseLinkProjectionQueryCreationListener(EntityManager em) {

			Assert.notNull(em, ""EntityManager must not be null!"");

			this.metamodel = new JpaMetamodel(em.getMetamodel());
		}

		/* 
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.core.support.QueryCreationListener#onCreation(org.springframework.data.repository.query.RepositoryQuery)
		 */
		@Override
		public void onCreation(AbstractJpaQuery query) {

			JpaQueryMethod queryMethod = query.getQueryMethod();
			ReturnedType type = queryMethod.getResultProcessor().getReturnedType();

			if (type.isProjecting() && !metamodel.isJpaManaged(type.getReturnedType())) {

				if (!warningLogged) {
					log.info(ECLIPSELINK_PROJECTIONS);
					this.warningLogged = true;
				}

				log.info("" - {}"", queryMethod);
			}
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactory.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import static org.springframework.data.querydsl.QueryDslUtils.*;

import lombok.extern.slf4j.Slf4j;

import java.io.Serializable;

import javax.persistence.EntityManager;
import javax.persistence.Tuple;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.data.jpa.projection.CollectionAwareProjectionFactory;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.query.AbstractJpaQuery;
import org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy;
import org.springframework.data.jpa.repository.query.JpaQueryMethod;
import org.springframework.data.jpa.util.JpaMetamodel;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.querydsl.QueryDslPredicateExecutor;
import org.springframework.data.repository.core.RepositoryInformation;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.QueryCreationListener;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.util.Assert;

/**
 * JPA specific generic repository factory.
 *
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Jens Schauder
 */
public class JpaRepositoryFactory extends RepositoryFactorySupport {

	private final EntityManager entityManager;
	private final QueryExtractor extractor;
	private final CrudMethodMetadataPostProcessor crudMethodMetadataPostProcessor;

	private EscapeCharacter escapeCharacter = EscapeCharacter.of('\\');

	/**
	 * Creates a new {@link JpaRepositoryFactory}.
	 *
	 * @param entityManager must not be {@literal null}
	 */
	public JpaRepositoryFactory(EntityManager entityManager) {

		Assert.notNull(entityManager, ""EntityManager must not be null!"");

		this.entityManager = entityManager;
		this.extractor = PersistenceProvider.fromEntityManager(entityManager);
		this.crudMethodMetadataPostProcessor = new CrudMethodMetadataPostProcessor();

		addRepositoryProxyPostProcessor(crudMethodMetadataPostProcessor);

		if (extractor.equals(PersistenceProvider.ECLIPSELINK)) {
			addQueryCreationListener(new EclipseLinkProjectionQueryCreationListener(entityManager));
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#setBeanClassLoader(java.lang.ClassLoader)
	 */
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {

		super.setBeanClassLoader(classLoader);
		this.crudMethodMetadataPostProcessor.setBeanClassLoader(classLoader);
	}

	/**
	 * Configures the escape character to be used for like-expressions created for derived queries.
	 *
	 * @param escapeCharacter a character used for escaping in certain like expressions.
	 */
	public void setEscapeCharacter(EscapeCharacter escapeCharacter) {
		this.escapeCharacter = escapeCharacter;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getTargetRepository(org.springframework.data.repository.core.RepositoryMetadata)
	 */
	@Override
	protected Object getTargetRepository(RepositoryInformation information) {

		SimpleJpaRepository<?, ?> repository = getTargetRepository(information, entityManager);
		repository.setRepositoryMethodMetadata(crudMethodMetadataPostProcessor.getCrudMethodMetadata());

		return repository;
	}

	/**
	 * Callback to create a {@link JpaRepository} instance with the given {@link EntityManager}
	 *
	 * @param <T>
	 * @param <ID>
	 * @param entityManager
	 * @see #getTargetRepository(RepositoryMetadata)
	 * @return
	 */
	protected <T, ID extends Serializable> SimpleJpaRepository<?, ?> getTargetRepository(
			RepositoryInformation information, EntityManager entityManager) {

		JpaEntityInformation<?, Serializable> entityInformation = getEntityInformation(information.getDomainType());

		return getTargetRepositoryViaReflection(information, entityInformation, entityManager);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.springframework.data.repository.support.RepositoryFactorySupport#
	 * getRepositoryBaseClass()
	 */
	@Override
	protected Class<?> getRepositoryBaseClass(RepositoryMetadata metadata) {

		if (isQueryDslExecutor(metadata.getRepositoryInterface())) {
			return QueryDslJpaRepository.class;
		} else {
			return SimpleJpaRepository.class;
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getProjectionFactory(java.lang.ClassLoader, org.springframework.beans.factory.BeanFactory)
	 */
	@Override
	protected ProjectionFactory getProjectionFactory(ClassLoader classLoader, BeanFactory beanFactory) {

		CollectionAwareProjectionFactory factory = new CollectionAwareProjectionFactory();
		factory.setBeanClassLoader(classLoader);
		factory.setBeanFactory(beanFactory);

		return factory;
	}

	/**
	 * Returns whether the given repository interface requires a QueryDsl specific implementation to be chosen.
	 *
	 * @param repositoryInterface
	 * @return
	 */
	private boolean isQueryDslExecutor(Class<?> repositoryInterface) {

		return QUERY_DSL_PRESENT && QueryDslPredicateExecutor.class.isAssignableFrom(repositoryInterface);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getQueryLookupStrategy(org.springframework.data.repository.query.QueryLookupStrategy.Key, org.springframework.data.repository.query.EvaluationContextProvider)
	 */
	@Override
	protected QueryLookupStrategy getQueryLookupStrategy(Key key, EvaluationContextProvider evaluationContextProvider) {
		return JpaQueryLookupStrategy.create(entityManager, key, extractor, evaluationContextProvider, escapeCharacter);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.springframework.data.repository.support.RepositoryFactorySupport#
	 * getEntityInformation(java.lang.Class)
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public <T, ID extends Serializable> JpaEntityInformation<T, ID> getEntityInformation(Class<T> domainClass) {

		return (JpaEntityInformation<T, ID>) JpaEntityInformationSupport.getEntityInformation(domainClass, entityManager);
	}

	/**
	 * Query creation listener that informs EclipseLink users that they have to be extra careful when defining repository
	 * query methods using projections as we have to rely on the declaration order of the accessors in projection
	 * interfaces matching the order in columns. Alias-based mapping doesn't work with EclipseLink as it doesn't support
	 * {@link Tuple} based queries yet.
	 *
	 * @author Oliver Gierke
	 * @since 2.0.5
	 * @see https://bugs.eclipse.org/bugs/show_bug.cgi?id=289141
	 */
	@Slf4j
	private static class EclipseLinkProjectionQueryCreationListener implements QueryCreationListener<AbstractJpaQuery> {

		private static final String ECLIPSELINK_PROJECTIONS = ""Usage of Spring Data projections detected on persistence provider EclipseLink. Make sure the following query methods declare result columns in exactly the order the accessors are declared in the projecting interface or the order of parameters for DTOs:"";

		private final JpaMetamodel metamodel;

		private boolean warningLogged = false;

		/**
		 * Creates a new {@link EclipseLinkProjectionQueryCreationListener} for the given {@link EntityManager}.
		 *
		 * @param em must not be {@literal null}.
		 */
		public EclipseLinkProjectionQueryCreationListener(EntityManager em) {

			Assert.notNull(em, ""EntityManager must not be null!"");

			this.metamodel = new JpaMetamodel(em.getMetamodel());
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.core.support.QueryCreationListener#onCreation(org.springframework.data.repository.query.RepositoryQuery)
		 */
		@Override
		public void onCreation(AbstractJpaQuery query) {

			JpaQueryMethod queryMethod = query.getQueryMethod();
			ReturnedType type = queryMethod.getResultProcessor().getReturnedType();

			if (type.isProjecting() && !metamodel.isJpaManaged(type.getReturnedType())) {

				if (!warningLogged) {
					log.info(ECLIPSELINK_PROJECTIONS);
					this.warningLogged = true;
				}

				log.info("" - {}"", queryMethod);
			}
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryBean.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import java.io.Serializable;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.springframework.data.mapping.context.MappingContext;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.core.support.TransactionalRepositoryFactoryBeanSupport;
import org.springframework.util.Assert;

/**
 * Special adapter for Springs {@link org.springframework.beans.factory.FactoryBean} interface to allow easy setup of
 * repository factories via Spring configuration.
 * 
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @param <T> the type of the repository
 */
public class JpaRepositoryFactoryBean<T extends Repository<S, ID>, S, ID extends Serializable>
		extends TransactionalRepositoryFactoryBeanSupport<T, S, ID> {

	private EntityManager entityManager;

	/**
	 * Creates a new {@link JpaRepositoryFactoryBean} for the given repository interface.
	 * 
	 * @param repositoryInterface must not be {@literal null}.
	 */
	public JpaRepositoryFactoryBean(Class<? extends T> repositoryInterface) {
		super(repositoryInterface);
	}

	/**
	 * The {@link EntityManager} to be used.
	 * 
	 * @param entityManager the entityManager to set
	 */
	@PersistenceContext
	public void setEntityManager(EntityManager entityManager) {
		this.entityManager = entityManager;
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport#setMappingContext(org.springframework.data.mapping.context.MappingContext)
	 */
	@Override
	public void setMappingContext(MappingContext<?, ?> mappingContext) {
		super.setMappingContext(mappingContext);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.springframework.data.repository.support.
	 * TransactionalRepositoryFactoryBeanSupport#doCreateRepositoryFactory()
	 */
	@Override
	protected RepositoryFactorySupport doCreateRepositoryFactory() {
		return createRepositoryFactory(entityManager);
	}

	/**
	 * Returns a {@link RepositoryFactorySupport}.
	 * 
	 * @param entityManager
	 * @return
	 */
	protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {
		return new JpaRepositoryFactory(entityManager);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() {

		Assert.notNull(entityManager, ""EntityManager must not be null!"");
		super.afterPropertiesSet();
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryBean.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import java.io.Serializable;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.springframework.data.mapping.context.MappingContext;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.core.support.TransactionalRepositoryFactoryBeanSupport;
import org.springframework.util.Assert;

/**
 * Special adapter for Springs {@link org.springframework.beans.factory.FactoryBean} interface to allow easy setup of
 * repository factories via Spring configuration.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @param <T> the type of the repository
 */
public class JpaRepositoryFactoryBean<T extends Repository<S, ID>, S, ID extends Serializable>
		extends TransactionalRepositoryFactoryBeanSupport<T, S, ID> {

	private EntityManager entityManager;
	private EscapeCharacter escapeCharacter = EscapeCharacter.of('\\');

	/**
	 * Creates a new {@link JpaRepositoryFactoryBean} for the given repository interface.
	 *
	 * @param repositoryInterface must not be {@literal null}.
	 */
	public JpaRepositoryFactoryBean(Class<? extends T> repositoryInterface) {
		super(repositoryInterface);
	}

	/**
	 * Configures the escape character to be used to escape reserved characters for LIKE expressions.
	 *
	 * @param escapeCharacter
	 */
	public void setEscapeCharacter(char escapeCharacter) {
		this.escapeCharacter = EscapeCharacter.of(escapeCharacter);
	}

	/**
	 * The {@link EntityManager} to be used.
	 *
	 * @param entityManager the entityManager to set
	 */
	@PersistenceContext
	public void setEntityManager(EntityManager entityManager) {
		this.entityManager = entityManager;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport#setMappingContext(org.springframework.data.mapping.context.MappingContext)
	 */
	@Override
	public void setMappingContext(MappingContext<?, ?> mappingContext) {
		super.setMappingContext(mappingContext);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.springframework.data.repository.support.
	 * TransactionalRepositoryFactoryBeanSupport#doCreateRepositoryFactory()
	 */
	@Override
	protected RepositoryFactorySupport doCreateRepositoryFactory() {
		return createRepositoryFactory(entityManager);
	}

	/**
	 * Returns a {@link RepositoryFactorySupport}.
	 *
	 * @param entityManager
	 * @return
	 */
	protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {

		JpaRepositoryFactory jpaRepositoryFactory = new JpaRepositoryFactory(entityManager);
		jpaRepositoryFactory.setEscapeCharacter(escapeCharacter);

		return jpaRepositoryFactory;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() {

		Assert.notNull(entityManager, ""EntityManager must not be null!"");
		super.afterPropertiesSet();
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/UserRepositoryFinderTests.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;
import static org.springframework.data.domain.Sort.Direction.*;

import java.util.Arrays;
import java.util.List;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.InvalidDataAccessApiUsageException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.sample.RoleRepository;
import org.springframework.data.jpa.repository.sample.UserRepository;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * Integration test for executing finders, thus testing various query lookup strategies.
 * 
 * @see QueryLookupStrategy
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = ""classpath:config/namespace-application-context.xml"")
@Transactional
public class UserRepositoryFinderTests {

	@Autowired UserRepository userRepository;
	@Autowired RoleRepository roleRepository;

	User dave, carter, oliver;
	Role drummer, guitarist, singer;

	@Before
	public void setUp() {

		drummer = roleRepository.save(new Role(""DRUMMER""));
		guitarist = roleRepository.save(new Role(""GUITARIST""));
		singer = roleRepository.save(new Role(""SINGER""));

		dave = userRepository.save(new User(""Dave"", ""Matthews"", ""dave@dmband.com"", singer));
		carter = userRepository.save(new User(""Carter"", ""Beauford"", ""carter@dmband.com"", singer, drummer));
		oliver = userRepository.save(new User(""Oliver August"", ""Matthews"", ""oliver@dmband.com""));
	}

	@After
	public void clearUp() {

		userRepository.deleteAll();
		roleRepository.deleteAll();
	}

	/**
	 * Tests creation of a simple query.
	 */
	@Test
	public void testSimpleCustomCreatedFinder() {

		User user = userRepository.findByEmailAddressAndLastname(""dave@dmband.com"", ""Matthews"");
		assertEquals(dave, user);
	}

	/**
	 * Tests that the repository returns {@code null} for not found objects for finder methods that return a single domain
	 * object.
	 */
	@Test
	public void returnsNullIfNothingFound() {

		User user = userRepository.findByEmailAddress(""foobar"");
		assertEquals(null, user);
	}

	/**
	 * Tests creation of a simple query consisting of {@code AND} and {@code OR} parts.
	 */
	@Test
	public void testAndOrFinder() {

		List<User> users = userRepository.findByEmailAddressAndLastnameOrFirstname(""dave@dmband.com"", ""Matthews"", ""Carter"");

		assertNotNull(users);
		assertEquals(2, users.size());
		assertTrue(users.contains(dave));
		assertTrue(users.contains(carter));
	}

	@Test
	public void executesPagingMethodToPageCorrectly() {

		Page<User> page = userRepository.findByLastname(new PageRequest(0, 1), ""Matthews"");
		assertThat(page.getNumberOfElements(), is(1));
		assertThat(page.getTotalElements(), is(2L));
		assertThat(page.getTotalPages(), is(2));
	}

	@Test
	public void executesPagingMethodToListCorrectly() {

		List<User> list = userRepository.findByFirstname(""Carter"", new PageRequest(0, 1));
		assertThat(list.size(), is(1));
	}

	@Test
	public void executesInKeywordForPageCorrectly() {

		Page<User> page = userRepository.findByFirstnameIn(new PageRequest(0, 1), ""Dave"", ""Oliver August"");

		assertThat(page.getNumberOfElements(), is(1));
		assertThat(page.getTotalElements(), is(2L));
		assertThat(page.getTotalPages(), is(2));
	}

	@Test
	public void executesNotInQueryCorrectly() throws Exception {

		List<User> result = userRepository.findByFirstnameNotIn(Arrays.asList(""Dave"", ""Carter""));
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(oliver));
	}

	@Test // DATAJPA-92
	public void findsByLastnameIgnoringCase() throws Exception {
		List<User> result = userRepository.findByLastnameIgnoringCase(""BeAUfoRd"");
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(carter));
	}

	@Test // DATAJPA-92
	public void findsByLastnameIgnoringCaseLike() throws Exception {
		List<User> result = userRepository.findByLastnameIgnoringCaseLike(""BeAUfo%"");
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(carter));
	}

	@Test // DATAJPA-92
	public void findByLastnameAndFirstnameAllIgnoringCase() throws Exception {
		List<User> result = userRepository.findByLastnameAndFirstnameAllIgnoringCase(""MaTTheWs"", ""DaVe"");
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(dave));
	}

	@Test // DATAJPA-94
	public void respectsPageableOrderOnQueryGenerateFromMethodName() throws Exception {
		Page<User> ascending = userRepository.findByLastnameIgnoringCase(new PageRequest(0, 10, new Sort(ASC, ""firstname"")),
				""Matthews"");
		Page<User> descending = userRepository
				.findByLastnameIgnoringCase(new PageRequest(0, 10, new Sort(DESC, ""firstname"")), ""Matthews"");
		assertThat(ascending.getTotalElements(), is(2L));
		assertThat(descending.getTotalElements(), is(2L));
		assertThat(ascending.getContent().get(0).getFirstname(),
				is(not(equalTo(descending.getContent().get(0).getFirstname()))));
		assertThat(ascending.getContent().get(0).getFirstname(),
				is(equalTo(descending.getContent().get(1).getFirstname())));
		assertThat(ascending.getContent().get(1).getFirstname(),
				is(equalTo(descending.getContent().get(0).getFirstname())));
	}

	@Test // DATAJPA-486
	public void executesQueryToSlice() {

		Slice<User> slice = userRepository.findSliceByLastname(""Matthews"", new PageRequest(0, 1, ASC, ""firstname""));

		assertThat(slice.getContent(), hasItem(dave));
		assertThat(slice.hasNext(), is(true));
	}

	@Test // DATAJPA-830
	public void executesMethodWithNotContainingOnStringCorrectly() {
		assertThat(userRepository.findByLastnameNotContaining(""u""), containsInAnyOrder(dave, oliver));
	}

	@Test // DATAJPA-829
	public void translatesContainsToMemberOf() {

		List<User> singers = userRepository.findByRolesContaining(singer);

		assertThat(singers, hasSize(2));
		assertThat(singers, hasItems(dave, carter));
		assertThat(userRepository.findByRolesContaining(drummer), contains(carter));
	}

	@Test // DATAJPA-829
	public void translatesNotContainsToNotMemberOf() {
		assertThat(userRepository.findByRolesNotContaining(drummer), hasItems(dave, oliver));
	}

	@Test // DATAJPA-974
	public void executesQueryWithProjectionContainingReferenceToPluralAttribute() {
		assertThat(userRepository.findRolesAndFirstnameBy(), is(notNullValue()));
	}

	@Test(expected = InvalidDataAccessApiUsageException.class) // DATAJPA-1023, DATACMNS-959
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	public void rejectsStreamExecutionIfNoSurroundingTransactionActive() {
		userRepository.findAllByCustomQueryAndStream();
	}

	@Test // DATAJPA-1334
	public void executesNamedQueryWithConstructorExpression() {
		userRepository.findByNamedQueryWithConstructorExpression();
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/UserRepositoryFinderTests.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;
import static org.springframework.data.domain.Sort.Direction.*;

import java.util.Arrays;
import java.util.List;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.InvalidDataAccessApiUsageException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.sample.RoleRepository;
import org.springframework.data.jpa.repository.sample.UserRepository;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * Integration test for executing finders, thus testing various query lookup strategies.
 *
 * @see QueryLookupStrategy
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = ""classpath:config/namespace-application-context.xml"")
@Transactional
public class UserRepositoryFinderTests {

	@Autowired UserRepository userRepository;
	@Autowired RoleRepository roleRepository;

	User dave, carter, oliver;
	Role drummer, guitarist, singer;

	@Before
	public void setUp() {

		drummer = roleRepository.save(new Role(""DRUMMER""));
		guitarist = roleRepository.save(new Role(""GUITARIST""));
		singer = roleRepository.save(new Role(""SINGER""));

		dave = userRepository.save(new User(""Dave"", ""Matthews"", ""dave@dmband.com"", singer));
		carter = userRepository.save(new User(""Carter"", ""Beauford"", ""carter@dmband.com"", singer, drummer));
		oliver = userRepository.save(new User(""Oliver August"", ""Matthews"", ""oliver@dmband.com""));
	}

	@After
	public void clearUp() {

		userRepository.deleteAll();
		roleRepository.deleteAll();
	}

	/**
	 * Tests creation of a simple query.
	 */
	@Test
	public void testSimpleCustomCreatedFinder() {

		User user = userRepository.findByEmailAddressAndLastname(""dave@dmband.com"", ""Matthews"");
		assertEquals(dave, user);
	}

	/**
	 * Tests that the repository returns {@code null} for not found objects for finder methods that return a single domain
	 * object.
	 */
	@Test
	public void returnsNullIfNothingFound() {

		User user = userRepository.findByEmailAddress(""foobar"");
		assertEquals(null, user);
	}

	/**
	 * Tests creation of a simple query consisting of {@code AND} and {@code OR} parts.
	 */
	@Test
	public void testAndOrFinder() {

		List<User> users = userRepository.findByEmailAddressAndLastnameOrFirstname(""dave@dmband.com"", ""Matthews"", ""Carter"");

		assertNotNull(users);
		assertEquals(2, users.size());
		assertTrue(users.contains(dave));
		assertTrue(users.contains(carter));
	}

	@Test
	public void executesPagingMethodToPageCorrectly() {

		Page<User> page = userRepository.findByLastname(new PageRequest(0, 1), ""Matthews"");
		assertThat(page.getNumberOfElements(), is(1));
		assertThat(page.getTotalElements(), is(2L));
		assertThat(page.getTotalPages(), is(2));
	}

	@Test
	public void executesPagingMethodToListCorrectly() {

		List<User> list = userRepository.findByFirstname(""Carter"", new PageRequest(0, 1));
		assertThat(list.size(), is(1));
	}

	@Test
	public void executesInKeywordForPageCorrectly() {

		Page<User> page = userRepository.findByFirstnameIn(new PageRequest(0, 1), ""Dave"", ""Oliver August"");

		assertThat(page.getNumberOfElements(), is(1));
		assertThat(page.getTotalElements(), is(2L));
		assertThat(page.getTotalPages(), is(2));
	}

	@Test
	public void executesNotInQueryCorrectly() throws Exception {

		List<User> result = userRepository.findByFirstnameNotIn(Arrays.asList(""Dave"", ""Carter""));
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(oliver));
	}

	@Test // DATAJPA-92
	public void findsByLastnameIgnoringCase() throws Exception {
		List<User> result = userRepository.findByLastnameIgnoringCase(""BeAUfoRd"");
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(carter));
	}

	@Test // DATAJPA-92
	public void findsByLastnameIgnoringCaseLike() throws Exception {
		List<User> result = userRepository.findByLastnameIgnoringCaseLike(""BeAUfo%"");
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(carter));
	}

	@Test // DATAJPA-92
	public void findByLastnameAndFirstnameAllIgnoringCase() throws Exception {
		List<User> result = userRepository.findByLastnameAndFirstnameAllIgnoringCase(""MaTTheWs"", ""DaVe"");
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(dave));
	}

	@Test // DATAJPA-94
	public void respectsPageableOrderOnQueryGenerateFromMethodName() throws Exception {
		Page<User> ascending = userRepository.findByLastnameIgnoringCase(new PageRequest(0, 10, new Sort(ASC, ""firstname"")),
				""Matthews"");
		Page<User> descending = userRepository
				.findByLastnameIgnoringCase(new PageRequest(0, 10, new Sort(DESC, ""firstname"")), ""Matthews"");
		assertThat(ascending.getTotalElements(), is(2L));
		assertThat(descending.getTotalElements(), is(2L));
		assertThat(ascending.getContent().get(0).getFirstname(),
				is(not(equalTo(descending.getContent().get(0).getFirstname()))));
		assertThat(ascending.getContent().get(0).getFirstname(),
				is(equalTo(descending.getContent().get(1).getFirstname())));
		assertThat(ascending.getContent().get(1).getFirstname(),
				is(equalTo(descending.getContent().get(0).getFirstname())));
	}

	@Test // DATAJPA-486
	public void executesQueryToSlice() {

		Slice<User> slice = userRepository.findSliceByLastname(""Matthews"", new PageRequest(0, 1, ASC, ""firstname""));

		assertThat(slice.getContent(), hasItem(dave));
		assertThat(slice.hasNext(), is(true));
	}

	@Test // DATAJPA-830
	public void executesMethodWithNotContainingOnStringCorrectly() {
		assertThat(userRepository.findByLastnameNotContaining(""u""), containsInAnyOrder(dave, oliver));
	}

	@Test // DATAJPA-1519
	public void parametersForContainsGetProperlyEscaped() {
		assertThat(userRepository.findByFirstnameContaining(""liv%""), hasSize(0));
	}

	@Test // DATAJPA-1519
	public void escapingInLikeSpels() {
		assertThat(userRepository.findContainingEscaped(""att_""), hasSize(0));
	}

	@Test // DATAJPA-829
	public void translatesContainsToMemberOf() {

		List<User> singers = userRepository.findByRolesContaining(singer);

		assertThat(singers, hasSize(2));
		assertThat(singers, hasItems(dave, carter));
		assertThat(userRepository.findByRolesContaining(drummer), contains(carter));
	}

	@Test // DATAJPA-829
	public void translatesNotContainsToNotMemberOf() {
		assertThat(userRepository.findByRolesNotContaining(drummer), hasItems(dave, oliver));
	}

	@Test // DATAJPA-974
	public void executesQueryWithProjectionContainingReferenceToPluralAttribute() {
		assertThat(userRepository.findRolesAndFirstnameBy(), is(notNullValue()));
	}

	@Test(expected = InvalidDataAccessApiUsageException.class) // DATAJPA-1023, DATACMNS-959
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	public void rejectsStreamExecutionIfNoSurroundingTransactionActive() {
		userRepository.findAllByCustomQueryAndStream();
	}

	@Test // DATAJPA-1334
	public void executesNamedQueryWithConstructorExpression() {
		userRepository.findByNamedQueryWithConstructorExpression();
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaCountQueryCreatorIntegrationTests.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.AbstractRepositoryMetadata;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link JpaCountQueryCreator}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class JpaCountQueryCreatorIntegrationTests {

	@PersistenceContext EntityManager entityManager;

	@Test // DATAJPA-1044
	public void distinctFlagOnCountQueryIssuesCountDistinct() throws Exception {

		Method method = SomeRepository.class.getMethod(""findDistinctByRolesIn"", List.class);

		PersistenceProvider provider = PersistenceProvider.fromEntityManager(entityManager);
		JpaQueryMethod queryMethod = new JpaQueryMethod(method,
				AbstractRepositoryMetadata.getMetadata(SomeRepository.class), new SpelAwareProxyProjectionFactory(), provider);

		PartTree tree = new PartTree(""findDistinctByRolesIn"", User.class);
		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(entityManager.getCriteriaBuilder(),
				queryMethod.getParameters(), provider);

		JpaCountQueryCreator creator = new JpaCountQueryCreator(tree, queryMethod.getResultProcessor().getReturnedType(),
				entityManager.getCriteriaBuilder(), metadataProvider);

		TypedQuery<? extends Object> query = entityManager.createQuery(creator.createQuery());

		assertThat(HibernateUtils.getHibernateQuery(query), startsWith(""select distinct count(distinct""));
	}

	interface SomeRepository extends Repository<User, Long> {
		void findDistinctByRolesIn(List<Role> roles);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaCountQueryCreatorIntegrationTests.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.AbstractRepositoryMetadata;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link JpaCountQueryCreator}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class JpaCountQueryCreatorIntegrationTests {

	@PersistenceContext EntityManager entityManager;

	@Test // DATAJPA-1044
	public void distinctFlagOnCountQueryIssuesCountDistinct() throws Exception {

		Method method = SomeRepository.class.getMethod(""findDistinctByRolesIn"", List.class);

		PersistenceProvider provider = PersistenceProvider.fromEntityManager(entityManager);
		JpaQueryMethod queryMethod = new JpaQueryMethod(method,
				AbstractRepositoryMetadata.getMetadata(SomeRepository.class), new SpelAwareProxyProjectionFactory(), provider);

		PartTree tree = new PartTree(""findDistinctByRolesIn"", User.class);
		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(entityManager.getCriteriaBuilder(),
				queryMethod.getParameters(), provider, EscapeCharacter.of('\\'));

		JpaCountQueryCreator creator = new JpaCountQueryCreator(tree, queryMethod.getResultProcessor().getReturnedType(),
				entityManager.getCriteriaBuilder(), metadataProvider);

		TypedQuery<? extends Object> query = entityManager.createQuery(creator.createQuery());

		assertThat(HibernateUtils.getHibernateQuery(query), startsWith(""select distinct count(distinct""));
	}

	interface SomeRepository extends Repository<User, Long> {
		void findDistinctByRolesIn(List<Role> roles);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategyUnitTests.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.metamodel.Metamodel;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.DefaultEvaluationContextProvider;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;

/**
 * Unit tests for {@link JpaQueryLookupStrategy}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
@RunWith(MockitoJUnitRunner.class)
public class JpaQueryLookupStrategyUnitTests {

	private static final EvaluationContextProvider EVALUATION_CONTEXT_PROVIDER = DefaultEvaluationContextProvider.INSTANCE;
	@Mock EntityManager em;
	@Mock EntityManagerFactory emf;
	@Mock QueryExtractor extractor;
	@Mock NamedQueries namedQueries;
	@Mock Metamodel metamodel;
	@Mock ProjectionFactory projectionFactory;

	public @Rule ExpectedException exception = ExpectedException.none();

	@Before
	public void setUp() {

		when(em.getMetamodel()).thenReturn(metamodel);
		when(em.getEntityManagerFactory()).thenReturn(emf);
		when(emf.createEntityManager()).thenReturn(em);
		when(em.getDelegate()).thenReturn(em);
	}

	@Test // DATAJPA-226
	public void invalidAnnotatedQueryCausesException() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER);
		Method method = UserRepository.class.getMethod(""findByFoo"", String.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		Throwable reference = new RuntimeException();
		when(em.createQuery(anyString())).thenThrow(reference);

		try {
			strategy.resolveQuery(method, metadata, projectionFactory, namedQueries);
		} catch (Exception e) {
			assertThat(e, is(instanceOf(IllegalArgumentException.class)));
			assertThat(e.getCause(), is(reference));
		}
	}

	@Test // DATAJPA-554
	public void sholdThrowMorePreciseExceptionIfTryingToUsePaginationInNativeQueries() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER);
		Method method = UserRepository.class.getMethod(""findByInvalidNativeQuery"", String.class, Pageable.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		exception.expect(InvalidJpaQueryMethodException.class);
		exception.expectMessage(""Cannot use native queries with dynamic sorting and/or pagination in method"");
		exception.expectMessage(method.toString());

		strategy.resolveQuery(method, metadata, projectionFactory, namedQueries);
	}

	interface UserRepository extends Repository<User, Long> {

		@Query(""something absurd"")
		User findByFoo(String foo);

		@Query(value = ""select u.* from User u"", nativeQuery = true)
		Page<User> findByInvalidNativeQuery(String param, Pageable page);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategyUnitTests.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.metamodel.Metamodel;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.DefaultEvaluationContextProvider;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;

/**
 * Unit tests for {@link JpaQueryLookupStrategy}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
@RunWith(MockitoJUnitRunner.class)
public class JpaQueryLookupStrategyUnitTests {

	private static final EvaluationContextProvider EVALUATION_CONTEXT_PROVIDER = DefaultEvaluationContextProvider.INSTANCE;
	@Mock EntityManager em;
	@Mock EntityManagerFactory emf;
	@Mock QueryExtractor extractor;
	@Mock NamedQueries namedQueries;
	@Mock Metamodel metamodel;
	@Mock ProjectionFactory projectionFactory;

	public @Rule ExpectedException exception = ExpectedException.none();

	@Before
	public void setUp() {

		when(em.getMetamodel()).thenReturn(metamodel);
		when(em.getEntityManagerFactory()).thenReturn(emf);
		when(emf.createEntityManager()).thenReturn(em);
		when(em.getDelegate()).thenReturn(em);
	}

	@Test // DATAJPA-226
	public void invalidAnnotatedQueryCausesException() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER, EscapeCharacter.of('\\'));
		Method method = UserRepository.class.getMethod(""findByFoo"", String.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		Throwable reference = new RuntimeException();
		when(em.createQuery(anyString())).thenThrow(reference);

		try {
			strategy.resolveQuery(method, metadata, projectionFactory, namedQueries);
		} catch (Exception e) {
			assertThat(e, is(instanceOf(IllegalArgumentException.class)));
			assertThat(e.getCause(), is(reference));
		}
	}

	@Test // DATAJPA-554
	public void sholdThrowMorePreciseExceptionIfTryingToUsePaginationInNativeQueries() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER, EscapeCharacter.of('\\'));
		Method method = UserRepository.class.getMethod(""findByInvalidNativeQuery"", String.class, Pageable.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		exception.expect(InvalidJpaQueryMethodException.class);
		exception.expectMessage(""Cannot use native queries with dynamic sorting and/or pagination in method"");
		exception.expectMessage(method.toString());

		strategy.resolveQuery(method, metadata, projectionFactory, namedQueries);
	}

	interface UserRepository extends Repository<User, Long> {

		@Query(""something absurd"")
		User findByFoo(String foo);

		@Query(value = ""select u.* from User u"", nativeQuery = true)
		Page<User> findByInvalidNativeQuery(String param, Pageable page);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterExpressionProviderTests.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.repository.query.DefaultParameters;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterExpressionProviderTests {

	@PersistenceContext EntityManager em;

	@Test // DATADOC-99
	@SuppressWarnings(""rawtypes"")
	public void createsParameterExpressionWithMostConcreteType() throws Exception {

		Method method = SampleRepository.class.getMethod(""findByIdGreaterThan"", int.class);
		Parameters<?, ?> parameters = new DefaultParameters(method);
		ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, new Object[] { 1 });
		Part part = new Part(""IdGreaterThan"", User.class);

		CriteriaBuilder builder = em.getCriteriaBuilder();
		PersistenceProvider persistenceProvider = PersistenceProvider.fromEntityManager(em);
		ParameterMetadataProvider provider = new ParameterMetadataProvider(builder, accessor, persistenceProvider);
		ParameterExpression<? extends Comparable> expression = provider.next(part, Comparable.class).getExpression();
		assertThat(expression.getParameterType(), is(typeCompatibleWith(int.class)));
	}

	interface SampleRepository {

		User findByIdGreaterThan(int id);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterExpressionProviderTests.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.DefaultParameters;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterExpressionProviderTests {

	@PersistenceContext EntityManager em;

	@Test // DATADOC-99
	@SuppressWarnings(""rawtypes"")
	public void createsParameterExpressionWithMostConcreteType() throws Exception {

		Method method = SampleRepository.class.getMethod(""findByIdGreaterThan"", int.class);
		Parameters<?, ?> parameters = new DefaultParameters(method);
		ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, new Object[] { 1 });
		Part part = new Part(""IdGreaterThan"", User.class);

		CriteriaBuilder builder = em.getCriteriaBuilder();
		PersistenceProvider persistenceProvider = PersistenceProvider.fromEntityManager(em);
		ParameterMetadataProvider provider = new ParameterMetadataProvider(builder, accessor, persistenceProvider, EscapeCharacter.of('\\'));
		ParameterExpression<? extends Comparable> expression = provider.next(part, Comparable.class).getExpression();
		assertThat(expression.getParameterType(), is(typeCompatibleWith(int.class)));
	}

	interface SampleRepository {

		User findByIdGreaterThan(int id);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderIntegrationTests.java,"/*
 * Copyright 2015-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.repository.query.Param;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.util.ReflectionTestUtils;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 * @soundtrack Elephants Crossing - We are (Irrelephant)
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterMetadataProviderIntegrationTests {

	@PersistenceContext EntityManager em;

	@Test // DATAJPA-758
	public void forwardsParameterNameIfTransparentlyNamed() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByFirstname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""firstname"", User.class));

		assertThat(metadata.getExpression().getName(), is(""name""));
	}

	@Test // DATAJPA-758
	public void forwardsParameterNameIfExplicitlyAnnotated() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByLastname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""lastname"", User.class));

		assertThat(metadata.getExpression().getName(), is(nullValue()));
	}

	@Test // DATAJPA-772
	public void doesNotApplyLikeExpansionOnNonStringProperties() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByAgeContaining"", Integer.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""ageContaining"", User.class));

		assertThat(metadata.prepare(1), is((Object) 1));
	}

	private ParameterMetadataProvider createProvider(Method method) {

		JpaParameters parameters = new JpaParameters(method);
		simulateDiscoveredParametername(parameters, 0, ""name"");

		return new ParameterMetadataProvider(em.getCriteriaBuilder(), parameters,
				PersistenceProvider.fromEntityManager(em));
	}

	@SuppressWarnings(""unchecked"")
	private static void simulateDiscoveredParametername(Parameters<?, ?> parameters, int index, String name) {

		List<Object> list = (List<Object>) ReflectionTestUtils.getField(parameters, ""parameters"");
		Object parameter = ReflectionTestUtils.getField(list.get(0), ""parameter"");
		ReflectionTestUtils.setField(parameter, ""parameterName"", name);
	}

	interface Sample {

		User findByFirstname(@Param(""name"") String firstname);

		User findByLastname(String lastname);

		User findByAgeContaining(@Param(""age"") Integer age);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderIntegrationTests.java,"/*
 * Copyright 2015-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.Param;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.util.ReflectionTestUtils;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 * @soundtrack Elephants Crossing - We are (Irrelephant)
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterMetadataProviderIntegrationTests {

	@PersistenceContext EntityManager em;

	@Test // DATAJPA-758
	public void forwardsParameterNameIfTransparentlyNamed() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByFirstname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""firstname"", User.class));

		assertThat(metadata.getExpression().getName(), is(""name""));
	}

	@Test // DATAJPA-758
	public void forwardsParameterNameIfExplicitlyAnnotated() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByLastname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""lastname"", User.class));

		assertThat(metadata.getExpression().getName(), is(nullValue()));
	}

	@Test // DATAJPA-772
	public void doesNotApplyLikeExpansionOnNonStringProperties() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByAgeContaining"", Integer.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""ageContaining"", User.class));

		assertThat(metadata.prepare(1), is((Object) 1));
	}

	private ParameterMetadataProvider createProvider(Method method) {

		JpaParameters parameters = new JpaParameters(method);
		simulateDiscoveredParametername(parameters, 0, ""name"");

		return new ParameterMetadataProvider(em.getCriteriaBuilder(), parameters,
				PersistenceProvider.fromEntityManager(em), EscapeCharacter.of('\\'));
	}

	@SuppressWarnings(""unchecked"")
	private static void simulateDiscoveredParametername(Parameters<?, ?> parameters, int index, String name) {

		List<Object> list = (List<Object>) ReflectionTestUtils.getField(parameters, ""parameters"");
		Object parameter = ReflectionTestUtils.getField(list.get(0), ""parameter"");
		ReflectionTestUtils.setField(parameter, ""parameterName"", name);
	}

	interface Sample {

		User findByFirstname(@Param(""name"") String firstname);

		User findByLastname(String lastname);

		User findByAgeContaining(@Param(""age"") Integer age);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderUnitTests.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.mockito.Mockito.*;

import javax.persistence.criteria.CriteriaBuilder;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;

/**
 * Unit tests for {@link ParameterMetadataProvider}.
 *
 * @author Jens Schauder
 * @author Oliver Gierke
 */
public class ParameterMetadataProviderUnitTests {

	public @Rule ExpectedException exception = ExpectedException.none();

	@Test // DATAJPA-863
	public void errorMessageMentionesParametersWhenParametersAreExhausted() {

		PersistenceProvider persistenceProvider = mock(PersistenceProvider.class);
		CriteriaBuilder builder = mock(CriteriaBuilder.class);

		Parameters<?, ?> parameters = mock(Parameters.class, RETURNS_DEEP_STUBS);
		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(builder, parameters,
				persistenceProvider);

		exception.expect(IllegalArgumentException.class);
		exception.expectMessage(""parameter"");

		metadataProvider.next(mock(Part.class));
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderUnitTests.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.mockito.Mockito.*;

import javax.persistence.criteria.CriteriaBuilder;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;

/**
 * Unit tests for {@link ParameterMetadataProvider}.
 *
 * @author Jens Schauder
 * @author Oliver Gierke
 */
public class ParameterMetadataProviderUnitTests {

	public @Rule ExpectedException exception = ExpectedException.none();

	@Test // DATAJPA-863
	public void errorMessageMentionesParametersWhenParametersAreExhausted() {

		PersistenceProvider persistenceProvider = mock(PersistenceProvider.class);
		CriteriaBuilder builder = mock(CriteriaBuilder.class);

		Parameters<?, ?> parameters = mock(Parameters.class, RETURNS_DEEP_STUBS);
		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(builder, parameters,
				persistenceProvider, EscapeCharacter.of('\\'));

		exception.expect(IllegalArgumentException.class);
		exception.expectMessage(""parameter"");

		metadataProvider.next(mock(Part.class));
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/PartTreeJpaQueryIntegrationTests.java,"/*
 * Copyright 2011-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License
import org.springframework.aop.framework.Advised;
"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;
import static org.springframework.test.util.ReflectionTestUtils.*;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.TemporalType;

import org.hibernate.Version;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.Temporal;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.Param;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link PartTreeJpaQuery}.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class PartTreeJpaQueryIntegrationTests {

	private static String PROPERTY = ""h.target."" + getQueryProperty();

	@Rule public ExpectedException thrown = ExpectedException.none();

	@PersistenceContext EntityManager entityManager;

	PersistenceProvider provider;

	@Before
	public void setUp() {
		this.provider = PersistenceProvider.fromEntityManager(entityManager);
	}

	@Test // DATADOC-90
	public void test() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider);

		jpaQuery.createQuery(new Object[] { ""Matthews"", new PageRequest(0, 1) });
		jpaQuery.createQuery(new Object[] { ""Matthews"", new PageRequest(0, 1) });
	}

	@Test
	public void cannotIgnoreCaseIfNotString() throws Exception {

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""Unable to ignore case of java.lang.Integer types, the property 'id' must reference a String"");
		testIgnoreCase(""findByIdIgnoringCase"", 3);
	}

	@Test
	public void cannotIgnoreCaseIfNotStringUnlessIgnoringAll() throws Exception {

		testIgnoreCase(""findByIdAllIgnoringCase"", 3);
	}

	@Test // DATAJPA-121
	public void recreatesQueryIfNullValueIsGiven() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider);

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"", new PageRequest(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY)), endsWith(""firstname=:param0""));

		query = jpaQuery.createQuery(new Object[] { null, new PageRequest(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY)), endsWith(""firstname is null""));
	}

	@Test // DATAJPA-920
	public void shouldLimitExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider);

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(query.getMaxResults(), is(1));
	}

	@Test // DATAJPA-920
	public void shouldSelectAliasedIdForExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider);

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY)), containsString("".id from User as""));
	}

	@Test // DATAJPA-863
	public void errorsDueToMismatchOfParametersContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByFirstname"");

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""UserRepository""); // the repository
		thrown.expectMessage(""findByFirstname""); // the method being analyzed
		thrown.expectMessage("" firstname ""); // the property we are looking for

		new PartTreeJpaQuery(method, entityManager, provider);
	}

	@Test // DATAJPA-863
	public void errorsDueToMissingPropertyContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByNoSuchProperty"", String.class);

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""UserRepository""); // the repository
		thrown.expectMessage(""findByNoSuchProperty""); // the method being analyzed
		thrown.expectMessage("" noSuchProperty ""); // the property we are looking for

		new PartTreeJpaQuery(method, entityManager, provider);
	}

	private void testIgnoreCase(String methodName, Object... values) throws Exception {

		Class<?>[] parameterTypes = new Class[values.length];

		for (int i = 0; i < values.length; i++) {
			parameterTypes[i] = values[i].getClass();
		}

		JpaQueryMethod queryMethod = getQueryMethod(methodName, parameterTypes);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager,
				PersistenceProvider.fromEntityManager(entityManager));
		jpaQuery.createQuery(values);
	}

	private JpaQueryMethod getQueryMethod(String methodName, Class<?>... parameterTypes) throws Exception {
		Method method = UserRepository.class.getMethod(methodName, parameterTypes);
		return new JpaQueryMethod(method, new DefaultRepositoryMetadata(UserRepository.class),
				new SpelAwareProxyProjectionFactory(), PersistenceProvider.fromEntityManager(entityManager));
	}

	@SuppressWarnings(""unchecked"")
	private static <T> T getValue(Object source, String path) {

		Iterator<String> split = Arrays.asList(path.split(""\\."")).iterator();
		Object result = source;

		while (split.hasNext()) {
			result = getField(result, split.next());
		}

		return (T) result;
	}

	private static String getQueryProperty() {
		return isHibernate43() || isHibernate5() ? ""jpqlQuery"" : ""val$jpaqlQuery"";
	}

	private static boolean isHibernate43() {
		return Version.getVersionString().startsWith(""4.3"");
	}

	private static boolean isHibernate5() {
		return Version.getVersionString().startsWith(""5."");
	}

	interface UserRepository extends Repository<User, Long> {

		Page<User> findByFirstname(String firstname, Pageable pageable);

		User findByIdIgnoringCase(Integer id);

		User findByIdAllIgnoringCase(Integer id);

		boolean existsByFirstname(String firstname);

		List<User> findByCreatedAtAfter(@Temporal(TemporalType.TIMESTAMP) @Param(""refDate"") Date refDate);

		// Wrong number of parameters
		User findByFirstname();

		// Wrong property name
		User findByNoSuchProperty(String x);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/PartTreeJpaQueryIntegrationTests.java,"/*
 * Copyright 2011-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License
import org.springframework.aop.framework.Advised;
"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;
import static org.springframework.test.util.ReflectionTestUtils.*;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.TemporalType;

import org.hibernate.Version;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.Temporal;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.Param;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link PartTreeJpaQuery}.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class PartTreeJpaQueryIntegrationTests {

	private static String PROPERTY = ""h.target."" + getQueryProperty();

	@Rule public ExpectedException thrown = ExpectedException.none();

	@PersistenceContext EntityManager entityManager;

	PersistenceProvider provider;

	@Before
	public void setUp() {
		this.provider = PersistenceProvider.fromEntityManager(entityManager);
	}

	@Test // DATADOC-90
	public void test() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		jpaQuery.createQuery(new Object[] { ""Matthews"", new PageRequest(0, 1) });
		jpaQuery.createQuery(new Object[] { ""Matthews"", new PageRequest(0, 1) });
	}

	@Test
	public void cannotIgnoreCaseIfNotString() throws Exception {

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""Unable to ignore case of java.lang.Integer types, the property 'id' must reference a String"");
		testIgnoreCase(""findByIdIgnoringCase"", 3);
	}

	@Test
	public void cannotIgnoreCaseIfNotStringUnlessIgnoringAll() throws Exception {

		testIgnoreCase(""findByIdAllIgnoringCase"", 3);
	}

	@Test // DATAJPA-121
	public void recreatesQueryIfNullValueIsGiven() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"", new PageRequest(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY)), endsWith(""firstname=:param0""));

		query = jpaQuery.createQuery(new Object[] { null, new PageRequest(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY)), endsWith(""firstname is null""));
	}

	@Test // DATAJPA-920
	public void shouldLimitExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(query.getMaxResults(), is(1));
	}

	@Test // DATAJPA-920
	public void shouldSelectAliasedIdForExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY)), containsString("".id from User as""));
	}

	@Test // DATAJPA-863
	public void errorsDueToMismatchOfParametersContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByFirstname"");

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""UserRepository""); // the repository
		thrown.expectMessage(""findByFirstname""); // the method being analyzed
		thrown.expectMessage("" firstname ""); // the property we are looking for

		new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'));
	}

	@Test // DATAJPA-863
	public void errorsDueToMissingPropertyContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByNoSuchProperty"", String.class);

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""UserRepository""); // the repository
		thrown.expectMessage(""findByNoSuchProperty""); // the method being analyzed
		thrown.expectMessage("" noSuchProperty ""); // the property we are looking for

		new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'));
	}

	private void testIgnoreCase(String methodName, Object... values) throws Exception {

		Class<?>[] parameterTypes = new Class[values.length];

		for (int i = 0; i < values.length; i++) {
			parameterTypes[i] = values[i].getClass();
		}

		JpaQueryMethod queryMethod = getQueryMethod(methodName, parameterTypes);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager,
				PersistenceProvider.fromEntityManager(entityManager), EscapeCharacter.of('\\'));
		jpaQuery.createQuery(values);
	}

	private JpaQueryMethod getQueryMethod(String methodName, Class<?>... parameterTypes) throws Exception {
		Method method = UserRepository.class.getMethod(methodName, parameterTypes);
		return new JpaQueryMethod(method, new DefaultRepositoryMetadata(UserRepository.class),
				new SpelAwareProxyProjectionFactory(), PersistenceProvider.fromEntityManager(entityManager));
	}

	@SuppressWarnings(""unchecked"")
	private static <T> T getValue(Object source, String path) {

		Iterator<String> split = Arrays.asList(path.split(""\\."")).iterator();
		Object result = source;

		while (split.hasNext()) {
			result = getField(result, split.next());
		}

		return (T) result;
	}

	private static String getQueryProperty() {
		return isHibernate43() || isHibernate5() ? ""jpqlQuery"" : ""val$jpaqlQuery"";
	}

	private static boolean isHibernate43() {
		return Version.getVersionString().startsWith(""4.3"");
	}

	private static boolean isHibernate5() {
		return Version.getVersionString().startsWith(""5."");
	}

	interface UserRepository extends Repository<User, Long> {

		Page<User> findByFirstname(String firstname, Pageable pageable);

		User findByIdIgnoringCase(Integer id);

		User findByIdAllIgnoringCase(Integer id);

		boolean existsByFirstname(String firstname);

		List<User> findByCreatedAtAfter(@Temporal(TemporalType.TIMESTAMP) @Param(""refDate"") Date refDate);

		// Wrong number of parameters
		User findByFirstname();

		// Wrong property name
		User findByNoSuchProperty(String x);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.sample;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;

import javax.persistence.EntityManager;
import javax.persistence.QueryHint;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.SpecialUser;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.QueryHints;
import org.springframework.data.jpa.repository.query.Procedure;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import com.google.common.base.Optional;

/**
 * Repository interface for {@code User}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public interface UserRepository
		extends JpaRepository<User, Integer>, JpaSpecificationExecutor<User>, UserRepositoryCustom {

	/**
	 * Retrieve users by their lastname. The finder {@literal User.findByLastname} is declared in
	 * {@literal META-INF/orm.xml} .
	 * 
	 * @param lastname
	 * @return all users with the given lastname
	 */
	@QueryHints({ @QueryHint(name = ""foo"", value = ""bar"") })
	List<User> findByLastname(String lastname);

	/**
	 * Redeclaration of {@link CrudRepository#findOne(java.io.Serializable)} to change transaction configuration.
	 */
	@Transactional
	User findOne(Integer primaryKey);

	/**
	 * Redeclaration of {@link CrudRepository#delete(java.io.Serializable)}. to make sure the transaction configuration of
	 * the original method is considered if the redeclaration does not carry a {@link Transactional} annotation.
	 */
	void delete(Integer id); // DATACMNS-649

	/**
	 * Retrieve users by their email address. The finder {@literal User.findByEmailAddress} is declared as annotation at
	 * {@code User}.
	 * 
	 * @param emailAddress
	 * @return the user with the given email address
	 */
	User findByEmailAddress(String emailAddress);

	@Query(""select u from User u left outer join u.manager as manager"")
	Page<User> findAllPaged(Pageable pageable);

	/**
	 * Retrieves users by the given email and lastname. Acts as a dummy method declaration to test finder query creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @return the user with the given email address and lastname
	 */
	User findByEmailAddressAndLastname(String emailAddress, String lastname);

	/**
	 * Retrieves users by email address and lastname or firstname. Acts as a dummy method declaration to test finder query
	 * creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @param username
	 * @return the users with the given email address and lastname or the given firstname
	 */
	List<User> findByEmailAddressAndLastnameOrFirstname(String emailAddress, String lastname, String username);

	/**
	 * Retrieves a user by its username using the query annotated to the method.
	 * 
	 * @param emailAddress
	 * @return
	 */
	@Query(""select u from User u where u.emailAddress = ?1"")
	@Transactional(readOnly = true)
	User findByAnnotatedQuery(String emailAddress);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * 
	 * @param pageable
	 * @param lastname
	 * @return
	 */
	Page<User> findByLastname(Pageable pageable, String lastname);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * Just returns the queried {@link Page}'s contents.
	 * 
	 * @param firstname
	 * @param pageable
	 * @return
	 */
	List<User> findByFirstname(String firstname, Pageable pageable);

	Page<User> findByFirstnameIn(Pageable pageable, String... firstnames);

	List<User> findByFirstnameNotIn(Collection<String> firstnames);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like ?1%"")
	List<User> findByFirstnameLike(String firstname);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like :firstname%"")
	List<User> findByFirstnameLikeNamed(@Param(""firstname"") String firstname);

	/**
	 * Manipulating query to set all {@link User}'s names to the given one.
	 * 
	 * @param lastname
	 */
	@Modifying
	@Query(""update User u set u.lastname = ?1"")
	void renameAllUsersTo(String lastname);

	@Query(""select count(u) from User u where u.firstname = ?1"")
	Long countWithFirstname(String firstname);

	/**
	 * Method where parameters will be applied by name. Note that the order of the parameters is then not crucial anymore.
	 * 
	 * @param foo
	 * @param bar
	 * @return
	 */
	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstname(@Param(""firstname"") String foo, @Param(""lastname"") String bar);

	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstnameUnannotated(String firstname, String lastname);

	/**
	 * Method to check query creation and named parameter usage go well hand in hand.
	 * 
	 * @param lastname
	 * @param firstname
	 * @return
	 */
	List<User> findByFirstnameOrLastname(@Param(""lastname"") String lastname, @Param(""firstname"") String firstname);

	List<User> findByLastnameLikeOrderByFirstnameDesc(String lastname);

	List<User> findByLastnameNotLike(String lastname);

	List<User> findByLastnameNot(String lastname);

	List<User> findByManagerLastname(String name);

	List<User> findByColleaguesLastname(String lastname);

	List<User> findByLastnameNotNull();

	List<User> findByLastnameNull();

	List<User> findByEmailAddressLike(String email, Sort sort);

	List<SpecialUser> findSpecialUsersByLastname(String lastname);

	List<User> findBySpringDataNamedQuery(String lastname);

	List<User> findByLastnameIgnoringCase(String lastname);

	Page<User> findByLastnameIgnoringCase(Pageable pageable, String lastname);

	List<User> findByLastnameIgnoringCaseLike(String lastname);

	List<User> findByLastnameAndFirstnameAllIgnoringCase(String lastname, String firstname);

	List<User> findByAgeGreaterThanEqual(int age);

	List<User> findByAgeLessThanEqual(int age);

	@Query(""select u.lastname from User u group by u.lastname"")
	Page<String> findByLastnameGrouped(Pageable pageable);

	// DATAJPA-117
	@Query(value = ""SELECT * FROM SD_User WHERE lastname = ?1"", nativeQuery = true)
	List<User> findNativeByLastname(String lastname);

	// DATAJPA-132
	List<User> findByActiveTrue();

	// DATAJPA-132
	List<User> findByActiveFalse();

	/**
	 * Commented out until OpenJPA supports this.
	 */
	// @Query(""select u.colleagues from User u where u = ?1"")
	// List<User> findColleaguesFor(User user);

	// DATAJPA-188
	List<User> findByCreatedAtBefore(Date date);

	// DATAJPA-188
	List<User> findByCreatedAtAfter(Date date);

	// DATAJPA-180
	List<User> findByFirstnameStartingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameEndingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameContaining(String firstname);

	@Query(value = ""SELECT 1 FROM SD_User"", nativeQuery = true)
	List<Integer> findOnesByNativeQuery();

	// DATAJPA-231
	long countByLastname(String lastname);

	// DATAJPA-231
	int countUsersByFirstname(String firstname);

	// DATAJPA-920
	boolean existsByLastname(String lastname);

	// DATAJPA-391
	@Query(""select u.firstname from User u where u.lastname = ?1"")
	List<String> findFirstnamesByLastname(String lastname);

	// DATAJPA-415
	Collection<User> findByIdIn(@Param(""ids"") Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in ?1"")
	Collection<User> findByIdsCustomWithPositionalVarArgs(Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in :ids"")
	Collection<User> findByIdsCustomWithNamedVarArgs(@Param(""ids"") Integer... ids);

	// DATAJPA-415
	@Modifying
	@Query(""update #{#entityName} u set u.active = :activeState where u.id in :ids"")
	void updateUserActiveState(@Param(""activeState"") boolean activeState, @Param(""ids"") Integer... ids);

	// DATAJPA-405
	List<User> findAllByOrderByLastnameAsc();

	// DATAJPA-454
	List<User> findByBinaryData(byte[] data);

	// DATAJPA-486
	Slice<User> findSliceByLastname(String lastname, Pageable pageable);

	// DATAJPA-496
	List<User> findByAttributesIn(Set<String> attributes);

	// DATAJPA-460
	Long removeByLastname(String lastname);

	// DATAJPA-460
	List<User> deleteByLastname(String lastname);

	/**
	 * @see <a href=""https://issues.apache.org/jira/browse/OPENJPA-2484"">OPENJPA-2484</a>
	 */
	// DATAJPA-505
	// @Query(value = ""select u.binaryData from User u where u.id = :id"")
	// byte[] findBinaryDataByIdJpaQl(@Param(""id"") Integer id);

	/**
	 * Explicitly mapped to a procedure with name ""plus1inout"" in database.
	 */
	@Procedure(""plus1inout"") // DATAJPA-455
	Integer explicitlyNamedPlus1inout(Integer arg);

	/**
	 * Implicitly mapped to a procedure with name ""plus1inout"" in database via alias.
	 */
	@Procedure(procedureName = ""plus1inout"") // DATAJPA-455
	Integer plus1inout(Integer arg);

	/**
	 * Explicitly mapped to named stored procedure ""User.plus1IO"" in {@link EntityManager}.
	 */
	@Procedure(name = ""User.plus1IO"") // DATAJPA-455
	Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param(""arg"") Integer arg);

	/**
	 * Implicitly mapped to named stored procedure ""User.plus1"" in {@link EntityManager}.
	 */
	@Procedure // DATAJPA-455
	Integer plus1(@Param(""arg"") Integer arg);

	// DATAJPA-456
	@Query(value = ""select u from User u where u.firstname like ?1%"", countProjection = ""u.firstname"")
	Page<User> findAllByFirstnameLike(String firstname, Pageable page);

	// DATAJPA-456
	@Query(name = ""User.findBySpringDataNamedQuery"", countProjection = ""u.firstname"")
	Page<User> findByNamedQueryAndCountProjection(String firstname, Pageable page);

	// DATAJPA-551
	User findFirstByOrderByAgeDesc();

	// DATAJPA-551
	User findFirst1ByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeAsc();

	// DATAJPA-551
	User findTop1ByOrderByAgeAsc();

	// DATAJPA-551
	List<User> findTop2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2UsersBy(Sort sort);

	// DATAJPA-551
	List<User> findTop2UsersBy(Sort sort);

	// DATAJPA-551
	Page<User> findFirst3UsersBy(Pageable page);

	// DATAJPA-551
	Page<User> findFirst2UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop3UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop2UsersBy(Pageable page);

	// DATAJPA-506
	@Query(value = ""select u.binaryData from SD_User u where u.id = ?1"", nativeQuery = true)
	byte[] findBinaryDataByIdNative(Integer id);

	// DATAJPA-506
	@Query(""select u from User u where u.emailAddress = ?1"")
	Optional<User> findOptionalByEmailAddress(String emailAddress);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]} and u.firstname = ?1 and u.lastname like %?#{[1]}% and u.lastname like %?2%"")
	List<User> findByFirstnameAndLastnameWithSpelExpression(String firstname, String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%"")
	List<User> findByLastnameWithSpelExpression(@Param(""lastname"") String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithQuestionmark();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithColon();

	// DATAJPA-564
	@Query(""select u from User u where u.age = ?#{[0]}"")
	List<User> findUsersByAgeForSpELExpressionByIndexedParameter(int age);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :firstname and u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpression(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findCurrentUserWithCustomQuery();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findByFirstnameAndCurrentUserWithCustomQuery(String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterVariableOnly(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnly(String firstname);

	// DATAJPA-564
	@Query(
			value = ""select * from (select rownum() as RN, u.* from SD_User u) where RN between ?#{ #pageable.offset -1} and ?#{#pageable.offset + #pageable.pageSize}"",
			countQuery = ""select count(u.id) from SD_User u"", nativeQuery = true)
	Page<User> findUsersInNativeQueryWithPagination(Pageable pageable);

	// DATAJPA-629
	@Query(""select u from #{#entityName} u where u.firstname = ?#{[0]} and u.lastname = ?#{[1]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnlyWithEntityExpression(String firstname,
			String lastname);

	// DATAJPA-606
	List<User> findByAgeIn(Collection<Integer> ages);

	// DATAJPA-606
	List<User> queryByAgeIn(Integer[] ages);

	// DATAJPA-606
	List<User> queryByAgeInOrFirstname(Integer[] ages, String firstname);

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> findAllByCustomQueryAndStream();

	// DATAJPA-677
	Stream<User> readAllByFirstnameNotNull();

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> streamAllPaged(Pageable pageable);

	// DATAJPA-830
	List<User> findByLastnameNotContaining(String part);

	// DATAJPA-829
	List<User> findByRolesContaining(Role role);

	// DATAJPA-829
	List<User> findByRolesNotContaining(Role role);

	// DATAJPA-858
	List<User> findByRolesNameContaining(String name);

	// DATAJPA-1179
	@Query(""select u from User u where u.firstname = :#{#firstname} and u.firstname = :#{#firstname}"")
	List<User> findUsersByDuplicateSpel(@Param(""firstname"") String firstname);

	List<RolesAndFirstname> findRolesAndFirstnameBy();

	@Query(value = ""SELECT firstname, lastname from SD_User WHERE id = ?1"", nativeQuery = true)
	NameOnly findByNativeQuery(Integer id);

	// DATAJPA-1185
	<T> Stream<T> findAsStreamByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1185
	<T> List<T> findAsListByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1248
	@Query(value = ""SELECT emailaddress FROM SD_User WHERE id = ?1"", nativeQuery = true)
	EmailOnly findEmailOnlyByNativeQuery(Integer id);


	// DATAJPA-1273
	List<NameOnly> findByNamedQueryWithAliasInInvertedOrder();

	// DATAJPA-1301
	@Query(""select firstname as firstname, lastname as lastname from User u where u.firstname = 'Oliver'"")
	Map<String, Object> findMapWithNullValues();

	// DATAJPA-1334
	List<NameOnlyDto> findByNamedQueryWithConstructorExpression();

	interface RolesAndFirstname {

		String getFirstname();

		Set<Role> getRoles();
	}

	interface NameOnly {

		String getFirstname();

		String getLastname();
	}

	interface EmailOnly {
		String getEmailAddress();
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.sample;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;

import javax.persistence.EntityManager;
import javax.persistence.QueryHint;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.SpecialUser;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.QueryHints;
import org.springframework.data.jpa.repository.query.Procedure;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import com.google.common.base.Optional;

/**
 * Repository interface for {@code User}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public interface UserRepository
		extends JpaRepository<User, Integer>, JpaSpecificationExecutor<User>, UserRepositoryCustom {

	/**
	 * Retrieve users by their lastname. The finder {@literal User.findByLastname} is declared in
	 * {@literal META-INF/orm.xml} .
	 * 
	 * @param lastname
	 * @return all users with the given lastname
	 */
	@QueryHints({ @QueryHint(name = ""foo"", value = ""bar"") })
	List<User> findByLastname(String lastname);

	/**
	 * Redeclaration of {@link CrudRepository#findOne(java.io.Serializable)} to change transaction configuration.
	 */
	@Transactional
	User findOne(Integer primaryKey);

	/**
	 * Redeclaration of {@link CrudRepository#delete(java.io.Serializable)}. to make sure the transaction configuration of
	 * the original method is considered if the redeclaration does not carry a {@link Transactional} annotation.
	 */
	void delete(Integer id); // DATACMNS-649

	/**
	 * Retrieve users by their email address. The finder {@literal User.findByEmailAddress} is declared as annotation at
	 * {@code User}.
	 * 
	 * @param emailAddress
	 * @return the user with the given email address
	 */
	User findByEmailAddress(String emailAddress);

	@Query(""select u from User u left outer join u.manager as manager"")
	Page<User> findAllPaged(Pageable pageable);

	/**
	 * Retrieves users by the given email and lastname. Acts as a dummy method declaration to test finder query creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @return the user with the given email address and lastname
	 */
	User findByEmailAddressAndLastname(String emailAddress, String lastname);

	/**
	 * Retrieves users by email address and lastname or firstname. Acts as a dummy method declaration to test finder query
	 * creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @param username
	 * @return the users with the given email address and lastname or the given firstname
	 */
	List<User> findByEmailAddressAndLastnameOrFirstname(String emailAddress, String lastname, String username);

	/**
	 * Retrieves a user by its username using the query annotated to the method.
	 * 
	 * @param emailAddress
	 * @return
	 */
	@Query(""select u from User u where u.emailAddress = ?1"")
	@Transactional(readOnly = true)
	User findByAnnotatedQuery(String emailAddress);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * 
	 * @param pageable
	 * @param lastname
	 * @return
	 */
	Page<User> findByLastname(Pageable pageable, String lastname);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * Just returns the queried {@link Page}'s contents.
	 * 
	 * @param firstname
	 * @param pageable
	 * @return
	 */
	List<User> findByFirstname(String firstname, Pageable pageable);

	Page<User> findByFirstnameIn(Pageable pageable, String... firstnames);

	List<User> findByFirstnameNotIn(Collection<String> firstnames);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like ?1%"")
	List<User> findByFirstnameLike(String firstname);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like :firstname%"")
	List<User> findByFirstnameLikeNamed(@Param(""firstname"") String firstname);

	/**
	 * Manipulating query to set all {@link User}'s names to the given one.
	 * 
	 * @param lastname
	 */
	@Modifying
	@Query(""update User u set u.lastname = ?1"")
	void renameAllUsersTo(String lastname);

	@Query(""select count(u) from User u where u.firstname = ?1"")
	Long countWithFirstname(String firstname);

	/**
	 * Method where parameters will be applied by name. Note that the order of the parameters is then not crucial anymore.
	 * 
	 * @param foo
	 * @param bar
	 * @return
	 */
	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstname(@Param(""firstname"") String foo, @Param(""lastname"") String bar);

	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstnameUnannotated(String firstname, String lastname);

	/**
	 * Method to check query creation and named parameter usage go well hand in hand.
	 * 
	 * @param lastname
	 * @param firstname
	 * @return
	 */
	List<User> findByFirstnameOrLastname(@Param(""lastname"") String lastname, @Param(""firstname"") String firstname);

	List<User> findByLastnameLikeOrderByFirstnameDesc(String lastname);

	List<User> findByLastnameNotLike(String lastname);

	List<User> findByLastnameNot(String lastname);

	List<User> findByManagerLastname(String name);

	List<User> findByColleaguesLastname(String lastname);

	List<User> findByLastnameNotNull();

	List<User> findByLastnameNull();

	List<User> findByEmailAddressLike(String email, Sort sort);

	List<SpecialUser> findSpecialUsersByLastname(String lastname);

	List<User> findBySpringDataNamedQuery(String lastname);

	List<User> findByLastnameIgnoringCase(String lastname);

	Page<User> findByLastnameIgnoringCase(Pageable pageable, String lastname);

	List<User> findByLastnameIgnoringCaseLike(String lastname);

	List<User> findByLastnameAndFirstnameAllIgnoringCase(String lastname, String firstname);

	List<User> findByAgeGreaterThanEqual(int age);

	List<User> findByAgeLessThanEqual(int age);

	@Query(""select u.lastname from User u group by u.lastname"")
	Page<String> findByLastnameGrouped(Pageable pageable);

	// DATAJPA-117
	@Query(value = ""SELECT * FROM SD_User WHERE lastname = ?1"", nativeQuery = true)
	List<User> findNativeByLastname(String lastname);

	// DATAJPA-132
	List<User> findByActiveTrue();

	// DATAJPA-132
	List<User> findByActiveFalse();

	/**
	 * Commented out until OpenJPA supports this.
	 */
	// @Query(""select u.colleagues from User u where u = ?1"")
	// List<User> findColleaguesFor(User user);

	// DATAJPA-188
	List<User> findByCreatedAtBefore(Date date);

	// DATAJPA-188
	List<User> findByCreatedAtAfter(Date date);

	// DATAJPA-180
	List<User> findByFirstnameStartingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameEndingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameContaining(String firstname);

	@Query(value = ""SELECT 1 FROM SD_User"", nativeQuery = true)
	List<Integer> findOnesByNativeQuery();

	// DATAJPA-231
	long countByLastname(String lastname);

	// DATAJPA-231
	int countUsersByFirstname(String firstname);

	// DATAJPA-920
	boolean existsByLastname(String lastname);

	// DATAJPA-391
	@Query(""select u.firstname from User u where u.lastname = ?1"")
	List<String> findFirstnamesByLastname(String lastname);

	// DATAJPA-415
	Collection<User> findByIdIn(@Param(""ids"") Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in ?1"")
	Collection<User> findByIdsCustomWithPositionalVarArgs(Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in :ids"")
	Collection<User> findByIdsCustomWithNamedVarArgs(@Param(""ids"") Integer... ids);

	// DATAJPA-415
	@Modifying
	@Query(""update #{#entityName} u set u.active = :activeState where u.id in :ids"")
	void updateUserActiveState(@Param(""activeState"") boolean activeState, @Param(""ids"") Integer... ids);

	// DATAJPA-405
	List<User> findAllByOrderByLastnameAsc();

	// DATAJPA-454
	List<User> findByBinaryData(byte[] data);

	// DATAJPA-486
	Slice<User> findSliceByLastname(String lastname, Pageable pageable);

	// DATAJPA-496
	List<User> findByAttributesIn(Set<String> attributes);

	// DATAJPA-460
	Long removeByLastname(String lastname);

	// DATAJPA-460
	List<User> deleteByLastname(String lastname);

	/**
	 * @see <a href=""https://issues.apache.org/jira/browse/OPENJPA-2484"">OPENJPA-2484</a>
	 */
	// DATAJPA-505
	// @Query(value = ""select u.binaryData from User u where u.id = :id"")
	// byte[] findBinaryDataByIdJpaQl(@Param(""id"") Integer id);

	/**
	 * Explicitly mapped to a procedure with name ""plus1inout"" in database.
	 */
	@Procedure(""plus1inout"") // DATAJPA-455
	Integer explicitlyNamedPlus1inout(Integer arg);

	/**
	 * Implicitly mapped to a procedure with name ""plus1inout"" in database via alias.
	 */
	@Procedure(procedureName = ""plus1inout"") // DATAJPA-455
	Integer plus1inout(Integer arg);

	/**
	 * Explicitly mapped to named stored procedure ""User.plus1IO"" in {@link EntityManager}.
	 */
	@Procedure(name = ""User.plus1IO"") // DATAJPA-455
	Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param(""arg"") Integer arg);

	/**
	 * Implicitly mapped to named stored procedure ""User.plus1"" in {@link EntityManager}.
	 */
	@Procedure // DATAJPA-455
	Integer plus1(@Param(""arg"") Integer arg);

	// DATAJPA-456
	@Query(value = ""select u from User u where u.firstname like ?1%"", countProjection = ""u.firstname"")
	Page<User> findAllByFirstnameLike(String firstname, Pageable page);

	// DATAJPA-456
	@Query(name = ""User.findBySpringDataNamedQuery"", countProjection = ""u.firstname"")
	Page<User> findByNamedQueryAndCountProjection(String firstname, Pageable page);

	// DATAJPA-551
	User findFirstByOrderByAgeDesc();

	// DATAJPA-551
	User findFirst1ByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeAsc();

	// DATAJPA-551
	User findTop1ByOrderByAgeAsc();

	// DATAJPA-551
	List<User> findTop2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2UsersBy(Sort sort);

	// DATAJPA-551
	List<User> findTop2UsersBy(Sort sort);

	// DATAJPA-551
	Page<User> findFirst3UsersBy(Pageable page);

	// DATAJPA-551
	Page<User> findFirst2UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop3UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop2UsersBy(Pageable page);

	// DATAJPA-506
	@Query(value = ""select u.binaryData from SD_User u where u.id = ?1"", nativeQuery = true)
	byte[] findBinaryDataByIdNative(Integer id);

	// DATAJPA-506
	@Query(""select u from User u where u.emailAddress = ?1"")
	Optional<User> findOptionalByEmailAddress(String emailAddress);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]} and u.firstname = ?1 and u.lastname like %?#{[1]}% and u.lastname like %?2%"")
	List<User> findByFirstnameAndLastnameWithSpelExpression(String firstname, String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%"")
	List<User> findByLastnameWithSpelExpression(@Param(""lastname"") String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithQuestionmark();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithColon();

	// DATAJPA-564
	@Query(""select u from User u where u.age = ?#{[0]}"")
	List<User> findUsersByAgeForSpELExpressionByIndexedParameter(int age);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :firstname and u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpression(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findCurrentUserWithCustomQuery();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findByFirstnameAndCurrentUserWithCustomQuery(String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterVariableOnly(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnly(String firstname);

	// DATAJPA-564
	@Query(
			value = ""select * from (select rownum() as RN, u.* from SD_User u) where RN between ?#{ #pageable.offset -1} and ?#{#pageable.offset + #pageable.pageSize}"",
			countQuery = ""select count(u.id) from SD_User u"", nativeQuery = true)
	Page<User> findUsersInNativeQueryWithPagination(Pageable pageable);

	// DATAJPA-629
	@Query(""select u from #{#entityName} u where u.firstname = ?#{[0]} and u.lastname = ?#{[1]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnlyWithEntityExpression(String firstname,
			String lastname);

	// DATAJPA-606
	List<User> findByAgeIn(Collection<Integer> ages);

	// DATAJPA-606
	List<User> queryByAgeIn(Integer[] ages);

	// DATAJPA-606
	List<User> queryByAgeInOrFirstname(Integer[] ages, String firstname);

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> findAllByCustomQueryAndStream();

	// DATAJPA-677
	Stream<User> readAllByFirstnameNotNull();

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> streamAllPaged(Pageable pageable);

	// DATAJPA-830
	List<User> findByLastnameNotContaining(String part);

	// DATAJPA-829
	List<User> findByRolesContaining(Role role);

	// DATAJPA-829
	List<User> findByRolesNotContaining(Role role);

	// DATAJPA-858
	List<User> findByRolesNameContaining(String name);

	// DATAJPA-1179
	@Query(""select u from User u where u.firstname = :#{#firstname} and u.firstname = :#{#firstname}"")
	List<User> findUsersByDuplicateSpel(@Param(""firstname"") String firstname);

	List<RolesAndFirstname> findRolesAndFirstnameBy();

	@Query(value = ""SELECT firstname, lastname from SD_User WHERE id = ?1"", nativeQuery = true)
	NameOnly findByNativeQuery(Integer id);

	// DATAJPA-1185
	<T> Stream<T> findAsStreamByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1185
	<T> List<T> findAsListByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1248
	@Query(value = ""SELECT emailaddress FROM SD_User WHERE id = ?1"", nativeQuery = true)
	EmailOnly findEmailOnlyByNativeQuery(Integer id);


	// DATAJPA-1273
	List<NameOnly> findByNamedQueryWithAliasInInvertedOrder();

	// DATAJPA-1301
	@Query(""select firstname as firstname, lastname as lastname from User u where u.firstname = 'Oliver'"")
	Map<String, Object> findMapWithNullValues();

	// DATAJPA-1334
	List<NameOnlyDto> findByNamedQueryWithConstructorExpression();

	// DATAJPA-1519
	@Query(""select u from User u where u.firstname like %?#{#escape([0],'#')}% escape '#'"")
	List<User> findContainingEscaped(String namePart);

	interface RolesAndFirstname {

		String getFirstname();

		Set<Role> getRoles();
	}

	interface NameOnly {

		String getFirstname();

		String getLastname();
	}

	interface EmailOnly {
		String getEmailAddress();
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/config/JpaRepositoryConfigExtension.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.config;

import static org.springframework.data.jpa.repository.config.BeanDefinitionNames.*;

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Locale;

import javax.persistence.Entity;
import javax.persistence.MappedSuperclass;
import javax.persistence.PersistenceContext;
import javax.persistence.PersistenceUnit;

import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.core.annotation.AnnotationAttributes;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.support.DefaultJpaContext;
import org.springframework.data.jpa.repository.support.EntityManagerBeanDefinitionRegistrarPostProcessor;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
import org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource;
import org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport;
import org.springframework.data.repository.config.RepositoryConfigurationSource;
import org.springframework.data.repository.config.XmlRepositoryConfigurationSource;
import org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor;
import org.springframework.util.StringUtils;

/**
 * JPA specific configuration extension parsing custom attributes from the XML namespace and
 * {@link EnableJpaRepositories} annotation. Also, it registers bean definitions for a
 * {@link PersistenceAnnotationBeanPostProcessor} (to trigger injection into {@link PersistenceContext}/
 * {@link PersistenceUnit} annotated properties and methods) as well as
 * {@link PersistenceExceptionTranslationPostProcessor} to enable exception translation of persistence specific
 * exceptions into Spring's {@link DataAccessException} hierarchy.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Gil Markham
 * @author Thomas Darimont
 */
public class JpaRepositoryConfigExtension extends RepositoryConfigurationExtensionSupport {

	private static final Class<?> PAB_POST_PROCESSOR = PersistenceAnnotationBeanPostProcessor.class;
	private static final String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = ""transactionManager"";
	private static final String ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE = ""enableDefaultTransactions"";

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getModuleName()
	 */
	@Override
	public String getModuleName() {
		return ""JPA"";
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config14.RepositoryConfigurationExtension#getRepositoryInterface()
	 */
	public String getRepositoryFactoryClassName() {
		return JpaRepositoryFactoryBean.class.getName();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config14.RepositoryConfigurationExtensionSupport#getModulePrefix()
	 */
	@Override
	protected String getModulePrefix() {
		return getModuleName().toLowerCase(Locale.US);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingAnnotations()
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	protected Collection<Class<? extends Annotation>> getIdentifyingAnnotations() {
		return Arrays.asList(Entity.class, MappedSuperclass.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingTypes()
	 */
	@Override
	protected Collection<Class<?>> getIdentifyingTypes() {
		return Collections.<Class<?>> singleton(JpaRepository.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, RepositoryConfigurationSource source) {

		Character escapeCharacter = getEscapeCharacter(source);

		String transactionManagerRef = source.getAttribute(""transactionManagerRef"");
		builder.addPropertyValue(""transactionManager"",
				transactionManagerRef == null ? DEFAULT_TRANSACTION_MANAGER_BEAN_NAME : transactionManagerRef);
		builder.addPropertyValue(""entityManager"", getEntityManagerBeanDefinitionFor(source, source.getSource()));
		builder.addPropertyValue(""escapeCharacter"", escapeCharacter == null ? '\\' : escapeCharacter);
		builder.addPropertyReference(""mappingContext"", JPA_MAPPING_CONTEXT_BEAN_NAME);
	}

	/**
	 * XML configurations do not support {@link Character} values. This method catches the exception thrown and returns an
	 * {@link Optional#empty()} instead.
	 */
	private static Character getEscapeCharacter(RepositoryConfigurationSource source) {

		try {

			return AnnotationRepositoryConfigurationSource.class.isInstance(source) //
					? (Character) AnnotationRepositoryConfigurationSource.class.cast(source).getAttributes()
							.get(""escapeCharacter"") //
					: source.getAttribute(""escapeCharacter"").toCharArray()[0];

		} catch (IllegalArgumentException ___) {
			return null;
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, AnnotationRepositoryConfigurationSource config) {

		AnnotationAttributes attributes = config.getAttributes();

		builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE,
				attributes.getBoolean(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.XmlRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, XmlRepositoryConfigurationSource config) {

		String enableDefaultTransactions = config.getAttribute(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE);

		if (StringUtils.hasText(enableDefaultTransactions)) {
			builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE, enableDefaultTransactions);
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#registerBeansForRoot(org.springframework.beans.factory.support.BeanDefinitionRegistry, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void registerBeansForRoot(BeanDefinitionRegistry registry, RepositoryConfigurationSource config) {

		super.registerBeansForRoot(registry, config);

		Object source = config.getSource();

		registerIfNotAlreadyRegistered(new RootBeanDefinition(EntityManagerBeanDefinitionRegistrarPostProcessor.class),
				registry, EM_BEAN_DEFINITION_REGISTRAR_POST_PROCESSOR_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(JpaMetamodelMappingContextFactoryBean.class), registry,
				JPA_MAPPING_CONTEXT_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(PAB_POST_PROCESSOR), registry,
				AnnotationConfigUtils.PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME, source);

		// Register bean definition for DefaultJpaContext

		RootBeanDefinition contextDefinition = new RootBeanDefinition(DefaultJpaContext.class);
		contextDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);

		registerIfNotAlreadyRegistered(contextDefinition, registry, JPA_CONTEXT_BEAN_NAME, source);
	}

	/**
	 * Creates an anonymous factory to extract the actual {@link javax.persistence.EntityManager} from the
	 * {@link javax.persistence.EntityManagerFactory} bean name reference.
	 *
	 * @param entityManagerFactoryBeanName
	 * @param source
	 * @return
	 */
	private static AbstractBeanDefinition getEntityManagerBeanDefinitionFor(RepositoryConfigurationSource config,
			Object source) {

		BeanDefinitionBuilder builder = BeanDefinitionBuilder
				.rootBeanDefinition(""org.springframework.orm.jpa.SharedEntityManagerCreator"");
		builder.setFactoryMethod(""createSharedEntityManager"");
		builder.addConstructorArgReference(getEntityManagerBeanRef(config));

		AbstractBeanDefinition bean = builder.getRawBeanDefinition();
		bean.setSource(source);

		return bean;
	}

	private static String getEntityManagerBeanRef(RepositoryConfigurationSource config) {

		String entityManagerFactoryRef = config == null ? null : config.getAttribute(""entityManagerFactoryRef"");
		return entityManagerFactoryRef == null ? ""entityManagerFactory"" : entityManagerFactoryRef;
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/config/JpaRepositoryConfigExtension.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.config;

import static org.springframework.data.jpa.repository.config.BeanDefinitionNames.*;

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Locale;

import javax.persistence.Entity;
import javax.persistence.MappedSuperclass;
import javax.persistence.PersistenceContext;
import javax.persistence.PersistenceUnit;

import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.core.annotation.AnnotationAttributes;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.support.DefaultJpaContext;
import org.springframework.data.jpa.repository.support.EntityManagerBeanDefinitionRegistrarPostProcessor;
import org.springframework.data.jpa.repository.support.JpaEvaluationContextExtension;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
import org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource;
import org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport;
import org.springframework.data.repository.config.RepositoryConfigurationSource;
import org.springframework.data.repository.config.XmlRepositoryConfigurationSource;
import org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor;
import org.springframework.util.StringUtils;

/**
 * JPA specific configuration extension parsing custom attributes from the XML namespace and
 * {@link EnableJpaRepositories} annotation. Also, it registers bean definitions for a
 * {@link PersistenceAnnotationBeanPostProcessor} (to trigger injection into {@link PersistenceContext}/
 * {@link PersistenceUnit} annotated properties and methods) as well as
 * {@link PersistenceExceptionTranslationPostProcessor} to enable exception translation of persistence specific
 * exceptions into Spring's {@link DataAccessException} hierarchy.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Gil Markham
 * @author Thomas Darimont
 */
public class JpaRepositoryConfigExtension extends RepositoryConfigurationExtensionSupport {

	private static final Class<?> PAB_POST_PROCESSOR = PersistenceAnnotationBeanPostProcessor.class;
	private static final String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = ""transactionManager"";
	private static final String ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE = ""enableDefaultTransactions"";
	private static final String ESCAPE_CHARACTER_PROPERTY = ""escapeCharacter"";

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getModuleName()
	 */
	@Override
	public String getModuleName() {
		return ""JPA"";
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config14.RepositoryConfigurationExtension#getRepositoryInterface()
	 */
	public String getRepositoryFactoryClassName() {
		return JpaRepositoryFactoryBean.class.getName();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config14.RepositoryConfigurationExtensionSupport#getModulePrefix()
	 */
	@Override
	protected String getModulePrefix() {
		return getModuleName().toLowerCase(Locale.US);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingAnnotations()
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	protected Collection<Class<? extends Annotation>> getIdentifyingAnnotations() {
		return Arrays.asList(Entity.class, MappedSuperclass.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingTypes()
	 */
	@Override
	protected Collection<Class<?>> getIdentifyingTypes() {
		return Collections.<Class<?>> singleton(JpaRepository.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, RepositoryConfigurationSource source) {

		Character escapeCharacter = getEscapeCharacter(source);

		String transactionManagerRef = source.getAttribute(""transactionManagerRef"");
		builder.addPropertyValue(""transactionManager"",
				transactionManagerRef == null ? DEFAULT_TRANSACTION_MANAGER_BEAN_NAME : transactionManagerRef);
		builder.addPropertyValue(""entityManager"", getEntityManagerBeanDefinitionFor(source, source.getSource()));
		builder.addPropertyValue(""escapeCharacter"", escapeCharacter == null ? '\\' : escapeCharacter);
		builder.addPropertyReference(""mappingContext"", JPA_MAPPING_CONTEXT_BEAN_NAME);
	}

	/**
	 * XML configurations do not support {@link Character} values. This method catches the exception thrown and returns an
	 * {@link Optional#empty()} instead.
	 */
	private static Character getEscapeCharacter(RepositoryConfigurationSource source) {

		if (AnnotationRepositoryConfigurationSource.class.isInstance(source)) {

			return (Character) AnnotationRepositoryConfigurationSource.class//
					.cast(source) //
					.getAttributes() //
					.get(ESCAPE_CHARACTER_PROPERTY);
		}

		String attribute = source.getAttribute(ESCAPE_CHARACTER_PROPERTY);

		return attribute == null ? null : attribute.toCharArray()[0];
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, AnnotationRepositoryConfigurationSource config) {

		AnnotationAttributes attributes = config.getAttributes();

		builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE,
				attributes.getBoolean(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.XmlRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, XmlRepositoryConfigurationSource config) {

		String enableDefaultTransactions = config.getAttribute(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE);

		if (StringUtils.hasText(enableDefaultTransactions)) {
			builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE, enableDefaultTransactions);
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#registerBeansForRoot(org.springframework.beans.factory.support.BeanDefinitionRegistry, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void registerBeansForRoot(BeanDefinitionRegistry registry, RepositoryConfigurationSource config) {

		super.registerBeansForRoot(registry, config);

		Object source = config.getSource();

		registerIfNotAlreadyRegistered(new RootBeanDefinition(EntityManagerBeanDefinitionRegistrarPostProcessor.class),
				registry, EM_BEAN_DEFINITION_REGISTRAR_POST_PROCESSOR_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(JpaMetamodelMappingContextFactoryBean.class), registry,
				JPA_MAPPING_CONTEXT_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(PAB_POST_PROCESSOR), registry,
				AnnotationConfigUtils.PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME, source);

		// Register bean definition for DefaultJpaContext

		RootBeanDefinition contextDefinition = new RootBeanDefinition(DefaultJpaContext.class);
		contextDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);

		registerIfNotAlreadyRegistered(contextDefinition, registry, JPA_CONTEXT_BEAN_NAME, source);

		// EvaluationContextExtension for JPA specific SpEL functions

		Character escapeCharacter = getEscapeCharacter(config);

		BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(JpaEvaluationContextExtension.class);
		builder.addConstructorArgValue(escapeCharacter == null ? '\\' : escapeCharacter);

		registerIfNotAlreadyRegistered(builder.getBeanDefinition(), registry, JpaEvaluationContextExtension.class.getName(),
				source);
	}

	/**
	 * Creates an anonymous factory to extract the actual {@link javax.persistence.EntityManager} from the
	 * {@link javax.persistence.EntityManagerFactory} bean name reference.
	 *
	 * @param entityManagerFactoryBeanName
	 * @param source
	 * @return
	 */
	private static AbstractBeanDefinition getEntityManagerBeanDefinitionFor(RepositoryConfigurationSource config,
			Object source) {

		BeanDefinitionBuilder builder = BeanDefinitionBuilder
				.rootBeanDefinition(""org.springframework.orm.jpa.SharedEntityManagerCreator"");
		builder.setFactoryMethod(""createSharedEntityManager"");
		builder.addConstructorArgReference(getEntityManagerBeanRef(config));

		AbstractBeanDefinition bean = builder.getRawBeanDefinition();
		bean.setSource(source);

		return bean;
	}

	private static String getEntityManagerBeanRef(RepositoryConfigurationSource config) {

		String entityManagerFactoryRef = config == null ? null : config.getAttribute(""entityManagerFactoryRef"");
		return entityManagerFactoryRef == null ? ""entityManagerFactory"" : entityManagerFactoryRef;
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryCreator.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.springframework.data.jpa.domain.AbstractPersistable_.*;
import static org.springframework.data.jpa.repository.query.QueryUtils.*;
import static org.springframework.data.repository.query.parser.Part.Type.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Selection;
import javax.persistence.metamodel.SingularAttribute;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.mapping.PropertyPath;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.AbstractQueryCreator;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.util.Assert;

/**
 * Query creator to create a {@link CriteriaQuery} from a {@link PartTree}.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 */
public class JpaQueryCreator extends AbstractQueryCreator<CriteriaQuery<? extends Object>, Predicate> {

	private final CriteriaBuilder builder;
	private final Root<?> root;
	private final CriteriaQuery<? extends Object> query;
	private final ParameterMetadataProvider provider;
	private final ReturnedType returnedType;
	private final PartTree tree;
	private final EscapeCharacter escape;

	/**
	 * Create a new {@link JpaQueryCreator}.
	 * 
	 * @param tree must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param builder must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public JpaQueryCreator(PartTree tree, ReturnedType type, CriteriaBuilder builder,
			ParameterMetadataProvider provider) {

		super(tree);
		this.tree = tree;

		CriteriaQuery<?> criteriaQuery = createCriteriaQuery(builder, type);

		this.builder = builder;
		this.query = criteriaQuery.distinct(tree.isDistinct());
		this.root = query.from(type.getDomainType());
		this.provider = provider;
		this.returnedType = type;
		this.escape = provider.getEscape();
	}

	/**
	 * Creates the {@link CriteriaQuery} to apply predicates on.
	 * 
	 * @param builder will never be {@literal null}.
	 * @param type will never be {@literal null}.
	 * @return must not be {@literal null}.
	 */
	protected CriteriaQuery<? extends Object> createCriteriaQuery(CriteriaBuilder builder, ReturnedType type) {

		Class<?> typeToRead = type.getTypeToRead();

		return typeToRead == null || tree.isExistsProjection() ? builder.createTupleQuery()
				: builder.createQuery(typeToRead);
	}

	/**
	 * Returns all {@link javax.persistence.criteria.ParameterExpression} created when creating the query.
	 * 
	 * @return the parameterExpressions
	 */
	public List<ParameterMetadata<?>> getParameterExpressions() {
		return provider.getExpressions();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#create(org.springframework.data.repository.query.parser.Part, java.util.Iterator)
	 */
	@Override
	protected Predicate create(Part part, Iterator<Object> iterator) {

		return toPredicate(part, root);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#and(org.springframework.data.repository.query.parser.Part, java.lang.Object, java.util.Iterator)
	 */
	@Override
	protected Predicate and(Part part, Predicate base, Iterator<Object> iterator) {
		return builder.and(base, toPredicate(part, root));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#or(java.lang.Object, java.lang.Object)
	 */
	@Override
	protected Predicate or(Predicate base, Predicate predicate) {
		return builder.or(base, predicate);
	}

	/**
	 * Finalizes the given {@link Predicate} and applies the given sort. Delegates to
	 * {@link #complete(Predicate, Sort, CriteriaQuery, CriteriaBuilder, Root)} and hands it the current {@link CriteriaQuery}
	 * and {@link CriteriaBuilder}.
	 */
	@Override
	protected final CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort) {
		return complete(predicate, sort, query, builder, root);
	}

	/**
	 * Template method to finalize the given {@link Predicate} using the given {@link CriteriaQuery} and
	 * {@link CriteriaBuilder}.
	 * 
	 * @param predicate
	 * @param sort
	 * @param query
	 * @param builder
	 * @return
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	protected CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort,
			CriteriaQuery<? extends Object> query, CriteriaBuilder builder, Root<?> root) {

		if (returnedType.needsCustomConstruction()) {

			List<Selection<?>> selections = new ArrayList<Selection<?>>();

			for (String property : returnedType.getInputProperties()) {

				PropertyPath path = PropertyPath.from(property, returnedType.getDomainType());
				selections.add(toExpressionRecursively(root, path).alias(property));
			}

			query = query.multiselect(selections);

		} else if (tree.isExistsProjection()) {

			if (root.getModel().hasSingleIdAttribute()) {

				SingularAttribute<?, ?> id = root.getModel().getId(root.getModel().getIdType().getJavaType());
				query = query.multiselect(root.get((SingularAttribute) id).alias(id.getName()));

			} else {

				List<Selection<?>> selections = new ArrayList<Selection<?>>();

				for (SingularAttribute<?, ?> attribute : root.getModel().getIdClassAttributes()) {
					selections.add(root.get((SingularAttribute) attribute).alias(attribute.getName()));
				}

				selections.add(root.get((SingularAttribute) id).alias(id.getName()));
				query = query.multiselect(selections);
			}

		} else {
			query = query.select((Root) root);
		}

		CriteriaQuery<? extends Object> select = query.orderBy(QueryUtils.toOrders(sort, root, builder));
		return predicate == null ? select : select.where(predicate);
	}

	/**
	 * Creates a {@link Predicate} from the given {@link Part}.
	 *
	 * @param part
	 * @param root
	 * @return
	 */
	private Predicate toPredicate(Part part, Root<?> root) {
		return new PredicateBuilder(part, root).build();
	}

	/**
	 * Simple builder to contain logic to create JPA {@link Predicate}s from {@link Part}s.
	 * 
	 * @author Phil Webb
	 * @author Oliver Gierke
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private class PredicateBuilder {

		private final Part part;
		private final Root<?> root;

		/**
		 * Creates a new {@link PredicateBuilder} for the given {@link Part} and {@link Root}.
		 * 
		 * @param part must not be {@literal null}.
		 * @param root must not be {@literal null}.
		 */
		public PredicateBuilder(Part part, Root<?> root) {

			Assert.notNull(part, ""Part must not be null!"");
			Assert.notNull(root, ""Root must not be null!"");
			this.part = part;
			this.root = root;
		}

		/**
		 * Builds a JPA {@link Predicate} from the underlying {@link Part}.
		 * 
		 * @return
		 */
		public Predicate build() {

			PropertyPath property = part.getProperty();
			Type type = part.getType();

			switch (type) {
				case BETWEEN:
					ParameterMetadata<Comparable> first = provider.next(part);
					ParameterMetadata<Comparable> second = provider.next(part);
					return builder.between(getComparablePath(root, part), first.getExpression(), second.getExpression());
				case AFTER:
				case GREATER_THAN:
					return builder.greaterThan(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case GREATER_THAN_EQUAL:
					return builder.greaterThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case BEFORE:
				case LESS_THAN:
					return builder.lessThan(getComparablePath(root, part), provider.next(part, Comparable.class).getExpression());
				case LESS_THAN_EQUAL:
					return builder.lessThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case IS_NULL:
					return getTypedPath(root, part).isNull();
				case IS_NOT_NULL:
					return getTypedPath(root, part).isNotNull();
				case NOT_IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression()).not();
				case IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression());
				case STARTING_WITH:
				case ENDING_WITH:
				case CONTAINING:
				case NOT_CONTAINING:

					if (property.getLeafProperty().isCollection()) {

						Expression<Collection<Object>> propertyExpression = traversePath(root, property);
						Expression<Object> parameterExpression = provider.next(part).getExpression();

						// Can't just call .not() in case of negation as EclipseLink chokes on that.
						return type.equals(NOT_CONTAINING) ? builder.isNotMember(parameterExpression, propertyExpression)
								: builder.isMember(parameterExpression, propertyExpression);
					}

				case LIKE:
				case NOT_LIKE:
					Expression<String> stringPath = getTypedPath(root, part);
					Expression<String> propertyExpression = upperIfIgnoreCase(stringPath);
					Expression<String> parameterExpression = upperIfIgnoreCase(provider.next(part, String.class).getExpression());
					Predicate like = builder.like(propertyExpression, parameterExpression, escape.getValue());
					return type.equals(NOT_LIKE) || type.equals(NOT_CONTAINING) ? like.not() : like;
				case TRUE:
					Expression<Boolean> truePath = getTypedPath(root, part);
					return builder.isTrue(truePath);
				case FALSE:
					Expression<Boolean> falsePath = getTypedPath(root, part);
					return builder.isFalse(falsePath);
				case SIMPLE_PROPERTY:
					ParameterMetadata<Object> expression = provider.next(part);
					Expression<Object> path = getTypedPath(root, part);
					return expression.isIsNullParameter() ? path.isNull()
							: builder.equal(upperIfIgnoreCase(path), upperIfIgnoreCase(expression.getExpression()));
				case NEGATING_SIMPLE_PROPERTY:
					return builder.notEqual(upperIfIgnoreCase(getTypedPath(root, part)),
							upperIfIgnoreCase(provider.next(part).getExpression()));
				default:
					throw new IllegalArgumentException(""Unsupported keyword "" + type);
			}
		}

		/**
		 * Applies an {@code UPPERCASE} conversion to the given {@link Expression} in case the underlying {@link Part}
		 * requires ignoring case.
		 * 
		 * @param expression must not be {@literal null}.
		 * @return
		 */
		private <T> Expression<T> upperIfIgnoreCase(Expression<? extends T> expression) {

			switch (part.shouldIgnoreCase()) {

				case ALWAYS:

					Assert.state(canUpperCase(expression), ""Unable to ignore case of "" + expression.getJavaType().getName()
							+ "" types, the property '"" + part.getProperty().getSegment() + ""' must reference a String"");
					return (Expression<T>) builder.upper((Expression<String>) expression);

				case WHEN_POSSIBLE:

					if (canUpperCase(expression)) {
						return (Expression<T>) builder.upper((Expression<String>) expression);
					}

				case NEVER:
				default:

					return (Expression<T>) expression;
			}
		}

		private boolean canUpperCase(Expression<?> expression) {
			return String.class.equals(expression.getJavaType());
		}

		/**
		 * Returns a path to a {@link Comparable}.
		 * 
		 * @param root
		 * @param part
		 * @return
		 */
		private Expression<? extends Comparable> getComparablePath(Root<?> root, Part part) {
			return getTypedPath(root, part);
		}

		private <T> Expression<T> getTypedPath(Root<?> root, Part part) {
			return toExpressionRecursively(root, part.getProperty());
		}

		private <T> Expression<T> traversePath(Path<?> root, PropertyPath path) {

			Path<Object> result = root.get(path.getSegment());
			return (Expression<T>) (path.hasNext() ? traversePath(result, path.next()) : result);
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryCreator.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.springframework.data.jpa.domain.AbstractPersistable_.*;
import static org.springframework.data.jpa.repository.query.QueryUtils.*;
import static org.springframework.data.repository.query.parser.Part.Type.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Selection;
import javax.persistence.metamodel.SingularAttribute;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.mapping.PropertyPath;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.AbstractQueryCreator;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.util.Assert;

/**
 * Query creator to create a {@link CriteriaQuery} from a {@link PartTree}.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 */
public class JpaQueryCreator extends AbstractQueryCreator<CriteriaQuery<? extends Object>, Predicate> {

	private final CriteriaBuilder builder;
	private final Root<?> root;
	private final CriteriaQuery<? extends Object> query;
	private final ParameterMetadataProvider provider;
	private final ReturnedType returnedType;
	private final PartTree tree;
	private final EscapeCharacter escape;

	/**
	 * Create a new {@link JpaQueryCreator}.
	 * 
	 * @param tree must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param builder must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public JpaQueryCreator(PartTree tree, ReturnedType type, CriteriaBuilder builder,
			ParameterMetadataProvider provider) {

		super(tree);
		this.tree = tree;

		CriteriaQuery<?> criteriaQuery = createCriteriaQuery(builder, type);

		this.builder = builder;
		this.query = criteriaQuery.distinct(tree.isDistinct());
		this.root = query.from(type.getDomainType());
		this.provider = provider;
		this.returnedType = type;
		this.escape = provider.getEscape();
	}

	/**
	 * Creates the {@link CriteriaQuery} to apply predicates on.
	 * 
	 * @param builder will never be {@literal null}.
	 * @param type will never be {@literal null}.
	 * @return must not be {@literal null}.
	 */
	protected CriteriaQuery<? extends Object> createCriteriaQuery(CriteriaBuilder builder, ReturnedType type) {

		Class<?> typeToRead = type.getTypeToRead();

		return typeToRead == null || tree.isExistsProjection() ? builder.createTupleQuery()
				: builder.createQuery(typeToRead);
	}

	/**
	 * Returns all {@link javax.persistence.criteria.ParameterExpression} created when creating the query.
	 * 
	 * @return the parameterExpressions
	 */
	public List<ParameterMetadata<?>> getParameterExpressions() {
		return provider.getExpressions();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#create(org.springframework.data.repository.query.parser.Part, java.util.Iterator)
	 */
	@Override
	protected Predicate create(Part part, Iterator<Object> iterator) {

		return toPredicate(part, root);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#and(org.springframework.data.repository.query.parser.Part, java.lang.Object, java.util.Iterator)
	 */
	@Override
	protected Predicate and(Part part, Predicate base, Iterator<Object> iterator) {
		return builder.and(base, toPredicate(part, root));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#or(java.lang.Object, java.lang.Object)
	 */
	@Override
	protected Predicate or(Predicate base, Predicate predicate) {
		return builder.or(base, predicate);
	}

	/**
	 * Finalizes the given {@link Predicate} and applies the given sort. Delegates to
	 * {@link #complete(Predicate, Sort, CriteriaQuery, CriteriaBuilder, Root)} and hands it the current {@link CriteriaQuery}
	 * and {@link CriteriaBuilder}.
	 */
	@Override
	protected final CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort) {
		return complete(predicate, sort, query, builder, root);
	}

	/**
	 * Template method to finalize the given {@link Predicate} using the given {@link CriteriaQuery} and
	 * {@link CriteriaBuilder}.
	 * 
	 * @param predicate
	 * @param sort
	 * @param query
	 * @param builder
	 * @return
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	protected CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort,
			CriteriaQuery<? extends Object> query, CriteriaBuilder builder, Root<?> root) {

		if (returnedType.needsCustomConstruction()) {

			List<Selection<?>> selections = new ArrayList<Selection<?>>();

			for (String property : returnedType.getInputProperties()) {

				PropertyPath path = PropertyPath.from(property, returnedType.getDomainType());
				selections.add(toExpressionRecursively(root, path).alias(property));
			}

			query = query.multiselect(selections);

		} else if (tree.isExistsProjection()) {

			if (root.getModel().hasSingleIdAttribute()) {

				SingularAttribute<?, ?> id = root.getModel().getId(root.getModel().getIdType().getJavaType());
				query = query.multiselect(root.get((SingularAttribute) id).alias(id.getName()));

			} else {

				List<Selection<?>> selections = new ArrayList<Selection<?>>();

				for (SingularAttribute<?, ?> attribute : root.getModel().getIdClassAttributes()) {
					selections.add(root.get((SingularAttribute) attribute).alias(attribute.getName()));
				}

				selections.add(root.get((SingularAttribute) id).alias(id.getName()));
				query = query.multiselect(selections);
			}

		} else {
			query = query.select((Root) root);
		}

		CriteriaQuery<? extends Object> select = query.orderBy(QueryUtils.toOrders(sort, root, builder));
		return predicate == null ? select : select.where(predicate);
	}

	/**
	 * Creates a {@link Predicate} from the given {@link Part}.
	 *
	 * @param part
	 * @param root
	 * @return
	 */
	private Predicate toPredicate(Part part, Root<?> root) {
		return new PredicateBuilder(part, root).build();
	}

	/**
	 * Simple builder to contain logic to create JPA {@link Predicate}s from {@link Part}s.
	 * 
	 * @author Phil Webb
	 * @author Oliver Gierke
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private class PredicateBuilder {

		private final Part part;
		private final Root<?> root;

		/**
		 * Creates a new {@link PredicateBuilder} for the given {@link Part} and {@link Root}.
		 * 
		 * @param part must not be {@literal null}.
		 * @param root must not be {@literal null}.
		 */
		public PredicateBuilder(Part part, Root<?> root) {

			Assert.notNull(part, ""Part must not be null!"");
			Assert.notNull(root, ""Root must not be null!"");
			this.part = part;
			this.root = root;
		}

		/**
		 * Builds a JPA {@link Predicate} from the underlying {@link Part}.
		 * 
		 * @return
		 */
		public Predicate build() {

			PropertyPath property = part.getProperty();
			Type type = part.getType();

			switch (type) {
				case BETWEEN:
					ParameterMetadata<Comparable> first = provider.next(part);
					ParameterMetadata<Comparable> second = provider.next(part);
					return builder.between(getComparablePath(root, part), first.getExpression(), second.getExpression());
				case AFTER:
				case GREATER_THAN:
					return builder.greaterThan(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case GREATER_THAN_EQUAL:
					return builder.greaterThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case BEFORE:
				case LESS_THAN:
					return builder.lessThan(getComparablePath(root, part), provider.next(part, Comparable.class).getExpression());
				case LESS_THAN_EQUAL:
					return builder.lessThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case IS_NULL:
					return getTypedPath(root, part).isNull();
				case IS_NOT_NULL:
					return getTypedPath(root, part).isNotNull();
				case NOT_IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression()).not();
				case IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression());
				case STARTING_WITH:
				case ENDING_WITH:
				case CONTAINING:
				case NOT_CONTAINING:

					if (property.getLeafProperty().isCollection()) {

						Expression<Collection<Object>> propertyExpression = traversePath(root, property);
						Expression<Object> parameterExpression = provider.next(part).getExpression();

						// Can't just call .not() in case of negation as EclipseLink chokes on that.
						return type.equals(NOT_CONTAINING) ? builder.isNotMember(parameterExpression, propertyExpression)
								: builder.isMember(parameterExpression, propertyExpression);
					}

				case LIKE:
				case NOT_LIKE:
					Expression<String> stringPath = getTypedPath(root, part);
					Expression<String> propertyExpression = upperIfIgnoreCase(stringPath);
					Expression<String> parameterExpression = upperIfIgnoreCase(provider.next(part, String.class).getExpression());
					Predicate like = builder.like(propertyExpression, parameterExpression, escape.getValue());
					return type.equals(NOT_LIKE) || type.equals(NOT_CONTAINING) ? like.not() : like;
				case TRUE:
					Expression<Boolean> truePath = getTypedPath(root, part);
					return builder.isTrue(truePath);
				case FALSE:
					Expression<Boolean> falsePath = getTypedPath(root, part);
					return builder.isFalse(falsePath);
				case SIMPLE_PROPERTY:
					ParameterMetadata<Object> expression = provider.next(part);
					Expression<Object> path = getTypedPath(root, part);
					return expression.isIsNullParameter() ? path.isNull()
							: builder.equal(upperIfIgnoreCase(path), upperIfIgnoreCase(expression.getExpression()));
				case NEGATING_SIMPLE_PROPERTY:
					return builder.notEqual(upperIfIgnoreCase(getTypedPath(root, part)),
							upperIfIgnoreCase(provider.next(part).getExpression()));
				default:
					throw new IllegalArgumentException(""Unsupported keyword "" + type);
			}
		}

		/**
		 * Applies an {@code UPPERCASE} conversion to the given {@link Expression} in case the underlying {@link Part}
		 * requires ignoring case.
		 * 
		 * @param expression must not be {@literal null}.
		 * @return
		 */
		private <T> Expression<T> upperIfIgnoreCase(Expression<? extends T> expression) {

			switch (part.shouldIgnoreCase()) {

				case ALWAYS:

					Assert.state(canUpperCase(expression), ""Unable to ignore case of "" + expression.getJavaType().getName()
							+ "" types, the property '"" + part.getProperty().getSegment() + ""' must reference a String"");
					return (Expression<T>) builder.upper((Expression<String>) expression);

				case WHEN_POSSIBLE:

					if (canUpperCase(expression)) {
						return (Expression<T>) builder.upper((Expression<String>) expression);
					}

				case NEVER:
				default:

					return (Expression<T>) expression;
			}
		}

		private boolean canUpperCase(Expression<?> expression) {
			return String.class.equals(expression.getJavaType());
		}

		/**
		 * Returns a path to a {@link Comparable}.
		 * 
		 * @param root
		 * @param part
		 * @return
		 */
		private Expression<? extends Comparable> getComparablePath(Root<?> root, Part part) {
			return getTypedPath(root, part);
		}

		private <T> Expression<T> getTypedPath(Root<?> root, Part part) {
			return toExpressionRecursively(root, part.getProperty());
		}

		private <T> Expression<T> traversePath(Path<?> root, PropertyPath path) {

			Path<Object> result = root.get(path.getSegment());
			return (Expression<T>) (path.hasNext() ? traversePath(result, path.next()) : result);
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.RepositoryQuery;
import org.springframework.util.Assert;

/**
 * Query lookup strategy to execute finders.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public final class JpaQueryLookupStrategy {

	/**
	 * Private constructor to prevent instantiation.
	 */
	private JpaQueryLookupStrategy() {}

	/**
	 * Base class for {@link QueryLookupStrategy} implementations that need access to an {@link EntityManager}.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private abstract static class AbstractQueryLookupStrategy implements QueryLookupStrategy {

		private final EntityManager em;
		private final QueryExtractor provider;

		/**
		 * Creates a new {@link AbstractQueryLookupStrategy}.
		 * 
		 * @param em
		 * @param extractor
		 */
		public AbstractQueryLookupStrategy(EntityManager em, QueryExtractor extractor) {

			this.em = em;
			this.provider = extractor;
		}

		/* 
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.query.QueryLookupStrategy#resolveQuery(java.lang.reflect.Method, org.springframework.data.repository.core.RepositoryMetadata, org.springframework.data.projection.ProjectionFactory, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		public final RepositoryQuery resolveQuery(Method method, RepositoryMetadata metadata, ProjectionFactory factory,
				NamedQueries namedQueries) {
			return resolveQuery(new JpaQueryMethod(method, metadata, factory, provider), em, namedQueries);
		}

		protected abstract RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries);
	}

	/**
	 * {@link QueryLookupStrategy} to create a query from the method name.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final PersistenceProvider persistenceProvider;
		private final EscapeCharacter escape;

		public CreateQueryLookupStrategy(EntityManager em, QueryExtractor extractor, EscapeCharacter escape) {

			super(em, extractor);

			this.persistenceProvider = PersistenceProvider.fromEntityManager(em);
			this.escape = escape;
		}

		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {
			return new PartTreeJpaQuery(method, em, persistenceProvider, escape);
		}

	}

	/**
	 * {@link QueryLookupStrategy} that tries to detect a declared query declared via {@link Query} annotation followed by
	 * a JPA named query lookup.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class DeclaredQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final EvaluationContextProvider evaluationContextProvider;

		/**
		 * Creates a new {@link DeclaredQueryLookupStrategy}.
		 * 
		 * @param em
		 * @param extractor
		 * @param evaluationContextProvider
		 */
		public DeclaredQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				EvaluationContextProvider evaluationContextProvider) {

			super(em, extractor);
			this.evaluationContextProvider = evaluationContextProvider;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			RepositoryQuery query = JpaQueryFactory.INSTANCE.fromQueryAnnotation(method, em, evaluationContextProvider);

			if (null != query) {
				return query;
			}

			query = JpaQueryFactory.INSTANCE.fromProcedureAnnotation(method, em);

			if (null != query) {
				return query;
			}

			String name = method.getNamedQueryName();
			if (namedQueries.hasQuery(name)) {
				return JpaQueryFactory.INSTANCE.fromMethodWithQueryString(method, em, namedQueries.getQuery(name),
						evaluationContextProvider);
			}

			query = NamedQuery.lookupFrom(method, em);

			if (null != query) {
				return query;
			}

			throw new IllegalStateException(
					String.format(""Did neither find a NamedQuery nor an annotated query for method %s!"", method));
		}
	}

	/**
	 * {@link QueryLookupStrategy} to try to detect a declared query first (
	 * {@link org.springframework.data.jpa.repository.Query}, JPA named query). In case none is found we fall back on
	 * query creation.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateIfNotFoundQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final DeclaredQueryLookupStrategy lookupStrategy;
		private final CreateQueryLookupStrategy createStrategy;

		/**
		 * Creates a new {@link CreateIfNotFoundQueryLookupStrategy}.
		 * 
		 * @param em
		 * @param extractor
		 * @param createStrategy
		 * @param lookupStrategy
		 */
		public CreateIfNotFoundQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				CreateQueryLookupStrategy createStrategy, DeclaredQueryLookupStrategy lookupStrategy) {

			super(em, extractor);

			this.createStrategy = createStrategy;
			this.lookupStrategy = lookupStrategy;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			try {
				return lookupStrategy.resolveQuery(method, em, namedQueries);
			} catch (IllegalStateException e) {
				return createStrategy.resolveQuery(method, em, namedQueries);
			}
		}
	}

	/**
	 * Creates a {@link QueryLookupStrategy} for the given {@link EntityManager} and {@link Key}.
	 * 
	 * @param em must not be {@literal null}.
	 * @param key may be {@literal null}.
	 * @param extractor must not be {@literal null}.
	 * @param evaluationContextProvider must not be {@literal null}.
	 * @param escape
	 * @return
	 */
	public static QueryLookupStrategy create(EntityManager em, Key key, QueryExtractor extractor,
			EvaluationContextProvider evaluationContextProvider, EscapeCharacter escape) {

		Assert.notNull(em, ""EntityManager must not be null!"");
		Assert.notNull(extractor, ""QueryExtractor must not be null!"");
		Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");

		switch (key != null ? key : Key.CREATE_IF_NOT_FOUND) {
			case CREATE:
				return new CreateQueryLookupStrategy(em, extractor, escape);
			case USE_DECLARED_QUERY:
				return new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider);
			case CREATE_IF_NOT_FOUND:
				return new CreateIfNotFoundQueryLookupStrategy(em, extractor,
						new CreateQueryLookupStrategy(em, extractor, escape),
						new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider));
			default:
				throw new IllegalArgumentException(String.format(""Unsupported query lookup strategy %s!"", key));
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.RepositoryQuery;
import org.springframework.util.Assert;

/**
 * Query lookup strategy to execute finders.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public final class JpaQueryLookupStrategy {

	/**
	 * Private constructor to prevent instantiation.
	 */
	private JpaQueryLookupStrategy() {}

	/**
	 * Base class for {@link QueryLookupStrategy} implementations that need access to an {@link EntityManager}.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private abstract static class AbstractQueryLookupStrategy implements QueryLookupStrategy {

		private final EntityManager em;
		private final QueryExtractor provider;

		/**
		 * Creates a new {@link AbstractQueryLookupStrategy}.
		 * 
		 * @param em
		 * @param extractor
		 */
		public AbstractQueryLookupStrategy(EntityManager em, QueryExtractor extractor) {

			this.em = em;
			this.provider = extractor;
		}

		/* 
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.query.QueryLookupStrategy#resolveQuery(java.lang.reflect.Method, org.springframework.data.repository.core.RepositoryMetadata, org.springframework.data.projection.ProjectionFactory, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		public final RepositoryQuery resolveQuery(Method method, RepositoryMetadata metadata, ProjectionFactory factory,
				NamedQueries namedQueries) {
			return resolveQuery(new JpaQueryMethod(method, metadata, factory, provider), em, namedQueries);
		}

		protected abstract RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries);
	}

	/**
	 * {@link QueryLookupStrategy} to create a query from the method name.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final PersistenceProvider persistenceProvider;
		private final EscapeCharacter escape;

		public CreateQueryLookupStrategy(EntityManager em, QueryExtractor extractor, EscapeCharacter escape) {

			super(em, extractor);

			this.persistenceProvider = PersistenceProvider.fromEntityManager(em);
			this.escape = escape;
		}

		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {
			return new PartTreeJpaQuery(method, em, persistenceProvider, escape);
		}

	}

	/**
	 * {@link QueryLookupStrategy} that tries to detect a declared query declared via {@link Query} annotation followed by
	 * a JPA named query lookup.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class DeclaredQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final EvaluationContextProvider evaluationContextProvider;

		/**
		 * Creates a new {@link DeclaredQueryLookupStrategy}.
		 * 
		 * @param em
		 * @param extractor
		 * @param evaluationContextProvider
		 */
		public DeclaredQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				EvaluationContextProvider evaluationContextProvider) {

			super(em, extractor);
			this.evaluationContextProvider = evaluationContextProvider;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			RepositoryQuery query = JpaQueryFactory.INSTANCE.fromQueryAnnotation(method, em, evaluationContextProvider);

			if (null != query) {
				return query;
			}

			query = JpaQueryFactory.INSTANCE.fromProcedureAnnotation(method, em);

			if (null != query) {
				return query;
			}

			String name = method.getNamedQueryName();
			if (namedQueries.hasQuery(name)) {
				return JpaQueryFactory.INSTANCE.fromMethodWithQueryString(method, em, namedQueries.getQuery(name),
						evaluationContextProvider);
			}

			query = NamedQuery.lookupFrom(method, em);

			if (null != query) {
				return query;
			}

			throw new IllegalStateException(
					String.format(""Did neither find a NamedQuery nor an annotated query for method %s!"", method));
		}
	}

	/**
	 * {@link QueryLookupStrategy} to try to detect a declared query first (
	 * {@link org.springframework.data.jpa.repository.Query}, JPA named query). In case none is found we fall back on
	 * query creation.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateIfNotFoundQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final DeclaredQueryLookupStrategy lookupStrategy;
		private final CreateQueryLookupStrategy createStrategy;

		/**
		 * Creates a new {@link CreateIfNotFoundQueryLookupStrategy}.
		 * 
		 * @param em
		 * @param extractor
		 * @param createStrategy
		 * @param lookupStrategy
		 */
		public CreateIfNotFoundQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				CreateQueryLookupStrategy createStrategy, DeclaredQueryLookupStrategy lookupStrategy) {

			super(em, extractor);

			this.createStrategy = createStrategy;
			this.lookupStrategy = lookupStrategy;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			try {
				return lookupStrategy.resolveQuery(method, em, namedQueries);
			} catch (IllegalStateException e) {
				return createStrategy.resolveQuery(method, em, namedQueries);
			}
		}
	}

	/**
	 * Creates a {@link QueryLookupStrategy} for the given {@link EntityManager} and {@link Key}.
	 * 
	 * @param em must not be {@literal null}.
	 * @param key may be {@literal null}.
	 * @param extractor must not be {@literal null}.
	 * @param evaluationContextProvider must not be {@literal null}.
	 * @param escape
	 * @return
	 */
	public static QueryLookupStrategy create(EntityManager em, Key key, QueryExtractor extractor,
			EvaluationContextProvider evaluationContextProvider, EscapeCharacter escape) {

		Assert.notNull(em, ""EntityManager must not be null!"");
		Assert.notNull(extractor, ""QueryExtractor must not be null!"");
		Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");

		switch (key != null ? key : Key.CREATE_IF_NOT_FOUND) {
			case CREATE:
				return new CreateQueryLookupStrategy(em, extractor, escape);
			case USE_DECLARED_QUERY:
				return new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider);
			case CREATE_IF_NOT_FOUND:
				return new CreateIfNotFoundQueryLookupStrategy(em, extractor,
						new CreateQueryLookupStrategy(em, extractor, escape),
						new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider));
			default:
				throw new IllegalArgumentException(String.format(""Unsupported query lookup strategy %s!"", key));
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/ParameterMetadataProvider.java,"/*
 * Copyright 2011-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.Parameter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.expression.Expression;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;

/**
 * Helper class to allow easy creation of {@link ParameterMetadata}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Mark Paluch
 */
class ParameterMetadataProvider {

	private final CriteriaBuilder builder;
	private final Iterator<? extends Parameter> parameters;
	private final List<ParameterMetadata<?>> expressions;
	private final Iterator<Object> bindableParameterValues;
	private final PersistenceProvider persistenceProvider;
	private final EscapeCharacter escape;

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and
	 * {@link ParametersParameterAccessor} with support for parameter value customizations via {@link PersistenceProvider}
	 * .
	 * 
	 * @param builder must not be {@literal null}.
	 * @param accessor must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, ParametersParameterAccessor accessor,
									 PersistenceProvider provider, EscapeCharacter escape) {
		this(builder, accessor.iterator(), accessor.getParameters(), provider, escape);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and {@link Parameters} with
	 * support for parameter value customizations via {@link PersistenceProvider}.
	 * 
	 *  @param builder must not be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, Parameters<?, ?> parameters, PersistenceProvider provider, EscapeCharacter escape) {
		this(builder, null, parameters, provider, escape);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} an {@link Iterable} of all
	 * bindable parameter values, and {@link Parameters} with support for parameter value customizations via
	 * {@link PersistenceProvider}.
	 * 
	 * @param builder must not be {@literal null}.
	 * @param bindableParameterValues may be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	private ParameterMetadataProvider(CriteriaBuilder builder, Iterator<Object> bindableParameterValues,
									  Parameters<?, ?> parameters, PersistenceProvider provider, EscapeCharacter escape) {

		Assert.notNull(builder, ""CriteriaBuilder must not be null!"");
		Assert.notNull(parameters, ""Parameters must not be null!"");
		Assert.notNull(provider, ""PesistenceProvider must not be null!"");

		this.builder = builder;
		this.parameters = parameters.getBindableParameters().iterator();
		this.expressions = new ArrayList<ParameterMetadata<?>>();
		this.bindableParameterValues = bindableParameterValues;
		this.persistenceProvider = provider;
		this.escape = escape;
	}

	/**
	 * Returns all {@link ParameterMetadata}s built.
	 * 
	 * @return the expressions
	 */
	public List<ParameterMetadata<?>> getExpressions() {
		return Collections.unmodifiableList(expressions);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for given {@link Part} and the next {@link Parameter}.
	 * 
	 * @param <T>
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<T> next(Part part) {

		Assert.isTrue(parameters.hasNext(), String.format(""No parameter available for part %s."", part));

		Parameter parameter = parameters.next();
		return (ParameterMetadata<T>) next(part, parameter.getType(), parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} of the given {@link Part} and type. Forwards the underlying
	 * {@link Parameters} as well.
	 * 
	 * @param <T>
	 * @param type must not be {@literal null}.
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<? extends T> next(Part part, Class<T> type) {

		Parameter parameter = parameters.next();
		Class<?> typeToUse = ClassUtils.isAssignable(type, parameter.getType()) ? parameter.getType() : type;
		return (ParameterMetadata<? extends T>) next(part, typeToUse, parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for the given type and name.
	 * 
	 * @param <T>
	 * @param part must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param parameter
	 * @return
	 */
	private <T> ParameterMetadata<T> next(Part part, Class<T> type, Parameter parameter) {

		Assert.notNull(type, ""Type must not be null!"");

		/*
		 * We treat Expression types as Object vales since the real value to be bound as a parameter is determined at query time.
		 */
		@SuppressWarnings(""unchecked"")
		Class<T> reifiedType = Expression.class.equals(type) ? (Class<T>) Object.class : type;

		ParameterExpression<T> expression = parameter.isExplicitlyNamed()
				? builder.parameter(reifiedType, parameter.getName())
				: builder.parameter(reifiedType);
		ParameterMetadata<T> value = new ParameterMetadata<T>(expression, part.getType(),
				bindableParameterValues == null ? ParameterMetadata.PLACEHOLDER : bindableParameterValues.next(),
				this.persistenceProvider, escape);
		expressions.add(value);

		return value;
	}

	EscapeCharacter getEscape() {
		return escape;
	}

	/**
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 * @param <T>
	 */
	static class ParameterMetadata<T> {

		static final Object PLACEHOLDER = new Object();

		private final Type type;
		private final ParameterExpression<T> expression;
		private final PersistenceProvider persistenceProvider;
		private final EscapeCharacter escape;

		/**
		 * Creates a new {@link ParameterMetadata}.
		 * 
		 * @param expression
		 * @param type
		 * @param value
		 * @param provider
		 * @param escape
		 */
		public ParameterMetadata(ParameterExpression<T> expression, Type type, Object value, PersistenceProvider provider, EscapeCharacter escape) {

			this.expression = expression;
			this.persistenceProvider = provider;
			this.type = value == null && Type.SIMPLE_PROPERTY.equals(type) ? Type.IS_NULL : type;
			this.escape = escape;
		}

		/**
		 * Returns the {@link ParameterExpression}.
		 * 
		 * @return the expression
		 */
		public ParameterExpression<T> getExpression() {
			return expression;
		}

		/**
		 * Returns whether the parameter shall be considered an {@literal IS NULL} parameter.
		 * 
		 * @return
		 */
		public boolean isIsNullParameter() {
			return Type.IS_NULL.equals(type);
		}

		/**
		 * Prepares the object before it's actually bound to the {@link javax.persistence.Query;}.
		 * 
		 * @param value must not be {@literal null}.
		 * @return
		 */
		public Object prepare(Object value) {

			Assert.notNull(value, ""Value must not be null!"");

			Class<? extends T> expressionType = expression.getJavaType();

			if (String.class.equals(expressionType)) {

				switch (type) {
					case STARTING_WITH:
						return String.format(""%s%%"", escape.escape(value.toString()));
					case ENDING_WITH:
						return String.format(""%%%s"", escape.escape(value.toString()));
					case CONTAINING:
					case NOT_CONTAINING:
						return String.format(""%%%s%%"", escape.escape(value.toString()));
					default:
						return value;
				}
			}

			return Collection.class.isAssignableFrom(expressionType)
					? persistenceProvider.potentiallyConvertEmptyCollection(toCollection(value))
					: value;
		}

		/**
		 * Returns the given argument as {@link Collection} which means it will return it as is if it's a
		 * {@link Collections}, turn an array into an {@link ArrayList} or simply wrap any other value into a single element
		 * {@link Collections}.
		 * 
		 * @param value
		 * @return
		 */
		private static Collection<?> toCollection(Object value) {

			if (value == null) {
				return null;
			}

			if (value instanceof Collection) {
				return (Collection<?>) value;
			}

			if (ObjectUtils.isArray(value)) {
				return Arrays.asList(ObjectUtils.toObjectArray(value));
			}

			return Collections.singleton(value);
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/ParameterMetadataProvider.java,"/*
 * Copyright 2011-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.repository.query.Parameter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.expression.Expression;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;

/**
 * Helper class to allow easy creation of {@link ParameterMetadata}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Mark Paluch
 */
class ParameterMetadataProvider {

	private final CriteriaBuilder builder;
	private final Iterator<? extends Parameter> parameters;
	private final List<ParameterMetadata<?>> expressions;
	private final Iterator<Object> bindableParameterValues;
	private final PersistenceProvider persistenceProvider;
	private final EscapeCharacter escape;

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and
	 * {@link ParametersParameterAccessor} with support for parameter value customizations via {@link PersistenceProvider}
	 * .
	 * 
	 * @param builder must not be {@literal null}.
	 * @param accessor must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, ParametersParameterAccessor accessor,
									 PersistenceProvider provider, EscapeCharacter escape) {
		this(builder, accessor.iterator(), accessor.getParameters(), provider, escape);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and {@link Parameters} with
	 * support for parameter value customizations via {@link PersistenceProvider}.
	 * 
	 *  @param builder must not be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, Parameters<?, ?> parameters, PersistenceProvider provider, EscapeCharacter escape) {
		this(builder, null, parameters, provider, escape);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} an {@link Iterable} of all
	 * bindable parameter values, and {@link Parameters} with support for parameter value customizations via
	 * {@link PersistenceProvider}.
	 * 
	 * @param builder must not be {@literal null}.
	 * @param bindableParameterValues may be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	private ParameterMetadataProvider(CriteriaBuilder builder, Iterator<Object> bindableParameterValues,
									  Parameters<?, ?> parameters, PersistenceProvider provider, EscapeCharacter escape) {

		Assert.notNull(builder, ""CriteriaBuilder must not be null!"");
		Assert.notNull(parameters, ""Parameters must not be null!"");
		Assert.notNull(provider, ""PesistenceProvider must not be null!"");

		this.builder = builder;
		this.parameters = parameters.getBindableParameters().iterator();
		this.expressions = new ArrayList<ParameterMetadata<?>>();
		this.bindableParameterValues = bindableParameterValues;
		this.persistenceProvider = provider;
		this.escape = escape;
	}

	/**
	 * Returns all {@link ParameterMetadata}s built.
	 * 
	 * @return the expressions
	 */
	public List<ParameterMetadata<?>> getExpressions() {
		return Collections.unmodifiableList(expressions);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for given {@link Part} and the next {@link Parameter}.
	 * 
	 * @param <T>
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<T> next(Part part) {

		Assert.isTrue(parameters.hasNext(), String.format(""No parameter available for part %s."", part));

		Parameter parameter = parameters.next();
		return (ParameterMetadata<T>) next(part, parameter.getType(), parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} of the given {@link Part} and type. Forwards the underlying
	 * {@link Parameters} as well.
	 * 
	 * @param <T>
	 * @param type must not be {@literal null}.
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<? extends T> next(Part part, Class<T> type) {

		Parameter parameter = parameters.next();
		Class<?> typeToUse = ClassUtils.isAssignable(type, parameter.getType()) ? parameter.getType() : type;
		return (ParameterMetadata<? extends T>) next(part, typeToUse, parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for the given type and name.
	 * 
	 * @param <T>
	 * @param part must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param parameter
	 * @return
	 */
	private <T> ParameterMetadata<T> next(Part part, Class<T> type, Parameter parameter) {

		Assert.notNull(type, ""Type must not be null!"");

		/*
		 * We treat Expression types as Object vales since the real value to be bound as a parameter is determined at query time.
		 */
		@SuppressWarnings(""unchecked"")
		Class<T> reifiedType = Expression.class.equals(type) ? (Class<T>) Object.class : type;

		ParameterExpression<T> expression = parameter.isExplicitlyNamed()
				? builder.parameter(reifiedType, parameter.getName())
				: builder.parameter(reifiedType);
		ParameterMetadata<T> value = new ParameterMetadata<T>(expression, part.getType(),
				bindableParameterValues == null ? ParameterMetadata.PLACEHOLDER : bindableParameterValues.next(),
				this.persistenceProvider, escape);
		expressions.add(value);

		return value;
	}

	EscapeCharacter getEscape() {
		return escape;
	}

	/**
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 * @param <T>
	 */
	static class ParameterMetadata<T> {

		static final Object PLACEHOLDER = new Object();

		private final Type type;
		private final ParameterExpression<T> expression;
		private final PersistenceProvider persistenceProvider;
		private final EscapeCharacter escape;

		/**
		 * Creates a new {@link ParameterMetadata}.
		 * 
		 * @param expression
		 * @param type
		 * @param value
		 * @param provider
		 * @param escape
		 */
		public ParameterMetadata(ParameterExpression<T> expression, Type type, Object value, PersistenceProvider provider, EscapeCharacter escape) {

			this.expression = expression;
			this.persistenceProvider = provider;
			this.type = value == null && Type.SIMPLE_PROPERTY.equals(type) ? Type.IS_NULL : type;
			this.escape = escape;
		}

		/**
		 * Returns the {@link ParameterExpression}.
		 * 
		 * @return the expression
		 */
		public ParameterExpression<T> getExpression() {
			return expression;
		}

		/**
		 * Returns whether the parameter shall be considered an {@literal IS NULL} parameter.
		 * 
		 * @return
		 */
		public boolean isIsNullParameter() {
			return Type.IS_NULL.equals(type);
		}

		/**
		 * Prepares the object before it's actually bound to the {@link javax.persistence.Query;}.
		 * 
		 * @param value must not be {@literal null}.
		 * @return
		 */
		public Object prepare(Object value) {

			Assert.notNull(value, ""Value must not be null!"");

			Class<? extends T> expressionType = expression.getJavaType();

			if (String.class.equals(expressionType)) {

				switch (type) {
					case STARTING_WITH:
						return String.format(""%s%%"", escape.escape(value.toString()));
					case ENDING_WITH:
						return String.format(""%%%s"", escape.escape(value.toString()));
					case CONTAINING:
					case NOT_CONTAINING:
						return String.format(""%%%s%%"", escape.escape(value.toString()));
					default:
						return value;
				}
			}

			return Collection.class.isAssignableFrom(expressionType)
					? persistenceProvider.potentiallyConvertEmptyCollection(toCollection(value))
					: value;
		}

		/**
		 * Returns the given argument as {@link Collection} which means it will return it as is if it's a
		 * {@link Collections}, turn an array into an {@link ArrayList} or simply wrap any other value into a single element
		 * {@link Collections}.
		 * 
		 * @param value
		 * @return
		 */
		private static Collection<?> toCollection(Object value) {

			if (value == null) {
				return null;
			}

			if (value instanceof Collection) {
				return (Collection<?>) value;
			}

			if (ObjectUtils.isArray(value)) {
				return Arrays.asList(ObjectUtils.toObjectArray(value));
			}

			return Collections.singleton(value);
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/PartTreeJpaQuery.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.DeleteExecution;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.ExistsExecution;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.ResultProcessor;
import org.springframework.data.repository.query.parser.PartTree;

/**
 * A {@link AbstractJpaQuery} implementation based on a {@link PartTree}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public class PartTreeJpaQuery extends AbstractJpaQuery {

	private final Class<?> domainClass;
	private final PartTree tree;
	private final JpaParameters parameters;

	private final QueryPreparer query;
	private final QueryPreparer countQuery;
	private final EntityManager em;
	private final EscapeCharacter escape;

	/**
	 * Creates a new {@link PartTreeJpaQuery}.
	 * 
	 * @param method must not be {@literal null}.
	 * @param factory must not be {@literal null}.
	 * @param em must not be {@literal null}.
	 * @param persistenceProvider must not be {@literal null}.
	 * @param escape
	 */
	public PartTreeJpaQuery(JpaQueryMethod method, EntityManager em, PersistenceProvider persistenceProvider, EscapeCharacter escape) {

		super(method, em);

		this.em = em;
		this.escape = escape;
		this.domainClass = method.getEntityInformation().getJavaType();
		this.parameters = method.getParameters();

		boolean recreationRequired = parameters.hasDynamicProjection() || parameters.potentiallySortsDynamically();

		try {

			this.tree = new PartTree(method.getName(), domainClass);
			this.countQuery = new CountQueryPreparer(persistenceProvider, recreationRequired);
			this.query = tree.isCountProjection() ? countQuery : new QueryPreparer(persistenceProvider, recreationRequired);

		} catch (Exception o_O) {
			throw new IllegalArgumentException(
					String.format(""Failed to create query method %s! %s"", method, o_O.getMessage()), o_O);
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateQuery(java.lang.Object[])
	 */
	@Override
	public Query doCreateQuery(Object[] values) {
		return query.createQuery(values);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateCountQuery(java.lang.Object[])
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public TypedQuery<Long> doCreateCountQuery(Object[] values) {
		return (TypedQuery<Long>) countQuery.createQuery(values);
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#getExecution()
	 */
	@Override
	protected JpaQueryExecution getExecution() {

		if (this.tree.isDelete()) {
			return new DeleteExecution(em);
		} else if (this.tree.isExistsProjection()) {
			return new ExistsExecution();
		}

		return super.getExecution();
	}

	/**
	 * Query preparer to create {@link CriteriaQuery} instances and potentially cache them.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class QueryPreparer {

		private final CriteriaQuery<?> cachedCriteriaQuery;
		private final List<ParameterMetadata<?>> expressions;
		private final PersistenceProvider persistenceProvider;

		public QueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {

			this.persistenceProvider = persistenceProvider;

			JpaQueryCreator creator = createCreator(null, persistenceProvider);

			this.cachedCriteriaQuery = recreateQueries ? null : creator.createQuery();
			this.expressions = recreateQueries ? null : creator.getParameterExpressions();
		}

		/**
		 * Creates a new {@link Query} for the given parameter values.
		 * 
		 * @param values
		 * @return
		 */
		public Query createQuery(Object[] values) {

			CriteriaQuery<?> criteriaQuery = cachedCriteriaQuery;
			List<ParameterMetadata<?>> expressions = this.expressions;
			ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, values);

			if (cachedCriteriaQuery == null || accessor.hasBindableNullValue()) {
				JpaQueryCreator creator = createCreator(accessor, persistenceProvider);
				criteriaQuery = creator.createQuery(getDynamicSort(values));
				expressions = creator.getParameterExpressions();
			}

			TypedQuery<?> jpaQuery = createQuery(criteriaQuery);

			return restrictMaxResultsIfNecessary(invokeBinding(getBinder(values, expressions), jpaQuery));
		}

		/**
		 * Restricts the max results of the given {@link Query} if the current {@code tree} marks this {@code query} as
		 * limited.
		 * 
		 * @param query
		 * @return
		 */
		private Query restrictMaxResultsIfNecessary(Query query) {

			if (tree.isLimiting()) {

				if (query.getMaxResults() != Integer.MAX_VALUE) {
					/*
					 * In order to return the correct results, we have to adjust the first result offset to be returned if:
					 * - a Pageable parameter is present 
					 * - AND the requested page number > 0
					 * - AND the requested page size was bigger than the derived result limitation via the First/Top keyword.
					 */
					if (query.getMaxResults() > tree.getMaxResults() && query.getFirstResult() > 0) {
						query.setFirstResult(query.getFirstResult() - (query.getMaxResults() - tree.getMaxResults()));
					}
				}

				query.setMaxResults(tree.getMaxResults());
			}

			if (tree.isExistsProjection()) {
				query.setMaxResults(1);
			}

			return query;
		}

		/**
		 * Checks whether we are working with a cached {@link CriteriaQuery} and synchronizes the creation of a
		 * {@link TypedQuery} instance from it. This is due to non-thread-safety in the {@link CriteriaQuery} implementation
		 * of some persistence providers (i.e. Hibernate in this case), see DATAJPA-396.
		 * 
		 * @param criteriaQuery must not be {@literal null}.
		 * @return
		 */
		private TypedQuery<?> createQuery(CriteriaQuery<?> criteriaQuery) {

			if (this.cachedCriteriaQuery != null) {
				synchronized (this.cachedCriteriaQuery) {
					return getEntityManager().createQuery(criteriaQuery);
				}
			}

			return getEntityManager().createQuery(criteriaQuery);
		}

		protected JpaQueryCreator createCreator(ParametersParameterAccessor accessor,
				PersistenceProvider persistenceProvider) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor == null
					? new ParameterMetadataProvider(builder, parameters, persistenceProvider, escape)
					: new ParameterMetadataProvider(builder, accessor, persistenceProvider, escape);

			ResultProcessor resultFactory = getQueryMethod().getResultProcessor().withDynamicProjection(accessor);

			return new JpaQueryCreator(tree, resultFactory.getReturnedType(), builder, provider);
		}

		/**
		 * Invokes parameter binding on the given {@link TypedQuery}.
		 * 
		 * @param binder
		 * @param query
		 * @return
		 */
		protected Query invokeBinding(ParameterBinder binder, TypedQuery<?> query) {

			return binder.bindAndPrepare(query);
		}

		private ParameterBinder getBinder(Object[] values, List<ParameterMetadata<?>> expressions) {
			return new CriteriaQueryParameterBinder(parameters, values, expressions);
		}

		private Sort getDynamicSort(Object[] values) {

			return parameters.potentiallySortsDynamically() ? new ParametersParameterAccessor(parameters, values).getSort()
					: null;
		}
	}

	/**
	 * Special {@link QueryPreparer} to create count queries.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class CountQueryPreparer extends QueryPreparer {

		public CountQueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {
			super(persistenceProvider, recreateQueries);
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#createCreator(org.springframework.data.repository.query.ParametersParameterAccessor, org.springframework.data.jpa.provider.PersistenceProvider)
		 */
		@Override
		protected JpaQueryCreator createCreator(ParametersParameterAccessor accessor,
				PersistenceProvider persistenceProvider) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor == null
					? new ParameterMetadataProvider(builder, parameters, persistenceProvider, escape)
					: new ParameterMetadataProvider(builder, accessor, persistenceProvider, escape);

			return new JpaCountQueryCreator(tree, getQueryMethod().getResultProcessor().getReturnedType(), builder, provider);
		}

		/**
		 * Customizes binding by skipping the pagination.
		 * 
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#invokeBinding(org.springframework.data.jpa.repository.query.ParameterBinder,
		 *      javax.persistence.TypedQuery)
		 */
		@Override
		protected Query invokeBinding(ParameterBinder binder, javax.persistence.TypedQuery<?> query) {
			return binder.bind(query);
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/PartTreeJpaQuery.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.DeleteExecution;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.ExistsExecution;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.ResultProcessor;
import org.springframework.data.repository.query.parser.PartTree;

/**
 * A {@link AbstractJpaQuery} implementation based on a {@link PartTree}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public class PartTreeJpaQuery extends AbstractJpaQuery {

	private final Class<?> domainClass;
	private final PartTree tree;
	private final JpaParameters parameters;

	private final QueryPreparer query;
	private final QueryPreparer countQuery;
	private final EntityManager em;
	private final EscapeCharacter escape;

	/**
	 * Creates a new {@link PartTreeJpaQuery}.
	 * 
	 * @param method must not be {@literal null}.
	 * @param factory must not be {@literal null}.
	 * @param em must not be {@literal null}.
	 * @param persistenceProvider must not be {@literal null}.
	 * @param escape
	 */
	public PartTreeJpaQuery(JpaQueryMethod method, EntityManager em, PersistenceProvider persistenceProvider, EscapeCharacter escape) {

		super(method, em);

		this.em = em;
		this.escape = escape;
		this.domainClass = method.getEntityInformation().getJavaType();
		this.parameters = method.getParameters();

		boolean recreationRequired = parameters.hasDynamicProjection() || parameters.potentiallySortsDynamically();

		try {

			this.tree = new PartTree(method.getName(), domainClass);
			this.countQuery = new CountQueryPreparer(persistenceProvider, recreationRequired);
			this.query = tree.isCountProjection() ? countQuery : new QueryPreparer(persistenceProvider, recreationRequired);

		} catch (Exception o_O) {
			throw new IllegalArgumentException(
					String.format(""Failed to create query method %s! %s"", method, o_O.getMessage()), o_O);
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateQuery(java.lang.Object[])
	 */
	@Override
	public Query doCreateQuery(Object[] values) {
		return query.createQuery(values);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateCountQuery(java.lang.Object[])
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public TypedQuery<Long> doCreateCountQuery(Object[] values) {
		return (TypedQuery<Long>) countQuery.createQuery(values);
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#getExecution()
	 */
	@Override
	protected JpaQueryExecution getExecution() {

		if (this.tree.isDelete()) {
			return new DeleteExecution(em);
		} else if (this.tree.isExistsProjection()) {
			return new ExistsExecution();
		}

		return super.getExecution();
	}

	/**
	 * Query preparer to create {@link CriteriaQuery} instances and potentially cache them.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class QueryPreparer {

		private final CriteriaQuery<?> cachedCriteriaQuery;
		private final List<ParameterMetadata<?>> expressions;
		private final PersistenceProvider persistenceProvider;

		public QueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {

			this.persistenceProvider = persistenceProvider;

			JpaQueryCreator creator = createCreator(null, persistenceProvider);

			this.cachedCriteriaQuery = recreateQueries ? null : creator.createQuery();
			this.expressions = recreateQueries ? null : creator.getParameterExpressions();
		}

		/**
		 * Creates a new {@link Query} for the given parameter values.
		 * 
		 * @param values
		 * @return
		 */
		public Query createQuery(Object[] values) {

			CriteriaQuery<?> criteriaQuery = cachedCriteriaQuery;
			List<ParameterMetadata<?>> expressions = this.expressions;
			ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, values);

			if (cachedCriteriaQuery == null || accessor.hasBindableNullValue()) {
				JpaQueryCreator creator = createCreator(accessor, persistenceProvider);
				criteriaQuery = creator.createQuery(getDynamicSort(values));
				expressions = creator.getParameterExpressions();
			}

			TypedQuery<?> jpaQuery = createQuery(criteriaQuery);

			return restrictMaxResultsIfNecessary(invokeBinding(getBinder(values, expressions), jpaQuery));
		}

		/**
		 * Restricts the max results of the given {@link Query} if the current {@code tree} marks this {@code query} as
		 * limited.
		 * 
		 * @param query
		 * @return
		 */
		private Query restrictMaxResultsIfNecessary(Query query) {

			if (tree.isLimiting()) {

				if (query.getMaxResults() != Integer.MAX_VALUE) {
					/*
					 * In order to return the correct results, we have to adjust the first result offset to be returned if:
					 * - a Pageable parameter is present 
					 * - AND the requested page number > 0
					 * - AND the requested page size was bigger than the derived result limitation via the First/Top keyword.
					 */
					if (query.getMaxResults() > tree.getMaxResults() && query.getFirstResult() > 0) {
						query.setFirstResult(query.getFirstResult() - (query.getMaxResults() - tree.getMaxResults()));
					}
				}

				query.setMaxResults(tree.getMaxResults());
			}

			if (tree.isExistsProjection()) {
				query.setMaxResults(1);
			}

			return query;
		}

		/**
		 * Checks whether we are working with a cached {@link CriteriaQuery} and synchronizes the creation of a
		 * {@link TypedQuery} instance from it. This is due to non-thread-safety in the {@link CriteriaQuery} implementation
		 * of some persistence providers (i.e. Hibernate in this case), see DATAJPA-396.
		 * 
		 * @param criteriaQuery must not be {@literal null}.
		 * @return
		 */
		private TypedQuery<?> createQuery(CriteriaQuery<?> criteriaQuery) {

			if (this.cachedCriteriaQuery != null) {
				synchronized (this.cachedCriteriaQuery) {
					return getEntityManager().createQuery(criteriaQuery);
				}
			}

			return getEntityManager().createQuery(criteriaQuery);
		}

		protected JpaQueryCreator createCreator(ParametersParameterAccessor accessor,
				PersistenceProvider persistenceProvider) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor == null
					? new ParameterMetadataProvider(builder, parameters, persistenceProvider, escape)
					: new ParameterMetadataProvider(builder, accessor, persistenceProvider, escape);

			ResultProcessor resultFactory = getQueryMethod().getResultProcessor().withDynamicProjection(accessor);

			return new JpaQueryCreator(tree, resultFactory.getReturnedType(), builder, provider);
		}

		/**
		 * Invokes parameter binding on the given {@link TypedQuery}.
		 * 
		 * @param binder
		 * @param query
		 * @return
		 */
		protected Query invokeBinding(ParameterBinder binder, TypedQuery<?> query) {

			return binder.bindAndPrepare(query);
		}

		private ParameterBinder getBinder(Object[] values, List<ParameterMetadata<?>> expressions) {
			return new CriteriaQueryParameterBinder(parameters, values, expressions);
		}

		private Sort getDynamicSort(Object[] values) {

			return parameters.potentiallySortsDynamically() ? new ParametersParameterAccessor(parameters, values).getSort()
					: null;
		}
	}

	/**
	 * Special {@link QueryPreparer} to create count queries.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class CountQueryPreparer extends QueryPreparer {

		public CountQueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {
			super(persistenceProvider, recreateQueries);
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#createCreator(org.springframework.data.repository.query.ParametersParameterAccessor, org.springframework.data.jpa.provider.PersistenceProvider)
		 */
		@Override
		protected JpaQueryCreator createCreator(ParametersParameterAccessor accessor,
				PersistenceProvider persistenceProvider) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor == null
					? new ParameterMetadataProvider(builder, parameters, persistenceProvider, escape)
					: new ParameterMetadataProvider(builder, accessor, persistenceProvider, escape);

			return new JpaCountQueryCreator(tree, getQueryMethod().getResultProcessor().getReturnedType(), builder, provider);
		}

		/**
		 * Customizes binding by skipping the pagination.
		 * 
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#invokeBinding(org.springframework.data.jpa.repository.query.ParameterBinder,
		 *      javax.persistence.TypedQuery)
		 */
		@Override
		protected Query invokeBinding(ParameterBinder binder, javax.persistence.TypedQuery<?> query) {
			return binder.bind(query);
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactory.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import static org.springframework.data.querydsl.QueryDslUtils.*;

import lombok.extern.slf4j.Slf4j;

import java.io.Serializable;

import javax.persistence.EntityManager;
import javax.persistence.Tuple;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.data.jpa.projection.CollectionAwareProjectionFactory;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.query.AbstractJpaQuery;
import org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy;
import org.springframework.data.jpa.repository.query.JpaQueryMethod;
import org.springframework.data.jpa.util.JpaMetamodel;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.querydsl.QueryDslPredicateExecutor;
import org.springframework.data.repository.core.RepositoryInformation;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.QueryCreationListener;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.util.Assert;

/**
 * JPA specific generic repository factory.
 *
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Jens Schauder
 */
public class JpaRepositoryFactory extends RepositoryFactorySupport {

	private final EntityManager entityManager;
	private final QueryExtractor extractor;
	private final CrudMethodMetadataPostProcessor crudMethodMetadataPostProcessor;

	private EscapeCharacter escapeCharacter = EscapeCharacter.of('\\');

	/**
	 * Creates a new {@link JpaRepositoryFactory}.
	 *
	 * @param entityManager must not be {@literal null}
	 */
	public JpaRepositoryFactory(EntityManager entityManager) {

		Assert.notNull(entityManager, ""EntityManager must not be null!"");

		this.entityManager = entityManager;
		this.extractor = PersistenceProvider.fromEntityManager(entityManager);
		this.crudMethodMetadataPostProcessor = new CrudMethodMetadataPostProcessor();

		addRepositoryProxyPostProcessor(crudMethodMetadataPostProcessor);

		if (extractor.equals(PersistenceProvider.ECLIPSELINK)) {
			addQueryCreationListener(new EclipseLinkProjectionQueryCreationListener(entityManager));
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#setBeanClassLoader(java.lang.ClassLoader)
	 */
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {

		super.setBeanClassLoader(classLoader);
		this.crudMethodMetadataPostProcessor.setBeanClassLoader(classLoader);
	}

	/**
	 * Configures the escape character to be used for like-expressions created for derived queries.
	 *
	 * @param escapeCharacter a character used for escaping in certain like expressions.
	 */
	public void setEscapeCharacter(EscapeCharacter escapeCharacter) {
		this.escapeCharacter = escapeCharacter;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getTargetRepository(org.springframework.data.repository.core.RepositoryMetadata)
	 */
	@Override
	protected Object getTargetRepository(RepositoryInformation information) {

		SimpleJpaRepository<?, ?> repository = getTargetRepository(information, entityManager);
		repository.setRepositoryMethodMetadata(crudMethodMetadataPostProcessor.getCrudMethodMetadata());

		return repository;
	}

	/**
	 * Callback to create a {@link JpaRepository} instance with the given {@link EntityManager}
	 *
	 * @param <T>
	 * @param <ID>
	 * @param entityManager
	 * @see #getTargetRepository(RepositoryMetadata)
	 * @return
	 */
	protected <T, ID extends Serializable> SimpleJpaRepository<?, ?> getTargetRepository(
			RepositoryInformation information, EntityManager entityManager) {

		JpaEntityInformation<?, Serializable> entityInformation = getEntityInformation(information.getDomainType());

		return getTargetRepositoryViaReflection(information, entityInformation, entityManager);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.springframework.data.repository.support.RepositoryFactorySupport#
	 * getRepositoryBaseClass()
	 */
	@Override
	protected Class<?> getRepositoryBaseClass(RepositoryMetadata metadata) {

		if (isQueryDslExecutor(metadata.getRepositoryInterface())) {
			return QueryDslJpaRepository.class;
		} else {
			return SimpleJpaRepository.class;
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getProjectionFactory(java.lang.ClassLoader, org.springframework.beans.factory.BeanFactory)
	 */
	@Override
	protected ProjectionFactory getProjectionFactory(ClassLoader classLoader, BeanFactory beanFactory) {

		CollectionAwareProjectionFactory factory = new CollectionAwareProjectionFactory();
		factory.setBeanClassLoader(classLoader);
		factory.setBeanFactory(beanFactory);

		return factory;
	}

	/**
	 * Returns whether the given repository interface requires a QueryDsl specific implementation to be chosen.
	 *
	 * @param repositoryInterface
	 * @return
	 */
	private boolean isQueryDslExecutor(Class<?> repositoryInterface) {

		return QUERY_DSL_PRESENT && QueryDslPredicateExecutor.class.isAssignableFrom(repositoryInterface);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getQueryLookupStrategy(org.springframework.data.repository.query.QueryLookupStrategy.Key, org.springframework.data.repository.query.EvaluationContextProvider)
	 */
	@Override
	protected QueryLookupStrategy getQueryLookupStrategy(Key key, EvaluationContextProvider evaluationContextProvider) {
		return JpaQueryLookupStrategy.create(entityManager, key, extractor, evaluationContextProvider, escapeCharacter);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.springframework.data.repository.support.RepositoryFactorySupport#
	 * getEntityInformation(java.lang.Class)
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public <T, ID extends Serializable> JpaEntityInformation<T, ID> getEntityInformation(Class<T> domainClass) {

		return (JpaEntityInformation<T, ID>) JpaEntityInformationSupport.getEntityInformation(domainClass, entityManager);
	}

	/**
	 * Query creation listener that informs EclipseLink users that they have to be extra careful when defining repository
	 * query methods using projections as we have to rely on the declaration order of the accessors in projection
	 * interfaces matching the order in columns. Alias-based mapping doesn't work with EclipseLink as it doesn't support
	 * {@link Tuple} based queries yet.
	 *
	 * @author Oliver Gierke
	 * @since 2.0.5
	 * @see https://bugs.eclipse.org/bugs/show_bug.cgi?id=289141
	 */
	@Slf4j
	private static class EclipseLinkProjectionQueryCreationListener implements QueryCreationListener<AbstractJpaQuery> {

		private static final String ECLIPSELINK_PROJECTIONS = ""Usage of Spring Data projections detected on persistence provider EclipseLink. Make sure the following query methods declare result columns in exactly the order the accessors are declared in the projecting interface or the order of parameters for DTOs:"";

		private final JpaMetamodel metamodel;

		private boolean warningLogged = false;

		/**
		 * Creates a new {@link EclipseLinkProjectionQueryCreationListener} for the given {@link EntityManager}.
		 *
		 * @param em must not be {@literal null}.
		 */
		public EclipseLinkProjectionQueryCreationListener(EntityManager em) {

			Assert.notNull(em, ""EntityManager must not be null!"");

			this.metamodel = new JpaMetamodel(em.getMetamodel());
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.core.support.QueryCreationListener#onCreation(org.springframework.data.repository.query.RepositoryQuery)
		 */
		@Override
		public void onCreation(AbstractJpaQuery query) {

			JpaQueryMethod queryMethod = query.getQueryMethod();
			ReturnedType type = queryMethod.getResultProcessor().getReturnedType();

			if (type.isProjecting() && !metamodel.isJpaManaged(type.getReturnedType())) {

				if (!warningLogged) {
					log.info(ECLIPSELINK_PROJECTIONS);
					this.warningLogged = true;
				}

				log.info("" - {}"", queryMethod);
			}
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactory.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import static org.springframework.data.querydsl.QueryDslUtils.*;

import lombok.extern.slf4j.Slf4j;

import java.io.Serializable;

import javax.persistence.EntityManager;
import javax.persistence.Tuple;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.data.jpa.projection.CollectionAwareProjectionFactory;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.query.AbstractJpaQuery;
import org.springframework.data.jpa.repository.query.EscapeCharacter;
import org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy;
import org.springframework.data.jpa.repository.query.JpaQueryMethod;
import org.springframework.data.jpa.util.JpaMetamodel;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.querydsl.QueryDslPredicateExecutor;
import org.springframework.data.repository.core.RepositoryInformation;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.QueryCreationListener;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.util.Assert;

/**
 * JPA specific generic repository factory.
 *
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Jens Schauder
 */
public class JpaRepositoryFactory extends RepositoryFactorySupport {

	private final EntityManager entityManager;
	private final QueryExtractor extractor;
	private final CrudMethodMetadataPostProcessor crudMethodMetadataPostProcessor;

	private EscapeCharacter escapeCharacter = EscapeCharacter.of('\\');

	/**
	 * Creates a new {@link JpaRepositoryFactory}.
	 *
	 * @param entityManager must not be {@literal null}
	 */
	public JpaRepositoryFactory(EntityManager entityManager) {

		Assert.notNull(entityManager, ""EntityManager must not be null!"");

		this.entityManager = entityManager;
		this.extractor = PersistenceProvider.fromEntityManager(entityManager);
		this.crudMethodMetadataPostProcessor = new CrudMethodMetadataPostProcessor();

		addRepositoryProxyPostProcessor(crudMethodMetadataPostProcessor);

		if (extractor.equals(PersistenceProvider.ECLIPSELINK)) {
			addQueryCreationListener(new EclipseLinkProjectionQueryCreationListener(entityManager));
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#setBeanClassLoader(java.lang.ClassLoader)
	 */
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {

		super.setBeanClassLoader(classLoader);
		this.crudMethodMetadataPostProcessor.setBeanClassLoader(classLoader);
	}

	/**
	 * Configures the escape character to be used for like-expressions created for derived queries.
	 *
	 * @param escapeCharacter a character used for escaping in certain like expressions.
	 */
	public void setEscapeCharacter(EscapeCharacter escapeCharacter) {
		this.escapeCharacter = escapeCharacter;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getTargetRepository(org.springframework.data.repository.core.RepositoryMetadata)
	 */
	@Override
	protected Object getTargetRepository(RepositoryInformation information) {

		SimpleJpaRepository<?, ?> repository = getTargetRepository(information, entityManager);
		repository.setRepositoryMethodMetadata(crudMethodMetadataPostProcessor.getCrudMethodMetadata());

		return repository;
	}

	/**
	 * Callback to create a {@link JpaRepository} instance with the given {@link EntityManager}
	 *
	 * @param <T>
	 * @param <ID>
	 * @param entityManager
	 * @see #getTargetRepository(RepositoryMetadata)
	 * @return
	 */
	protected <T, ID extends Serializable> SimpleJpaRepository<?, ?> getTargetRepository(
			RepositoryInformation information, EntityManager entityManager) {

		JpaEntityInformation<?, Serializable> entityInformation = getEntityInformation(information.getDomainType());

		return getTargetRepositoryViaReflection(information, entityInformation, entityManager);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.springframework.data.repository.support.RepositoryFactorySupport#
	 * getRepositoryBaseClass()
	 */
	@Override
	protected Class<?> getRepositoryBaseClass(RepositoryMetadata metadata) {

		if (isQueryDslExecutor(metadata.getRepositoryInterface())) {
			return QueryDslJpaRepository.class;
		} else {
			return SimpleJpaRepository.class;
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getProjectionFactory(java.lang.ClassLoader, org.springframework.beans.factory.BeanFactory)
	 */
	@Override
	protected ProjectionFactory getProjectionFactory(ClassLoader classLoader, BeanFactory beanFactory) {

		CollectionAwareProjectionFactory factory = new CollectionAwareProjectionFactory();
		factory.setBeanClassLoader(classLoader);
		factory.setBeanFactory(beanFactory);

		return factory;
	}

	/**
	 * Returns whether the given repository interface requires a QueryDsl specific implementation to be chosen.
	 *
	 * @param repositoryInterface
	 * @return
	 */
	private boolean isQueryDslExecutor(Class<?> repositoryInterface) {

		return QUERY_DSL_PRESENT && QueryDslPredicateExecutor.class.isAssignableFrom(repositoryInterface);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getQueryLookupStrategy(org.springframework.data.repository.query.QueryLookupStrategy.Key, org.springframework.data.repository.query.EvaluationContextProvider)
	 */
	@Override
	protected QueryLookupStrategy getQueryLookupStrategy(Key key, EvaluationContextProvider evaluationContextProvider) {
		return JpaQueryLookupStrategy.create(entityManager, key, extractor, evaluationContextProvider, escapeCharacter);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.springframework.data.repository.support.RepositoryFactorySupport#
	 * getEntityInformation(java.lang.Class)
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public <T, ID extends Serializable> JpaEntityInformation<T, ID> getEntityInformation(Class<T> domainClass) {

		return (JpaEntityInformation<T, ID>) JpaEntityInformationSupport.getEntityInformation(domainClass, entityManager);
	}

	/**
	 * Query creation listener that informs EclipseLink users that they have to be extra careful when defining repository
	 * query methods using projections as we have to rely on the declaration order of the accessors in projection
	 * interfaces matching the order in columns. Alias-based mapping doesn't work with EclipseLink as it doesn't support
	 * {@link Tuple} based queries yet.
	 *
	 * @author Oliver Gierke
	 * @since 2.0.5
	 * @see https://bugs.eclipse.org/bugs/show_bug.cgi?id=289141
	 */
	@Slf4j
	private static class EclipseLinkProjectionQueryCreationListener implements QueryCreationListener<AbstractJpaQuery> {

		private static final String ECLIPSELINK_PROJECTIONS = ""Usage of Spring Data projections detected on persistence provider EclipseLink. Make sure the following query methods declare result columns in exactly the order the accessors are declared in the projecting interface or the order of parameters for DTOs:"";

		private final JpaMetamodel metamodel;

		private boolean warningLogged = false;

		/**
		 * Creates a new {@link EclipseLinkProjectionQueryCreationListener} for the given {@link EntityManager}.
		 *
		 * @param em must not be {@literal null}.
		 */
		public EclipseLinkProjectionQueryCreationListener(EntityManager em) {

			Assert.notNull(em, ""EntityManager must not be null!"");

			this.metamodel = new JpaMetamodel(em.getMetamodel());
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.core.support.QueryCreationListener#onCreation(org.springframework.data.repository.query.RepositoryQuery)
		 */
		@Override
		public void onCreation(AbstractJpaQuery query) {

			JpaQueryMethod queryMethod = query.getQueryMethod();
			ReturnedType type = queryMethod.getResultProcessor().getReturnedType();

			if (type.isProjecting() && !metamodel.isJpaManaged(type.getReturnedType())) {

				if (!warningLogged) {
					log.info(ECLIPSELINK_PROJECTIONS);
					this.warningLogged = true;
				}

				log.info("" - {}"", queryMethod);
			}
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryBean.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import java.io.Serializable;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.springframework.data.mapping.context.MappingContext;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.core.support.TransactionalRepositoryFactoryBeanSupport;
import org.springframework.util.Assert;

/**
 * Special adapter for Springs {@link org.springframework.beans.factory.FactoryBean} interface to allow easy setup of
 * repository factories via Spring configuration.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @param <T> the type of the repository
 */
public class JpaRepositoryFactoryBean<T extends Repository<S, ID>, S, ID extends Serializable>
		extends TransactionalRepositoryFactoryBeanSupport<T, S, ID> {

	private EntityManager entityManager;
	private EscapeCharacter escapeCharacter = EscapeCharacter.of('\\');

	/**
	 * Creates a new {@link JpaRepositoryFactoryBean} for the given repository interface.
	 *
	 * @param repositoryInterface must not be {@literal null}.
	 */
	public JpaRepositoryFactoryBean(Class<? extends T> repositoryInterface) {
		super(repositoryInterface);
	}

	/**
	 * Configures the escape character to be used to escape reserved characters for LIKE expressions.
	 *
	 * @param escapeCharacter
	 */
	public void setEscapeCharacter(char escapeCharacter) {
		this.escapeCharacter = EscapeCharacter.of(escapeCharacter);
	}

	/**
	 * The {@link EntityManager} to be used.
	 *
	 * @param entityManager the entityManager to set
	 */
	@PersistenceContext
	public void setEntityManager(EntityManager entityManager) {
		this.entityManager = entityManager;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport#setMappingContext(org.springframework.data.mapping.context.MappingContext)
	 */
	@Override
	public void setMappingContext(MappingContext<?, ?> mappingContext) {
		super.setMappingContext(mappingContext);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.springframework.data.repository.support.
	 * TransactionalRepositoryFactoryBeanSupport#doCreateRepositoryFactory()
	 */
	@Override
	protected RepositoryFactorySupport doCreateRepositoryFactory() {
		return createRepositoryFactory(entityManager);
	}

	/**
	 * Returns a {@link RepositoryFactorySupport}.
	 *
	 * @param entityManager
	 * @return
	 */
	protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {

		JpaRepositoryFactory jpaRepositoryFactory = new JpaRepositoryFactory(entityManager);
		jpaRepositoryFactory.setEscapeCharacter(escapeCharacter);

		return jpaRepositoryFactory;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() {

		Assert.notNull(entityManager, ""EntityManager must not be null!"");
		super.afterPropertiesSet();
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryBean.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import java.io.Serializable;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.springframework.data.jpa.repository.query.EscapeCharacter;
import org.springframework.data.mapping.context.MappingContext;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.core.support.TransactionalRepositoryFactoryBeanSupport;
import org.springframework.util.Assert;

/**
 * Special adapter for Springs {@link org.springframework.beans.factory.FactoryBean} interface to allow easy setup of
 * repository factories via Spring configuration.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @param <T> the type of the repository
 */
public class JpaRepositoryFactoryBean<T extends Repository<S, ID>, S, ID extends Serializable>
		extends TransactionalRepositoryFactoryBeanSupport<T, S, ID> {

	private EntityManager entityManager;
	private EscapeCharacter escapeCharacter = EscapeCharacter.of('\\');

	/**
	 * Creates a new {@link JpaRepositoryFactoryBean} for the given repository interface.
	 *
	 * @param repositoryInterface must not be {@literal null}.
	 */
	public JpaRepositoryFactoryBean(Class<? extends T> repositoryInterface) {
		super(repositoryInterface);
	}

	/**
	 * Configures the escape character to be used to escape reserved characters for LIKE expressions.
	 *
	 * @param escapeCharacter
	 */
	public void setEscapeCharacter(char escapeCharacter) {
		this.escapeCharacter = EscapeCharacter.of(escapeCharacter);
	}

	/**
	 * The {@link EntityManager} to be used.
	 *
	 * @param entityManager the entityManager to set
	 */
	@PersistenceContext
	public void setEntityManager(EntityManager entityManager) {
		this.entityManager = entityManager;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport#setMappingContext(org.springframework.data.mapping.context.MappingContext)
	 */
	@Override
	public void setMappingContext(MappingContext<?, ?> mappingContext) {
		super.setMappingContext(mappingContext);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.springframework.data.repository.support.
	 * TransactionalRepositoryFactoryBeanSupport#doCreateRepositoryFactory()
	 */
	@Override
	protected RepositoryFactorySupport doCreateRepositoryFactory() {
		return createRepositoryFactory(entityManager);
	}

	/**
	 * Returns a {@link RepositoryFactorySupport}.
	 *
	 * @param entityManager
	 * @return
	 */
	protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {

		JpaRepositoryFactory jpaRepositoryFactory = new JpaRepositoryFactory(entityManager);
		jpaRepositoryFactory.setEscapeCharacter(escapeCharacter);

		return jpaRepositoryFactory;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() {

		Assert.notNull(entityManager, ""EntityManager must not be null!"");
		super.afterPropertiesSet();
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaCountQueryCreatorIntegrationTests.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.AbstractRepositoryMetadata;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link JpaCountQueryCreator}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class JpaCountQueryCreatorIntegrationTests {

	@PersistenceContext EntityManager entityManager;

	@Test // DATAJPA-1044
	public void distinctFlagOnCountQueryIssuesCountDistinct() throws Exception {

		Method method = SomeRepository.class.getMethod(""findDistinctByRolesIn"", List.class);

		PersistenceProvider provider = PersistenceProvider.fromEntityManager(entityManager);
		JpaQueryMethod queryMethod = new JpaQueryMethod(method,
				AbstractRepositoryMetadata.getMetadata(SomeRepository.class), new SpelAwareProxyProjectionFactory(), provider);

		PartTree tree = new PartTree(""findDistinctByRolesIn"", User.class);
		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(entityManager.getCriteriaBuilder(),
				queryMethod.getParameters(), provider, EscapeCharacter.of('\\'));

		JpaCountQueryCreator creator = new JpaCountQueryCreator(tree, queryMethod.getResultProcessor().getReturnedType(),
				entityManager.getCriteriaBuilder(), metadataProvider);

		TypedQuery<? extends Object> query = entityManager.createQuery(creator.createQuery());

		assertThat(HibernateUtils.getHibernateQuery(query), startsWith(""select distinct count(distinct""));
	}

	interface SomeRepository extends Repository<User, Long> {
		void findDistinctByRolesIn(List<Role> roles);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaCountQueryCreatorIntegrationTests.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.AbstractRepositoryMetadata;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link JpaCountQueryCreator}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class JpaCountQueryCreatorIntegrationTests {

	@PersistenceContext EntityManager entityManager;

	@Test // DATAJPA-1044
	public void distinctFlagOnCountQueryIssuesCountDistinct() throws Exception {

		Method method = SomeRepository.class.getMethod(""findDistinctByRolesIn"", List.class);

		PersistenceProvider provider = PersistenceProvider.fromEntityManager(entityManager);
		JpaQueryMethod queryMethod = new JpaQueryMethod(method,
				AbstractRepositoryMetadata.getMetadata(SomeRepository.class), new SpelAwareProxyProjectionFactory(), provider);

		PartTree tree = new PartTree(""findDistinctByRolesIn"", User.class);
		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(entityManager.getCriteriaBuilder(),
				queryMethod.getParameters(), provider, EscapeCharacter.of('\\'));

		JpaCountQueryCreator creator = new JpaCountQueryCreator(tree, queryMethod.getResultProcessor().getReturnedType(),
				entityManager.getCriteriaBuilder(), metadataProvider);

		TypedQuery<? extends Object> query = entityManager.createQuery(creator.createQuery());

		assertThat(HibernateUtils.getHibernateQuery(query), startsWith(""select distinct count(distinct""));
	}

	interface SomeRepository extends Repository<User, Long> {
		void findDistinctByRolesIn(List<Role> roles);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategyUnitTests.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.metamodel.Metamodel;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.DefaultEvaluationContextProvider;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;

/**
 * Unit tests for {@link JpaQueryLookupStrategy}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
@RunWith(MockitoJUnitRunner.class)
public class JpaQueryLookupStrategyUnitTests {

	private static final EvaluationContextProvider EVALUATION_CONTEXT_PROVIDER = DefaultEvaluationContextProvider.INSTANCE;
	@Mock EntityManager em;
	@Mock EntityManagerFactory emf;
	@Mock QueryExtractor extractor;
	@Mock NamedQueries namedQueries;
	@Mock Metamodel metamodel;
	@Mock ProjectionFactory projectionFactory;

	public @Rule ExpectedException exception = ExpectedException.none();

	@Before
	public void setUp() {

		when(em.getMetamodel()).thenReturn(metamodel);
		when(em.getEntityManagerFactory()).thenReturn(emf);
		when(emf.createEntityManager()).thenReturn(em);
		when(em.getDelegate()).thenReturn(em);
	}

	@Test // DATAJPA-226
	public void invalidAnnotatedQueryCausesException() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER, EscapeCharacter.of('\\'));
		Method method = UserRepository.class.getMethod(""findByFoo"", String.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		Throwable reference = new RuntimeException();
		when(em.createQuery(anyString())).thenThrow(reference);

		try {
			strategy.resolveQuery(method, metadata, projectionFactory, namedQueries);
		} catch (Exception e) {
			assertThat(e, is(instanceOf(IllegalArgumentException.class)));
			assertThat(e.getCause(), is(reference));
		}
	}

	@Test // DATAJPA-554
	public void sholdThrowMorePreciseExceptionIfTryingToUsePaginationInNativeQueries() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER, EscapeCharacter.of('\\'));
		Method method = UserRepository.class.getMethod(""findByInvalidNativeQuery"", String.class, Pageable.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		exception.expect(InvalidJpaQueryMethodException.class);
		exception.expectMessage(""Cannot use native queries with dynamic sorting and/or pagination in method"");
		exception.expectMessage(method.toString());

		strategy.resolveQuery(method, metadata, projectionFactory, namedQueries);
	}

	interface UserRepository extends Repository<User, Long> {

		@Query(""something absurd"")
		User findByFoo(String foo);

		@Query(value = ""select u.* from User u"", nativeQuery = true)
		Page<User> findByInvalidNativeQuery(String param, Pageable page);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategyUnitTests.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.metamodel.Metamodel;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.DefaultEvaluationContextProvider;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;

/**
 * Unit tests for {@link JpaQueryLookupStrategy}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
@RunWith(MockitoJUnitRunner.class)
public class JpaQueryLookupStrategyUnitTests {

	private static final EvaluationContextProvider EVALUATION_CONTEXT_PROVIDER = DefaultEvaluationContextProvider.INSTANCE;
	@Mock EntityManager em;
	@Mock EntityManagerFactory emf;
	@Mock QueryExtractor extractor;
	@Mock NamedQueries namedQueries;
	@Mock Metamodel metamodel;
	@Mock ProjectionFactory projectionFactory;

	public @Rule ExpectedException exception = ExpectedException.none();

	@Before
	public void setUp() {

		when(em.getMetamodel()).thenReturn(metamodel);
		when(em.getEntityManagerFactory()).thenReturn(emf);
		when(emf.createEntityManager()).thenReturn(em);
		when(em.getDelegate()).thenReturn(em);
	}

	@Test // DATAJPA-226
	public void invalidAnnotatedQueryCausesException() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER, EscapeCharacter.of('\\'));
		Method method = UserRepository.class.getMethod(""findByFoo"", String.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		Throwable reference = new RuntimeException();
		when(em.createQuery(anyString())).thenThrow(reference);

		try {
			strategy.resolveQuery(method, metadata, projectionFactory, namedQueries);
		} catch (Exception e) {
			assertThat(e, is(instanceOf(IllegalArgumentException.class)));
			assertThat(e.getCause(), is(reference));
		}
	}

	@Test // DATAJPA-554
	public void sholdThrowMorePreciseExceptionIfTryingToUsePaginationInNativeQueries() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER, EscapeCharacter.of('\\'));
		Method method = UserRepository.class.getMethod(""findByInvalidNativeQuery"", String.class, Pageable.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		exception.expect(InvalidJpaQueryMethodException.class);
		exception.expectMessage(""Cannot use native queries with dynamic sorting and/or pagination in method"");
		exception.expectMessage(method.toString());

		strategy.resolveQuery(method, metadata, projectionFactory, namedQueries);
	}

	interface UserRepository extends Repository<User, Long> {

		@Query(""something absurd"")
		User findByFoo(String foo);

		@Query(value = ""select u.* from User u"", nativeQuery = true)
		Page<User> findByInvalidNativeQuery(String param, Pageable page);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterExpressionProviderTests.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.DefaultParameters;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterExpressionProviderTests {

	@PersistenceContext EntityManager em;

	@Test // DATADOC-99
	@SuppressWarnings(""rawtypes"")
	public void createsParameterExpressionWithMostConcreteType() throws Exception {

		Method method = SampleRepository.class.getMethod(""findByIdGreaterThan"", int.class);
		Parameters<?, ?> parameters = new DefaultParameters(method);
		ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, new Object[] { 1 });
		Part part = new Part(""IdGreaterThan"", User.class);

		CriteriaBuilder builder = em.getCriteriaBuilder();
		PersistenceProvider persistenceProvider = PersistenceProvider.fromEntityManager(em);
		ParameterMetadataProvider provider = new ParameterMetadataProvider(builder, accessor, persistenceProvider, EscapeCharacter.of('\\'));
		ParameterExpression<? extends Comparable> expression = provider.next(part, Comparable.class).getExpression();
		assertThat(expression.getParameterType(), is(typeCompatibleWith(int.class)));
	}

	interface SampleRepository {

		User findByIdGreaterThan(int id);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterExpressionProviderTests.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.repository.query.DefaultParameters;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterExpressionProviderTests {

	@PersistenceContext EntityManager em;

	@Test // DATADOC-99
	@SuppressWarnings(""rawtypes"")
	public void createsParameterExpressionWithMostConcreteType() throws Exception {

		Method method = SampleRepository.class.getMethod(""findByIdGreaterThan"", int.class);
		Parameters<?, ?> parameters = new DefaultParameters(method);
		ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, new Object[] { 1 });
		Part part = new Part(""IdGreaterThan"", User.class);

		CriteriaBuilder builder = em.getCriteriaBuilder();
		PersistenceProvider persistenceProvider = PersistenceProvider.fromEntityManager(em);
		ParameterMetadataProvider provider = new ParameterMetadataProvider(builder, accessor, persistenceProvider, EscapeCharacter.of('\\'));
		ParameterExpression<? extends Comparable> expression = provider.next(part, Comparable.class).getExpression();
		assertThat(expression.getParameterType(), is(typeCompatibleWith(int.class)));
	}

	interface SampleRepository {

		User findByIdGreaterThan(int id);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderIntegrationTests.java,"/*
 * Copyright 2015-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.Param;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.util.ReflectionTestUtils;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 * @soundtrack Elephants Crossing - We are (Irrelephant)
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterMetadataProviderIntegrationTests {

	@PersistenceContext EntityManager em;

	@Test // DATAJPA-758
	public void forwardsParameterNameIfTransparentlyNamed() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByFirstname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""firstname"", User.class));

		assertThat(metadata.getExpression().getName(), is(""name""));
	}

	@Test // DATAJPA-758
	public void forwardsParameterNameIfExplicitlyAnnotated() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByLastname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""lastname"", User.class));

		assertThat(metadata.getExpression().getName(), is(nullValue()));
	}

	@Test // DATAJPA-772
	public void doesNotApplyLikeExpansionOnNonStringProperties() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByAgeContaining"", Integer.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""ageContaining"", User.class));

		assertThat(metadata.prepare(1), is((Object) 1));
	}

	private ParameterMetadataProvider createProvider(Method method) {

		JpaParameters parameters = new JpaParameters(method);
		simulateDiscoveredParametername(parameters, 0, ""name"");

		return new ParameterMetadataProvider(em.getCriteriaBuilder(), parameters,
				PersistenceProvider.fromEntityManager(em), EscapeCharacter.of('\\'));
	}

	@SuppressWarnings(""unchecked"")
	private static void simulateDiscoveredParametername(Parameters<?, ?> parameters, int index, String name) {

		List<Object> list = (List<Object>) ReflectionTestUtils.getField(parameters, ""parameters"");
		Object parameter = ReflectionTestUtils.getField(list.get(0), ""parameter"");
		ReflectionTestUtils.setField(parameter, ""parameterName"", name);
	}

	interface Sample {

		User findByFirstname(@Param(""name"") String firstname);

		User findByLastname(String lastname);

		User findByAgeContaining(@Param(""age"") Integer age);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderIntegrationTests.java,"/*
 * Copyright 2015-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.repository.query.Param;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.util.ReflectionTestUtils;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 * @soundtrack Elephants Crossing - We are (Irrelephant)
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterMetadataProviderIntegrationTests {

	@PersistenceContext EntityManager em;

	@Test // DATAJPA-758
	public void forwardsParameterNameIfTransparentlyNamed() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByFirstname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""firstname"", User.class));

		assertThat(metadata.getExpression().getName(), is(""name""));
	}

	@Test // DATAJPA-758
	public void forwardsParameterNameIfExplicitlyAnnotated() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByLastname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""lastname"", User.class));

		assertThat(metadata.getExpression().getName(), is(nullValue()));
	}

	@Test // DATAJPA-772
	public void doesNotApplyLikeExpansionOnNonStringProperties() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByAgeContaining"", Integer.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""ageContaining"", User.class));

		assertThat(metadata.prepare(1), is((Object) 1));
	}

	private ParameterMetadataProvider createProvider(Method method) {

		JpaParameters parameters = new JpaParameters(method);
		simulateDiscoveredParametername(parameters, 0, ""name"");

		return new ParameterMetadataProvider(em.getCriteriaBuilder(), parameters,
				PersistenceProvider.fromEntityManager(em), EscapeCharacter.of('\\'));
	}

	@SuppressWarnings(""unchecked"")
	private static void simulateDiscoveredParametername(Parameters<?, ?> parameters, int index, String name) {

		List<Object> list = (List<Object>) ReflectionTestUtils.getField(parameters, ""parameters"");
		Object parameter = ReflectionTestUtils.getField(list.get(0), ""parameter"");
		ReflectionTestUtils.setField(parameter, ""parameterName"", name);
	}

	interface Sample {

		User findByFirstname(@Param(""name"") String firstname);

		User findByLastname(String lastname);

		User findByAgeContaining(@Param(""age"") Integer age);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderUnitTests.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.mockito.Mockito.*;

import javax.persistence.criteria.CriteriaBuilder;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;

/**
 * Unit tests for {@link ParameterMetadataProvider}.
 *
 * @author Jens Schauder
 * @author Oliver Gierke
 */
public class ParameterMetadataProviderUnitTests {

	public @Rule ExpectedException exception = ExpectedException.none();

	@Test // DATAJPA-863
	public void errorMessageMentionesParametersWhenParametersAreExhausted() {

		PersistenceProvider persistenceProvider = mock(PersistenceProvider.class);
		CriteriaBuilder builder = mock(CriteriaBuilder.class);

		Parameters<?, ?> parameters = mock(Parameters.class, RETURNS_DEEP_STUBS);
		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(builder, parameters,
				persistenceProvider, EscapeCharacter.of('\\'));

		exception.expect(IllegalArgumentException.class);
		exception.expectMessage(""parameter"");

		metadataProvider.next(mock(Part.class));
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderUnitTests.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.mockito.Mockito.*;

import javax.persistence.criteria.CriteriaBuilder;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;

/**
 * Unit tests for {@link ParameterMetadataProvider}.
 *
 * @author Jens Schauder
 * @author Oliver Gierke
 */
public class ParameterMetadataProviderUnitTests {

	public @Rule ExpectedException exception = ExpectedException.none();

	@Test // DATAJPA-863
	public void errorMessageMentionesParametersWhenParametersAreExhausted() {

		PersistenceProvider persistenceProvider = mock(PersistenceProvider.class);
		CriteriaBuilder builder = mock(CriteriaBuilder.class);

		Parameters<?, ?> parameters = mock(Parameters.class, RETURNS_DEEP_STUBS);
		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(builder, parameters,
				persistenceProvider, EscapeCharacter.of('\\'));

		exception.expect(IllegalArgumentException.class);
		exception.expectMessage(""parameter"");

		metadataProvider.next(mock(Part.class));
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/PartTreeJpaQueryIntegrationTests.java,"/*
 * Copyright 2011-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License
import org.springframework.aop.framework.Advised;
"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;
import static org.springframework.test.util.ReflectionTestUtils.*;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.TemporalType;

import org.hibernate.Version;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.Temporal;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.Param;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link PartTreeJpaQuery}.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class PartTreeJpaQueryIntegrationTests {

	private static String PROPERTY = ""h.target."" + getQueryProperty();

	@Rule public ExpectedException thrown = ExpectedException.none();

	@PersistenceContext EntityManager entityManager;

	PersistenceProvider provider;

	@Before
	public void setUp() {
		this.provider = PersistenceProvider.fromEntityManager(entityManager);
	}

	@Test // DATADOC-90
	public void test() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		jpaQuery.createQuery(new Object[] { ""Matthews"", new PageRequest(0, 1) });
		jpaQuery.createQuery(new Object[] { ""Matthews"", new PageRequest(0, 1) });
	}

	@Test
	public void cannotIgnoreCaseIfNotString() throws Exception {

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""Unable to ignore case of java.lang.Integer types, the property 'id' must reference a String"");
		testIgnoreCase(""findByIdIgnoringCase"", 3);
	}

	@Test
	public void cannotIgnoreCaseIfNotStringUnlessIgnoringAll() throws Exception {

		testIgnoreCase(""findByIdAllIgnoringCase"", 3);
	}

	@Test // DATAJPA-121
	public void recreatesQueryIfNullValueIsGiven() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"", new PageRequest(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY)), endsWith(""firstname=:param0""));

		query = jpaQuery.createQuery(new Object[] { null, new PageRequest(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY)), endsWith(""firstname is null""));
	}

	@Test // DATAJPA-920
	public void shouldLimitExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(query.getMaxResults(), is(1));
	}

	@Test // DATAJPA-920
	public void shouldSelectAliasedIdForExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY)), containsString("".id from User as""));
	}

	@Test // DATAJPA-863
	public void errorsDueToMismatchOfParametersContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByFirstname"");

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""UserRepository""); // the repository
		thrown.expectMessage(""findByFirstname""); // the method being analyzed
		thrown.expectMessage("" firstname ""); // the property we are looking for

		new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'));
	}

	@Test // DATAJPA-863
	public void errorsDueToMissingPropertyContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByNoSuchProperty"", String.class);

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""UserRepository""); // the repository
		thrown.expectMessage(""findByNoSuchProperty""); // the method being analyzed
		thrown.expectMessage("" noSuchProperty ""); // the property we are looking for

		new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'));
	}

	private void testIgnoreCase(String methodName, Object... values) throws Exception {

		Class<?>[] parameterTypes = new Class[values.length];

		for (int i = 0; i < values.length; i++) {
			parameterTypes[i] = values[i].getClass();
		}

		JpaQueryMethod queryMethod = getQueryMethod(methodName, parameterTypes);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager,
				PersistenceProvider.fromEntityManager(entityManager), EscapeCharacter.of('\\'));
		jpaQuery.createQuery(values);
	}

	private JpaQueryMethod getQueryMethod(String methodName, Class<?>... parameterTypes) throws Exception {
		Method method = UserRepository.class.getMethod(methodName, parameterTypes);
		return new JpaQueryMethod(method, new DefaultRepositoryMetadata(UserRepository.class),
				new SpelAwareProxyProjectionFactory(), PersistenceProvider.fromEntityManager(entityManager));
	}

	@SuppressWarnings(""unchecked"")
	private static <T> T getValue(Object source, String path) {

		Iterator<String> split = Arrays.asList(path.split(""\\."")).iterator();
		Object result = source;

		while (split.hasNext()) {
			result = getField(result, split.next());
		}

		return (T) result;
	}

	private static String getQueryProperty() {
		return isHibernate43() || isHibernate5() ? ""jpqlQuery"" : ""val$jpaqlQuery"";
	}

	private static boolean isHibernate43() {
		return Version.getVersionString().startsWith(""4.3"");
	}

	private static boolean isHibernate5() {
		return Version.getVersionString().startsWith(""5."");
	}

	interface UserRepository extends Repository<User, Long> {

		Page<User> findByFirstname(String firstname, Pageable pageable);

		User findByIdIgnoringCase(Integer id);

		User findByIdAllIgnoringCase(Integer id);

		boolean existsByFirstname(String firstname);

		List<User> findByCreatedAtAfter(@Temporal(TemporalType.TIMESTAMP) @Param(""refDate"") Date refDate);

		// Wrong number of parameters
		User findByFirstname();

		// Wrong property name
		User findByNoSuchProperty(String x);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/PartTreeJpaQueryIntegrationTests.java,"/*
 * Copyright 2011-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License
import org.springframework.aop.framework.Advised;
"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;
import static org.springframework.test.util.ReflectionTestUtils.*;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.TemporalType;

import org.hibernate.Version;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.Temporal;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.Param;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link PartTreeJpaQuery}.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class PartTreeJpaQueryIntegrationTests {

	private static String PROPERTY = ""h.target."" + getQueryProperty();

	@Rule public ExpectedException thrown = ExpectedException.none();

	@PersistenceContext EntityManager entityManager;

	PersistenceProvider provider;

	@Before
	public void setUp() {
		this.provider = PersistenceProvider.fromEntityManager(entityManager);
	}

	@Test // DATADOC-90
	public void test() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		jpaQuery.createQuery(new Object[] { ""Matthews"", new PageRequest(0, 1) });
		jpaQuery.createQuery(new Object[] { ""Matthews"", new PageRequest(0, 1) });
	}

	@Test
	public void cannotIgnoreCaseIfNotString() throws Exception {

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""Unable to ignore case of java.lang.Integer types, the property 'id' must reference a String"");
		testIgnoreCase(""findByIdIgnoringCase"", 3);
	}

	@Test
	public void cannotIgnoreCaseIfNotStringUnlessIgnoringAll() throws Exception {

		testIgnoreCase(""findByIdAllIgnoringCase"", 3);
	}

	@Test // DATAJPA-121
	public void recreatesQueryIfNullValueIsGiven() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"", new PageRequest(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY)), endsWith(""firstname=:param0""));

		query = jpaQuery.createQuery(new Object[] { null, new PageRequest(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY)), endsWith(""firstname is null""));
	}

	@Test // DATAJPA-920
	public void shouldLimitExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(query.getMaxResults(), is(1));
	}

	@Test // DATAJPA-920
	public void shouldSelectAliasedIdForExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY)), containsString("".id from User as""));
	}

	@Test // DATAJPA-863
	public void errorsDueToMismatchOfParametersContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByFirstname"");

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""UserRepository""); // the repository
		thrown.expectMessage(""findByFirstname""); // the method being analyzed
		thrown.expectMessage("" firstname ""); // the property we are looking for

		new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'));
	}

	@Test // DATAJPA-863
	public void errorsDueToMissingPropertyContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByNoSuchProperty"", String.class);

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""UserRepository""); // the repository
		thrown.expectMessage(""findByNoSuchProperty""); // the method being analyzed
		thrown.expectMessage("" noSuchProperty ""); // the property we are looking for

		new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'));
	}

	private void testIgnoreCase(String methodName, Object... values) throws Exception {

		Class<?>[] parameterTypes = new Class[values.length];

		for (int i = 0; i < values.length; i++) {
			parameterTypes[i] = values[i].getClass();
		}

		JpaQueryMethod queryMethod = getQueryMethod(methodName, parameterTypes);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager,
				PersistenceProvider.fromEntityManager(entityManager), EscapeCharacter.of('\\'));
		jpaQuery.createQuery(values);
	}

	private JpaQueryMethod getQueryMethod(String methodName, Class<?>... parameterTypes) throws Exception {
		Method method = UserRepository.class.getMethod(methodName, parameterTypes);
		return new JpaQueryMethod(method, new DefaultRepositoryMetadata(UserRepository.class),
				new SpelAwareProxyProjectionFactory(), PersistenceProvider.fromEntityManager(entityManager));
	}

	@SuppressWarnings(""unchecked"")
	private static <T> T getValue(Object source, String path) {

		Iterator<String> split = Arrays.asList(path.split(""\\."")).iterator();
		Object result = source;

		while (split.hasNext()) {
			result = getField(result, split.next());
		}

		return (T) result;
	}

	private static String getQueryProperty() {
		return isHibernate43() || isHibernate5() ? ""jpqlQuery"" : ""val$jpaqlQuery"";
	}

	private static boolean isHibernate43() {
		return Version.getVersionString().startsWith(""4.3"");
	}

	private static boolean isHibernate5() {
		return Version.getVersionString().startsWith(""5."");
	}

	interface UserRepository extends Repository<User, Long> {

		Page<User> findByFirstname(String firstname, Pageable pageable);

		User findByIdIgnoringCase(Integer id);

		User findByIdAllIgnoringCase(Integer id);

		boolean existsByFirstname(String firstname);

		List<User> findByCreatedAtAfter(@Temporal(TemporalType.TIMESTAMP) @Param(""refDate"") Date refDate);

		// Wrong number of parameters
		User findByFirstname();

		// Wrong property name
		User findByNoSuchProperty(String x);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.sample;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;

import javax.persistence.EntityManager;
import javax.persistence.QueryHint;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.SpecialUser;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.QueryHints;
import org.springframework.data.jpa.repository.query.Procedure;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import com.google.common.base.Optional;

/**
 * Repository interface for {@code User}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public interface UserRepository
		extends JpaRepository<User, Integer>, JpaSpecificationExecutor<User>, UserRepositoryCustom {

	/**
	 * Retrieve users by their lastname. The finder {@literal User.findByLastname} is declared in
	 * {@literal META-INF/orm.xml} .
	 * 
	 * @param lastname
	 * @return all users with the given lastname
	 */
	@QueryHints({ @QueryHint(name = ""foo"", value = ""bar"") })
	List<User> findByLastname(String lastname);

	/**
	 * Redeclaration of {@link CrudRepository#findOne(java.io.Serializable)} to change transaction configuration.
	 */
	@Transactional
	User findOne(Integer primaryKey);

	/**
	 * Redeclaration of {@link CrudRepository#delete(java.io.Serializable)}. to make sure the transaction configuration of
	 * the original method is considered if the redeclaration does not carry a {@link Transactional} annotation.
	 */
	void delete(Integer id); // DATACMNS-649

	/**
	 * Retrieve users by their email address. The finder {@literal User.findByEmailAddress} is declared as annotation at
	 * {@code User}.
	 * 
	 * @param emailAddress
	 * @return the user with the given email address
	 */
	User findByEmailAddress(String emailAddress);

	@Query(""select u from User u left outer join u.manager as manager"")
	Page<User> findAllPaged(Pageable pageable);

	/**
	 * Retrieves users by the given email and lastname. Acts as a dummy method declaration to test finder query creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @return the user with the given email address and lastname
	 */
	User findByEmailAddressAndLastname(String emailAddress, String lastname);

	/**
	 * Retrieves users by email address and lastname or firstname. Acts as a dummy method declaration to test finder query
	 * creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @param username
	 * @return the users with the given email address and lastname or the given firstname
	 */
	List<User> findByEmailAddressAndLastnameOrFirstname(String emailAddress, String lastname, String username);

	/**
	 * Retrieves a user by its username using the query annotated to the method.
	 * 
	 * @param emailAddress
	 * @return
	 */
	@Query(""select u from User u where u.emailAddress = ?1"")
	@Transactional(readOnly = true)
	User findByAnnotatedQuery(String emailAddress);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * 
	 * @param pageable
	 * @param lastname
	 * @return
	 */
	Page<User> findByLastname(Pageable pageable, String lastname);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * Just returns the queried {@link Page}'s contents.
	 * 
	 * @param firstname
	 * @param pageable
	 * @return
	 */
	List<User> findByFirstname(String firstname, Pageable pageable);

	Page<User> findByFirstnameIn(Pageable pageable, String... firstnames);

	List<User> findByFirstnameNotIn(Collection<String> firstnames);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like ?1%"")
	List<User> findByFirstnameLike(String firstname);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like :firstname%"")
	List<User> findByFirstnameLikeNamed(@Param(""firstname"") String firstname);

	/**
	 * Manipulating query to set all {@link User}'s names to the given one.
	 * 
	 * @param lastname
	 */
	@Modifying
	@Query(""update User u set u.lastname = ?1"")
	void renameAllUsersTo(String lastname);

	@Query(""select count(u) from User u where u.firstname = ?1"")
	Long countWithFirstname(String firstname);

	/**
	 * Method where parameters will be applied by name. Note that the order of the parameters is then not crucial anymore.
	 * 
	 * @param foo
	 * @param bar
	 * @return
	 */
	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstname(@Param(""firstname"") String foo, @Param(""lastname"") String bar);

	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstnameUnannotated(String firstname, String lastname);

	/**
	 * Method to check query creation and named parameter usage go well hand in hand.
	 * 
	 * @param lastname
	 * @param firstname
	 * @return
	 */
	List<User> findByFirstnameOrLastname(@Param(""lastname"") String lastname, @Param(""firstname"") String firstname);

	List<User> findByLastnameLikeOrderByFirstnameDesc(String lastname);

	List<User> findByLastnameNotLike(String lastname);

	List<User> findByLastnameNot(String lastname);

	List<User> findByManagerLastname(String name);

	List<User> findByColleaguesLastname(String lastname);

	List<User> findByLastnameNotNull();

	List<User> findByLastnameNull();

	List<User> findByEmailAddressLike(String email, Sort sort);

	List<SpecialUser> findSpecialUsersByLastname(String lastname);

	List<User> findBySpringDataNamedQuery(String lastname);

	List<User> findByLastnameIgnoringCase(String lastname);

	Page<User> findByLastnameIgnoringCase(Pageable pageable, String lastname);

	List<User> findByLastnameIgnoringCaseLike(String lastname);

	List<User> findByLastnameAndFirstnameAllIgnoringCase(String lastname, String firstname);

	List<User> findByAgeGreaterThanEqual(int age);

	List<User> findByAgeLessThanEqual(int age);

	@Query(""select u.lastname from User u group by u.lastname"")
	Page<String> findByLastnameGrouped(Pageable pageable);

	// DATAJPA-117
	@Query(value = ""SELECT * FROM SD_User WHERE lastname = ?1"", nativeQuery = true)
	List<User> findNativeByLastname(String lastname);

	// DATAJPA-132
	List<User> findByActiveTrue();

	// DATAJPA-132
	List<User> findByActiveFalse();

	/**
	 * Commented out until OpenJPA supports this.
	 */
	// @Query(""select u.colleagues from User u where u = ?1"")
	// List<User> findColleaguesFor(User user);

	// DATAJPA-188
	List<User> findByCreatedAtBefore(Date date);

	// DATAJPA-188
	List<User> findByCreatedAtAfter(Date date);

	// DATAJPA-180
	List<User> findByFirstnameStartingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameEndingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameContaining(String firstname);

	@Query(value = ""SELECT 1 FROM SD_User"", nativeQuery = true)
	List<Integer> findOnesByNativeQuery();

	// DATAJPA-231
	long countByLastname(String lastname);

	// DATAJPA-231
	int countUsersByFirstname(String firstname);

	// DATAJPA-920
	boolean existsByLastname(String lastname);

	// DATAJPA-391
	@Query(""select u.firstname from User u where u.lastname = ?1"")
	List<String> findFirstnamesByLastname(String lastname);

	// DATAJPA-415
	Collection<User> findByIdIn(@Param(""ids"") Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in ?1"")
	Collection<User> findByIdsCustomWithPositionalVarArgs(Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in :ids"")
	Collection<User> findByIdsCustomWithNamedVarArgs(@Param(""ids"") Integer... ids);

	// DATAJPA-415
	@Modifying
	@Query(""update #{#entityName} u set u.active = :activeState where u.id in :ids"")
	void updateUserActiveState(@Param(""activeState"") boolean activeState, @Param(""ids"") Integer... ids);

	// DATAJPA-405
	List<User> findAllByOrderByLastnameAsc();

	// DATAJPA-454
	List<User> findByBinaryData(byte[] data);

	// DATAJPA-486
	Slice<User> findSliceByLastname(String lastname, Pageable pageable);

	// DATAJPA-496
	List<User> findByAttributesIn(Set<String> attributes);

	// DATAJPA-460
	Long removeByLastname(String lastname);

	// DATAJPA-460
	List<User> deleteByLastname(String lastname);

	/**
	 * @see <a href=""https://issues.apache.org/jira/browse/OPENJPA-2484"">OPENJPA-2484</a>
	 */
	// DATAJPA-505
	// @Query(value = ""select u.binaryData from User u where u.id = :id"")
	// byte[] findBinaryDataByIdJpaQl(@Param(""id"") Integer id);

	/**
	 * Explicitly mapped to a procedure with name ""plus1inout"" in database.
	 */
	@Procedure(""plus1inout"") // DATAJPA-455
	Integer explicitlyNamedPlus1inout(Integer arg);

	/**
	 * Implicitly mapped to a procedure with name ""plus1inout"" in database via alias.
	 */
	@Procedure(procedureName = ""plus1inout"") // DATAJPA-455
	Integer plus1inout(Integer arg);

	/**
	 * Explicitly mapped to named stored procedure ""User.plus1IO"" in {@link EntityManager}.
	 */
	@Procedure(name = ""User.plus1IO"") // DATAJPA-455
	Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param(""arg"") Integer arg);

	/**
	 * Implicitly mapped to named stored procedure ""User.plus1"" in {@link EntityManager}.
	 */
	@Procedure // DATAJPA-455
	Integer plus1(@Param(""arg"") Integer arg);

	// DATAJPA-456
	@Query(value = ""select u from User u where u.firstname like ?1%"", countProjection = ""u.firstname"")
	Page<User> findAllByFirstnameLike(String firstname, Pageable page);

	// DATAJPA-456
	@Query(name = ""User.findBySpringDataNamedQuery"", countProjection = ""u.firstname"")
	Page<User> findByNamedQueryAndCountProjection(String firstname, Pageable page);

	// DATAJPA-551
	User findFirstByOrderByAgeDesc();

	// DATAJPA-551
	User findFirst1ByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeAsc();

	// DATAJPA-551
	User findTop1ByOrderByAgeAsc();

	// DATAJPA-551
	List<User> findTop2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2UsersBy(Sort sort);

	// DATAJPA-551
	List<User> findTop2UsersBy(Sort sort);

	// DATAJPA-551
	Page<User> findFirst3UsersBy(Pageable page);

	// DATAJPA-551
	Page<User> findFirst2UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop3UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop2UsersBy(Pageable page);

	// DATAJPA-506
	@Query(value = ""select u.binaryData from SD_User u where u.id = ?1"", nativeQuery = true)
	byte[] findBinaryDataByIdNative(Integer id);

	// DATAJPA-506
	@Query(""select u from User u where u.emailAddress = ?1"")
	Optional<User> findOptionalByEmailAddress(String emailAddress);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]} and u.firstname = ?1 and u.lastname like %?#{[1]}% and u.lastname like %?2%"")
	List<User> findByFirstnameAndLastnameWithSpelExpression(String firstname, String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%"")
	List<User> findByLastnameWithSpelExpression(@Param(""lastname"") String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithQuestionmark();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithColon();

	// DATAJPA-564
	@Query(""select u from User u where u.age = ?#{[0]}"")
	List<User> findUsersByAgeForSpELExpressionByIndexedParameter(int age);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :firstname and u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpression(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findCurrentUserWithCustomQuery();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findByFirstnameAndCurrentUserWithCustomQuery(String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterVariableOnly(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnly(String firstname);

	// DATAJPA-564
	@Query(
			value = ""select * from (select rownum() as RN, u.* from SD_User u) where RN between ?#{ #pageable.offset -1} and ?#{#pageable.offset + #pageable.pageSize}"",
			countQuery = ""select count(u.id) from SD_User u"", nativeQuery = true)
	Page<User> findUsersInNativeQueryWithPagination(Pageable pageable);

	// DATAJPA-629
	@Query(""select u from #{#entityName} u where u.firstname = ?#{[0]} and u.lastname = ?#{[1]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnlyWithEntityExpression(String firstname,
			String lastname);

	// DATAJPA-606
	List<User> findByAgeIn(Collection<Integer> ages);

	// DATAJPA-606
	List<User> queryByAgeIn(Integer[] ages);

	// DATAJPA-606
	List<User> queryByAgeInOrFirstname(Integer[] ages, String firstname);

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> findAllByCustomQueryAndStream();

	// DATAJPA-677
	Stream<User> readAllByFirstnameNotNull();

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> streamAllPaged(Pageable pageable);

	// DATAJPA-830
	List<User> findByLastnameNotContaining(String part);

	// DATAJPA-829
	List<User> findByRolesContaining(Role role);

	// DATAJPA-829
	List<User> findByRolesNotContaining(Role role);

	// DATAJPA-858
	List<User> findByRolesNameContaining(String name);

	// DATAJPA-1179
	@Query(""select u from User u where u.firstname = :#{#firstname} and u.firstname = :#{#firstname}"")
	List<User> findUsersByDuplicateSpel(@Param(""firstname"") String firstname);

	List<RolesAndFirstname> findRolesAndFirstnameBy();

	@Query(value = ""SELECT firstname, lastname from SD_User WHERE id = ?1"", nativeQuery = true)
	NameOnly findByNativeQuery(Integer id);

	// DATAJPA-1185
	<T> Stream<T> findAsStreamByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1185
	<T> List<T> findAsListByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1248
	@Query(value = ""SELECT emailaddress FROM SD_User WHERE id = ?1"", nativeQuery = true)
	EmailOnly findEmailOnlyByNativeQuery(Integer id);


	// DATAJPA-1273
	List<NameOnly> findByNamedQueryWithAliasInInvertedOrder();

	// DATAJPA-1301
	@Query(""select firstname as firstname, lastname as lastname from User u where u.firstname = 'Oliver'"")
	Map<String, Object> findMapWithNullValues();

	// DATAJPA-1334
	List<NameOnlyDto> findByNamedQueryWithConstructorExpression();

	// DATAJPA-1519
	@Query(""select u from User u where u.firstname like %?#{#escape([0],'#')}% escape '#'"")
	List<User> findContainingEscaped(String namePart);

	interface RolesAndFirstname {

		String getFirstname();

		Set<Role> getRoles();
	}

	interface NameOnly {

		String getFirstname();

		String getLastname();
	}

	interface EmailOnly {
		String getEmailAddress();
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.sample;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;

import javax.persistence.EntityManager;
import javax.persistence.QueryHint;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.SpecialUser;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.QueryHints;
import org.springframework.data.jpa.repository.query.Procedure;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import com.google.common.base.Optional;

/**
 * Repository interface for {@code User}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public interface UserRepository
		extends JpaRepository<User, Integer>, JpaSpecificationExecutor<User>, UserRepositoryCustom {

	/**
	 * Retrieve users by their lastname. The finder {@literal User.findByLastname} is declared in
	 * {@literal META-INF/orm.xml} .
	 * 
	 * @param lastname
	 * @return all users with the given lastname
	 */
	@QueryHints({ @QueryHint(name = ""foo"", value = ""bar"") })
	List<User> findByLastname(String lastname);

	/**
	 * Redeclaration of {@link CrudRepository#findOne(java.io.Serializable)} to change transaction configuration.
	 */
	@Transactional
	User findOne(Integer primaryKey);

	/**
	 * Redeclaration of {@link CrudRepository#delete(java.io.Serializable)}. to make sure the transaction configuration of
	 * the original method is considered if the redeclaration does not carry a {@link Transactional} annotation.
	 */
	void delete(Integer id); // DATACMNS-649

	/**
	 * Retrieve users by their email address. The finder {@literal User.findByEmailAddress} is declared as annotation at
	 * {@code User}.
	 * 
	 * @param emailAddress
	 * @return the user with the given email address
	 */
	User findByEmailAddress(String emailAddress);

	@Query(""select u from User u left outer join u.manager as manager"")
	Page<User> findAllPaged(Pageable pageable);

	/**
	 * Retrieves users by the given email and lastname. Acts as a dummy method declaration to test finder query creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @return the user with the given email address and lastname
	 */
	User findByEmailAddressAndLastname(String emailAddress, String lastname);

	/**
	 * Retrieves users by email address and lastname or firstname. Acts as a dummy method declaration to test finder query
	 * creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @param username
	 * @return the users with the given email address and lastname or the given firstname
	 */
	List<User> findByEmailAddressAndLastnameOrFirstname(String emailAddress, String lastname, String username);

	/**
	 * Retrieves a user by its username using the query annotated to the method.
	 * 
	 * @param emailAddress
	 * @return
	 */
	@Query(""select u from User u where u.emailAddress = ?1"")
	@Transactional(readOnly = true)
	User findByAnnotatedQuery(String emailAddress);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * 
	 * @param pageable
	 * @param lastname
	 * @return
	 */
	Page<User> findByLastname(Pageable pageable, String lastname);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * Just returns the queried {@link Page}'s contents.
	 * 
	 * @param firstname
	 * @param pageable
	 * @return
	 */
	List<User> findByFirstname(String firstname, Pageable pageable);

	Page<User> findByFirstnameIn(Pageable pageable, String... firstnames);

	List<User> findByFirstnameNotIn(Collection<String> firstnames);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like ?1%"")
	List<User> findByFirstnameLike(String firstname);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like :firstname%"")
	List<User> findByFirstnameLikeNamed(@Param(""firstname"") String firstname);

	/**
	 * Manipulating query to set all {@link User}'s names to the given one.
	 * 
	 * @param lastname
	 */
	@Modifying
	@Query(""update User u set u.lastname = ?1"")
	void renameAllUsersTo(String lastname);

	@Query(""select count(u) from User u where u.firstname = ?1"")
	Long countWithFirstname(String firstname);

	/**
	 * Method where parameters will be applied by name. Note that the order of the parameters is then not crucial anymore.
	 * 
	 * @param foo
	 * @param bar
	 * @return
	 */
	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstname(@Param(""firstname"") String foo, @Param(""lastname"") String bar);

	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstnameUnannotated(String firstname, String lastname);

	/**
	 * Method to check query creation and named parameter usage go well hand in hand.
	 * 
	 * @param lastname
	 * @param firstname
	 * @return
	 */
	List<User> findByFirstnameOrLastname(@Param(""lastname"") String lastname, @Param(""firstname"") String firstname);

	List<User> findByLastnameLikeOrderByFirstnameDesc(String lastname);

	List<User> findByLastnameNotLike(String lastname);

	List<User> findByLastnameNot(String lastname);

	List<User> findByManagerLastname(String name);

	List<User> findByColleaguesLastname(String lastname);

	List<User> findByLastnameNotNull();

	List<User> findByLastnameNull();

	List<User> findByEmailAddressLike(String email, Sort sort);

	List<SpecialUser> findSpecialUsersByLastname(String lastname);

	List<User> findBySpringDataNamedQuery(String lastname);

	List<User> findByLastnameIgnoringCase(String lastname);

	Page<User> findByLastnameIgnoringCase(Pageable pageable, String lastname);

	List<User> findByLastnameIgnoringCaseLike(String lastname);

	List<User> findByLastnameAndFirstnameAllIgnoringCase(String lastname, String firstname);

	List<User> findByAgeGreaterThanEqual(int age);

	List<User> findByAgeLessThanEqual(int age);

	@Query(""select u.lastname from User u group by u.lastname"")
	Page<String> findByLastnameGrouped(Pageable pageable);

	// DATAJPA-117
	@Query(value = ""SELECT * FROM SD_User WHERE lastname = ?1"", nativeQuery = true)
	List<User> findNativeByLastname(String lastname);

	// DATAJPA-132
	List<User> findByActiveTrue();

	// DATAJPA-132
	List<User> findByActiveFalse();

	/**
	 * Commented out until OpenJPA supports this.
	 */
	// @Query(""select u.colleagues from User u where u = ?1"")
	// List<User> findColleaguesFor(User user);

	// DATAJPA-188
	List<User> findByCreatedAtBefore(Date date);

	// DATAJPA-188
	List<User> findByCreatedAtAfter(Date date);

	// DATAJPA-180
	List<User> findByFirstnameStartingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameEndingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameContaining(String firstname);

	@Query(value = ""SELECT 1 FROM SD_User"", nativeQuery = true)
	List<Integer> findOnesByNativeQuery();

	// DATAJPA-231
	long countByLastname(String lastname);

	// DATAJPA-231
	int countUsersByFirstname(String firstname);

	// DATAJPA-920
	boolean existsByLastname(String lastname);

	// DATAJPA-391
	@Query(""select u.firstname from User u where u.lastname = ?1"")
	List<String> findFirstnamesByLastname(String lastname);

	// DATAJPA-415
	Collection<User> findByIdIn(@Param(""ids"") Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in ?1"")
	Collection<User> findByIdsCustomWithPositionalVarArgs(Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in :ids"")
	Collection<User> findByIdsCustomWithNamedVarArgs(@Param(""ids"") Integer... ids);

	// DATAJPA-415
	@Modifying
	@Query(""update #{#entityName} u set u.active = :activeState where u.id in :ids"")
	void updateUserActiveState(@Param(""activeState"") boolean activeState, @Param(""ids"") Integer... ids);

	// DATAJPA-405
	List<User> findAllByOrderByLastnameAsc();

	// DATAJPA-454
	List<User> findByBinaryData(byte[] data);

	// DATAJPA-486
	Slice<User> findSliceByLastname(String lastname, Pageable pageable);

	// DATAJPA-496
	List<User> findByAttributesIn(Set<String> attributes);

	// DATAJPA-460
	Long removeByLastname(String lastname);

	// DATAJPA-460
	List<User> deleteByLastname(String lastname);

	/**
	 * @see <a href=""https://issues.apache.org/jira/browse/OPENJPA-2484"">OPENJPA-2484</a>
	 */
	// DATAJPA-505
	// @Query(value = ""select u.binaryData from User u where u.id = :id"")
	// byte[] findBinaryDataByIdJpaQl(@Param(""id"") Integer id);

	/**
	 * Explicitly mapped to a procedure with name ""plus1inout"" in database.
	 */
	@Procedure(""plus1inout"") // DATAJPA-455
	Integer explicitlyNamedPlus1inout(Integer arg);

	/**
	 * Implicitly mapped to a procedure with name ""plus1inout"" in database via alias.
	 */
	@Procedure(procedureName = ""plus1inout"") // DATAJPA-455
	Integer plus1inout(Integer arg);

	/**
	 * Explicitly mapped to named stored procedure ""User.plus1IO"" in {@link EntityManager}.
	 */
	@Procedure(name = ""User.plus1IO"") // DATAJPA-455
	Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param(""arg"") Integer arg);

	/**
	 * Implicitly mapped to named stored procedure ""User.plus1"" in {@link EntityManager}.
	 */
	@Procedure // DATAJPA-455
	Integer plus1(@Param(""arg"") Integer arg);

	// DATAJPA-456
	@Query(value = ""select u from User u where u.firstname like ?1%"", countProjection = ""u.firstname"")
	Page<User> findAllByFirstnameLike(String firstname, Pageable page);

	// DATAJPA-456
	@Query(name = ""User.findBySpringDataNamedQuery"", countProjection = ""u.firstname"")
	Page<User> findByNamedQueryAndCountProjection(String firstname, Pageable page);

	// DATAJPA-551
	User findFirstByOrderByAgeDesc();

	// DATAJPA-551
	User findFirst1ByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeAsc();

	// DATAJPA-551
	User findTop1ByOrderByAgeAsc();

	// DATAJPA-551
	List<User> findTop2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2UsersBy(Sort sort);

	// DATAJPA-551
	List<User> findTop2UsersBy(Sort sort);

	// DATAJPA-551
	Page<User> findFirst3UsersBy(Pageable page);

	// DATAJPA-551
	Page<User> findFirst2UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop3UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop2UsersBy(Pageable page);

	// DATAJPA-506
	@Query(value = ""select u.binaryData from SD_User u where u.id = ?1"", nativeQuery = true)
	byte[] findBinaryDataByIdNative(Integer id);

	// DATAJPA-506
	@Query(""select u from User u where u.emailAddress = ?1"")
	Optional<User> findOptionalByEmailAddress(String emailAddress);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]} and u.firstname = ?1 and u.lastname like %?#{[1]}% and u.lastname like %?2%"")
	List<User> findByFirstnameAndLastnameWithSpelExpression(String firstname, String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%"")
	List<User> findByLastnameWithSpelExpression(@Param(""lastname"") String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithQuestionmark();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithColon();

	// DATAJPA-564
	@Query(""select u from User u where u.age = ?#{[0]}"")
	List<User> findUsersByAgeForSpELExpressionByIndexedParameter(int age);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :firstname and u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpression(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findCurrentUserWithCustomQuery();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findByFirstnameAndCurrentUserWithCustomQuery(String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterVariableOnly(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnly(String firstname);

	// DATAJPA-564
	@Query(
			value = ""select * from (select rownum() as RN, u.* from SD_User u) where RN between ?#{ #pageable.offset -1} and ?#{#pageable.offset + #pageable.pageSize}"",
			countQuery = ""select count(u.id) from SD_User u"", nativeQuery = true)
	Page<User> findUsersInNativeQueryWithPagination(Pageable pageable);

	// DATAJPA-629
	@Query(""select u from #{#entityName} u where u.firstname = ?#{[0]} and u.lastname = ?#{[1]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnlyWithEntityExpression(String firstname,
			String lastname);

	// DATAJPA-606
	List<User> findByAgeIn(Collection<Integer> ages);

	// DATAJPA-606
	List<User> queryByAgeIn(Integer[] ages);

	// DATAJPA-606
	List<User> queryByAgeInOrFirstname(Integer[] ages, String firstname);

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> findAllByCustomQueryAndStream();

	// DATAJPA-677
	Stream<User> readAllByFirstnameNotNull();

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> streamAllPaged(Pageable pageable);

	// DATAJPA-830
	List<User> findByLastnameNotContaining(String part);

	// DATAJPA-829
	List<User> findByRolesContaining(Role role);

	// DATAJPA-829
	List<User> findByRolesNotContaining(Role role);

	// DATAJPA-858
	List<User> findByRolesNameContaining(String name);

	// DATAJPA-1179
	@Query(""select u from User u where u.firstname = :#{#firstname} and u.firstname = :#{#firstname}"")
	List<User> findUsersByDuplicateSpel(@Param(""firstname"") String firstname);

	List<RolesAndFirstname> findRolesAndFirstnameBy();

	@Query(value = ""SELECT firstname, lastname from SD_User WHERE id = ?1"", nativeQuery = true)
	NameOnly findByNativeQuery(Integer id);

	// DATAJPA-1185
	<T> Stream<T> findAsStreamByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1185
	<T> List<T> findAsListByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1248
	@Query(value = ""SELECT emailaddress FROM SD_User WHERE id = ?1"", nativeQuery = true)
	EmailOnly findEmailOnlyByNativeQuery(Integer id);


	// DATAJPA-1273
	List<NameOnly> findByNamedQueryWithAliasInInvertedOrder();

	// DATAJPA-1301
	@Query(""select firstname as firstname, lastname as lastname from User u where u.firstname = 'Oliver'"")
	Map<String, Object> findMapWithNullValues();

	// DATAJPA-1334
	List<NameOnlyDto> findByNamedQueryWithConstructorExpression();

	// DATAJPA-1519
	@Query(""select u from User u where u.firstname like %?#{escape([0])}% escape '\\'"")
	List<User> findContainingEscaped(String namePart);

	interface RolesAndFirstname {

		String getFirstname();

		Set<Role> getRoles();
	}

	interface NameOnly {

		String getFirstname();

		String getLastname();
	}

	interface EmailOnly {
		String getEmailAddress();
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/config/EnableJpaRepositories.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.config;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import javax.persistence.EntityManagerFactory;

import org.springframework.beans.factory.FactoryBean;
import org.springframework.context.annotation.ComponentScan.Filter;
import org.springframework.context.annotation.Import;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
import org.springframework.data.repository.config.DefaultRepositoryBaseClass;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * Annotation to enable JPA repositories. Will scan the package of the annotated configuration class for Spring Data
 * repositories by default.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(JpaRepositoriesRegistrar.class)
public @interface EnableJpaRepositories {

	/**
	 * Alias for the {@link #basePackages()} attribute. Allows for more concise annotation declarations e.g.:
	 * {@code @EnableJpaRepositories(""org.my.pkg"")} instead of {@code @EnableJpaRepositories(basePackages=""org.my.pkg"")}.
	 */
	String[] value() default {};

	/**
	 * Base packages to scan for annotated components. {@link #value()} is an alias for (and mutually exclusive with) this
	 * attribute. Use {@link #basePackageClasses()} for a type-safe alternative to String-based package names.
	 */
	String[] basePackages() default {};

	/**
	 * Type-safe alternative to {@link #basePackages()} for specifying the packages to scan for annotated components. The
	 * package of each class specified will be scanned. Consider creating a special no-op marker class or interface in
	 * each package that serves no purpose other than being referenced by this attribute.
	 */
	Class<?>[] basePackageClasses() default {};

	/**
	 * Specifies which types are eligible for component scanning. Further narrows the set of candidate components from
	 * everything in {@link #basePackages()} to everything in the base packages that matches the given filter or filters.
	 */
	Filter[] includeFilters() default {};

	/**
	 * Specifies which types are not eligible for component scanning.
	 */
	Filter[] excludeFilters() default {};

	/**
	 * Returns the postfix to be used when looking up custom repository implementations. Defaults to {@literal Impl}. So
	 * for a repository named {@code PersonRepository} the corresponding implementation class will be looked up scanning
	 * for {@code PersonRepositoryImpl}.
	 * 
	 * @return
	 */
	String repositoryImplementationPostfix() default ""Impl"";

	/**
	 * Configures the location of where to find the Spring Data named queries properties file. Will default to
	 * {@code META-INF/jpa-named-queries.properties}.
	 * 
	 * @return
	 */
	String namedQueriesLocation() default """";

	/**
	 * Returns the key of the {@link QueryLookupStrategy} to be used for lookup queries for query methods. Defaults to
	 * {@link Key#CREATE_IF_NOT_FOUND}.
	 * 
	 * @return
	 */
	Key queryLookupStrategy() default Key.CREATE_IF_NOT_FOUND;

	/**
	 * Returns the {@link FactoryBean} class to be used for each repository instance. Defaults to
	 * {@link JpaRepositoryFactoryBean}.
	 * 
	 * @return
	 */
	Class<?> repositoryFactoryBeanClass() default JpaRepositoryFactoryBean.class;

	/**
	 * Configure the repository base class to be used to create repository proxies for this particular configuration.
	 * 
	 * @return
	 * @since 1.9
	 */
	Class<?> repositoryBaseClass() default DefaultRepositoryBaseClass.class;

	// JPA specific configuration

	/**
	 * Configures the name of the {@link EntityManagerFactory} bean definition to be used to create repositories
	 * discovered through this annotation. Defaults to {@code entityManagerFactory}.
	 * 
	 * @return
	 */
	String entityManagerFactoryRef() default ""entityManagerFactory"";

	/**
	 * Configures the name of the {@link PlatformTransactionManager} bean definition to be used to create repositories
	 * discovered through this annotation. Defaults to {@code transactionManager}.
	 * 
	 * @return
	 */
	String transactionManagerRef() default ""transactionManager"";

	/**
	 * Configures whether nested repository-interfaces (e.g. defined as inner classes) should be discovered by the
	 * repositories infrastructure.
	 */
	boolean considerNestedRepositories() default false;

	/**
	 * Configures whether to enable default transactions for Spring Data JPA repositories. Defaults to {@literal true}. If
	 * disabled, repositories must be used behind a facade that's configuring transactions (e.g. using Spring's annotation
	 * driven transaction facilities) or repository methods have to be used to demarcate transactions.
	 * 
	 * @return whether to enable default transactions, defaults to {@literal true}.
	 */
	boolean enableDefaultTransactions() default true;
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/config/EnableJpaRepositories.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.config;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import javax.persistence.EntityManagerFactory;

import org.springframework.beans.factory.FactoryBean;
import org.springframework.context.annotation.ComponentScan.Filter;
import org.springframework.context.annotation.Import;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
import org.springframework.data.repository.config.DefaultRepositoryBaseClass;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * Annotation to enable JPA repositories. Will scan the package of the annotated configuration class for Spring Data
 * repositories by default.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(JpaRepositoriesRegistrar.class)
public @interface EnableJpaRepositories {

	/**
	 * Alias for the {@link #basePackages()} attribute. Allows for more concise annotation declarations e.g.:
	 * {@code @EnableJpaRepositories(""org.my.pkg"")} instead of {@code @EnableJpaRepositories(basePackages=""org.my.pkg"")}.
	 */
	String[] value() default {};

	/**
	 * Base packages to scan for annotated components. {@link #value()} is an alias for (and mutually exclusive with) this
	 * attribute. Use {@link #basePackageClasses()} for a type-safe alternative to String-based package names.
	 */
	String[] basePackages() default {};

	/**
	 * Type-safe alternative to {@link #basePackages()} for specifying the packages to scan for annotated components. The
	 * package of each class specified will be scanned. Consider creating a special no-op marker class or interface in
	 * each package that serves no purpose other than being referenced by this attribute.
	 */
	Class<?>[] basePackageClasses() default {};

	/**
	 * Specifies which types are eligible for component scanning. Further narrows the set of candidate components from
	 * everything in {@link #basePackages()} to everything in the base packages that matches the given filter or filters.
	 */
	Filter[] includeFilters() default {};

	/**
	 * Specifies which types are not eligible for component scanning.
	 */
	Filter[] excludeFilters() default {};

	/**
	 * Returns the postfix to be used when looking up custom repository implementations. Defaults to {@literal Impl}. So
	 * for a repository named {@code PersonRepository} the corresponding implementation class will be looked up scanning
	 * for {@code PersonRepositoryImpl}.
	 * 
	 * @return
	 */
	String repositoryImplementationPostfix() default ""Impl"";

	/**
	 * Configures the location of where to find the Spring Data named queries properties file. Will default to
	 * {@code META-INF/jpa-named-queries.properties}.
	 * 
	 * @return
	 */
	String namedQueriesLocation() default """";

	/**
	 * Returns the key of the {@link QueryLookupStrategy} to be used for lookup queries for query methods. Defaults to
	 * {@link Key#CREATE_IF_NOT_FOUND}.
	 * 
	 * @return
	 */
	Key queryLookupStrategy() default Key.CREATE_IF_NOT_FOUND;

	/**
	 * Returns the {@link FactoryBean} class to be used for each repository instance. Defaults to
	 * {@link JpaRepositoryFactoryBean}.
	 * 
	 * @return
	 */
	Class<?> repositoryFactoryBeanClass() default JpaRepositoryFactoryBean.class;

	/**
	 * Configure the repository base class to be used to create repository proxies for this particular configuration.
	 * 
	 * @return
	 * @since 1.9
	 */
	Class<?> repositoryBaseClass() default DefaultRepositoryBaseClass.class;

	// JPA specific configuration

	/**
	 * Configures the name of the {@link EntityManagerFactory} bean definition to be used to create repositories
	 * discovered through this annotation. Defaults to {@code entityManagerFactory}.
	 * 
	 * @return
	 */
	String entityManagerFactoryRef() default ""entityManagerFactory"";

	/**
	 * Configures the name of the {@link PlatformTransactionManager} bean definition to be used to create repositories
	 * discovered through this annotation. Defaults to {@code transactionManager}.
	 * 
	 * @return
	 */
	String transactionManagerRef() default ""transactionManager"";

	/**
	 * Configures whether nested repository-interfaces (e.g. defined as inner classes) should be discovered by the
	 * repositories infrastructure.
	 */
	boolean considerNestedRepositories() default false;

	/**
	 * Configures whether to enable default transactions for Spring Data JPA repositories. Defaults to {@literal true}. If
	 * disabled, repositories must be used behind a facade that's configuring transactions (e.g. using Spring's annotation
	 * driven transaction facilities) or repository methods have to be used to demarcate transactions.
	 * 
	 * @return whether to enable default transactions, defaults to {@literal true}.
	 */
	boolean enableDefaultTransactions() default true;

	/**
	 * Configures what character is used to escape the wildcards {@literal _} and {@literal %} in derived queries with
	 * {@literal contains}, {@literal startsWith} or {@literal endsWith} clauses.
	 * 
	 * @return a single character used for escaping.
	 */
	char escapeCharacter() default '\\';
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/config/JpaRepositoryConfigExtension.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.config;

import static org.springframework.data.jpa.repository.config.BeanDefinitionNames.*;

import lombok.experimental.UtilityClass;

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Optional;
import java.util.Set;

import javax.persistence.Entity;
import javax.persistence.MappedSuperclass;
import javax.persistence.PersistenceContext;
import javax.persistence.PersistenceUnit;

import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.core.annotation.AnnotationAttributes;
import org.springframework.core.io.ResourceLoader;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.support.DefaultJpaContext;
import org.springframework.data.jpa.repository.support.EntityManagerBeanDefinitionRegistrarPostProcessor;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
import org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource;
import org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport;
import org.springframework.data.repository.config.RepositoryConfigurationSource;
import org.springframework.data.repository.config.XmlRepositoryConfigurationSource;
import org.springframework.lang.Nullable;
import org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor;
import org.springframework.util.ClassUtils;
import org.springframework.util.StringUtils;

/**
 * JPA specific configuration extension parsing custom attributes from the XML namespace and
 * {@link EnableJpaRepositories} annotation. Also, it registers bean definitions for a
 * {@link PersistenceAnnotationBeanPostProcessor} (to trigger injection into {@link PersistenceContext}/
 * {@link PersistenceUnit} annotated properties and methods) as well as
 * {@link PersistenceExceptionTranslationPostProcessor} to enable exception translation of persistence specific
 * exceptions into Spring's {@link DataAccessException} hierarchy.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Gil Markham
 * @author Thomas Darimont
 * @author Christoph Strobl
 * @author Mark Paluch
 */
public class JpaRepositoryConfigExtension extends RepositoryConfigurationExtensionSupport {

	private static final Class<?> PAB_POST_PROCESSOR = PersistenceAnnotationBeanPostProcessor.class;
	private static final String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = ""transactionManager"";
	private static final String ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE = ""enableDefaultTransactions"";
	private static final String JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME = ""org.springframework.data.jpa.util.JpaMetamodelCacheCleanup"";

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getModuleName()
	 */
	@Override
	public String getModuleName() {
		return ""JPA"";
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtension#getRepositoryFactoryBeanClassName()
	 */
	@Override
	public String getRepositoryFactoryBeanClassName() {
		return JpaRepositoryFactoryBean.class.getName();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config14.RepositoryConfigurationExtensionSupport#getModulePrefix()
	 */
	@Override
	protected String getModulePrefix() {
		return getModuleName().toLowerCase(Locale.US);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingAnnotations()
	 */
	@Override
	protected Collection<Class<? extends Annotation>> getIdentifyingAnnotations() {
		return Arrays.asList(Entity.class, MappedSuperclass.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingTypes()
	 */
	@Override
	protected Collection<Class<?>> getIdentifyingTypes() {
		return Collections.<Class<?>> singleton(JpaRepository.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, RepositoryConfigurationSource source) {

		Optional<String> transactionManagerRef = source.getAttribute(""transactionManagerRef"");
		builder.addPropertyValue(""transactionManager"", transactionManagerRef.orElse(DEFAULT_TRANSACTION_MANAGER_BEAN_NAME));
		builder.addPropertyValue(""entityManager"", getEntityManagerBeanDefinitionFor(source, source.getSource()));
		builder.addPropertyReference(""mappingContext"", JPA_MAPPING_CONTEXT_BEAN_NAME);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, AnnotationRepositoryConfigurationSource config) {

		AnnotationAttributes attributes = config.getAttributes();

		builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE,
				attributes.getBoolean(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.XmlRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, XmlRepositoryConfigurationSource config) {

		Optional<String> enableDefaultTransactions = config.getAttribute(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE);

		if (enableDefaultTransactions.isPresent() && StringUtils.hasText(enableDefaultTransactions.get())) {
			builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE, enableDefaultTransactions.get());
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#registerBeansForRoot(org.springframework.beans.factory.support.BeanDefinitionRegistry, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void registerBeansForRoot(BeanDefinitionRegistry registry, RepositoryConfigurationSource config) {

		super.registerBeansForRoot(registry, config);

		Object source = config.getSource();

		registerIfNotAlreadyRegistered(new RootBeanDefinition(EntityManagerBeanDefinitionRegistrarPostProcessor.class),
				registry, EM_BEAN_DEFINITION_REGISTRAR_POST_PROCESSOR_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(JpaMetamodelMappingContextFactoryBean.class), registry,
				JPA_MAPPING_CONTEXT_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(PAB_POST_PROCESSOR), registry,
				AnnotationConfigUtils.PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME, source);

		// Register bean definition for DefaultJpaContext

		RootBeanDefinition contextDefinition = new RootBeanDefinition(DefaultJpaContext.class);
		contextDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);

		registerIfNotAlreadyRegistered(contextDefinition, registry, JPA_CONTEXT_BEAN_NAME, source);
		registerIfNotAlreadyRegistered(new RootBeanDefinition(JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME), registry,
				JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME, source);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getConfigurationInspectionClassLoader(org.springframework.core.io.ResourceLoader)
	 */
	protected ClassLoader getConfigurationInspectionClassLoader(ResourceLoader loader) {

		ClassLoader classLoader = loader.getClassLoader();

		return classLoader != null && LazyJvmAgent.isActive(loader.getClassLoader())
				? new InspectionClassLoader(loader.getClassLoader())
				: loader.getClassLoader();
	}

	/**
	 * Creates an anonymous factory to extract the actual {@link javax.persistence.EntityManager} from the
	 * {@link javax.persistence.EntityManagerFactory} bean name reference.
	 *
	 * @param config
	 * @param source
	 * @return
	 */
	private static AbstractBeanDefinition getEntityManagerBeanDefinitionFor(RepositoryConfigurationSource config,
			@Nullable Object source) {

		BeanDefinitionBuilder builder = BeanDefinitionBuilder
				.rootBeanDefinition(""org.springframework.orm.jpa.SharedEntityManagerCreator"");
		builder.setFactoryMethod(""createSharedEntityManager"");
		builder.addConstructorArgReference(getEntityManagerBeanRef(config));

		AbstractBeanDefinition bean = builder.getRawBeanDefinition();
		bean.setSource(source);

		return bean;
	}

	private static String getEntityManagerBeanRef(RepositoryConfigurationSource config) {

		Optional<String> entityManagerFactoryRef = config.getAttribute(""entityManagerFactoryRef"");
		return entityManagerFactoryRef.orElse(""entityManagerFactory"");
	}

	/**
	 * Utility to determine if a lazy Java agent is being used that might transform classes at a later time.
	 *
	 * @author Mark Paluch
	 * @since 2.1
	 */
	@UtilityClass
	static class LazyJvmAgent {

		private static final Set<String> AGENT_CLASSES;

		static {

			Set<String> agentClasses = new LinkedHashSet<>();

			agentClasses.add(""org.springframework.instrument.InstrumentationSavingAgent"");
			agentClasses.add(""org.eclipse.persistence.internal.jpa.deployment.JavaSECMPInitializerAgent"");

			AGENT_CLASSES = Collections.unmodifiableSet(agentClasses);
		}

		/**
		 * Determine if any agent is active.
		 *
		 * @return {@literal true} if an agent is active.
		 */
		static boolean isActive(@Nullable ClassLoader classLoader) {

			return AGENT_CLASSES.stream() //
					.anyMatch(agentClass -> ClassUtils.isPresent(agentClass, classLoader));
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/config/JpaRepositoryConfigExtension.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.config;

import static org.springframework.data.jpa.repository.config.BeanDefinitionNames.*;

import lombok.experimental.UtilityClass;

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Optional;
import java.util.Set;

import javax.persistence.Entity;
import javax.persistence.MappedSuperclass;
import javax.persistence.PersistenceContext;
import javax.persistence.PersistenceUnit;

import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.core.annotation.AnnotationAttributes;
import org.springframework.core.io.ResourceLoader;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.support.DefaultJpaContext;
import org.springframework.data.jpa.repository.support.EntityManagerBeanDefinitionRegistrarPostProcessor;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
import org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource;
import org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport;
import org.springframework.data.repository.config.RepositoryConfigurationSource;
import org.springframework.data.repository.config.XmlRepositoryConfigurationSource;
import org.springframework.lang.Nullable;
import org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor;
import org.springframework.util.ClassUtils;
import org.springframework.util.StringUtils;

/**
 * JPA specific configuration extension parsing custom attributes from the XML namespace and
 * {@link EnableJpaRepositories} annotation. Also, it registers bean definitions for a
 * {@link PersistenceAnnotationBeanPostProcessor} (to trigger injection into {@link PersistenceContext}/
 * {@link PersistenceUnit} annotated properties and methods) as well as
 * {@link PersistenceExceptionTranslationPostProcessor} to enable exception translation of persistence specific
 * exceptions into Spring's {@link DataAccessException} hierarchy.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Gil Markham
 * @author Thomas Darimont
 * @author Christoph Strobl
 * @author Mark Paluch
 */
public class JpaRepositoryConfigExtension extends RepositoryConfigurationExtensionSupport {

	private static final Class<?> PAB_POST_PROCESSOR = PersistenceAnnotationBeanPostProcessor.class;
	private static final String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = ""transactionManager"";
	private static final String ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE = ""enableDefaultTransactions"";
	private static final String JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME = ""org.springframework.data.jpa.util.JpaMetamodelCacheCleanup"";

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getModuleName()
	 */
	@Override
	public String getModuleName() {
		return ""JPA"";
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtension#getRepositoryFactoryBeanClassName()
	 */
	@Override
	public String getRepositoryFactoryBeanClassName() {
		return JpaRepositoryFactoryBean.class.getName();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config14.RepositoryConfigurationExtensionSupport#getModulePrefix()
	 */
	@Override
	protected String getModulePrefix() {
		return getModuleName().toLowerCase(Locale.US);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingAnnotations()
	 */
	@Override
	protected Collection<Class<? extends Annotation>> getIdentifyingAnnotations() {
		return Arrays.asList(Entity.class, MappedSuperclass.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingTypes()
	 */
	@Override
	protected Collection<Class<?>> getIdentifyingTypes() {
		return Collections.<Class<?>> singleton(JpaRepository.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, RepositoryConfigurationSource source) {

		Optional<String> transactionManagerRef = source.getAttribute(""transactionManagerRef"");
		builder.addPropertyValue(""transactionManager"", transactionManagerRef.orElse(DEFAULT_TRANSACTION_MANAGER_BEAN_NAME));
		builder.addPropertyValue(""entityManager"", getEntityManagerBeanDefinitionFor(source, source.getSource()));
		builder.addPropertyValue(""escapeCharacter"", getEscapeCharacter(source).orElse('\\'));
		builder.addPropertyReference(""mappingContext"", JPA_MAPPING_CONTEXT_BEAN_NAME);
	}

	/**
	 * XML configurations do not support {@link Character} values. This method catches the exception thrown and returns an {@link Optional#empty()} instead.
	 */
	private static Optional<Character> getEscapeCharacter(RepositoryConfigurationSource source) {

		try {
			return source.getAttribute(""escapeCharacter"", Character.class);
		} catch (IllegalArgumentException ___) {
			return Optional.empty();
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, AnnotationRepositoryConfigurationSource config) {

		AnnotationAttributes attributes = config.getAttributes();

		builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE,
				attributes.getBoolean(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.XmlRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, XmlRepositoryConfigurationSource config) {

		Optional<String> enableDefaultTransactions = config.getAttribute(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE);

		if (enableDefaultTransactions.isPresent() && StringUtils.hasText(enableDefaultTransactions.get())) {
			builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE, enableDefaultTransactions.get());
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#registerBeansForRoot(org.springframework.beans.factory.support.BeanDefinitionRegistry, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void registerBeansForRoot(BeanDefinitionRegistry registry, RepositoryConfigurationSource config) {

		super.registerBeansForRoot(registry, config);

		Object source = config.getSource();

		registerIfNotAlreadyRegistered(new RootBeanDefinition(EntityManagerBeanDefinitionRegistrarPostProcessor.class),
				registry, EM_BEAN_DEFINITION_REGISTRAR_POST_PROCESSOR_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(JpaMetamodelMappingContextFactoryBean.class), registry,
				JPA_MAPPING_CONTEXT_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(PAB_POST_PROCESSOR), registry,
				AnnotationConfigUtils.PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME, source);

		// Register bean definition for DefaultJpaContext

		RootBeanDefinition contextDefinition = new RootBeanDefinition(DefaultJpaContext.class);
		contextDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);

		registerIfNotAlreadyRegistered(contextDefinition, registry, JPA_CONTEXT_BEAN_NAME, source);
		registerIfNotAlreadyRegistered(new RootBeanDefinition(JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME), registry,
				JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME, source);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getConfigurationInspectionClassLoader(org.springframework.core.io.ResourceLoader)
	 */
	protected ClassLoader getConfigurationInspectionClassLoader(ResourceLoader loader) {

		ClassLoader classLoader = loader.getClassLoader();

		return classLoader != null && LazyJvmAgent.isActive(loader.getClassLoader())
				? new InspectionClassLoader(loader.getClassLoader())
				: loader.getClassLoader();
	}

	/**
	 * Creates an anonymous factory to extract the actual {@link javax.persistence.EntityManager} from the
	 * {@link javax.persistence.EntityManagerFactory} bean name reference.
	 *
	 * @param config
	 * @param source
	 * @return
	 */
	private static AbstractBeanDefinition getEntityManagerBeanDefinitionFor(RepositoryConfigurationSource config,
			@Nullable Object source) {

		BeanDefinitionBuilder builder = BeanDefinitionBuilder
				.rootBeanDefinition(""org.springframework.orm.jpa.SharedEntityManagerCreator"");
		builder.setFactoryMethod(""createSharedEntityManager"");
		builder.addConstructorArgReference(getEntityManagerBeanRef(config));

		AbstractBeanDefinition bean = builder.getRawBeanDefinition();
		bean.setSource(source);

		return bean;
	}

	private static String getEntityManagerBeanRef(RepositoryConfigurationSource config) {

		Optional<String> entityManagerFactoryRef = config.getAttribute(""entityManagerFactoryRef"");
		return entityManagerFactoryRef.orElse(""entityManagerFactory"");
	}

	/**
	 * Utility to determine if a lazy Java agent is being used that might transform classes at a later time.
	 *
	 * @author Mark Paluch
	 * @since 2.1
	 */
	@UtilityClass
	static class LazyJvmAgent {

		private static final Set<String> AGENT_CLASSES;

		static {

			Set<String> agentClasses = new LinkedHashSet<>();

			agentClasses.add(""org.springframework.instrument.InstrumentationSavingAgent"");
			agentClasses.add(""org.eclipse.persistence.internal.jpa.deployment.JavaSECMPInitializerAgent"");

			AGENT_CLASSES = Collections.unmodifiableSet(agentClasses);
		}

		/**
		 * Determine if any agent is active.
		 *
		 * @return {@literal true} if an agent is active.
		 */
		static boolean isActive(@Nullable ClassLoader classLoader) {

			return AGENT_CLASSES.stream() //
					.anyMatch(agentClass -> ClassUtils.isPresent(agentClass, classLoader));
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryCreator.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.springframework.data.jpa.repository.query.QueryUtils.*;
import static org.springframework.data.repository.query.parser.Part.Type.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.ParameterExpression;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Selection;
import javax.persistence.metamodel.SingularAttribute;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.mapping.PropertyPath;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.AbstractQueryCreator;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Query creator to create a {@link CriteriaQuery} from a {@link PartTree}.
 *
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Michael Cramer
 * @author Mark Paluch
 * @author Reda.Housni-Alaoui
 */
public class JpaQueryCreator extends AbstractQueryCreator<CriteriaQuery<? extends Object>, Predicate> {

	private final CriteriaBuilder builder;
	private final Root<?> root;
	private final CriteriaQuery<? extends Object> query;
	private final ParameterMetadataProvider provider;
	private final ReturnedType returnedType;
	private final PartTree tree;

	/**
	 * Create a new {@link JpaQueryCreator}.
	 *
	 * @param tree must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param builder must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public JpaQueryCreator(PartTree tree, ReturnedType type, CriteriaBuilder builder,
			ParameterMetadataProvider provider) {

		super(tree);
		this.tree = tree;

		CriteriaQuery<? extends Object> criteriaQuery = createCriteriaQuery(builder, type);

		this.builder = builder;
		this.query = criteriaQuery.distinct(tree.isDistinct());
		this.root = query.from(type.getDomainType());
		this.provider = provider;
		this.returnedType = type;
	}

	/**
	 * Creates the {@link CriteriaQuery} to apply predicates on.
	 *
	 * @param builder will never be {@literal null}.
	 * @param type will never be {@literal null}.
	 * @return must not be {@literal null}.
	 */
	protected CriteriaQuery<? extends Object> createCriteriaQuery(CriteriaBuilder builder, ReturnedType type) {

		Class<?> typeToRead = type.getTypeToRead();

		return typeToRead == null || tree.isExistsProjection() ? builder.createTupleQuery()
				: builder.createQuery(typeToRead);
	}

	/**
	 * Returns all {@link javax.persistence.criteria.ParameterExpression} created when creating the query.
	 *
	 * @return the parameterExpressions
	 */
	public List<ParameterMetadata<?>> getParameterExpressions() {
		return provider.getExpressions();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#create(org.springframework.data.repository.query.parser.Part, java.util.Iterator)
	 */
	@Override
	protected Predicate create(Part part, Iterator<Object> iterator) {

		return toPredicate(part, root);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#and(org.springframework.data.repository.query.parser.Part, java.lang.Object, java.util.Iterator)
	 */
	@Override
	protected Predicate and(Part part, Predicate base, Iterator<Object> iterator) {
		return builder.and(base, toPredicate(part, root));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#or(java.lang.Object, java.lang.Object)
	 */
	@Override
	protected Predicate or(Predicate base, Predicate predicate) {
		return builder.or(base, predicate);
	}

	/**
	 * Finalizes the given {@link Predicate} and applies the given sort. Delegates to
	 * {@link #complete(Predicate, Sort, CriteriaQuery, CriteriaBuilder, Root)} and hands it the current {@link CriteriaQuery}
	 * and {@link CriteriaBuilder}.
	 */
	@Override
	protected final CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort) {
		return complete(predicate, sort, query, builder, root);
	}

	/**
	 * Template method to finalize the given {@link Predicate} using the given {@link CriteriaQuery} and
	 * {@link CriteriaBuilder}.
	 *
	 * @param predicate
	 * @param sort
	 * @param query
	 * @param builder
	 * @return
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	protected CriteriaQuery<? extends Object> complete(@Nullable Predicate predicate, Sort sort,
			CriteriaQuery<? extends Object> query, CriteriaBuilder builder, Root<?> root) {

		if (returnedType.needsCustomConstruction()) {

			List<Selection<?>> selections = new ArrayList<>();

			for (String property : returnedType.getInputProperties()) {

				PropertyPath path = PropertyPath.from(property, returnedType.getDomainType());
				selections.add(toExpressionRecursively(root, path, true).alias(property));
			}

			query = query.multiselect(selections);

		} else if (tree.isExistsProjection()) {

			if (root.getModel().hasSingleIdAttribute()) {

				SingularAttribute<?, ?> id = root.getModel().getId(root.getModel().getIdType().getJavaType());
				query = query.multiselect(root.get((SingularAttribute) id).alias(id.getName()));

			} else {

				query = query.multiselect(root.getModel().getIdClassAttributes().stream()//
						.map(it -> (Selection<?>) root.get((SingularAttribute) it).alias(it.getName()))
						.collect(Collectors.toList()));
			}

		} else {
			query = query.select((Root) root);
		}

		CriteriaQuery<? extends Object> select = query.orderBy(QueryUtils.toOrders(sort, root, builder));
		return predicate == null ? select : select.where(predicate);
	}

	/**
	 * Creates a {@link Predicate} from the given {@link Part}.
	 *
	 * @param part
	 * @param root
	 * @return
	 */
	private Predicate toPredicate(Part part, Root<?> root) {
		return new PredicateBuilder(part, root).build();
	}

	/**
	 * Simple builder to contain logic to create JPA {@link Predicate}s from {@link Part}s.
	 *
	 * @author Phil Webb
	 * @author Oliver Gierke
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private class PredicateBuilder {

		private final Part part;
		private final Root<?> root;

		/**
		 * Creates a new {@link PredicateBuilder} for the given {@link Part} and {@link Root}.
		 *
		 * @param part must not be {@literal null}.
		 * @param root must not be {@literal null}.
		 */
		public PredicateBuilder(Part part, Root<?> root) {

			Assert.notNull(part, ""Part must not be null!"");
			Assert.notNull(root, ""Root must not be null!"");
			this.part = part;
			this.root = root;
		}

		/**
		 * Builds a JPA {@link Predicate} from the underlying {@link Part}.
		 *
		 * @return
		 */
		public Predicate build() {

			PropertyPath property = part.getProperty();
			Type type = part.getType();

			switch (type) {
				case BETWEEN:
					ParameterMetadata<Comparable> first = provider.next(part);
					ParameterMetadata<Comparable> second = provider.next(part);
					return builder.between(getComparablePath(root, part), first.getExpression(), second.getExpression());
				case AFTER:
				case GREATER_THAN:
					return builder.greaterThan(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case GREATER_THAN_EQUAL:
					return builder.greaterThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case BEFORE:
				case LESS_THAN:
					return builder.lessThan(getComparablePath(root, part), provider.next(part, Comparable.class).getExpression());
				case LESS_THAN_EQUAL:
					return builder.lessThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case IS_NULL:
					return getTypedPath(root, part).isNull();
				case IS_NOT_NULL:
					return getTypedPath(root, part).isNotNull();
				case NOT_IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression()).not();
				case IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression());
				case STARTING_WITH:
				case ENDING_WITH:
				case CONTAINING:
				case NOT_CONTAINING:

					if (property.getLeafProperty().isCollection()) {

						Expression<Collection<Object>> propertyExpression = traversePath(root, property);
						ParameterExpression<Object> parameterExpression = provider.next(part).getExpression();

						// Can't just call .not() in case of negation as EclipseLink chokes on that.
						return type.equals(NOT_CONTAINING) ? isNotMember(builder, parameterExpression, propertyExpression)
								: isMember(builder, parameterExpression, propertyExpression);
					}

				case LIKE:
				case NOT_LIKE:
					Expression<String> stringPath = getTypedPath(root, part);
					Expression<String> propertyExpression = upperIfIgnoreCase(stringPath);
					Expression<String> parameterExpression = upperIfIgnoreCase(provider.next(part, String.class).getExpression());
					Predicate like = builder.like(propertyExpression, parameterExpression);
					return type.equals(NOT_LIKE) || type.equals(NOT_CONTAINING) ? like.not() : like;
				case TRUE:
					Expression<Boolean> truePath = getTypedPath(root, part);
					return builder.isTrue(truePath);
				case FALSE:
					Expression<Boolean> falsePath = getTypedPath(root, part);
					return builder.isFalse(falsePath);
				case SIMPLE_PROPERTY:
					ParameterMetadata<Object> expression = provider.next(part);
					Expression<Object> path = getTypedPath(root, part);
					return expression.isIsNullParameter() ? path.isNull()
							: builder.equal(upperIfIgnoreCase(path), upperIfIgnoreCase(expression.getExpression()));
				case NEGATING_SIMPLE_PROPERTY:
					return builder.notEqual(upperIfIgnoreCase(getTypedPath(root, part)),
							upperIfIgnoreCase(provider.next(part).getExpression()));
				case IS_EMPTY:
				case IS_NOT_EMPTY:

					if (!property.getLeafProperty().isCollection()) {
						throw new IllegalArgumentException(""IsEmpty / IsNotEmpty can only be used on collection properties!"");
					}

					Expression<Collection<Object>> collectionPath = traversePath(root, property);
					return type.equals(IS_NOT_EMPTY) ? builder.isNotEmpty(collectionPath) : builder.isEmpty(collectionPath);

				default:
					throw new IllegalArgumentException(""Unsupported keyword "" + type);
			}
		}

		private <T> Predicate isMember(CriteriaBuilder builder, Expression<T> parameter,
				Expression<Collection<T>> property) {
			return builder.isMember(parameter, property);
		}

		private <T> Predicate isNotMember(CriteriaBuilder builder, Expression<T> parameter,
				Expression<Collection<T>> property) {
			return builder.isNotMember(parameter, property);
		}

		/**
		 * Applies an {@code UPPERCASE} conversion to the given {@link Expression} in case the underlying {@link Part}
		 * requires ignoring case.
		 *
		 * @param expression must not be {@literal null}.
		 * @return
		 */
		private <T> Expression<T> upperIfIgnoreCase(Expression<? extends T> expression) {

			switch (part.shouldIgnoreCase()) {

				case ALWAYS:

					Assert.state(canUpperCase(expression), ""Unable to ignore case of "" + expression.getJavaType().getName()
							+ "" types, the property '"" + part.getProperty().getSegment() + ""' must reference a String"");
					return (Expression<T>) builder.upper((Expression<String>) expression);

				case WHEN_POSSIBLE:

					if (canUpperCase(expression)) {
						return (Expression<T>) builder.upper((Expression<String>) expression);
					}

				case NEVER:
				default:

					return (Expression<T>) expression;
			}
		}

		private boolean canUpperCase(Expression<?> expression) {
			return String.class.equals(expression.getJavaType());
		}

		/**
		 * Returns a path to a {@link Comparable}.
		 *
		 * @param root
		 * @param part
		 * @return
		 */
		private Expression<? extends Comparable> getComparablePath(Root<?> root, Part part) {
			return getTypedPath(root, part);
		}

		private <T> Expression<T> getTypedPath(Root<?> root, Part part) {
			return toExpressionRecursively(root, part.getProperty());
		}

		private <T> Expression<T> traversePath(Path<?> root, PropertyPath path) {

			Path<Object> result = root.get(path.getSegment());
			return (Expression<T>) (path.hasNext() ? traversePath(result, path.next()) : result);
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryCreator.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.springframework.data.jpa.repository.query.QueryUtils.*;
import static org.springframework.data.repository.query.parser.Part.Type.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.ParameterExpression;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Selection;
import javax.persistence.metamodel.SingularAttribute;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.mapping.PropertyPath;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.AbstractQueryCreator;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Query creator to create a {@link CriteriaQuery} from a {@link PartTree}.
 *
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Michael Cramer
 * @author Mark Paluch
 * @author Reda.Housni-Alaoui
 */
public class JpaQueryCreator extends AbstractQueryCreator<CriteriaQuery<? extends Object>, Predicate> {

	private final CriteriaBuilder builder;
	private final Root<?> root;
	private final CriteriaQuery<? extends Object> query;
	private final ParameterMetadataProvider provider;
	private final ReturnedType returnedType;
	private final PartTree tree;
	private final EscapeCharacter escape;

	/**
	 * Create a new {@link JpaQueryCreator}.
	 *
	 * @param tree must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param builder must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public JpaQueryCreator(PartTree tree, ReturnedType type, CriteriaBuilder builder,
			ParameterMetadataProvider provider) {

		super(tree);
		this.tree = tree;

		CriteriaQuery<?> criteriaQuery = createCriteriaQuery(builder, type);

		this.builder = builder;
		this.query = criteriaQuery.distinct(tree.isDistinct());
		this.root = query.from(type.getDomainType());
		this.provider = provider;
		this.returnedType = type;
		this.escape = provider.getEscape();
	}

	/**
	 * Creates the {@link CriteriaQuery} to apply predicates on.
	 *
	 * @param builder will never be {@literal null}.
	 * @param type will never be {@literal null}.
	 * @return must not be {@literal null}.
	 */
	protected CriteriaQuery<? extends Object> createCriteriaQuery(CriteriaBuilder builder, ReturnedType type) {

		Class<?> typeToRead = type.getTypeToRead();

		return typeToRead == null || tree.isExistsProjection() ? builder.createTupleQuery()
				: builder.createQuery(typeToRead);
	}

	/**
	 * Returns all {@link javax.persistence.criteria.ParameterExpression} created when creating the query.
	 *
	 * @return the parameterExpressions
	 */
	public List<ParameterMetadata<?>> getParameterExpressions() {
		return provider.getExpressions();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#create(org.springframework.data.repository.query.parser.Part, java.util.Iterator)
	 */
	@Override
	protected Predicate create(Part part, Iterator<Object> iterator) {

		return toPredicate(part, root);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#and(org.springframework.data.repository.query.parser.Part, java.lang.Object, java.util.Iterator)
	 */
	@Override
	protected Predicate and(Part part, Predicate base, Iterator<Object> iterator) {
		return builder.and(base, toPredicate(part, root));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#or(java.lang.Object, java.lang.Object)
	 */
	@Override
	protected Predicate or(Predicate base, Predicate predicate) {
		return builder.or(base, predicate);
	}

	/**
	 * Finalizes the given {@link Predicate} and applies the given sort. Delegates to
	 * {@link #complete(Predicate, Sort, CriteriaQuery, CriteriaBuilder, Root)} and hands it the current {@link CriteriaQuery}
	 * and {@link CriteriaBuilder}.
	 */
	@Override
	protected final CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort) {
		return complete(predicate, sort, query, builder, root);
	}

	/**
	 * Template method to finalize the given {@link Predicate} using the given {@link CriteriaQuery} and
	 * {@link CriteriaBuilder}.
	 *
	 * @param predicate
	 * @param sort
	 * @param query
	 * @param builder
	 * @return
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	protected CriteriaQuery<? extends Object> complete(@Nullable Predicate predicate, Sort sort,
			CriteriaQuery<? extends Object> query, CriteriaBuilder builder, Root<?> root) {

		if (returnedType.needsCustomConstruction()) {

			List<Selection<?>> selections = new ArrayList<>();

			for (String property : returnedType.getInputProperties()) {

				PropertyPath path = PropertyPath.from(property, returnedType.getDomainType());
				selections.add(toExpressionRecursively(root, path, true).alias(property));
			}

			query = query.multiselect(selections);

		} else if (tree.isExistsProjection()) {

			if (root.getModel().hasSingleIdAttribute()) {

				SingularAttribute<?, ?> id = root.getModel().getId(root.getModel().getIdType().getJavaType());
				query = query.multiselect(root.get((SingularAttribute) id).alias(id.getName()));

			} else {

				query = query.multiselect(root.getModel().getIdClassAttributes().stream()//
						.map(it -> (Selection<?>) root.get((SingularAttribute) it).alias(it.getName()))
						.collect(Collectors.toList()));
			}

		} else {
			query = query.select((Root) root);
		}

		CriteriaQuery<? extends Object> select = query.orderBy(QueryUtils.toOrders(sort, root, builder));
		return predicate == null ? select : select.where(predicate);
	}

	/**
	 * Creates a {@link Predicate} from the given {@link Part}.
	 *
	 * @param part
	 * @param root
	 * @return
	 */
	private Predicate toPredicate(Part part, Root<?> root) {
		return new PredicateBuilder(part, root).build();
	}

	/**
	 * Simple builder to contain logic to create JPA {@link Predicate}s from {@link Part}s.
	 *
	 * @author Phil Webb
	 * @author Oliver Gierke
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private class PredicateBuilder {

		private final Part part;
		private final Root<?> root;

		/**
		 * Creates a new {@link PredicateBuilder} for the given {@link Part} and {@link Root}.
		 *
		 * @param part must not be {@literal null}.
		 * @param root must not be {@literal null}.
		 */
		public PredicateBuilder(Part part, Root<?> root) {

			Assert.notNull(part, ""Part must not be null!"");
			Assert.notNull(root, ""Root must not be null!"");
			this.part = part;
			this.root = root;
		}

		/**
		 * Builds a JPA {@link Predicate} from the underlying {@link Part}.
		 *
		 * @return
		 */
		public Predicate build() {

			PropertyPath property = part.getProperty();
			Type type = part.getType();

			switch (type) {
				case BETWEEN:
					ParameterMetadata<Comparable> first = provider.next(part);
					ParameterMetadata<Comparable> second = provider.next(part);
					return builder.between(getComparablePath(root, part), first.getExpression(), second.getExpression());
				case AFTER:
				case GREATER_THAN:
					return builder.greaterThan(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case GREATER_THAN_EQUAL:
					return builder.greaterThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case BEFORE:
				case LESS_THAN:
					return builder.lessThan(getComparablePath(root, part), provider.next(part, Comparable.class).getExpression());
				case LESS_THAN_EQUAL:
					return builder.lessThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case IS_NULL:
					return getTypedPath(root, part).isNull();
				case IS_NOT_NULL:
					return getTypedPath(root, part).isNotNull();
				case NOT_IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression()).not();
				case IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression());
				case STARTING_WITH:
				case ENDING_WITH:
				case CONTAINING:
				case NOT_CONTAINING:

					if (property.getLeafProperty().isCollection()) {

						Expression<Collection<Object>> propertyExpression = traversePath(root, property);
						ParameterExpression<Object> parameterExpression = provider.next(part).getExpression();

						// Can't just call .not() in case of negation as EclipseLink chokes on that.
						return type.equals(NOT_CONTAINING) ? isNotMember(builder, parameterExpression, propertyExpression)
								: isMember(builder, parameterExpression, propertyExpression);
					}

				case LIKE:
				case NOT_LIKE:
					Expression<String> stringPath = getTypedPath(root, part);
					Expression<String> propertyExpression = upperIfIgnoreCase(stringPath);
					Expression<String> parameterExpression = upperIfIgnoreCase(provider.next(part, String.class).getExpression());
					Predicate like = builder.like(propertyExpression, parameterExpression, escape.getValue());
					return type.equals(NOT_LIKE) || type.equals(NOT_CONTAINING) ? like.not() : like;
				case TRUE:
					Expression<Boolean> truePath = getTypedPath(root, part);
					return builder.isTrue(truePath);
				case FALSE:
					Expression<Boolean> falsePath = getTypedPath(root, part);
					return builder.isFalse(falsePath);
				case SIMPLE_PROPERTY:
					ParameterMetadata<Object> expression = provider.next(part);
					Expression<Object> path = getTypedPath(root, part);
					return expression.isIsNullParameter() ? path.isNull()
							: builder.equal(upperIfIgnoreCase(path), upperIfIgnoreCase(expression.getExpression()));
				case NEGATING_SIMPLE_PROPERTY:
					return builder.notEqual(upperIfIgnoreCase(getTypedPath(root, part)),
							upperIfIgnoreCase(provider.next(part).getExpression()));
				case IS_EMPTY:
				case IS_NOT_EMPTY:

					if (!property.getLeafProperty().isCollection()) {
						throw new IllegalArgumentException(""IsEmpty / IsNotEmpty can only be used on collection properties!"");
					}

					Expression<Collection<Object>> collectionPath = traversePath(root, property);
					return type.equals(IS_NOT_EMPTY) ? builder.isNotEmpty(collectionPath) : builder.isEmpty(collectionPath);

				default:
					throw new IllegalArgumentException(""Unsupported keyword "" + type);
			}
		}

		private <T> Predicate isMember(CriteriaBuilder builder, Expression<T> parameter,
				Expression<Collection<T>> property) {
			return builder.isMember(parameter, property);
		}

		private <T> Predicate isNotMember(CriteriaBuilder builder, Expression<T> parameter,
				Expression<Collection<T>> property) {
			return builder.isNotMember(parameter, property);
		}

		/**
		 * Applies an {@code UPPERCASE} conversion to the given {@link Expression} in case the underlying {@link Part}
		 * requires ignoring case.
		 *
		 * @param expression must not be {@literal null}.
		 * @return
		 */
		private <T> Expression<T> upperIfIgnoreCase(Expression<? extends T> expression) {

			switch (part.shouldIgnoreCase()) {

				case ALWAYS:

					Assert.state(canUpperCase(expression), ""Unable to ignore case of "" + expression.getJavaType().getName()
							+ "" types, the property '"" + part.getProperty().getSegment() + ""' must reference a String"");
					return (Expression<T>) builder.upper((Expression<String>) expression);

				case WHEN_POSSIBLE:

					if (canUpperCase(expression)) {
						return (Expression<T>) builder.upper((Expression<String>) expression);
					}

				case NEVER:
				default:

					return (Expression<T>) expression;
			}
		}

		private boolean canUpperCase(Expression<?> expression) {
			return String.class.equals(expression.getJavaType());
		}

		/**
		 * Returns a path to a {@link Comparable}.
		 *
		 * @param root
		 * @param part
		 * @return
		 */
		private Expression<? extends Comparable> getComparablePath(Root<?> root, Part part) {
			return getTypedPath(root, part);
		}

		private <T> Expression<T> getTypedPath(Root<?> root, Part part) {
			return toExpressionRecursively(root, part.getProperty());
		}

		private <T> Expression<T> traversePath(Path<?> root, PropertyPath path) {

			Path<Object> result = root.get(path.getSegment());
			return (Expression<T>) (path.hasNext() ? traversePath(result, path.next()) : result);
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.RepositoryQuery;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Query lookup strategy to execute finders.
 *
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Mark Paluch
 */
public final class JpaQueryLookupStrategy {

	/**
	 * Private constructor to prevent instantiation.
	 */
	private JpaQueryLookupStrategy() {}

	/**
	 * Base class for {@link QueryLookupStrategy} implementations that need access to an {@link EntityManager}.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private abstract static class AbstractQueryLookupStrategy implements QueryLookupStrategy {

		private final EntityManager em;
		private final QueryExtractor provider;

		/**
		 * Creates a new {@link AbstractQueryLookupStrategy}.
		 *
		 * @param em
		 * @param extractor
		 */
		public AbstractQueryLookupStrategy(EntityManager em, QueryExtractor extractor) {

			this.em = em;
			this.provider = extractor;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.query.QueryLookupStrategy#resolveQuery(java.lang.reflect.Method, org.springframework.data.repository.core.RepositoryMetadata, org.springframework.data.projection.ProjectionFactory, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		public final RepositoryQuery resolveQuery(Method method, RepositoryMetadata metadata, ProjectionFactory factory,
				NamedQueries namedQueries) {
			return resolveQuery(new JpaQueryMethod(method, metadata, factory, provider), em, namedQueries);
		}

		protected abstract RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries);
	}

	/**
	 * {@link QueryLookupStrategy} to create a query from the method name.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final PersistenceProvider persistenceProvider;

		public CreateQueryLookupStrategy(EntityManager em, QueryExtractor extractor) {

			super(em, extractor);
			this.persistenceProvider = PersistenceProvider.fromEntityManager(em);
		}

		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {
			return new PartTreeJpaQuery(method, em, persistenceProvider);
		}
	}

	/**
	 * {@link QueryLookupStrategy} that tries to detect a declared query declared via {@link Query} annotation followed by
	 * a JPA named query lookup.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class DeclaredQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final EvaluationContextProvider evaluationContextProvider;

		/**
		 * Creates a new {@link DeclaredQueryLookupStrategy}.
		 *
		 * @param em
		 * @param extractor
		 * @param evaluationContextProvider
		 */
		public DeclaredQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				EvaluationContextProvider evaluationContextProvider) {

			super(em, extractor);
			this.evaluationContextProvider = evaluationContextProvider;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			RepositoryQuery query = JpaQueryFactory.INSTANCE.fromQueryAnnotation(method, em, evaluationContextProvider);

			if (null != query) {
				return query;
			}

			query = JpaQueryFactory.INSTANCE.fromProcedureAnnotation(method, em);

			if (null != query) {
				return query;
			}

			String name = method.getNamedQueryName();
			if (namedQueries.hasQuery(name)) {
				return JpaQueryFactory.INSTANCE.fromMethodWithQueryString(method, em, namedQueries.getQuery(name),
						evaluationContextProvider);
			}

			query = NamedQuery.lookupFrom(method, em);

			if (null != query) {
				return query;
			}

			throw new IllegalStateException(
					String.format(""Did neither find a NamedQuery nor an annotated query for method %s!"", method));
		}
	}

	/**
	 * {@link QueryLookupStrategy} to try to detect a declared query first (
	 * {@link org.springframework.data.jpa.repository.Query}, JPA named query). In case none is found we fall back on
	 * query creation.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateIfNotFoundQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final DeclaredQueryLookupStrategy lookupStrategy;
		private final CreateQueryLookupStrategy createStrategy;

		/**
		 * Creates a new {@link CreateIfNotFoundQueryLookupStrategy}.
		 *
		 * @param em
		 * @param extractor
		 * @param createStrategy
		 * @param lookupStrategy
		 */
		public CreateIfNotFoundQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				CreateQueryLookupStrategy createStrategy, DeclaredQueryLookupStrategy lookupStrategy) {

			super(em, extractor);

			this.createStrategy = createStrategy;
			this.lookupStrategy = lookupStrategy;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			try {
				return lookupStrategy.resolveQuery(method, em, namedQueries);
			} catch (IllegalStateException e) {
				return createStrategy.resolveQuery(method, em, namedQueries);
			}
		}
	}

	/**
	 * Creates a {@link QueryLookupStrategy} for the given {@link EntityManager} and {@link Key}.
	 *
	 * @param em must not be {@literal null}.
	 * @param key may be {@literal null}.
	 * @param extractor must not be {@literal null}.
	 * @param evaluationContextProvider must not be {@literal null}.
	 * @return
	 */
	public static QueryLookupStrategy create(EntityManager em, @Nullable Key key, QueryExtractor extractor,
			EvaluationContextProvider evaluationContextProvider) {

		Assert.notNull(em, ""EntityManager must not be null!"");
		Assert.notNull(extractor, ""QueryExtractor must not be null!"");
		Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");

		switch (key != null ? key : Key.CREATE_IF_NOT_FOUND) {
			case CREATE:
				return new CreateQueryLookupStrategy(em, extractor);
			case USE_DECLARED_QUERY:
				return new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider);
			case CREATE_IF_NOT_FOUND:
				return new CreateIfNotFoundQueryLookupStrategy(em, extractor, new CreateQueryLookupStrategy(em, extractor),
						new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider));
			default:
				throw new IllegalArgumentException(String.format(""Unsupported query lookup strategy %s!"", key));
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.RepositoryQuery;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Query lookup strategy to execute finders.
 *
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Mark Paluch
 */
public final class JpaQueryLookupStrategy {

	/**
	 * Private constructor to prevent instantiation.
	 */
	private JpaQueryLookupStrategy() {}

	/**
	 * Base class for {@link QueryLookupStrategy} implementations that need access to an {@link EntityManager}.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private abstract static class AbstractQueryLookupStrategy implements QueryLookupStrategy {

		private final EntityManager em;
		private final QueryExtractor provider;

		/**
		 * Creates a new {@link AbstractQueryLookupStrategy}.
		 *
		 * @param em
		 * @param extractor
		 */
		public AbstractQueryLookupStrategy(EntityManager em, QueryExtractor extractor) {

			this.em = em;
			this.provider = extractor;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.query.QueryLookupStrategy#resolveQuery(java.lang.reflect.Method, org.springframework.data.repository.core.RepositoryMetadata, org.springframework.data.projection.ProjectionFactory, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		public final RepositoryQuery resolveQuery(Method method, RepositoryMetadata metadata, ProjectionFactory factory,
				NamedQueries namedQueries) {
			return resolveQuery(new JpaQueryMethod(method, metadata, factory, provider), em, namedQueries);
		}

		protected abstract RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries);
	}

	/**
	 * {@link QueryLookupStrategy} to create a query from the method name.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final PersistenceProvider persistenceProvider;
		private final EscapeCharacter escape;

		public CreateQueryLookupStrategy(EntityManager em, QueryExtractor extractor, EscapeCharacter escape) {

			super(em, extractor);

			this.persistenceProvider = PersistenceProvider.fromEntityManager(em);
			this.escape = escape;
		}

		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {
			return new PartTreeJpaQuery(method, em, persistenceProvider, escape);
		}
	}

	/**
	 * {@link QueryLookupStrategy} that tries to detect a declared query declared via {@link Query} annotation followed by
	 * a JPA named query lookup.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class DeclaredQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final EvaluationContextProvider evaluationContextProvider;

		/**
		 * Creates a new {@link DeclaredQueryLookupStrategy}.
		 *
		 * @param em
		 * @param extractor
		 * @param evaluationContextProvider
		 */
		public DeclaredQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				EvaluationContextProvider evaluationContextProvider) {

			super(em, extractor);
			this.evaluationContextProvider = evaluationContextProvider;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			RepositoryQuery query = JpaQueryFactory.INSTANCE.fromQueryAnnotation(method, em, evaluationContextProvider);

			if (null != query) {
				return query;
			}

			query = JpaQueryFactory.INSTANCE.fromProcedureAnnotation(method, em);

			if (null != query) {
				return query;
			}

			String name = method.getNamedQueryName();
			if (namedQueries.hasQuery(name)) {
				return JpaQueryFactory.INSTANCE.fromMethodWithQueryString(method, em, namedQueries.getQuery(name),
						evaluationContextProvider);
			}

			query = NamedQuery.lookupFrom(method, em);

			if (null != query) {
				return query;
			}

			throw new IllegalStateException(
					String.format(""Did neither find a NamedQuery nor an annotated query for method %s!"", method));
		}
	}

	/**
	 * {@link QueryLookupStrategy} to try to detect a declared query first (
	 * {@link org.springframework.data.jpa.repository.Query}, JPA named query). In case none is found we fall back on
	 * query creation.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateIfNotFoundQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final DeclaredQueryLookupStrategy lookupStrategy;
		private final CreateQueryLookupStrategy createStrategy;

		/**
		 * Creates a new {@link CreateIfNotFoundQueryLookupStrategy}.
		 *
		 * @param em
		 * @param extractor
		 * @param createStrategy
		 * @param lookupStrategy
		 */
		public CreateIfNotFoundQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				CreateQueryLookupStrategy createStrategy, DeclaredQueryLookupStrategy lookupStrategy) {

			super(em, extractor);

			this.createStrategy = createStrategy;
			this.lookupStrategy = lookupStrategy;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			try {
				return lookupStrategy.resolveQuery(method, em, namedQueries);
			} catch (IllegalStateException e) {
				return createStrategy.resolveQuery(method, em, namedQueries);
			}
		}
	}

	/**
	 * Creates a {@link QueryLookupStrategy} for the given {@link EntityManager} and {@link Key}.
	 *
	 * @param em must not be {@literal null}.
	 * @param key may be {@literal null}.
	 * @param extractor must not be {@literal null}.
	 * @param evaluationContextProvider must not be {@literal null}.
	 * @param escape
	 * @return
	 */
	public static QueryLookupStrategy create(EntityManager em, @Nullable Key key, QueryExtractor extractor,
			EvaluationContextProvider evaluationContextProvider, EscapeCharacter escape) {

		Assert.notNull(em, ""EntityManager must not be null!"");
		Assert.notNull(extractor, ""QueryExtractor must not be null!"");
		Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");

		switch (key != null ? key : Key.CREATE_IF_NOT_FOUND) {
			case CREATE:
				return new CreateQueryLookupStrategy(em, extractor, escape);
			case USE_DECLARED_QUERY:
				return new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider);
			case CREATE_IF_NOT_FOUND:
				return new CreateIfNotFoundQueryLookupStrategy(em, extractor,
						new CreateQueryLookupStrategy(em, extractor, escape),
						new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider));
			default:
				throw new IllegalArgumentException(String.format(""Unsupported query lookup strategy %s!"", key));
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/ParameterMetadataProvider.java,"/*
 * Copyright 2011-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.function.Supplier;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.repository.query.Parameter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.expression.Expression;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;

/**
 * Helper class to allow easy creation of {@link ParameterMetadata}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Mark Paluch
 * @author Christoph Strobl
 * @author Jens Schauder
 */
class ParameterMetadataProvider {

	private final CriteriaBuilder builder;
	private final Iterator<? extends Parameter> parameters;
	private final List<ParameterMetadata<?>> expressions;
	private final @Nullable Iterator<Object> bindableParameterValues;
	private final PersistenceProvider persistenceProvider;

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and
	 * {@link ParametersParameterAccessor} with support for parameter value customizations via {@link PersistenceProvider}
	 * .
	 * 
	 * @param builder must not be {@literal null}.
	 * @param accessor must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, ParametersParameterAccessor accessor,
			PersistenceProvider provider) {
		this(builder, accessor.iterator(), accessor.getParameters(), provider);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and {@link Parameters} with
	 * support for parameter value customizations via {@link PersistenceProvider}.
	 * 
	 * @param builder must not be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, Parameters<?, ?> parameters, PersistenceProvider provider) {
		this(builder, null, parameters, provider);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} an {@link Iterable} of all
	 * bindable parameter values, and {@link Parameters} with support for parameter value customizations via
	 * {@link PersistenceProvider}.
	 * 
	 * @param builder must not be {@literal null}.
	 * @param bindableParameterValues may be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	private ParameterMetadataProvider(CriteriaBuilder builder, @Nullable Iterator<Object> bindableParameterValues,
			Parameters<?, ?> parameters, PersistenceProvider provider) {

		Assert.notNull(builder, ""CriteriaBuilder must not be null!"");
		Assert.notNull(parameters, ""Parameters must not be null!"");
		Assert.notNull(provider, ""PesistenceProvider must not be null!"");

		this.builder = builder;
		this.parameters = parameters.getBindableParameters().iterator();
		this.expressions = new ArrayList<>();
		this.bindableParameterValues = bindableParameterValues;
		this.persistenceProvider = provider;
	}

	/**
	 * Returns all {@link ParameterMetadata}s built.
	 * 
	 * @return the expressions
	 */
	public List<ParameterMetadata<?>> getExpressions() {
		return Collections.unmodifiableList(expressions);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for given {@link Part} and the next {@link Parameter}.
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<T> next(Part part) {

		Assert.isTrue(parameters.hasNext(), () -> String.format(""No parameter available for part %s."", part));

		Parameter parameter = parameters.next();
		return (ParameterMetadata<T>) next(part, parameter.getType(), parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} of the given {@link Part} and type. Forwards the underlying
	 * {@link Parameters} as well.
	 * 
	 * @param <T> is the type parameter of the returend {@link ParameterMetadata}.
	 * @param type must not be {@literal null}.
	 * @return ParameterMetadata for the next parameter.
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<? extends T> next(Part part, Class<T> type) {

		Parameter parameter = parameters.next();
		Class<?> typeToUse = ClassUtils.isAssignable(type, parameter.getType()) ? parameter.getType() : type;
		return (ParameterMetadata<? extends T>) next(part, typeToUse, parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for the given type and name.
	 * 
	 * @param <T> type parameter for the returned {@link ParameterMetadata}.
	 * @param part must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param parameter providing the name for the returned {@link ParameterMetadata}.
	 * @return a new {@link ParameterMetadata} for the given type and name.
	 */
	private <T> ParameterMetadata<T> next(Part part, Class<T> type, Parameter parameter) {

		Assert.notNull(type, ""Type must not be null!"");

		/*
		 * We treat Expression types as Object vales since the real value to be bound as a parameter is determined at query time.
		 */
		@SuppressWarnings(""unchecked"")
		Class<T> reifiedType = Expression.class.equals(type) ? (Class<T>) Object.class : type;

		Supplier<String> name = () -> parameter.getName()
				.orElseThrow(() -> new IllegalArgumentException(""o_O Parameter needs to be named""));

		ParameterExpression<T> expression = parameter.isExplicitlyNamed() //
				? builder.parameter(reifiedType, name.get()) //
				: builder.parameter(reifiedType);

		Object value = bindableParameterValues == null ? ParameterMetadata.PLACEHOLDER : bindableParameterValues.next();

		ParameterMetadata<T> metadata = new ParameterMetadata<>(expression, part.getType(), value, persistenceProvider);
		expressions.add(metadata);

		return metadata;
	}

	/**
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 * @param <T>
	 */
	static class ParameterMetadata<T> {

		static final Object PLACEHOLDER = new Object();

		private final Type type;
		private final ParameterExpression<T> expression;
		private final PersistenceProvider persistenceProvider;

		/**
		 * Creates a new {@link ParameterMetadata}.
		 */
		public ParameterMetadata(ParameterExpression<T> expression, Type type, @Nullable Object value,
				PersistenceProvider provider) {

			this.expression = expression;
			this.persistenceProvider = provider;
			this.type = value == null && Type.SIMPLE_PROPERTY.equals(type) ? Type.IS_NULL : type;
		}

		/**
		 * Returns the {@link ParameterExpression}.
		 * 
		 * @return the expression
		 */
		public ParameterExpression<T> getExpression() {
			return expression;
		}

		/**
		 * Returns whether the parameter shall be considered an {@literal IS NULL} parameter.
		 */
		public boolean isIsNullParameter() {
			return Type.IS_NULL.equals(type);
		}

		/**
		 * Prepares the object before it's actually bound to the {@link javax.persistence.Query;}.
		 * 
		 * @param value must not be {@literal null}.
		 */
		@Nullable
		public Object prepare(Object value) {

			Assert.notNull(value, ""Value must not be null!"");

			Class<? extends T> expressionType = expression.getJavaType();

			if (String.class.equals(expressionType)) {

				switch (type) {
					case STARTING_WITH:
						return String.format(""%s%%"", value.toString());
					case ENDING_WITH:
						return String.format(""%%%s"", value.toString());
					case CONTAINING:
					case NOT_CONTAINING:
						return String.format(""%%%s%%"", value.toString());
					default:
						return value;
				}
			}

			return Collection.class.isAssignableFrom(expressionType) //
					? persistenceProvider.potentiallyConvertEmptyCollection(toCollection(value)) //
					: value;
		}

		/**
		 * Returns the given argument as {@link Collection} which means it will return it as is if it's a
		 * {@link Collections}, turn an array into an {@link ArrayList} or simply wrap any other value into a single element
		 * {@link Collections}.
		 * 
		 * @param value the value to be converted to a {@link Collection}.
		 * @return the object itself as a {@link Collection} or a {@link Collection} constructed from the value.
		 */
		@Nullable
		private static Collection<?> toCollection(@Nullable Object value) {

			if (value == null) {
				return null;
			}

			if (value instanceof Collection) {
				return (Collection<?>) value;
			}

			if (ObjectUtils.isArray(value)) {
				return Arrays.asList(ObjectUtils.toObjectArray(value));
			}

			return Collections.singleton(value);
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/ParameterMetadataProvider.java,"/*
 * Copyright 2011-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.function.Supplier;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.Parameter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.expression.Expression;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;

/**
 * Helper class to allow easy creation of {@link ParameterMetadata}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Mark Paluch
 * @author Christoph Strobl
 * @author Jens Schauder
 */
class ParameterMetadataProvider {

	private final CriteriaBuilder builder;
	private final Iterator<? extends Parameter> parameters;
	private final List<ParameterMetadata<?>> expressions;
	private final @Nullable Iterator<Object> bindableParameterValues;
	private final PersistenceProvider persistenceProvider;
	private final EscapeCharacter escape;

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and
	 * {@link ParametersParameterAccessor} with support for parameter value customizations via {@link PersistenceProvider}
	 * .
	 * 
	 * @param builder must not be {@literal null}.
	 * @param accessor must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, ParametersParameterAccessor accessor,
									 PersistenceProvider provider, EscapeCharacter escape) {
		this(builder, accessor.iterator(), accessor.getParameters(), provider, escape);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and {@link Parameters} with
	 * support for parameter value customizations via {@link PersistenceProvider}.
	 * 
	 *  @param builder must not be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, Parameters<?, ?> parameters, PersistenceProvider provider, EscapeCharacter escape) {
		this(builder, null, parameters, provider, escape);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} an {@link Iterable} of all
	 * bindable parameter values, and {@link Parameters} with support for parameter value customizations via
	 * {@link PersistenceProvider}.
	 * 
	 * @param builder must not be {@literal null}.
	 * @param bindableParameterValues may be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	private ParameterMetadataProvider(CriteriaBuilder builder, @Nullable Iterator<Object> bindableParameterValues,
									  Parameters<?, ?> parameters, PersistenceProvider provider, EscapeCharacter escape) {

		Assert.notNull(builder, ""CriteriaBuilder must not be null!"");
		Assert.notNull(parameters, ""Parameters must not be null!"");
		Assert.notNull(provider, ""PesistenceProvider must not be null!"");

		this.builder = builder;
		this.parameters = parameters.getBindableParameters().iterator();
		this.expressions = new ArrayList<>();
		this.bindableParameterValues = bindableParameterValues;
		this.persistenceProvider = provider;
		this.escape = escape;
	}

	/**
	 * Returns all {@link ParameterMetadata}s built.
	 * 
	 * @return the expressions
	 */
	public List<ParameterMetadata<?>> getExpressions() {
		return Collections.unmodifiableList(expressions);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for given {@link Part} and the next {@link Parameter}.
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<T> next(Part part) {

		Assert.isTrue(parameters.hasNext(), () -> String.format(""No parameter available for part %s."", part));

		Parameter parameter = parameters.next();
		return (ParameterMetadata<T>) next(part, parameter.getType(), parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} of the given {@link Part} and type. Forwards the underlying
	 * {@link Parameters} as well.
	 * 
	 * @param <T> is the type parameter of the returend {@link ParameterMetadata}.
	 * @param type must not be {@literal null}.
	 * @return ParameterMetadata for the next parameter.
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<? extends T> next(Part part, Class<T> type) {

		Parameter parameter = parameters.next();
		Class<?> typeToUse = ClassUtils.isAssignable(type, parameter.getType()) ? parameter.getType() : type;
		return (ParameterMetadata<? extends T>) next(part, typeToUse, parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for the given type and name.
	 * 
	 * @param <T> type parameter for the returned {@link ParameterMetadata}.
	 * @param part must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param parameter providing the name for the returned {@link ParameterMetadata}.
	 * @return a new {@link ParameterMetadata} for the given type and name.
	 */
	private <T> ParameterMetadata<T> next(Part part, Class<T> type, Parameter parameter) {

		Assert.notNull(type, ""Type must not be null!"");

		/*
		 * We treat Expression types as Object vales since the real value to be bound as a parameter is determined at query time.
		 */
		@SuppressWarnings(""unchecked"")
		Class<T> reifiedType = Expression.class.equals(type) ? (Class<T>) Object.class : type;

		Supplier<String> name = () -> parameter.getName()
				.orElseThrow(() -> new IllegalArgumentException(""o_O Parameter needs to be named""));

		ParameterExpression<T> expression = parameter.isExplicitlyNamed() //
				? builder.parameter(reifiedType, name.get()) //
				: builder.parameter(reifiedType);

		Object value = bindableParameterValues == null ? ParameterMetadata.PLACEHOLDER : bindableParameterValues.next();

		ParameterMetadata<T> metadata = new ParameterMetadata<>(expression, part.getType(), value, persistenceProvider, escape);
		expressions.add(metadata);

		return metadata;
	}

	EscapeCharacter getEscape() {
		return escape;
	}

	/**
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 * @param <T>
	 */
	static class ParameterMetadata<T> {

		static final Object PLACEHOLDER = new Object();

		private final Type type;
		private final ParameterExpression<T> expression;
		private final PersistenceProvider persistenceProvider;
		private final EscapeCharacter escape;

		/**
		 * Creates a new {@link ParameterMetadata}.
		 */
		public ParameterMetadata(ParameterExpression<T> expression, Type type, @Nullable Object value,
								 PersistenceProvider provider, EscapeCharacter escape) {

			this.expression = expression;
			this.persistenceProvider = provider;
			this.type = value == null && Type.SIMPLE_PROPERTY.equals(type) ? Type.IS_NULL : type;
			this.escape = escape;
		}

		/**
		 * Returns the {@link ParameterExpression}.
		 * 
		 * @return the expression
		 */
		public ParameterExpression<T> getExpression() {
			return expression;
		}

		/**
		 * Returns whether the parameter shall be considered an {@literal IS NULL} parameter.
		 */
		public boolean isIsNullParameter() {
			return Type.IS_NULL.equals(type);
		}

		/**
		 * Prepares the object before it's actually bound to the {@link javax.persistence.Query;}.
		 * 
		 * @param value must not be {@literal null}.
		 */
		@Nullable
		public Object prepare(Object value) {

			Assert.notNull(value, ""Value must not be null!"");

			Class<? extends T> expressionType = expression.getJavaType();

			if (String.class.equals(expressionType)) {

				switch (type) {
					case STARTING_WITH:
						return String.format(""%s%%"", escape.escape(value.toString()));
					case ENDING_WITH:
						return String.format(""%%%s"", escape.escape(value.toString()));
					case CONTAINING:
					case NOT_CONTAINING:
						return String.format(""%%%s%%"", escape.escape(value.toString()));
					default:
						return value;
				}
			}

			return Collection.class.isAssignableFrom(expressionType) //
					? persistenceProvider.potentiallyConvertEmptyCollection(toCollection(value)) //
					: value;
		}

		/**
		 * Returns the given argument as {@link Collection} which means it will return it as is if it's a
		 * {@link Collections}, turn an array into an {@link ArrayList} or simply wrap any other value into a single element
		 * {@link Collections}.
		 * 
		 * @param value the value to be converted to a {@link Collection}.
		 * @return the object itself as a {@link Collection} or a {@link Collection} constructed from the value.
		 */
		@Nullable
		private static Collection<?> toCollection(@Nullable Object value) {

			if (value == null) {
				return null;
			}

			if (value instanceof Collection) {
				return (Collection<?>) value;
			}

			if (ObjectUtils.isArray(value)) {
				return Arrays.asList(ObjectUtils.toObjectArray(value));
			}

			return Collections.singleton(value);
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/PartTreeJpaQuery.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.List;
import java.util.Optional;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.DeleteExecution;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.ExistsExecution;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.ResultProcessor;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.lang.Nullable;

/**
 * A {@link AbstractJpaQuery} implementation based on a {@link PartTree}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Christoph Strobl
 * @author Jens Schauder
 * @author Mark Paluch
 * @author Сергей Цыпанов
 */
public class PartTreeJpaQuery extends AbstractJpaQuery {

	private final PartTree tree;
	private final JpaParameters parameters;

	private final QueryPreparer query;
	private final QueryPreparer countQuery;
	private final EntityManager em;

	/**
	 * Creates a new {@link PartTreeJpaQuery}.
	 * 
	 * @param method must not be {@literal null}.
	 * @param em must not be {@literal null}.
	 * @param persistenceProvider must not be {@literal null}.
	 */
	PartTreeJpaQuery(JpaQueryMethod method, EntityManager em, PersistenceProvider persistenceProvider) {

		super(method, em);

		this.em = em;
		Class<?> domainClass = method.getEntityInformation().getJavaType();
		this.parameters = method.getParameters();

		boolean recreationRequired = parameters.hasDynamicProjection() || parameters.potentiallySortsDynamically();

		try {

			this.tree = new PartTree(method.getName(), domainClass);
			this.countQuery = new CountQueryPreparer(persistenceProvider, recreationRequired);
			this.query = tree.isCountProjection() ? countQuery : new QueryPreparer(persistenceProvider, recreationRequired);

		} catch (Exception o_O) {
			throw new IllegalArgumentException(
					String.format(""Failed to create query for method %s! %s"", method, o_O.getMessage()), o_O);
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateQuery(java.lang.Object[])
	 */
	@Override
	public Query doCreateQuery(Object[] values) {
		return query.createQuery(values);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateCountQuery(java.lang.Object[])
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public TypedQuery<Long> doCreateCountQuery(Object[] values) {
		return (TypedQuery<Long>) countQuery.createQuery(values);
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#getExecution()
	 */
	@Override
	protected JpaQueryExecution getExecution() {

		if (this.tree.isDelete()) {
			return new DeleteExecution(em);
		} else if (this.tree.isExistsProjection()) {
			return new ExistsExecution();
		}

		return super.getExecution();
	}

	/**
	 * Query preparer to create {@link CriteriaQuery} instances and potentially cache them.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class QueryPreparer {

		private final @Nullable CriteriaQuery<?> cachedCriteriaQuery;
		private final @Nullable ParameterBinder cachedParameterBinder;
		private final @Nullable List<ParameterMetadata<?>> expressions;
		private final PersistenceProvider persistenceProvider;

		QueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {

			this.persistenceProvider = persistenceProvider;

			JpaQueryCreator creator = createCreator(persistenceProvider, Optional.empty());

			if (recreateQueries) {
				this.cachedCriteriaQuery = null;
				this.expressions = null;
				this.cachedParameterBinder = null;
			} else {
				this.cachedCriteriaQuery = creator.createQuery();
				this.expressions = creator.getParameterExpressions();
				this.cachedParameterBinder = getBinder(expressions);
			}
		}

		/**
		 * Creates a new {@link Query} for the given parameter values.
		 */
		public Query createQuery(Object[] values) {

			CriteriaQuery<?> criteriaQuery = cachedCriteriaQuery;
			ParameterBinder parameterBinder = cachedParameterBinder;
			ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, values);

			if (cachedCriteriaQuery == null || accessor.hasBindableNullValue()) {
				JpaQueryCreator creator = createCreator(persistenceProvider, Optional.of(accessor));
				criteriaQuery = creator.createQuery(getDynamicSort(values));
				List<ParameterMetadata<?>> expressions = creator.getParameterExpressions();
				parameterBinder = getBinder(expressions);
			}

			if (parameterBinder == null) {
				throw new IllegalStateException(""ParameterBinder is null!"");
			}

			return restrictMaxResultsIfNecessary(invokeBinding(parameterBinder, createQuery(criteriaQuery), values));
		}

		/**
		 * Restricts the max results of the given {@link Query} if the current {@code tree} marks this {@code query} as
		 * limited.
		 */
		private Query restrictMaxResultsIfNecessary(Query query) {

			if (tree.isLimiting()) {

				if (query.getMaxResults() != Integer.MAX_VALUE) {
					/*
					 * In order to return the correct results, we have to adjust the first result offset to be returned if:
					 * - a Pageable parameter is present 
					 * - AND the requested page number > 0
					 * - AND the requested page size was bigger than the derived result limitation via the First/Top keyword.
					 */
					if (query.getMaxResults() > tree.getMaxResults() && query.getFirstResult() > 0) {
						query.setFirstResult(query.getFirstResult() - (query.getMaxResults() - tree.getMaxResults()));
					}
				}

				query.setMaxResults(tree.getMaxResults());
			}

			if (tree.isExistsProjection()) {
				query.setMaxResults(1);
			}

			return query;
		}

		/**
		 * Checks whether we are working with a cached {@link CriteriaQuery} and synchronizes the creation of a
		 * {@link TypedQuery} instance from it. This is due to non-thread-safety in the {@link CriteriaQuery} implementation
		 * of some persistence providers (i.e. Hibernate in this case), see DATAJPA-396.
		 * 
		 * @param criteriaQuery must not be {@literal null}.
		 */
		private TypedQuery<?> createQuery(CriteriaQuery<?> criteriaQuery) {

			if (this.cachedCriteriaQuery != null) {
				synchronized (this.cachedCriteriaQuery) {
					return getEntityManager().createQuery(criteriaQuery);
				}
			}

			return getEntityManager().createQuery(criteriaQuery);
		}

		protected JpaQueryCreator createCreator(PersistenceProvider persistenceProvider,
				Optional<ParametersParameterAccessor> accessor) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor
					.map(it -> new ParameterMetadataProvider(builder, it, persistenceProvider))//
					.orElseGet(() -> new ParameterMetadataProvider(builder, parameters, persistenceProvider));

			ResultProcessor processor = getQueryMethod().getResultProcessor();
			ReturnedType returnedType = accessor.map(processor::withDynamicProjection)//
					.orElse(processor).getReturnedType();

			return new JpaQueryCreator(tree, returnedType, builder, provider);
		}

		/**
		 * Invokes parameter binding on the given {@link TypedQuery}.
		 */
		protected Query invokeBinding(ParameterBinder binder, TypedQuery<?> query, Object[] values) {

			return binder.bindAndPrepare(query, values);
		}

		private ParameterBinder getBinder(List<ParameterMetadata<?>> expressions) {
			return ParameterBinderFactory.createCriteriaBinder(parameters, expressions);
		}

		private Sort getDynamicSort(Object[] values) {

			return parameters.potentiallySortsDynamically() //
					? new ParametersParameterAccessor(parameters, values).getSort() //
					: Sort.unsorted();
		}
	}

	/**
	 * Special {@link QueryPreparer} to create count queries.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class CountQueryPreparer extends QueryPreparer {

		CountQueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {
			super(persistenceProvider, recreateQueries);
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#createCreator(org.springframework.data.repository.query.ParametersParameterAccessor, org.springframework.data.jpa.provider.PersistenceProvider)
		 */
		@Override
		protected JpaQueryCreator createCreator(PersistenceProvider persistenceProvider,
				Optional<ParametersParameterAccessor> accessor) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor
					.map(it -> new ParameterMetadataProvider(builder, it, persistenceProvider))//
					.orElseGet(() -> new ParameterMetadataProvider(builder, parameters, persistenceProvider));

			return new JpaCountQueryCreator(tree, getQueryMethod().getResultProcessor().getReturnedType(), builder, provider);
		}

		/**
		 * Customizes binding by skipping the pagination.
		 * 
		 * @see QueryPreparer#invokeBinding(ParameterBinder, TypedQuery, Object[])
		 */
		@Override
		protected Query invokeBinding(ParameterBinder binder, TypedQuery<?> query, Object[] values) {
			return binder.bind(query, values);
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/PartTreeJpaQuery.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.List;
import java.util.Optional;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.DeleteExecution;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.ExistsExecution;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.ResultProcessor;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.lang.Nullable;

/**
 * A {@link AbstractJpaQuery} implementation based on a {@link PartTree}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Christoph Strobl
 * @author Jens Schauder
 * @author Mark Paluch
 * @author Сергей Цыпанов
 */
public class PartTreeJpaQuery extends AbstractJpaQuery {

	private final PartTree tree;
	private final JpaParameters parameters;

	private final QueryPreparer query;
	private final QueryPreparer countQuery;
	private final EntityManager em;
	private final EscapeCharacter escape;

	/**
	 * Creates a new {@link PartTreeJpaQuery}.
	 * 
	 * @param method must not be {@literal null}.
	 * @param em must not be {@literal null}.
	 * @param persistenceProvider must not be {@literal null}.
	 * @param escape
	 */
	PartTreeJpaQuery(JpaQueryMethod method, EntityManager em, PersistenceProvider persistenceProvider, EscapeCharacter escape) {

		super(method, em);

		this.em = em;
		this.escape = escape;
		Class<?> domainClass = method.getEntityInformation().getJavaType();
		this.parameters = method.getParameters();

		boolean recreationRequired = parameters.hasDynamicProjection() || parameters.potentiallySortsDynamically();

		try {

			this.tree = new PartTree(method.getName(), domainClass);
			this.countQuery = new CountQueryPreparer(persistenceProvider, recreationRequired);
			this.query = tree.isCountProjection() ? countQuery : new QueryPreparer(persistenceProvider, recreationRequired);

		} catch (Exception o_O) {
			throw new IllegalArgumentException(
					String.format(""Failed to create query for method %s! %s"", method, o_O.getMessage()), o_O);
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateQuery(java.lang.Object[])
	 */
	@Override
	public Query doCreateQuery(Object[] values) {
		return query.createQuery(values);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateCountQuery(java.lang.Object[])
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public TypedQuery<Long> doCreateCountQuery(Object[] values) {
		return (TypedQuery<Long>) countQuery.createQuery(values);
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#getExecution()
	 */
	@Override
	protected JpaQueryExecution getExecution() {

		if (this.tree.isDelete()) {
			return new DeleteExecution(em);
		} else if (this.tree.isExistsProjection()) {
			return new ExistsExecution();
		}

		return super.getExecution();
	}

	/**
	 * Query preparer to create {@link CriteriaQuery} instances and potentially cache them.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class QueryPreparer {

		private final @Nullable CriteriaQuery<?> cachedCriteriaQuery;
		private final @Nullable ParameterBinder cachedParameterBinder;
		private final @Nullable List<ParameterMetadata<?>> expressions;
		private final PersistenceProvider persistenceProvider;

		QueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {

			this.persistenceProvider = persistenceProvider;

			JpaQueryCreator creator = createCreator(persistenceProvider, Optional.empty());

			if (recreateQueries) {
				this.cachedCriteriaQuery = null;
				this.expressions = null;
				this.cachedParameterBinder = null;
			} else {
				this.cachedCriteriaQuery = creator.createQuery();
				this.expressions = creator.getParameterExpressions();
				this.cachedParameterBinder = getBinder(expressions);
			}
		}

		/**
		 * Creates a new {@link Query} for the given parameter values.
		 */
		public Query createQuery(Object[] values) {

			CriteriaQuery<?> criteriaQuery = cachedCriteriaQuery;
			ParameterBinder parameterBinder = cachedParameterBinder;
			ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, values);

			if (cachedCriteriaQuery == null || accessor.hasBindableNullValue()) {
				JpaQueryCreator creator = createCreator(persistenceProvider, Optional.of(accessor));
				criteriaQuery = creator.createQuery(getDynamicSort(values));
				List<ParameterMetadata<?>> expressions = creator.getParameterExpressions();
				parameterBinder = getBinder(expressions);
			}

			if (parameterBinder == null) {
				throw new IllegalStateException(""ParameterBinder is null!"");
			}

			return restrictMaxResultsIfNecessary(invokeBinding(parameterBinder, createQuery(criteriaQuery), values));
		}

		/**
		 * Restricts the max results of the given {@link Query} if the current {@code tree} marks this {@code query} as
		 * limited.
		 */
		private Query restrictMaxResultsIfNecessary(Query query) {

			if (tree.isLimiting()) {

				if (query.getMaxResults() != Integer.MAX_VALUE) {
					/*
					 * In order to return the correct results, we have to adjust the first result offset to be returned if:
					 * - a Pageable parameter is present 
					 * - AND the requested page number > 0
					 * - AND the requested page size was bigger than the derived result limitation via the First/Top keyword.
					 */
					if (query.getMaxResults() > tree.getMaxResults() && query.getFirstResult() > 0) {
						query.setFirstResult(query.getFirstResult() - (query.getMaxResults() - tree.getMaxResults()));
					}
				}

				query.setMaxResults(tree.getMaxResults());
			}

			if (tree.isExistsProjection()) {
				query.setMaxResults(1);
			}

			return query;
		}

		/**
		 * Checks whether we are working with a cached {@link CriteriaQuery} and synchronizes the creation of a
		 * {@link TypedQuery} instance from it. This is due to non-thread-safety in the {@link CriteriaQuery} implementation
		 * of some persistence providers (i.e. Hibernate in this case), see DATAJPA-396.
		 * 
		 * @param criteriaQuery must not be {@literal null}.
		 */
		private TypedQuery<?> createQuery(CriteriaQuery<?> criteriaQuery) {

			if (this.cachedCriteriaQuery != null) {
				synchronized (this.cachedCriteriaQuery) {
					return getEntityManager().createQuery(criteriaQuery);
				}
			}

			return getEntityManager().createQuery(criteriaQuery);
		}

		protected JpaQueryCreator createCreator(PersistenceProvider persistenceProvider,
				Optional<ParametersParameterAccessor> accessor) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor
					.map(it -> new ParameterMetadataProvider(builder, it, persistenceProvider, escape))//
					.orElseGet(() -> new ParameterMetadataProvider(builder, parameters, persistenceProvider, escape));

			ResultProcessor processor = getQueryMethod().getResultProcessor();
			ReturnedType returnedType = accessor.map(processor::withDynamicProjection)//
					.orElse(processor).getReturnedType();

			return new JpaQueryCreator(tree, returnedType, builder, provider);
		}

		/**
		 * Invokes parameter binding on the given {@link TypedQuery}.
		 */
		protected Query invokeBinding(ParameterBinder binder, TypedQuery<?> query, Object[] values) {

			return binder.bindAndPrepare(query, values);
		}

		private ParameterBinder getBinder(List<ParameterMetadata<?>> expressions) {
			return ParameterBinderFactory.createCriteriaBinder(parameters, expressions);
		}

		private Sort getDynamicSort(Object[] values) {

			return parameters.potentiallySortsDynamically() //
					? new ParametersParameterAccessor(parameters, values).getSort() //
					: Sort.unsorted();
		}
	}

	/**
	 * Special {@link QueryPreparer} to create count queries.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class CountQueryPreparer extends QueryPreparer {

		CountQueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {
			super(persistenceProvider, recreateQueries);
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#createCreator(org.springframework.data.repository.query.ParametersParameterAccessor, org.springframework.data.jpa.provider.PersistenceProvider)
		 */
		@Override
		protected JpaQueryCreator createCreator(PersistenceProvider persistenceProvider,
				Optional<ParametersParameterAccessor> accessor) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor
					.map(it -> new ParameterMetadataProvider(builder, it, persistenceProvider, escape))//
					.orElseGet(() -> new ParameterMetadataProvider(builder, parameters, persistenceProvider, escape));

			return new JpaCountQueryCreator(tree, getQueryMethod().getResultProcessor().getReturnedType(), builder, provider);
		}

		/**
		 * Customizes binding by skipping the pagination.
		 * 
		 * @see QueryPreparer#invokeBinding(ParameterBinder, TypedQuery, Object[])
		 */
		@Override
		protected Query invokeBinding(ParameterBinder binder, TypedQuery<?> query, Object[] values) {
			return binder.bind(query, values);
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/QueryParameterSetterFactory.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.List;
import java.util.function.Function;

import javax.persistence.Query;
import javax.persistence.TemporalType;

import org.springframework.data.jpa.repository.query.JpaParameters.JpaParameter;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.query.QueryParameterSetter.NamedOrIndexedQueryParameterSetter;
import org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.Parameter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.expression.EvaluationContext;
import org.springframework.expression.Expression;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Encapsulates different strategies for the creation of a {@link QueryParameterSetter} from a {@link Query} and a
 * {@link ParameterBinding}
 *
 * @author Jens Schauder
 * @author Oliver Gierke
 * @author Mark Paluch
 * @since 2.0
 */
abstract class QueryParameterSetterFactory {

	@Nullable
	abstract QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery);

	/**
	 * Creates a new {@link QueryParameterSetterFactory} for the given {@link JpaParameters}.
	 *
	 * @param parameters must not be {@literal null}.
	 * @return a basic {@link QueryParameterSetterFactory} that can handle named and index parameters.
	 */
	static QueryParameterSetterFactory basic(JpaParameters parameters) {

		Assert.notNull(parameters, ""JpaParameters must not be null!"");

		return new BasicQueryParameterSetterFactory(parameters);
	}

	/**
	 * Creates a new {@link QueryParameterSetterFactory} using the given {@link JpaParameters} and
	 * {@link ParameterMetadata}.
	 *
	 * @param parameters must not be {@literal null}.
	 * @param metadata must not be {@literal null}.
	 * @return a {@link QueryParameterSetterFactory} for criteria Queries.
	 */
	static QueryParameterSetterFactory forCriteriaQuery(JpaParameters parameters, List<ParameterMetadata<?>> metadata) {

		Assert.notNull(parameters, ""JpaParameters must not be null!"");
		Assert.notNull(metadata, ""ParameterMetadata must not be null!"");

		return new CriteriaQueryParameterSetterFactory(parameters, metadata);
	}

	/**
	 * Creates a new {@link QueryParameterSetterFactory} for the given {@link SpelExpressionParser},
	 * {@link EvaluationContextProvider} and {@link Parameters}.
	 *
	 * @param parser must not be {@literal null}.
	 * @param evaluationContextProvider must not be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @return a {@link QueryParameterSetterFactory} that can handle
	 *         {@link org.springframework.expression.spel.standard.SpelExpression}s.
	 */
	static QueryParameterSetterFactory parsing(SpelExpressionParser parser,
			EvaluationContextProvider evaluationContextProvider, Parameters<?, ?> parameters) {

		Assert.notNull(parser, ""SpelExpressionParser must not be null!"");
		Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");
		Assert.notNull(parameters, ""Parameters must not be null!"");

		return new ExpressionBasedQueryParameterSetterFactory(parser, evaluationContextProvider, parameters);
	}

	/**
	 * Creates a {@link QueryParameterSetter} from a {@link JpaParameter}. Handles named and indexed parameters,
	 * TemporalType annotations and might ignore certain exception when requested to do so.
	 *
	 * @param valueExtractor extracts the relevant value from an array of method parameter values.
	 * @param binding the binding of the query parameter to be set.
	 * @param parameter the method parameter to bind.
	 */
	private static QueryParameterSetter createSetter(Function<Object[], Object> valueExtractor, ParameterBinding binding,
			@Nullable JpaParameter parameter) {

		TemporalType temporalType = parameter != null && parameter.isTemporalParameter() //
				? parameter.getRequiredTemporalType() //
				: null;

		return new NamedOrIndexedQueryParameterSetter(valueExtractor.andThen(binding::prepare),
				ParameterImpl.of(parameter, binding), temporalType);
	}

	/**
	 * Handles bindings that are SpEL expressions by evaluating the expression to obtain a value.
	 *
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @since 2.0
	 */
	private static class ExpressionBasedQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final SpelExpressionParser parser;
		private final EvaluationContextProvider evaluationContextProvider;
		private final Parameters<?, ?> parameters;

		/**
		 * @param parser must not be {@literal null}.
		 * @param evaluationContextProvider must not be {@literal null}.
		 * @param parameters must not be {@literal null}.
		 */
		ExpressionBasedQueryParameterSetterFactory(SpelExpressionParser parser,
				EvaluationContextProvider evaluationContextProvider, Parameters<?, ?> parameters) {

			Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");
			Assert.notNull(parser, ""SpelExpressionParser must not be null!"");
			Assert.notNull(parameters, ""Parameters must not be null!"");

			this.evaluationContextProvider = evaluationContextProvider;
			this.parser = parser;
			this.parameters = parameters;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Nullable
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			if (!binding.isExpression()) {
				return null;
			}

			Expression expression = parser.parseExpression(binding.getExpression());

			return createSetter(values -> evaluateExpression(expression, values), binding, null);
		}

		/**
		 * Evaluates the given {@link Expression} against the given values.
		 *
		 * @param expression must not be {@literal null}.
		 * @param values must not be {@literal null}.
		 * @return the result of the evaluation.
		 */
		@Nullable
		private Object evaluateExpression(Expression expression, Object[] values) {

			EvaluationContext context = evaluationContextProvider.getEvaluationContext(parameters, values);
			return expression.getValue(context, Object.class);
		}
	}

	/**
	 * Extracts values for parameter bindings from method parameters. It handles named as well as indexed parameters.
	 *
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @since 2.0
	 */
	private static class BasicQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final JpaParameters parameters;

		/**
		 * @param parameters must not be {@literal null}.
		 */
		BasicQueryParameterSetterFactory(JpaParameters parameters) {

			Assert.notNull(parameters, ""JpaParameters must not be null!"");

			this.parameters = parameters;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			Assert.notNull(binding, ""Binding must not be null."");

			JpaParameter parameter;

			if (declaredQuery.hasNamedParameter()) {
				parameter = findParameterForBinding(binding);
			} else {

				int parameterIndex = binding.getRequiredPosition() - 1;
				JpaParameters bindableParameters = parameters.getBindableParameters();

				Assert.isTrue( //
						parameterIndex < bindableParameters.getNumberOfParameters(), //
						() -> String.format( //
								""At least %s parameter(s) provided but only %s parameter(s) present in query."", //
								binding.getRequiredPosition(), //
								bindableParameters.getNumberOfParameters() //
						) //
				);

				parameter = bindableParameters.getParameter(binding.getRequiredPosition() - 1);
			}

			return parameter == null //
					? QueryParameterSetter.NOOP //
					: createSetter(values -> getValue(values, parameter), binding, parameter);
		}

		@Nullable
		private JpaParameter findParameterForBinding(ParameterBinding binding) {

			return parameters.getBindableParameters().stream() //
					.filter(candidate -> binding.getRequiredName().equals(getName(candidate))) //
					.findFirst().orElse(null);
		}

		private Object getValue(Object[] values, Parameter parameter) {
			return new JpaParametersParameterAccessor(parameters, values).getValue(parameter);
		}

		private static String getName(JpaParameter p) {
			return p.getName().orElseThrow(() -> new IllegalStateException(ParameterBinder.PARAMETER_NEEDS_TO_BE_NAMED));
		}
	}

	/**
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @see QueryParameterSetterFactory
	 */
	private static class CriteriaQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final JpaParameters parameters;
		private final List<ParameterMetadata<?>> expressions;

		/**
		 * Creates a new {@link QueryParameterSetterFactory} from the given {@link JpaParameters} and
		 * {@link ParameterMetadata}.
		 *
		 * @param parameters must not be {@literal null}.
		 * @param metadata must not be {@literal null}.
		 */
		CriteriaQueryParameterSetterFactory(JpaParameters parameters, List<ParameterMetadata<?>> metadata) {

			Assert.notNull(parameters, ""JpaParameters must not be null!"");
			Assert.notNull(metadata, ""Expressions must not be null!"");

			this.parameters = parameters;
			this.expressions = metadata;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			int parameterIndex = binding.getRequiredPosition() - 1;

			Assert.isTrue( //
					parameterIndex < expressions.size(), //
					() -> String.format( //
							""At least %s parameter(s) provided but only %s parameter(s) present in query."", //
							binding.getRequiredPosition(), //
							expressions.size() //
					) //
			);

			ParameterMetadata<?> metadata = expressions.get(parameterIndex);

			if (metadata.isIsNullParameter()) {
				return QueryParameterSetter.NOOP;
			}

			JpaParameter parameter = parameters.getBindableParameter(parameterIndex);
			TemporalType temporalType = parameter.isTemporalParameter() ? parameter.getRequiredTemporalType() : null;

			return new NamedOrIndexedQueryParameterSetter(values -> getAndPrepare(parameter, metadata, values),
					metadata.getExpression(), temporalType);
		}

		@Nullable
		private Object getAndPrepare(JpaParameter parameter, ParameterMetadata<?> metadata, Object[] values) {

			JpaParametersParameterAccessor accessor = new JpaParametersParameterAccessor(parameters, values);

			return metadata.prepare(accessor.getValue(parameter));
		}
	}

	private static class ParameterImpl<T> implements javax.persistence.Parameter<T> {

		private final Class<T> parameterType;
		private final @Nullable String name;
		private final @Nullable Integer position;

		/**
		 * Creates a new {@link ParameterImpl} for the given {@link JpaParameter} and {@link ParameterBinding}.
		 *
		 * @param parameter can be {@literal null}.
		 * @param binding must not be {@literal null}.
		 * @return a {@link javax.persistence.Parameter} object based on the information from the arguments.
		 */
		static javax.persistence.Parameter<?> of(@Nullable JpaParameter parameter, ParameterBinding binding) {

			Class<?> type = parameter == null ? Object.class : parameter.getType();

			return new ParameterImpl<>(type, getName(parameter, binding), binding.getPosition());
		}

		/**
		 * Creates a new {@link ParameterImpl} for the given name, position and parameter type.
		 *
		 * @param parameterType must not be {@literal null}.
		 * @param name can be {@literal null}.
		 * @param position can be {@literal null}.
		 */
		private ParameterImpl(Class<T> parameterType, @Nullable String name, @Nullable Integer position) {

			this.name = name;
			this.position = position;
			this.parameterType = parameterType;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getName()
		 */
		@Nullable
		@Override
		public String getName() {
			return name;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getPosition()
		 */
		@Nullable
		@Override
		public Integer getPosition() {
			return position;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getParameterType()
		 */
		@Override
		public Class<T> getParameterType() {
			return parameterType;
		}

		@Nullable
		private static String getName(@Nullable JpaParameter parameter, ParameterBinding binding) {

			if (parameter == null) {
				return binding.getName();
			}

			return parameter.isNamedParameter() //
					? parameter.getName().orElseThrow(() -> new IllegalArgumentException(""o_O parameter needs to have a name!"")) //
					: null;
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/QueryParameterSetterFactory.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.lang.reflect.Method;
import java.util.List;
import java.util.function.Function;

import javax.persistence.Query;
import javax.persistence.TemporalType;

import org.springframework.data.jpa.repository.query.JpaParameters.JpaParameter;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.query.QueryParameterSetter.NamedOrIndexedQueryParameterSetter;
import org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.Parameter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.expression.EvaluationContext;
import org.springframework.expression.Expression;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ReflectionUtils;

/**
 * Encapsulates different strategies for the creation of a {@link QueryParameterSetter} from a {@link Query} and a
 * {@link ParameterBinding}
 *
 * @author Jens Schauder
 * @author Oliver Gierke
 * @author Mark Paluch
 * @since 2.0
 */
abstract class QueryParameterSetterFactory {

	@Nullable
	abstract QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery);

	/**
	 * Creates a new {@link QueryParameterSetterFactory} for the given {@link JpaParameters}.
	 *
	 * @param parameters must not be {@literal null}.
	 * @return a basic {@link QueryParameterSetterFactory} that can handle named and index parameters.
	 */
	static QueryParameterSetterFactory basic(JpaParameters parameters) {

		Assert.notNull(parameters, ""JpaParameters must not be null!"");

		return new BasicQueryParameterSetterFactory(parameters);
	}

	/**
	 * Creates a new {@link QueryParameterSetterFactory} using the given {@link JpaParameters} and
	 * {@link ParameterMetadata}.
	 *
	 * @param parameters must not be {@literal null}.
	 * @param metadata must not be {@literal null}.
	 * @return a {@link QueryParameterSetterFactory} for criteria Queries.
	 */
	static QueryParameterSetterFactory forCriteriaQuery(JpaParameters parameters, List<ParameterMetadata<?>> metadata) {

		Assert.notNull(parameters, ""JpaParameters must not be null!"");
		Assert.notNull(metadata, ""ParameterMetadata must not be null!"");

		return new CriteriaQueryParameterSetterFactory(parameters, metadata);
	}

	/**
	 * Creates a new {@link QueryParameterSetterFactory} for the given {@link SpelExpressionParser},
	 * {@link EvaluationContextProvider} and {@link Parameters}.
	 *
	 * @param parser must not be {@literal null}.
	 * @param evaluationContextProvider must not be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @return a {@link QueryParameterSetterFactory} that can handle
	 *         {@link org.springframework.expression.spel.standard.SpelExpression}s.
	 */
	static QueryParameterSetterFactory parsing(SpelExpressionParser parser,
			EvaluationContextProvider evaluationContextProvider, Parameters<?, ?> parameters) {

		Assert.notNull(parser, ""SpelExpressionParser must not be null!"");
		Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");
		Assert.notNull(parameters, ""Parameters must not be null!"");

		return new ExpressionBasedQueryParameterSetterFactory(parser, evaluationContextProvider, parameters);
	}

	/**
	 * Creates a {@link QueryParameterSetter} from a {@link JpaParameter}. Handles named and indexed parameters,
	 * TemporalType annotations and might ignore certain exception when requested to do so.
	 *
	 * @param valueExtractor extracts the relevant value from an array of method parameter values.
	 * @param binding the binding of the query parameter to be set.
	 * @param parameter the method parameter to bind.
	 */
	private static QueryParameterSetter createSetter(Function<Object[], Object> valueExtractor, ParameterBinding binding,
			@Nullable JpaParameter parameter) {

		TemporalType temporalType = parameter != null && parameter.isTemporalParameter() //
				? parameter.getRequiredTemporalType() //
				: null;

		return new NamedOrIndexedQueryParameterSetter(valueExtractor.andThen(binding::prepare),
				ParameterImpl.of(parameter, binding), temporalType);
	}

	/**
	 * Handles bindings that are SpEL expressions by evaluating the expression to obtain a value.
	 *
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @since 2.0
	 */
	private static class ExpressionBasedQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final SpelExpressionParser parser;
		private final EvaluationContextProvider evaluationContextProvider;
		private final Parameters<?, ?> parameters;

		/**
		 * @param parser must not be {@literal null}.
		 * @param evaluationContextProvider must not be {@literal null}.
		 * @param parameters must not be {@literal null}.
		 */
		ExpressionBasedQueryParameterSetterFactory(SpelExpressionParser parser,
				EvaluationContextProvider evaluationContextProvider, Parameters<?, ?> parameters) {

			Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");
			Assert.notNull(parser, ""SpelExpressionParser must not be null!"");
			Assert.notNull(parameters, ""Parameters must not be null!"");

			this.evaluationContextProvider = evaluationContextProvider;
			this.parser = parser;
			this.parameters = parameters;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Nullable
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			if (!binding.isExpression()) {
				return null;
			}

			Expression expression = parser.parseExpression(binding.getExpression());

			return createSetter(values -> evaluateExpression(expression, values), binding, null);
		}

		/**
		 * Evaluates the given {@link Expression} against the given values.
		 *
		 * @param expression must not be {@literal null}.
		 * @param values must not be {@literal null}.
		 * @return the result of the evaluation.
		 */
		@Nullable
		private Object evaluateExpression(Expression expression, Object[] values) {

			EvaluationContext context = evaluationContextProvider.getEvaluationContext(parameters, values);
			Method escapeMethod = ReflectionUtils.findMethod(EscapeCharacter.class, ""escape"", String.class, String.class);

			Assert.notNull(escapeMethod, ""Escape method must not be null."");

			context.setVariable(""escape"", escapeMethod);
			return expression.getValue(context, Object.class);
		}
	}

	/**
	 * Extracts values for parameter bindings from method parameters. It handles named as well as indexed parameters.
	 *
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @since 2.0
	 */
	private static class BasicQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final JpaParameters parameters;

		/**
		 * @param parameters must not be {@literal null}.
		 */
		BasicQueryParameterSetterFactory(JpaParameters parameters) {

			Assert.notNull(parameters, ""JpaParameters must not be null!"");

			this.parameters = parameters;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			Assert.notNull(binding, ""Binding must not be null."");

			JpaParameter parameter;

			if (declaredQuery.hasNamedParameter()) {
				parameter = findParameterForBinding(binding);
			} else {

				int parameterIndex = binding.getRequiredPosition() - 1;
				JpaParameters bindableParameters = parameters.getBindableParameters();

				Assert.isTrue( //
						parameterIndex < bindableParameters.getNumberOfParameters(), //
						() -> String.format( //
								""At least %s parameter(s) provided but only %s parameter(s) present in query."", //
								binding.getRequiredPosition(), //
								bindableParameters.getNumberOfParameters() //
						) //
				);

				parameter = bindableParameters.getParameter(binding.getRequiredPosition() - 1);
			}

			return parameter == null //
					? QueryParameterSetter.NOOP //
					: createSetter(values -> getValue(values, parameter), binding, parameter);
		}

		@Nullable
		private JpaParameter findParameterForBinding(ParameterBinding binding) {

			return parameters.getBindableParameters().stream() //
					.filter(candidate -> binding.getRequiredName().equals(getName(candidate))) //
					.findFirst().orElse(null);
		}

		private Object getValue(Object[] values, Parameter parameter) {
			return new JpaParametersParameterAccessor(parameters, values).getValue(parameter);
		}

		private static String getName(JpaParameter p) {
			return p.getName().orElseThrow(() -> new IllegalStateException(ParameterBinder.PARAMETER_NEEDS_TO_BE_NAMED));
		}
	}

	/**
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @see QueryParameterSetterFactory
	 */
	private static class CriteriaQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final JpaParameters parameters;
		private final List<ParameterMetadata<?>> expressions;

		/**
		 * Creates a new {@link QueryParameterSetterFactory} from the given {@link JpaParameters} and
		 * {@link ParameterMetadata}.
		 *
		 * @param parameters must not be {@literal null}.
		 * @param metadata must not be {@literal null}.
		 */
		CriteriaQueryParameterSetterFactory(JpaParameters parameters, List<ParameterMetadata<?>> metadata) {

			Assert.notNull(parameters, ""JpaParameters must not be null!"");
			Assert.notNull(metadata, ""Expressions must not be null!"");

			this.parameters = parameters;
			this.expressions = metadata;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			int parameterIndex = binding.getRequiredPosition() - 1;

			Assert.isTrue( //
					parameterIndex < expressions.size(), //
					() -> String.format( //
							""At least %s parameter(s) provided but only %s parameter(s) present in query."", //
							binding.getRequiredPosition(), //
							expressions.size() //
					) //
			);

			ParameterMetadata<?> metadata = expressions.get(parameterIndex);

			if (metadata.isIsNullParameter()) {
				return QueryParameterSetter.NOOP;
			}

			JpaParameter parameter = parameters.getBindableParameter(parameterIndex);
			TemporalType temporalType = parameter.isTemporalParameter() ? parameter.getRequiredTemporalType() : null;

			return new NamedOrIndexedQueryParameterSetter(values -> getAndPrepare(parameter, metadata, values),
					metadata.getExpression(), temporalType);
		}

		@Nullable
		private Object getAndPrepare(JpaParameter parameter, ParameterMetadata<?> metadata, Object[] values) {

			JpaParametersParameterAccessor accessor = new JpaParametersParameterAccessor(parameters, values);

			return metadata.prepare(accessor.getValue(parameter));
		}
	}

	private static class ParameterImpl<T> implements javax.persistence.Parameter<T> {

		private final Class<T> parameterType;
		private final @Nullable String name;
		private final @Nullable Integer position;

		/**
		 * Creates a new {@link ParameterImpl} for the given {@link JpaParameter} and {@link ParameterBinding}.
		 *
		 * @param parameter can be {@literal null}.
		 * @param binding must not be {@literal null}.
		 * @return a {@link javax.persistence.Parameter} object based on the information from the arguments.
		 */
		static javax.persistence.Parameter<?> of(@Nullable JpaParameter parameter, ParameterBinding binding) {

			Class<?> type = parameter == null ? Object.class : parameter.getType();

			return new ParameterImpl<>(type, getName(parameter, binding), binding.getPosition());
		}

		/**
		 * Creates a new {@link ParameterImpl} for the given name, position and parameter type.
		 *
		 * @param parameterType must not be {@literal null}.
		 * @param name can be {@literal null}.
		 * @param position can be {@literal null}.
		 */
		private ParameterImpl(Class<T> parameterType, @Nullable String name, @Nullable Integer position) {

			this.name = name;
			this.position = position;
			this.parameterType = parameterType;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getName()
		 */
		@Nullable
		@Override
		public String getName() {
			return name;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getPosition()
		 */
		@Nullable
		@Override
		public Integer getPosition() {
			return position;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getParameterType()
		 */
		@Override
		public Class<T> getParameterType() {
			return parameterType;
		}

		@Nullable
		private static String getName(@Nullable JpaParameter parameter, ParameterBinding binding) {

			if (parameter == null) {
				return binding.getName();
			}

			return parameter.isNamedParameter() //
					? parameter.getName().orElseThrow(() -> new IllegalArgumentException(""o_O parameter needs to have a name!"")) //
					: null;
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactory.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import static org.springframework.data.querydsl.QuerydslUtils.*;

import lombok.extern.slf4j.Slf4j;

import java.util.Optional;

import javax.persistence.EntityManager;
import javax.persistence.Tuple;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.data.jpa.projection.CollectionAwareProjectionFactory;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.query.AbstractJpaQuery;
import org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy;
import org.springframework.data.jpa.repository.query.JpaQueryMethod;
import org.springframework.data.jpa.util.JpaMetamodel;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.querydsl.QuerydslPredicateExecutor;
import org.springframework.data.repository.core.RepositoryInformation;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.QueryCreationListener;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * JPA specific generic repository factory.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Christoph Strobl
 * @author Jens Schauder
 */
public class JpaRepositoryFactory extends RepositoryFactorySupport {

	private final EntityManager entityManager;
	private final QueryExtractor extractor;
	private final CrudMethodMetadataPostProcessor crudMethodMetadataPostProcessor;

	/**
	 * Creates a new {@link JpaRepositoryFactory}.
	 * 
	 * @param entityManager must not be {@literal null}
	 */
	public JpaRepositoryFactory(EntityManager entityManager) {

		Assert.notNull(entityManager, ""EntityManager must not be null!"");

		this.entityManager = entityManager;
		this.extractor = PersistenceProvider.fromEntityManager(entityManager);
		this.crudMethodMetadataPostProcessor = new CrudMethodMetadataPostProcessor();

		addRepositoryProxyPostProcessor(crudMethodMetadataPostProcessor);

		if (extractor.equals(PersistenceProvider.ECLIPSELINK)) {
			addQueryCreationListener(new EclipseLinkProjectionQueryCreationListener(entityManager));
		}
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#setBeanClassLoader(java.lang.ClassLoader)
	 */
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {

		super.setBeanClassLoader(classLoader);
		this.crudMethodMetadataPostProcessor.setBeanClassLoader(classLoader);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getTargetRepository(org.springframework.data.repository.core.RepositoryMetadata)
	 */
	@Override
	protected Object getTargetRepository(RepositoryInformation information) {

		SimpleJpaRepository<?, ?> repository = getTargetRepository(information, entityManager);
		repository.setRepositoryMethodMetadata(crudMethodMetadataPostProcessor.getCrudMethodMetadata());

		return repository;
	}

	/**
	 * Callback to create a {@link JpaRepository} instance with the given {@link EntityManager}
	 * 
	 * @param <T>
	 * @param <ID>
	 * @param entityManager
	 * @return
	 */
	protected SimpleJpaRepository<?, ?> getTargetRepository(RepositoryInformation information,
			EntityManager entityManager) {

		JpaEntityInformation<?, ?> entityInformation = getEntityInformation(information.getDomainType());

		return getTargetRepositoryViaReflection(information, entityInformation, entityManager);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getRepositoryBaseClass(org.springframework.data.repository.core.RepositoryMetadata)
	 */
	@Override
	protected Class<?> getRepositoryBaseClass(RepositoryMetadata metadata) {

		if (isQueryDslExecutor(metadata.getRepositoryInterface())) {
			return QuerydslJpaRepository.class;
		} else {
			return SimpleJpaRepository.class;
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getProjectionFactory(java.lang.ClassLoader, org.springframework.beans.factory.BeanFactory)
	 */
	@Override
	protected ProjectionFactory getProjectionFactory(ClassLoader classLoader, BeanFactory beanFactory) {

		CollectionAwareProjectionFactory factory = new CollectionAwareProjectionFactory();
		factory.setBeanClassLoader(classLoader);
		factory.setBeanFactory(beanFactory);

		return factory;
	}

	/**
	 * Returns whether the given repository interface requires a QueryDsl specific implementation to be chosen.
	 * 
	 * @param repositoryInterface
	 * @return
	 */
	private boolean isQueryDslExecutor(Class<?> repositoryInterface) {

		return QUERY_DSL_PRESENT && QuerydslPredicateExecutor.class.isAssignableFrom(repositoryInterface);
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getQueryLookupStrategy(org.springframework.data.repository.query.QueryLookupStrategy.Key, org.springframework.data.repository.query.EvaluationContextProvider)
	 */
	@Override
	protected Optional<QueryLookupStrategy> getQueryLookupStrategy(@Nullable Key key,
			EvaluationContextProvider evaluationContextProvider) {
		return Optional.of(JpaQueryLookupStrategy.create(entityManager, key, extractor, evaluationContextProvider));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getEntityInformation(java.lang.Class)
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public <T, ID> JpaEntityInformation<T, ID> getEntityInformation(Class<T> domainClass) {

		return (JpaEntityInformation<T, ID>) JpaEntityInformationSupport.getEntityInformation(domainClass, entityManager);
	}

	/**
	 * Query creation listener that informs EclipseLink users that they have to be extra careful when defining repository
	 * query methods using projections as we have to rely on the declaration order of the accessors in projection
	 * interfaces matching the order in columns. Alias-based mapping doesn't work with EclipseLink as it doesn't support
	 * {@link Tuple} based queries yet.
	 *
	 * @author Oliver Gierke
	 * @since 2.0.5
	 * @see https://bugs.eclipse.org/bugs/show_bug.cgi?id=289141
	 */
	@Slf4j
	private static class EclipseLinkProjectionQueryCreationListener implements QueryCreationListener<AbstractJpaQuery> {

		private static final String ECLIPSELINK_PROJECTIONS = ""Usage of Spring Data projections detected on persistence provider EclipseLink. Make sure the following query methods declare result columns in exactly the order the accessors are declared in the projecting interface or the order of parameters for DTOs:"";

		private final JpaMetamodel metamodel;

		private boolean warningLogged = false;

		/**
		 * Creates a new {@link EclipseLinkProjectionQueryCreationListener} for the given {@link EntityManager}.
		 * 
		 * @param em must not be {@literal null}.
		 */
		public EclipseLinkProjectionQueryCreationListener(EntityManager em) {

			Assert.notNull(em, ""EntityManager must not be null!"");

			this.metamodel = JpaMetamodel.of(em.getMetamodel());
		}

		/* 
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.core.support.QueryCreationListener#onCreation(org.springframework.data.repository.query.RepositoryQuery)
		 */
		@Override
		public void onCreation(AbstractJpaQuery query) {

			JpaQueryMethod queryMethod = query.getQueryMethod();
			ReturnedType type = queryMethod.getResultProcessor().getReturnedType();

			if (type.isProjecting() && !metamodel.isJpaManaged(type.getReturnedType())) {

				if (!warningLogged) {
					log.info(ECLIPSELINK_PROJECTIONS);
					this.warningLogged = true;
				}

				log.info("" - {}"", queryMethod);
			}
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactory.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import static org.springframework.data.querydsl.QuerydslUtils.*;

import lombok.extern.slf4j.Slf4j;

import java.util.Optional;

import javax.persistence.EntityManager;
import javax.persistence.Tuple;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.data.jpa.projection.CollectionAwareProjectionFactory;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.query.AbstractJpaQuery;
import org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy;
import org.springframework.data.jpa.repository.query.JpaQueryMethod;
import org.springframework.data.jpa.util.JpaMetamodel;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.querydsl.QuerydslPredicateExecutor;
import org.springframework.data.repository.core.RepositoryInformation;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.QueryCreationListener;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * JPA specific generic repository factory.
 *
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Christoph Strobl
 * @author Jens Schauder
 */
public class JpaRepositoryFactory extends RepositoryFactorySupport {

	private final EntityManager entityManager;
	private final QueryExtractor extractor;
	private final CrudMethodMetadataPostProcessor crudMethodMetadataPostProcessor;

	private EscapeCharacter escapeCharacter = EscapeCharacter.of('\\');

	/**
	 * Creates a new {@link JpaRepositoryFactory}.
	 *
	 * @param entityManager must not be {@literal null}
	 */
	public JpaRepositoryFactory(EntityManager entityManager) {

		Assert.notNull(entityManager, ""EntityManager must not be null!"");

		this.entityManager = entityManager;
		this.extractor = PersistenceProvider.fromEntityManager(entityManager);
		this.crudMethodMetadataPostProcessor = new CrudMethodMetadataPostProcessor();

		addRepositoryProxyPostProcessor(crudMethodMetadataPostProcessor);

		if (extractor.equals(PersistenceProvider.ECLIPSELINK)) {
			addQueryCreationListener(new EclipseLinkProjectionQueryCreationListener(entityManager));
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#setBeanClassLoader(java.lang.ClassLoader)
	 */
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {

		super.setBeanClassLoader(classLoader);
		this.crudMethodMetadataPostProcessor.setBeanClassLoader(classLoader);
	}

	/**
	 * Configures the escape character to be used for like-expressions created for derived queries.
	 *
	 * @param escapeCharacter a character used for escaping in certain like expressions.
	 */
	public void setEscapeCharacter(EscapeCharacter escapeCharacter) {
		this.escapeCharacter = escapeCharacter;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getTargetRepository(org.springframework.data.repository.core.RepositoryMetadata)
	 */
	@Override
	protected Object getTargetRepository(RepositoryInformation information) {

		SimpleJpaRepository<?, ?> repository = getTargetRepository(information, entityManager);
		repository.setRepositoryMethodMetadata(crudMethodMetadataPostProcessor.getCrudMethodMetadata());

		return repository;
	}

	/**
	 * Callback to create a {@link JpaRepository} instance with the given {@link EntityManager}
	 *
	 * @param <T>
	 * @param <ID>
	 * @param entityManager
	 * @return
	 */
	protected SimpleJpaRepository<?, ?> getTargetRepository(RepositoryInformation information,
			EntityManager entityManager) {

		JpaEntityInformation<?, ?> entityInformation = getEntityInformation(information.getDomainType());

		return getTargetRepositoryViaReflection(information, entityInformation, entityManager);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getRepositoryBaseClass(org.springframework.data.repository.core.RepositoryMetadata)
	 */
	@Override
	protected Class<?> getRepositoryBaseClass(RepositoryMetadata metadata) {

		if (isQueryDslExecutor(metadata.getRepositoryInterface())) {
			return QuerydslJpaRepository.class;
		} else {
			return SimpleJpaRepository.class;
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getProjectionFactory(java.lang.ClassLoader, org.springframework.beans.factory.BeanFactory)
	 */
	@Override
	protected ProjectionFactory getProjectionFactory(ClassLoader classLoader, BeanFactory beanFactory) {

		CollectionAwareProjectionFactory factory = new CollectionAwareProjectionFactory();
		factory.setBeanClassLoader(classLoader);
		factory.setBeanFactory(beanFactory);

		return factory;
	}

	/**
	 * Returns whether the given repository interface requires a QueryDsl specific implementation to be chosen.
	 *
	 * @param repositoryInterface
	 * @return
	 */
	private boolean isQueryDslExecutor(Class<?> repositoryInterface) {

		return QUERY_DSL_PRESENT && QuerydslPredicateExecutor.class.isAssignableFrom(repositoryInterface);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getQueryLookupStrategy(org.springframework.data.repository.query.QueryLookupStrategy.Key, org.springframework.data.repository.query.EvaluationContextProvider)
	 */
	@Override
	protected Optional<QueryLookupStrategy> getQueryLookupStrategy(@Nullable Key key,
			EvaluationContextProvider evaluationContextProvider) {
		return Optional
				.of(JpaQueryLookupStrategy.create(entityManager, key, extractor, evaluationContextProvider, escapeCharacter));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getEntityInformation(java.lang.Class)
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public <T, ID> JpaEntityInformation<T, ID> getEntityInformation(Class<T> domainClass) {

		return (JpaEntityInformation<T, ID>) JpaEntityInformationSupport.getEntityInformation(domainClass, entityManager);
	}

	/**
	 * Query creation listener that informs EclipseLink users that they have to be extra careful when defining repository
	 * query methods using projections as we have to rely on the declaration order of the accessors in projection
	 * interfaces matching the order in columns. Alias-based mapping doesn't work with EclipseLink as it doesn't support
	 * {@link Tuple} based queries yet.
	 *
	 * @author Oliver Gierke
	 * @since 2.0.5
	 * @see https://bugs.eclipse.org/bugs/show_bug.cgi?id=289141
	 */
	@Slf4j
	private static class EclipseLinkProjectionQueryCreationListener implements QueryCreationListener<AbstractJpaQuery> {

		private static final String ECLIPSELINK_PROJECTIONS = ""Usage of Spring Data projections detected on persistence provider EclipseLink. Make sure the following query methods declare result columns in exactly the order the accessors are declared in the projecting interface or the order of parameters for DTOs:"";

		private final JpaMetamodel metamodel;

		private boolean warningLogged = false;

		/**
		 * Creates a new {@link EclipseLinkProjectionQueryCreationListener} for the given {@link EntityManager}.
		 *
		 * @param em must not be {@literal null}.
		 */
		public EclipseLinkProjectionQueryCreationListener(EntityManager em) {

			Assert.notNull(em, ""EntityManager must not be null!"");

			this.metamodel = JpaMetamodel.of(em.getMetamodel());
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.core.support.QueryCreationListener#onCreation(org.springframework.data.repository.query.RepositoryQuery)
		 */
		@Override
		public void onCreation(AbstractJpaQuery query) {

			JpaQueryMethod queryMethod = query.getQueryMethod();
			ReturnedType type = queryMethod.getResultProcessor().getReturnedType();

			if (type.isProjecting() && !metamodel.isJpaManaged(type.getReturnedType())) {

				if (!warningLogged) {
					log.info(ECLIPSELINK_PROJECTIONS);
					this.warningLogged = true;
				}

				log.info("" - {}"", queryMethod);
			}
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryBean.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.springframework.data.mapping.context.MappingContext;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.core.support.TransactionalRepositoryFactoryBeanSupport;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Special adapter for Springs {@link org.springframework.beans.factory.FactoryBean} interface to allow easy setup of
 * repository factories via Spring configuration.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Mark Paluch
 * @param <T> the type of the repository
 */
public class JpaRepositoryFactoryBean<T extends Repository<S, ID>, S, ID>
		extends TransactionalRepositoryFactoryBeanSupport<T, S, ID> {

	private @Nullable EntityManager entityManager;

	/**
	 * Creates a new {@link JpaRepositoryFactoryBean} for the given repository interface.
	 *
	 * @param repositoryInterface must not be {@literal null}.
	 */
	public JpaRepositoryFactoryBean(Class<? extends T> repositoryInterface) {
		super(repositoryInterface);
	}

	/**
	 * The {@link EntityManager} to be used.
	 *
	 * @param entityManager the entityManager to set
	 */
	@PersistenceContext
	public void setEntityManager(EntityManager entityManager) {
		this.entityManager = entityManager;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport#setMappingContext(org.springframework.data.mapping.context.MappingContext)
	 */
	@Override
	public void setMappingContext(MappingContext<?, ?> mappingContext) {
		super.setMappingContext(mappingContext);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.springframework.data.repository.support.
	 * TransactionalRepositoryFactoryBeanSupport#doCreateRepositoryFactory()
	 */
	@Override
	protected RepositoryFactorySupport doCreateRepositoryFactory() {

		Assert.state(entityManager != null,""EntityManager must not be null!"");

		return createRepositoryFactory(entityManager);
	}

	/**
	 * Returns a {@link RepositoryFactorySupport}.
	 *
	 * @param entityManager
	 * @return
	 */
	protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {
		return new JpaRepositoryFactory(entityManager);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() {

		Assert.state(entityManager != null,""EntityManager must not be null!"");
		super.afterPropertiesSet();
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryBean.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.springframework.data.mapping.context.MappingContext;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.core.support.TransactionalRepositoryFactoryBeanSupport;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Special adapter for Springs {@link org.springframework.beans.factory.FactoryBean} interface to allow easy setup of
 * repository factories via Spring configuration.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Mark Paluch
 * @param <T> the type of the repository
 */
public class JpaRepositoryFactoryBean<T extends Repository<S, ID>, S, ID>
		extends TransactionalRepositoryFactoryBeanSupport<T, S, ID> {

	private @Nullable EntityManager entityManager;
	/**
	 * Creates a new {@link JpaRepositoryFactoryBean} for the given repository interface.
	 *
	 * @param repositoryInterface must not be {@literal null}.
	 */
	public JpaRepositoryFactoryBean(Class<? extends T> repositoryInterface) {
		super(repositoryInterface);
	}

	/**
	 * The {@link EntityManager} to be used.
	 *
	 * @param entityManager the entityManager to set
	 */
	@PersistenceContext
	public void setEntityManager(EntityManager entityManager) {
		this.entityManager = entityManager;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport#setMappingContext(org.springframework.data.mapping.context.MappingContext)
	 */
	@Override
	public void setMappingContext(MappingContext<?, ?> mappingContext) {
		super.setMappingContext(mappingContext);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.springframework.data.repository.support.
	 * TransactionalRepositoryFactoryBeanSupport#doCreateRepositoryFactory()
	 */
	@Override
	protected RepositoryFactorySupport doCreateRepositoryFactory() {

		Assert.state(entityManager != null,""EntityManager must not be null!"");

		return createRepositoryFactory(entityManager);
	}

	/**
	 * Returns a {@link RepositoryFactorySupport}.
	 *
	 * @param entityManager
	 * @return
	 */
	protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {

		JpaRepositoryFactory jpaRepositoryFactory = new JpaRepositoryFactory(entityManager);
		jpaRepositoryFactory.setEscapeCharacter(escapeCharacter);

		return jpaRepositoryFactory;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() {

		Assert.state(entityManager != null,""EntityManager must not be null!"");
		super.afterPropertiesSet();
	}

	public void setEscapeCharacter(char escapeCharacter) {

		this.escapeCharacter = EscapeCharacter.of(escapeCharacter);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/UserRepositoryFinderTests.java,"/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;
import static org.springframework.data.domain.Sort.Direction.*;

import java.util.Arrays;
import java.util.List;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.InvalidDataAccessApiUsageException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.sample.RoleRepository;
import org.springframework.data.jpa.repository.sample.UserRepository;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * Integration test for executing finders, thus testing various query lookup strategies.
 * 
 * @see QueryLookupStrategy
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = ""classpath:config/namespace-application-context.xml"")
@Transactional
public class UserRepositoryFinderTests {

	@Autowired UserRepository userRepository;
	@Autowired RoleRepository roleRepository;

	User dave, carter, oliver;
	Role drummer, guitarist, singer;

	@Before
	public void setUp() {

		drummer = roleRepository.save(new Role(""DRUMMER""));
		guitarist = roleRepository.save(new Role(""GUITARIST""));
		singer = roleRepository.save(new Role(""SINGER""));

		dave = userRepository.save(new User(""Dave"", ""Matthews"", ""dave@dmband.com"", singer));
		carter = userRepository.save(new User(""Carter"", ""Beauford"", ""carter@dmband.com"", singer, drummer));
		oliver = userRepository.save(new User(""Oliver August"", ""Matthews"", ""oliver@dmband.com""));
	}

	@After
	public void clearUp() {

		userRepository.deleteAll();
		roleRepository.deleteAll();
	}

	/**
	 * Tests creation of a simple query.
	 */
	@Test
	public void testSimpleCustomCreatedFinder() {

		User user = userRepository.findByEmailAddressAndLastname(""dave@dmband.com"", ""Matthews"");
		assertEquals(dave, user);
	}

	/**
	 * Tests that the repository returns {@code null} for not found objects for finder methods that return a single domain
	 * object.
	 */
	@Test
	public void returnsNullIfNothingFound() {

		User user = userRepository.findByEmailAddress(""foobar"");
		assertEquals(null, user);
	}

	/**
	 * Tests creation of a simple query consisting of {@code AND} and {@code OR} parts.
	 */
	@Test
	public void testAndOrFinder() {

		List<User> users = userRepository.findByEmailAddressAndLastnameOrFirstname(""dave@dmband.com"", ""Matthews"", ""Carter"");

		assertNotNull(users);
		assertEquals(2, users.size());
		assertTrue(users.contains(dave));
		assertTrue(users.contains(carter));
	}

	@Test
	public void executesPagingMethodToPageCorrectly() {

		Page<User> page = userRepository.findByLastname(PageRequest.of(0, 1), ""Matthews"");
		assertThat(page.getNumberOfElements(), is(1));
		assertThat(page.getTotalElements(), is(2L));
		assertThat(page.getTotalPages(), is(2));
	}

	@Test
	public void executesPagingMethodToListCorrectly() {

		List<User> list = userRepository.findByFirstname(""Carter"", PageRequest.of(0, 1));
		assertThat(list.size(), is(1));
	}

	@Test
	public void executesInKeywordForPageCorrectly() {

		Page<User> page = userRepository.findByFirstnameIn(PageRequest.of(0, 1), ""Dave"", ""Oliver August"");

		assertThat(page.getNumberOfElements(), is(1));
		assertThat(page.getTotalElements(), is(2L));
		assertThat(page.getTotalPages(), is(2));
	}

	@Test
	public void executesNotInQueryCorrectly() throws Exception {

		List<User> result = userRepository.findByFirstnameNotIn(Arrays.asList(""Dave"", ""Carter""));
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(oliver));
	}

	@Test // DATAJPA-92
	public void findsByLastnameIgnoringCase() throws Exception {
		List<User> result = userRepository.findByLastnameIgnoringCase(""BeAUfoRd"");
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(carter));
	}

	@Test // DATAJPA-92
	public void findsByLastnameIgnoringCaseLike() throws Exception {
		List<User> result = userRepository.findByLastnameIgnoringCaseLike(""BeAUfo%"");
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(carter));
	}

	@Test // DATAJPA-92
	public void findByLastnameAndFirstnameAllIgnoringCase() throws Exception {
		List<User> result = userRepository.findByLastnameAndFirstnameAllIgnoringCase(""MaTTheWs"", ""DaVe"");
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(dave));
	}

	@Test // DATAJPA-94
	public void respectsPageableOrderOnQueryGenerateFromMethodName() throws Exception {
		Page<User> ascending = userRepository.findByLastnameIgnoringCase(PageRequest.of(0, 10, Sort.by(ASC, ""firstname"")),
				""Matthews"");
		Page<User> descending = userRepository.findByLastnameIgnoringCase(PageRequest.of(0, 10, Sort.by(DESC, ""firstname"")),
				""Matthews"");
		assertThat(ascending.getTotalElements(), is(2L));
		assertThat(descending.getTotalElements(), is(2L));
		assertThat(ascending.getContent().get(0).getFirstname(),
				is(not(equalTo(descending.getContent().get(0).getFirstname()))));
		assertThat(ascending.getContent().get(0).getFirstname(),
				is(equalTo(descending.getContent().get(1).getFirstname())));
		assertThat(ascending.getContent().get(1).getFirstname(),
				is(equalTo(descending.getContent().get(0).getFirstname())));
	}

	@Test // DATAJPA-486
	public void executesQueryToSlice() {

		Slice<User> slice = userRepository.findSliceByLastname(""Matthews"", PageRequest.of(0, 1, ASC, ""firstname""));

		assertThat(slice.getContent(), hasItem(dave));
		assertThat(slice.hasNext(), is(true));
	}

	@Test // DATAJPA-830
	public void executesMethodWithNotContainingOnStringCorrectly() {
		assertThat(userRepository.findByLastnameNotContaining(""u""), containsInAnyOrder(dave, oliver));
	}

	@Test // DATAJPA-829
	public void translatesContainsToMemberOf() {

		List<User> singers = userRepository.findByRolesContaining(singer);

		assertThat(singers, hasSize(2));
		assertThat(singers, hasItems(dave, carter));
		assertThat(userRepository.findByRolesContaining(drummer), contains(carter));
	}

	@Test // DATAJPA-829
	public void translatesNotContainsToNotMemberOf() {
		assertThat(userRepository.findByRolesNotContaining(drummer), hasItems(dave, oliver));
	}

	@Test // DATAJPA-974
	public void executesQueryWithProjectionContainingReferenceToPluralAttribute() {
		assertThat(userRepository.findRolesAndFirstnameBy(), is(notNullValue()));
	}

	@Test(expected = InvalidDataAccessApiUsageException.class) // DATAJPA-1023, DATACMNS-959
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	public void rejectsStreamExecutionIfNoSurroundingTransactionActive() {
		userRepository.findAllByCustomQueryAndStream();
	}

	@Test // DATAJPA-1334
	public void executesNamedQueryWithConstructorExpression() {
		userRepository.findByNamedQueryWithConstructorExpression();
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/UserRepositoryFinderTests.java,"/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;
import static org.springframework.data.domain.Sort.Direction.*;

import java.util.Arrays;
import java.util.List;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.InvalidDataAccessApiUsageException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.sample.RoleRepository;
import org.springframework.data.jpa.repository.sample.UserRepository;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * Integration test for executing finders, thus testing various query lookup strategies.
 * 
 * @see QueryLookupStrategy
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = ""classpath:config/namespace-application-context.xml"")
@Transactional
public class UserRepositoryFinderTests {

	@Autowired UserRepository userRepository;
	@Autowired RoleRepository roleRepository;

	User dave, carter, oliver;
	Role drummer, guitarist, singer;

	@Before
	public void setUp() {

		drummer = roleRepository.save(new Role(""DRUMMER""));
		guitarist = roleRepository.save(new Role(""GUITARIST""));
		singer = roleRepository.save(new Role(""SINGER""));

		dave = userRepository.save(new User(""Dave"", ""Matthews"", ""dave@dmband.com"", singer));
		carter = userRepository.save(new User(""Carter"", ""Beauford"", ""carter@dmband.com"", singer, drummer));
		oliver = userRepository.save(new User(""Oliver August"", ""Matthews"", ""oliver@dmband.com""));
	}

	@After
	public void clearUp() {

		userRepository.deleteAll();
		roleRepository.deleteAll();
	}

	/**
	 * Tests creation of a simple query.
	 */
	@Test
	public void testSimpleCustomCreatedFinder() {

		User user = userRepository.findByEmailAddressAndLastname(""dave@dmband.com"", ""Matthews"");
		assertEquals(dave, user);
	}

	/**
	 * Tests that the repository returns {@code null} for not found objects for finder methods that return a single domain
	 * object.
	 */
	@Test
	public void returnsNullIfNothingFound() {

		User user = userRepository.findByEmailAddress(""foobar"");
		assertEquals(null, user);
	}

	/**
	 * Tests creation of a simple query consisting of {@code AND} and {@code OR} parts.
	 */
	@Test
	public void testAndOrFinder() {

		List<User> users = userRepository.findByEmailAddressAndLastnameOrFirstname(""dave@dmband.com"", ""Matthews"", ""Carter"");

		assertNotNull(users);
		assertEquals(2, users.size());
		assertTrue(users.contains(dave));
		assertTrue(users.contains(carter));
	}

	@Test
	public void executesPagingMethodToPageCorrectly() {

		Page<User> page = userRepository.findByLastname(PageRequest.of(0, 1), ""Matthews"");
		assertThat(page.getNumberOfElements(), is(1));
		assertThat(page.getTotalElements(), is(2L));
		assertThat(page.getTotalPages(), is(2));
	}

	@Test
	public void executesPagingMethodToListCorrectly() {

		List<User> list = userRepository.findByFirstname(""Carter"", PageRequest.of(0, 1));
		assertThat(list.size(), is(1));
	}

	@Test
	public void executesInKeywordForPageCorrectly() {

		Page<User> page = userRepository.findByFirstnameIn(PageRequest.of(0, 1), ""Dave"", ""Oliver August"");

		assertThat(page.getNumberOfElements(), is(1));
		assertThat(page.getTotalElements(), is(2L));
		assertThat(page.getTotalPages(), is(2));
	}

	@Test
	public void executesNotInQueryCorrectly() throws Exception {

		List<User> result = userRepository.findByFirstnameNotIn(Arrays.asList(""Dave"", ""Carter""));
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(oliver));
	}

	@Test // DATAJPA-92
	public void findsByLastnameIgnoringCase() throws Exception {
		List<User> result = userRepository.findByLastnameIgnoringCase(""BeAUfoRd"");
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(carter));
	}

	@Test // DATAJPA-92
	public void findsByLastnameIgnoringCaseLike() throws Exception {
		List<User> result = userRepository.findByLastnameIgnoringCaseLike(""BeAUfo%"");
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(carter));
	}

	@Test // DATAJPA-92
	public void findByLastnameAndFirstnameAllIgnoringCase() throws Exception {
		List<User> result = userRepository.findByLastnameAndFirstnameAllIgnoringCase(""MaTTheWs"", ""DaVe"");
		assertThat(result.size(), is(1));
		assertThat(result.get(0), is(dave));
	}

	@Test // DATAJPA-94
	public void respectsPageableOrderOnQueryGenerateFromMethodName() throws Exception {
		Page<User> ascending = userRepository.findByLastnameIgnoringCase(PageRequest.of(0, 10, Sort.by(ASC, ""firstname"")),
				""Matthews"");
		Page<User> descending = userRepository.findByLastnameIgnoringCase(PageRequest.of(0, 10, Sort.by(DESC, ""firstname"")),
				""Matthews"");
		assertThat(ascending.getTotalElements(), is(2L));
		assertThat(descending.getTotalElements(), is(2L));
		assertThat(ascending.getContent().get(0).getFirstname(),
				is(not(equalTo(descending.getContent().get(0).getFirstname()))));
		assertThat(ascending.getContent().get(0).getFirstname(),
				is(equalTo(descending.getContent().get(1).getFirstname())));
		assertThat(ascending.getContent().get(1).getFirstname(),
				is(equalTo(descending.getContent().get(0).getFirstname())));
	}

	@Test // DATAJPA-486
	public void executesQueryToSlice() {

		Slice<User> slice = userRepository.findSliceByLastname(""Matthews"", PageRequest.of(0, 1, ASC, ""firstname""));

		assertThat(slice.getContent(), hasItem(dave));
		assertThat(slice.hasNext(), is(true));
	}

	@Test // DATAJPA-830
	public void executesMethodWithNotContainingOnStringCorrectly() {
		assertThat(userRepository.findByLastnameNotContaining(""u""), containsInAnyOrder(dave, oliver));
	}

	@Test // DATAJPA-1519
	public void parametersForContainsGetProperlyEscaped() {
		assertThat(userRepository.findByFirstnameContaining(""liv%""), iterableWithSize(0));
	}

	@Test // DATAJPA-1519
	public void escapingInLikeSpels() {
		assertThat(userRepository.findContainingEscaped(""att_""), iterableWithSize(0));
	}

	@Test // DATAJPA-829
	public void translatesContainsToMemberOf() {

		List<User> singers = userRepository.findByRolesContaining(singer);

		assertThat(singers, hasSize(2));
		assertThat(singers, hasItems(dave, carter));
		assertThat(userRepository.findByRolesContaining(drummer), contains(carter));
	}

	@Test // DATAJPA-829
	public void translatesNotContainsToNotMemberOf() {
		assertThat(userRepository.findByRolesNotContaining(drummer), hasItems(dave, oliver));
	}

	@Test // DATAJPA-974
	public void executesQueryWithProjectionContainingReferenceToPluralAttribute() {
		assertThat(userRepository.findRolesAndFirstnameBy(), is(notNullValue()));
	}

	@Test(expected = InvalidDataAccessApiUsageException.class) // DATAJPA-1023, DATACMNS-959
	@Transactional(propagation = Propagation.NOT_SUPPORTED)
	public void rejectsStreamExecutionIfNoSurroundingTransactionActive() {
		userRepository.findAllByCustomQueryAndStream();
	}

	@Test // DATAJPA-1334
	public void executesNamedQueryWithConstructorExpression() {
		userRepository.findByNamedQueryWithConstructorExpression();
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaCountQueryCreatorIntegrationTests.java,"/*
 * Copyright 2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.AbstractRepositoryMetadata;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link JpaCountQueryCreator}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class JpaCountQueryCreatorIntegrationTests {

	@PersistenceContext EntityManager entityManager;

	@Test // DATAJPA-1044
	public void distinctFlagOnCountQueryIssuesCountDistinct() throws Exception {

		Method method = SomeRepository.class.getMethod(""findDistinctByRolesIn"", List.class);

		PersistenceProvider provider = PersistenceProvider.fromEntityManager(entityManager);
		JpaQueryMethod queryMethod = new JpaQueryMethod(method,
				AbstractRepositoryMetadata.getMetadata(SomeRepository.class), new SpelAwareProxyProjectionFactory(), provider);

		PartTree tree = new PartTree(""findDistinctByRolesIn"", User.class);
		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(entityManager.getCriteriaBuilder(),
				queryMethod.getParameters(), provider);

		JpaCountQueryCreator creator = new JpaCountQueryCreator(tree, queryMethod.getResultProcessor().getReturnedType(),
				entityManager.getCriteriaBuilder(), metadataProvider);

		TypedQuery<? extends Object> query = entityManager.createQuery(creator.createQuery());

		assertThat(HibernateUtils.getHibernateQuery(query), startsWith(""select distinct count(distinct""));
	}

	interface SomeRepository extends Repository<User, Long> {
		void findDistinctByRolesIn(List<Role> roles);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaCountQueryCreatorIntegrationTests.java,"/*
 * Copyright 2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.AbstractRepositoryMetadata;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link JpaCountQueryCreator}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class JpaCountQueryCreatorIntegrationTests {

	@PersistenceContext EntityManager entityManager;

	@Test // DATAJPA-1044
	public void distinctFlagOnCountQueryIssuesCountDistinct() throws Exception {

		Method method = SomeRepository.class.getMethod(""findDistinctByRolesIn"", List.class);

		PersistenceProvider provider = PersistenceProvider.fromEntityManager(entityManager);
		JpaQueryMethod queryMethod = new JpaQueryMethod(method,
				AbstractRepositoryMetadata.getMetadata(SomeRepository.class), new SpelAwareProxyProjectionFactory(), provider);

		PartTree tree = new PartTree(""findDistinctByRolesIn"", User.class);
		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(entityManager.getCriteriaBuilder(),
				queryMethod.getParameters(), provider, EscapeCharacter.of('\\'));

		JpaCountQueryCreator creator = new JpaCountQueryCreator(tree, queryMethod.getResultProcessor().getReturnedType(),
				entityManager.getCriteriaBuilder(), metadataProvider);

		TypedQuery<? extends Object> query = entityManager.createQuery(creator.createQuery());

		assertThat(HibernateUtils.getHibernateQuery(query), startsWith(""select distinct count(distinct""));
	}

	interface SomeRepository extends Repository<User, Long> {
		void findDistinctByRolesIn(List<Role> roles);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategyUnitTests.java,"/*
 * Copyright 2012-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.metamodel.Metamodel;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.DefaultEvaluationContextProvider;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;

/**
 * Unit tests for {@link JpaQueryLookupStrategy}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Jens Schauder
 */
@RunWith(MockitoJUnitRunner.class)
public class JpaQueryLookupStrategyUnitTests {

	private static final EvaluationContextProvider EVALUATION_CONTEXT_PROVIDER = DefaultEvaluationContextProvider.INSTANCE;
	@Mock EntityManager em;
	@Mock EntityManagerFactory emf;
	@Mock QueryExtractor extractor;
	@Mock NamedQueries namedQueries;
	@Mock Metamodel metamodel;
	@Mock ProjectionFactory projectionFactory;

	@Before
	public void setUp() {

		when(em.getMetamodel()).thenReturn(metamodel);
		when(em.getEntityManagerFactory()).thenReturn(emf);
		when(emf.createEntityManager()).thenReturn(em);
		when(em.getDelegate()).thenReturn(em);
	}

	@Test // DATAJPA-226
	public void invalidAnnotatedQueryCausesException() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER);
		Method method = UserRepository.class.getMethod(""findByFoo"", String.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		Throwable reference = new RuntimeException();
		when(em.createQuery(anyString())).thenThrow(reference);

		assertThatExceptionOfType(IllegalArgumentException.class)
				.isThrownBy(() -> strategy.resolveQuery(method, metadata, projectionFactory, namedQueries))
				.withCause(reference);
	}

	@Test // DATAJPA-554
	public void sholdThrowMorePreciseExceptionIfTryingToUsePaginationInNativeQueries() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER);
		Method method = UserRepository.class.getMethod(""findByInvalidNativeQuery"", String.class, Sort.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		assertThatExceptionOfType(InvalidJpaQueryMethodException.class)
				.isThrownBy(() -> strategy.resolveQuery(method, metadata, projectionFactory, namedQueries))
				.withMessageContaining(""Cannot use native queries with dynamic sorting in method"")
				.withMessageContaining(method.toString());
	}

	interface UserRepository extends Repository<User, Long> {

		@Query(""something absurd"")
		User findByFoo(String foo);

		@Query(value = ""select u.* from User u"", nativeQuery = true)
		List<User> findByInvalidNativeQuery(String param, Sort sort);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategyUnitTests.java,"/*
 * Copyright 2012-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.metamodel.Metamodel;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.DefaultEvaluationContextProvider;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;

/**
 * Unit tests for {@link JpaQueryLookupStrategy}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Jens Schauder
 */
@RunWith(MockitoJUnitRunner.class)
public class JpaQueryLookupStrategyUnitTests {

	private static final EvaluationContextProvider EVALUATION_CONTEXT_PROVIDER = DefaultEvaluationContextProvider.INSTANCE;
	@Mock EntityManager em;
	@Mock EntityManagerFactory emf;
	@Mock QueryExtractor extractor;
	@Mock NamedQueries namedQueries;
	@Mock Metamodel metamodel;
	@Mock ProjectionFactory projectionFactory;

	@Before
	public void setUp() {

		when(em.getMetamodel()).thenReturn(metamodel);
		when(em.getEntityManagerFactory()).thenReturn(emf);
		when(emf.createEntityManager()).thenReturn(em);
		when(em.getDelegate()).thenReturn(em);
	}

	@Test // DATAJPA-226
	public void invalidAnnotatedQueryCausesException() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER, EscapeCharacter.of('\\'));
		Method method = UserRepository.class.getMethod(""findByFoo"", String.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		Throwable reference = new RuntimeException();
		when(em.createQuery(anyString())).thenThrow(reference);

		assertThatExceptionOfType(IllegalArgumentException.class)
				.isThrownBy(() -> strategy.resolveQuery(method, metadata, projectionFactory, namedQueries))
				.withCause(reference);
	}

	@Test // DATAJPA-554
	public void sholdThrowMorePreciseExceptionIfTryingToUsePaginationInNativeQueries() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER, EscapeCharacter.of('\\'));
		Method method = UserRepository.class.getMethod(""findByInvalidNativeQuery"", String.class, Sort.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		assertThatExceptionOfType(InvalidJpaQueryMethodException.class)
				.isThrownBy(() -> strategy.resolveQuery(method, metadata, projectionFactory, namedQueries))
				.withMessageContaining(""Cannot use native queries with dynamic sorting in method"")
				.withMessageContaining(method.toString());
	}

	interface UserRepository extends Repository<User, Long> {

		@Query(""something absurd"")
		User findByFoo(String foo);

		@Query(value = ""select u.* from User u"", nativeQuery = true)
		List<User> findByInvalidNativeQuery(String param, Sort sort);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterExpressionProviderTests.java,"/*
 * Copyright 2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.repository.query.DefaultParameters;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterExpressionProviderTests {

	@PersistenceContext EntityManager em;

	@Test // DATADOC-99
	@SuppressWarnings(""rawtypes"")
	public void createsParameterExpressionWithMostConcreteType() throws Exception {

		Method method = SampleRepository.class.getMethod(""findByIdGreaterThan"", int.class);
		Parameters<?, ?> parameters = new DefaultParameters(method);
		ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, new Object[] { 1 });
		Part part = new Part(""IdGreaterThan"", User.class);

		CriteriaBuilder builder = em.getCriteriaBuilder();
		PersistenceProvider persistenceProvider = PersistenceProvider.fromEntityManager(em);
		ParameterMetadataProvider provider = new ParameterMetadataProvider(builder, accessor, persistenceProvider);
		ParameterExpression<? extends Comparable> expression = provider.next(part, Comparable.class).getExpression();
		assertThat(expression.getParameterType(), is(typeCompatibleWith(int.class)));
	}

	interface SampleRepository {

		User findByIdGreaterThan(int id);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterExpressionProviderTests.java,"/*
 * Copyright 2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.DefaultParameters;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterExpressionProviderTests {

	@PersistenceContext EntityManager em;

	@Test // DATADOC-99
	@SuppressWarnings(""rawtypes"")
	public void createsParameterExpressionWithMostConcreteType() throws Exception {

		Method method = SampleRepository.class.getMethod(""findByIdGreaterThan"", int.class);
		Parameters<?, ?> parameters = new DefaultParameters(method);
		ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, new Object[] { 1 });
		Part part = new Part(""IdGreaterThan"", User.class);

		CriteriaBuilder builder = em.getCriteriaBuilder();
		PersistenceProvider persistenceProvider = PersistenceProvider.fromEntityManager(em);
		ParameterMetadataProvider provider = new ParameterMetadataProvider(builder, accessor, persistenceProvider, EscapeCharacter.of('\\'));
		ParameterExpression<? extends Comparable> expression = provider.next(part, Comparable.class).getExpression();
		assertThat(expression.getParameterType(), is(typeCompatibleWith(int.class)));
	}

	interface SampleRepository {

		User findByIdGreaterThan(int id);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderIntegrationTests.java,"/*
 * Copyright 2015-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.assertThat;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.repository.query.Param;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.util.ReflectionTestUtils;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 * @author Jens Schauder
 * @soundtrack Elephants Crossing - We are (Irrelephant)
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterMetadataProviderIntegrationTests {

	@PersistenceContext EntityManager em;

	@Test // DATAJPA-758
	public void forwardsParameterNameIfTransparentlyNamed() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByFirstname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""firstname"", User.class));

		assertThat(metadata.getExpression().getName()).isEqualTo(""name"");
	}

	@Test // DATAJPA-758
	public void forwardsParameterNameIfExplicitlyAnnotated() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByLastname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""lastname"", User.class));

		assertThat(metadata.getExpression().getName()).isNull();
	}

	@Test // DATAJPA-772
	public void doesNotApplyLikeExpansionOnNonStringProperties() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByAgeContaining"", Integer.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""ageContaining"", User.class));

		assertThat(metadata.prepare(1)).isEqualTo(1);
	}

	private ParameterMetadataProvider createProvider(Method method) {

		JpaParameters parameters = new JpaParameters(method);
		simulateDiscoveredParametername(parameters);

		return new ParameterMetadataProvider(em.getCriteriaBuilder(), parameters,
				PersistenceProvider.fromEntityManager(em));
	}

	@SuppressWarnings({ ""unchecked"", ""ConstantConditions"" })
	private static void simulateDiscoveredParametername(Parameters<?, ?> parameters) {

		List<Object> list = (List<Object>) ReflectionTestUtils.getField(parameters, ""parameters"");
		Object parameter = ReflectionTestUtils.getField(list.get(0), ""parameter"");
		ReflectionTestUtils.setField(parameter, ""parameterName"", ""name"");
	}

	interface Sample {

		User findByFirstname(@Param(""name"") String firstname);

		User findByLastname(String lastname);

		User findByAgeContaining(@Param(""age"") Integer age);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderIntegrationTests.java,"/*
 * Copyright 2015-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.Param;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.util.ReflectionTestUtils;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 * @author Jens Schauder
 * @soundtrack Elephants Crossing - We are (Irrelephant)
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterMetadataProviderIntegrationTests {

	@PersistenceContext EntityManager em;

	@Test // DATAJPA-758
	public void forwardsParameterNameIfTransparentlyNamed() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByFirstname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""firstname"", User.class));

		assertThat(metadata.getExpression().getName()).isEqualTo(""name"");
	}

	@Test // DATAJPA-758
	public void forwardsParameterNameIfExplicitlyAnnotated() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByLastname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""lastname"", User.class));

		assertThat(metadata.getExpression().getName()).isNull();
	}

	@Test // DATAJPA-772
	public void doesNotApplyLikeExpansionOnNonStringProperties() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByAgeContaining"", Integer.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""ageContaining"", User.class));

		assertThat(metadata.prepare(1)).isEqualTo(1);
	}

	private ParameterMetadataProvider createProvider(Method method) {

		JpaParameters parameters = new JpaParameters(method);
		simulateDiscoveredParametername(parameters);

		return new ParameterMetadataProvider(em.getCriteriaBuilder(), parameters,
				PersistenceProvider.fromEntityManager(em), EscapeCharacter.of('\\'));
	}

	@SuppressWarnings({ ""unchecked"", ""ConstantConditions"" })
	private static void simulateDiscoveredParametername(Parameters<?, ?> parameters) {

		List<Object> list = (List<Object>) ReflectionTestUtils.getField(parameters, ""parameters"");
		Object parameter = ReflectionTestUtils.getField(list.get(0), ""parameter"");
		ReflectionTestUtils.setField(parameter, ""parameterName"", ""name"");
	}

	interface Sample {

		User findByFirstname(@Param(""name"") String firstname);

		User findByLastname(String lastname);

		User findByAgeContaining(@Param(""age"") Integer age);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderUnitTests.java,"/*
 * Copyright 2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.mockito.Mockito.*;

import java.util.Collections;

import javax.persistence.criteria.CriteriaBuilder;

import org.junit.Test;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;

/**
 * Unit tests for {@link ParameterMetadataProvider}.
 *
 * @author Jens Schauder
 */
public class ParameterMetadataProviderUnitTests {

	@Test // DATAJPA-863
	public void errorMessageMentionesParametersWhenParametersAreExhausted() {

		PersistenceProvider persistenceProvider = mock(PersistenceProvider.class);
		CriteriaBuilder builder = mock(CriteriaBuilder.class);

		Parameters<?, ?> parameters = mock(Parameters.class, RETURNS_DEEP_STUBS);
		when(parameters.getBindableParameters().iterator()).thenReturn(Collections.emptyListIterator());

		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(builder, parameters,
				persistenceProvider);

		assertThatExceptionOfType(RuntimeException.class) //
				.isThrownBy(() -> metadataProvider.next(mock(Part.class))) //
                .withMessageContaining(""parameter"");
	}

}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderUnitTests.java,"/*
 * Copyright 2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.Collections;

import javax.persistence.criteria.CriteriaBuilder;

import org.junit.Test;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;

/**
 * Unit tests for {@link ParameterMetadataProvider}.
 *
 * @author Jens Schauder
 */
public class ParameterMetadataProviderUnitTests {

	@Test // DATAJPA-863
	public void errorMessageMentionesParametersWhenParametersAreExhausted() {

		PersistenceProvider persistenceProvider = mock(PersistenceProvider.class);
		CriteriaBuilder builder = mock(CriteriaBuilder.class);

		Parameters<?, ?> parameters = mock(Parameters.class, RETURNS_DEEP_STUBS);
		when(parameters.getBindableParameters().iterator()).thenReturn(Collections.emptyListIterator());

		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(builder, parameters,
				persistenceProvider, EscapeCharacter.of('\\'));

		assertThatExceptionOfType(RuntimeException.class) //
				.isThrownBy(() -> metadataProvider.next(mock(Part.class))) //
                .withMessageContaining(""parameter"");
	}

}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/PartTreeJpaQueryIntegrationTests.java,"/*
 * Copyright 2011-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License
import org.springframework.aop.framework.Advised;
"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.*;
import static org.springframework.test.util.ReflectionTestUtils.*;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.TemporalType;

import org.hibernate.Version;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.Temporal;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.Param;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.util.Assert;

/**
 * Integration tests for {@link PartTreeJpaQuery}.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Michael Cramer
 * @author Jens Schauder
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class PartTreeJpaQueryIntegrationTests {

	private static String PROPERTY = ""h.target."" + getQueryProperty();

	@Rule public ExpectedException thrown = ExpectedException.none();

	@PersistenceContext EntityManager entityManager;

	PersistenceProvider provider;

	@Before
	public void setUp() {
		this.provider = PersistenceProvider.fromEntityManager(entityManager);
	}

	@Test // DATADOC-90
	public void test() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider);

		jpaQuery.createQuery(new Object[] { ""Matthews"", PageRequest.of(0, 1) });
		jpaQuery.createQuery(new Object[] { ""Matthews"", PageRequest.of(0, 1) });
	}

	@Test
	public void cannotIgnoreCaseIfNotString() throws Exception {

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""Unable to ignore case of java.lang.Integer types, the property 'id' must reference a String"");
		testIgnoreCase(""findByIdIgnoringCase"", 3);
	}

	@Test
	public void cannotIgnoreCaseIfNotStringUnlessIgnoringAll() throws Exception {

		testIgnoreCase(""findByIdAllIgnoringCase"", 3);
	}

	@Test // DATAJPA-121
	public void recreatesQueryIfNullValueIsGiven() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider);

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"", PageRequest.of(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""firstname=:param0"");

		query = jpaQuery.createQuery(new Object[] { null, PageRequest.of(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""firstname is null"");
	}

	@Test // DATAJPA-920
	public void shouldLimitExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider);

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(query.getMaxResults()).isEqualTo(1);
	}

	@Test // DATAJPA-920
	public void shouldSelectAliasedIdForExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider);

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).contains("".id from User as"");
	}

	@Test // DATAJPA-1074
	public void isEmptyCollection() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByRolesIsEmpty"");
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider);

		Query query = jpaQuery.createQuery(new Object[] {});

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""roles is empty"");
	}

	@Test // DATAJPA-1074
	public void isNotEmptyCollection() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByRolesIsNotEmpty"");
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider);

		Query query = jpaQuery.createQuery(new Object[] {});

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""roles is not empty"");
	}

	@Test(expected = IllegalArgumentException.class) // DATAJPA-1074
	public void rejectsIsEmptyOnNonCollectionProperty() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByFirstnameIsEmpty"");
		AbstractJpaQuery jpaQuery = new PartTreeJpaQuery(method, entityManager, provider);

		jpaQuery.createQuery(new Object[] { ""Oliver"" });
	}

	@Test // DATAJPA-863
	public void errorsDueToMismatchOfParametersContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByFirstname"");

		assertThatExceptionOfType(IllegalArgumentException.class) //
				.isThrownBy(() -> new PartTreeJpaQuery(method, entityManager, provider)) //
				.withMessageContaining(""findByFirstname"") // the method being analyzed
				.withMessageContaining("" firstname "") // the property we are looking for
				.withMessageContaining(""UserRepository""); // the repository
	}

	@Test // DATAJPA-863
	public void errorsDueToMissingPropertyContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByNoSuchProperty"", String.class);

		assertThatExceptionOfType(IllegalArgumentException.class) //
				.isThrownBy(() -> new PartTreeJpaQuery(method, entityManager, provider)) //
				.withMessageContaining(""findByNoSuchProperty"") // the method being analyzed
				.withMessageContaining("" noSuchProperty "") // the property we are looking for
				.withMessageContaining(""UserRepository""); // the repository
	}

	private void testIgnoreCase(String methodName, Object... values) throws Exception {

		Class<?>[] parameterTypes = new Class[values.length];

		for (int i = 0; i < values.length; i++) {
			parameterTypes[i] = values[i].getClass();
		}

		JpaQueryMethod queryMethod = getQueryMethod(methodName, parameterTypes);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager,
				PersistenceProvider.fromEntityManager(entityManager));
		jpaQuery.createQuery(values);
	}

	private JpaQueryMethod getQueryMethod(String methodName, Class<?>... parameterTypes) throws Exception {
		Method method = UserRepository.class.getMethod(methodName, parameterTypes);
		return new JpaQueryMethod(method, new DefaultRepositoryMetadata(UserRepository.class),
				new SpelAwareProxyProjectionFactory(), PersistenceProvider.fromEntityManager(entityManager));
	}

	@SuppressWarnings(""unchecked"")
	private static <T> T getValue(Object source, String path) {

		Iterator<String> split = Arrays.asList(path.split(""\\."")).iterator();
		Object result = source;

		while (split.hasNext()) {

			Assert.notNull(source, ""result must not be null."");
			result = getField(result, split.next());
		}

		Assert.notNull(result, ""result must not be null."");
		return (T) result;
	}

	private static String getQueryProperty() {
		return isHibernate43() || isHibernate5() ? ""jpqlQuery"" : ""val$jpaqlQuery"";
	}

	private static boolean isHibernate43() {
		return Version.getVersionString().startsWith(""4.3"");
	}

	private static boolean isHibernate5() {
		return Version.getVersionString().startsWith(""5."");
	}

	@SuppressWarnings(""unused"")
	interface UserRepository extends Repository<User, Long> {

		Page<User> findByFirstname(String firstname, Pageable pageable);

		User findByIdIgnoringCase(Integer id);

		User findByIdAllIgnoringCase(Integer id);

		boolean existsByFirstname(String firstname);

		List<User> findByCreatedAtAfter(@Temporal(TemporalType.TIMESTAMP) @Param(""refDate"") Date refDate);

		List<User> findByRolesIsEmpty();

		List<User> findByRolesIsNotEmpty();

		List<User> findByFirstnameIsEmpty();

		// Wrong number of parameters
		User findByFirstname();

		// Wrong property name
		User findByNoSuchProperty(String x);
	}

}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/PartTreeJpaQueryIntegrationTests.java,"/*
 * Copyright 2011-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License
import org.springframework.aop.framework.Advised;
"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.*;
import static org.springframework.test.util.ReflectionTestUtils.*;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.TemporalType;

import org.hibernate.Version;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.Temporal;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.Param;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.util.Assert;

/**
 * Integration tests for {@link PartTreeJpaQuery}.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Michael Cramer
 * @author Jens Schauder
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class PartTreeJpaQueryIntegrationTests {

	private static String PROPERTY = ""h.target."" + getQueryProperty();

	@Rule public ExpectedException thrown = ExpectedException.none();

	@PersistenceContext EntityManager entityManager;

	PersistenceProvider provider;

	@Before
	public void setUp() {
		this.provider = PersistenceProvider.fromEntityManager(entityManager);
	}

	@Test // DATADOC-90
	public void test() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		jpaQuery.createQuery(new Object[] { ""Matthews"", PageRequest.of(0, 1) });
		jpaQuery.createQuery(new Object[] { ""Matthews"", PageRequest.of(0, 1) });
	}

	@Test
	public void cannotIgnoreCaseIfNotString() throws Exception {

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""Unable to ignore case of java.lang.Integer types, the property 'id' must reference a String"");
		testIgnoreCase(""findByIdIgnoringCase"", 3);
	}

	@Test
	public void cannotIgnoreCaseIfNotStringUnlessIgnoringAll() throws Exception {

		testIgnoreCase(""findByIdAllIgnoringCase"", 3);
	}

	@Test // DATAJPA-121
	public void recreatesQueryIfNullValueIsGiven() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"", PageRequest.of(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""firstname=:param0"");

		query = jpaQuery.createQuery(new Object[] { null, PageRequest.of(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""firstname is null"");
	}

	@Test // DATAJPA-920
	public void shouldLimitExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(query.getMaxResults()).isEqualTo(1);
	}

	@Test // DATAJPA-920
	public void shouldSelectAliasedIdForExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).contains("".id from User as"");
	}

	@Test // DATAJPA-1074
	public void isEmptyCollection() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByRolesIsEmpty"");
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] {});

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""roles is empty"");
	}

	@Test // DATAJPA-1074
	public void isNotEmptyCollection() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByRolesIsNotEmpty"");
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] {});

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""roles is not empty"");
	}

	@Test(expected = IllegalArgumentException.class) // DATAJPA-1074
	public void rejectsIsEmptyOnNonCollectionProperty() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByFirstnameIsEmpty"");
		AbstractJpaQuery jpaQuery = new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'));

		jpaQuery.createQuery(new Object[] { ""Oliver"" });
	}

	@Test // DATAJPA-863
	public void errorsDueToMismatchOfParametersContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByFirstname"");

		assertThatExceptionOfType(IllegalArgumentException.class) //
				.isThrownBy(() -> new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'))) //
				.withMessageContaining(""findByFirstname"") // the method being analyzed
				.withMessageContaining("" firstname "") // the property we are looking for
				.withMessageContaining(""UserRepository""); // the repository
	}

	@Test // DATAJPA-863
	public void errorsDueToMissingPropertyContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByNoSuchProperty"", String.class);

		assertThatExceptionOfType(IllegalArgumentException.class) //
				.isThrownBy(() -> new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'))) //
				.withMessageContaining(""findByNoSuchProperty"") // the method being analyzed
				.withMessageContaining("" noSuchProperty "") // the property we are looking for
				.withMessageContaining(""UserRepository""); // the repository
	}

	private void testIgnoreCase(String methodName, Object... values) throws Exception {

		Class<?>[] parameterTypes = new Class[values.length];

		for (int i = 0; i < values.length; i++) {
			parameterTypes[i] = values[i].getClass();
		}

		JpaQueryMethod queryMethod = getQueryMethod(methodName, parameterTypes);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager,
				PersistenceProvider.fromEntityManager(entityManager), EscapeCharacter.of('\\'));
		jpaQuery.createQuery(values);
	}

	private JpaQueryMethod getQueryMethod(String methodName, Class<?>... parameterTypes) throws Exception {
		Method method = UserRepository.class.getMethod(methodName, parameterTypes);
		return new JpaQueryMethod(method, new DefaultRepositoryMetadata(UserRepository.class),
				new SpelAwareProxyProjectionFactory(), PersistenceProvider.fromEntityManager(entityManager));
	}

	@SuppressWarnings(""unchecked"")
	private static <T> T getValue(Object source, String path) {

		Iterator<String> split = Arrays.asList(path.split(""\\."")).iterator();
		Object result = source;

		while (split.hasNext()) {

			Assert.notNull(source, ""result must not be null."");
			result = getField(result, split.next());
		}

		Assert.notNull(result, ""result must not be null."");
		return (T) result;
	}

	private static String getQueryProperty() {
		return isHibernate43() || isHibernate5() ? ""jpqlQuery"" : ""val$jpaqlQuery"";
	}

	private static boolean isHibernate43() {
		return Version.getVersionString().startsWith(""4.3"");
	}

	private static boolean isHibernate5() {
		return Version.getVersionString().startsWith(""5."");
	}

	@SuppressWarnings(""unused"")
	interface UserRepository extends Repository<User, Long> {

		Page<User> findByFirstname(String firstname, Pageable pageable);

		User findByIdIgnoringCase(Integer id);

		User findByIdAllIgnoringCase(Integer id);

		boolean existsByFirstname(String firstname);

		List<User> findByCreatedAtAfter(@Temporal(TemporalType.TIMESTAMP) @Param(""refDate"") Date refDate);

		List<User> findByRolesIsEmpty();

		List<User> findByRolesIsNotEmpty();

		List<User> findByFirstnameIsEmpty();

		// Wrong number of parameters
		User findByFirstname();

		// Wrong property name
		User findByNoSuchProperty(String x);
	}

}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java,"/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.sample;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;

import javax.persistence.EntityManager;
import javax.persistence.QueryHint;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.SpecialUser;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.QueryHints;
import org.springframework.data.jpa.repository.query.Procedure;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import com.google.common.base.Optional;

/**
 * Repository interface for {@code User}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Kevin Peters
 */
public interface UserRepository
		extends JpaRepository<User, Integer>, JpaSpecificationExecutor<User>, UserRepositoryCustom {

	/**
	 * Retrieve users by their lastname. The finder {@literal User.findByLastname} is declared in
	 * {@literal META-INF/orm.xml} .
	 * 
	 * @param lastname
	 * @return all users with the given lastname
	 */
	@QueryHints({ @QueryHint(name = ""foo"", value = ""bar"") })
	List<User> findByLastname(String lastname);

	/**
	 * Redeclaration of {@link CrudRepository#findById(java.io.Serializable)} to change transaction configuration.
	 */
	@Transactional
	java.util.Optional<User> findById(Integer primaryKey);

	/**
	 * Redeclaration of {@link CrudRepository#deleteById(java.io.Serializable)}. to make sure the transaction
	 * configuration of the original method is considered if the redeclaration does not carry a {@link Transactional}
	 * annotation.
	 */
	void deleteById(Integer id); // DATACMNS-649

	/**
	 * Retrieve users by their email address. The finder {@literal User.findByEmailAddress} is declared as annotation at
	 * {@code User}.
	 * 
	 * @param emailAddress
	 * @return the user with the given email address
	 */
	User findByEmailAddress(String emailAddress);

	@Query(""select u from User u left outer join u.manager as manager"")
	Page<User> findAllPaged(Pageable pageable);

	/**
	 * Retrieves users by the given email and lastname. Acts as a dummy method declaration to test finder query creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @return the user with the given email address and lastname
	 */
	User findByEmailAddressAndLastname(String emailAddress, String lastname);

	/**
	 * Retrieves users by email address and lastname or firstname. Acts as a dummy method declaration to test finder query
	 * creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @param username
	 * @return the users with the given email address and lastname or the given firstname
	 */
	List<User> findByEmailAddressAndLastnameOrFirstname(String emailAddress, String lastname, String username);

	/**
	 * Retrieves a user by its username using the query annotated to the method.
	 * 
	 * @param emailAddress
	 * @return
	 */
	@Query(""select u from User u where u.emailAddress = ?1"")
	@Transactional(readOnly = true)
	User findByAnnotatedQuery(String emailAddress);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * 
	 * @param pageable
	 * @param lastname
	 * @return
	 */
	Page<User> findByLastname(Pageable pageable, String lastname);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * Just returns the queried {@link Page}'s contents.
	 * 
	 * @param firstname
	 * @param pageable
	 * @return
	 */
	List<User> findByFirstname(String firstname, Pageable pageable);

	Page<User> findByFirstnameIn(Pageable pageable, String... firstnames);

	List<User> findByFirstnameNotIn(Collection<String> firstnames);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like ?1%"")
	List<User> findByFirstnameLike(String firstname);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like :firstname%"")
	List<User> findByFirstnameLikeNamed(@Param(""firstname"") String firstname);

	/**
	 * Manipulating query to set all {@link User}'s names to the given one.
	 * 
	 * @param lastname
	 */
	@Modifying
	@Query(""update User u set u.lastname = ?1"")
	void renameAllUsersTo(String lastname);

	@Query(""select count(u) from User u where u.firstname = ?1"")
	Long countWithFirstname(String firstname);

	/**
	 * Method where parameters will be applied by name. Note that the order of the parameters is then not crucial anymore.
	 * 
	 * @param foo
	 * @param bar
	 * @return
	 */
	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstname(@Param(""firstname"") String foo, @Param(""lastname"") String bar);

	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstnameUnannotated(String firstname, String lastname);

	/**
	 * Method to check query creation and named parameter usage go well hand in hand.
	 * 
	 * @param lastname
	 * @param firstname
	 * @return
	 */
	List<User> findByFirstnameOrLastname(@Param(""lastname"") String lastname, @Param(""firstname"") String firstname);

	List<User> findByLastnameLikeOrderByFirstnameDesc(String lastname);

	List<User> findByLastnameNotLike(String lastname);

	List<User> findByLastnameNot(String lastname);

	List<User> findByManagerLastname(String name);

	List<User> findByColleaguesLastname(String lastname);

	List<User> findByLastnameNotNull();

	List<User> findByLastnameNull();

	List<User> findByEmailAddressLike(String email, Sort sort);

	List<SpecialUser> findSpecialUsersByLastname(String lastname);

	List<User> findBySpringDataNamedQuery(String lastname);

	List<User> findByLastnameIgnoringCase(String lastname);

	Page<User> findByLastnameIgnoringCase(Pageable pageable, String lastname);

	List<User> findByLastnameIgnoringCaseLike(String lastname);

	List<User> findByLastnameAndFirstnameAllIgnoringCase(String lastname, String firstname);

	List<User> findByAgeGreaterThanEqual(int age);

	List<User> findByAgeLessThanEqual(int age);

	@Query(""select u.lastname from User u group by u.lastname"")
	Page<String> findByLastnameGrouped(Pageable pageable);

	// DATAJPA-117
	@Query(value = ""SELECT * FROM SD_User WHERE lastname = ?1"", nativeQuery = true)
	List<User> findNativeByLastname(String lastname);

	// DATAJPA-132
	List<User> findByActiveTrue();

	// DATAJPA-132
	List<User> findByActiveFalse();

	@Query(""select u.colleagues from User u where u = ?1"")
	List<User> findColleaguesFor(User user);

	// DATAJPA-188
	List<User> findByCreatedAtBefore(Date date);

	// DATAJPA-188
	List<User> findByCreatedAtAfter(Date date);

	// DATAJPA-180
	List<User> findByFirstnameStartingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameEndingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameContaining(String firstname);

	@Query(value = ""SELECT 1 FROM SD_User"", nativeQuery = true)
	List<Integer> findOnesByNativeQuery();

	// DATAJPA-231
	long countByLastname(String lastname);

	// DATAJPA-231
	int countUsersByFirstname(String firstname);

	// DATAJPA-920
	boolean existsByLastname(String lastname);

	// DATAJPA-391
	@Query(""select u.firstname from User u where u.lastname = ?1"")
	List<String> findFirstnamesByLastname(String lastname);

	// DATAJPA-415
	Collection<User> findByIdIn(@Param(""ids"") Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in ?1"")
	Collection<User> findByIdsCustomWithPositionalVarArgs(Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in :ids"")
	Collection<User> findByIdsCustomWithNamedVarArgs(@Param(""ids"") Integer... ids);

	// DATAJPA-415
	@Modifying
	@Query(""update #{#entityName} u set u.active = :activeState where u.id in :ids"")
	void updateUserActiveState(@Param(""activeState"") boolean activeState, @Param(""ids"") Integer... ids);

	// DATAJPA-405
	List<User> findAllByOrderByLastnameAsc();

	// DATAJPA-454
	List<User> findByBinaryData(byte[] data);

	// DATAJPA-486
	Slice<User> findSliceByLastname(String lastname, Pageable pageable);

	// DATAJPA-496
	List<User> findByAttributesIn(Set<String> attributes);

	// DATAJPA-460
	Long removeByLastname(String lastname);

	// DATAJPA-460
	List<User> deleteByLastname(String lastname);

	/**
	 * @see <a href=""https://issues.apache.org/jira/browse/OPENJPA-2484"">OPENJPA-2484</a>
	 */
	// DATAJPA-505
	// @Query(value = ""select u.binaryData from User u where u.id = :id"")
	// byte[] findBinaryDataByIdJpaQl(@Param(""id"") Integer id);

	/**
	 * Explicitly mapped to a procedure with name ""plus1inout"" in database.
	 */
	@Procedure(""plus1inout"") // DATAJPA-455
	Integer explicitlyNamedPlus1inout(Integer arg);

	/**
	 * Implicitly mapped to a procedure with name ""plus1inout"" in database via alias.
	 */
	@Procedure(procedureName = ""plus1inout"") // DATAJPA-455
	Integer plus1inout(Integer arg);

	/**
	 * Explicitly mapped to named stored procedure ""User.plus1IO"" in {@link EntityManager}.
	 */
	@Procedure(name = ""User.plus1IO"") // DATAJPA-455
	Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param(""arg"") Integer arg);

	/**
	 * Implicitly mapped to named stored procedure ""User.plus1"" in {@link EntityManager}.
	 */
	@Procedure // DATAJPA-455
	Integer plus1(@Param(""arg"") Integer arg);

	// DATAJPA-456
	@Query(value = ""select u from User u where u.firstname like ?1%"", countProjection = ""u.firstname"")
	Page<User> findAllByFirstnameLike(String firstname, Pageable page);

	// DATAJPA-456
	@Query(name = ""User.findBySpringDataNamedQuery"", countProjection = ""u.firstname"")
	Page<User> findByNamedQueryAndCountProjection(String firstname, Pageable page);

	// DATAJPA-551
	User findFirstByOrderByAgeDesc();

	// DATAJPA-551
	User findFirst1ByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeAsc();

	// DATAJPA-551
	User findTop1ByOrderByAgeAsc();

	// DATAJPA-551
	List<User> findTop2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2UsersBy(Sort sort);

	// DATAJPA-551
	List<User> findTop2UsersBy(Sort sort);

	// DATAJPA-551
	Page<User> findFirst3UsersBy(Pageable page);

	// DATAJPA-551
	Page<User> findFirst2UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop3UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop2UsersBy(Pageable page);

	// DATAJPA-506
	@Query(value = ""select u.binaryData from SD_User u where u.id = ?1"", nativeQuery = true)
	byte[] findBinaryDataByIdNative(Integer id);

	// DATAJPA-506
	@Query(""select u from User u where u.emailAddress = ?1"")
	Optional<User> findOptionalByEmailAddress(String emailAddress);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]} and u.firstname = ?1 and u.lastname like %?#{[1]}% and u.lastname like %?2%"")
	List<User> findByFirstnameAndLastnameWithSpelExpression(String firstname, String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%"")
	List<User> findByLastnameWithSpelExpression(@Param(""lastname"") String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithQuestionmark();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithColon();

	// DATAJPA-564
	@Query(""select u from User u where u.age = ?#{[0]}"")
	List<User> findUsersByAgeForSpELExpressionByIndexedParameter(int age);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :firstname and u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpression(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findCurrentUserWithCustomQuery();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findByFirstnameAndCurrentUserWithCustomQuery(String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterVariableOnly(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnly(String firstname);

	// DATAJPA-564
	@Query(
			value = ""select * from ("" +
					""select u.*, rownum() as RN from ("" +
					""select * from SD_User ORDER BY ucase(firstname)"" +
					"") u"" +
					"") where RN between ?#{ #pageable.offset +1 } and ?#{#pageable.offset + #pageable.pageSize}"",
			countQuery = ""select count(u.id) from SD_User u"", nativeQuery = true)
	Page<User> findUsersInNativeQueryWithPagination(Pageable pageable);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#user.firstname} and u.lastname =:lastname"")
	List<User> findUsersByUserFirstnameAsSpELExpressionAndLastnameAsString(@Param(""user"") User user,
			@Param(""lastname"") String lastname);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:firstname and u.lastname =:#{#user.lastname}"")
	List<User> findUsersByFirstnameAsStringAndUserLastnameAsSpELExpression(@Param(""firstname"") String firstname,
			@Param(""user"") User user);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#user.firstname} and u.lastname =:#{#lastname}"")
	List<User> findUsersByUserFirstnameAsSpELExpressionAndLastnameAsFakeSpELExpression(@Param(""user"") User user,
			@Param(""lastname"") String lastname);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#firstname} and u.lastname =:#{#user.lastname}"")
	List<User> findUsersByFirstnameAsFakeSpELExpressionAndUserLastnameAsSpELExpression(
			@Param(""firstname"") String firstname, @Param(""user"") User user);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:firstname"")
	List<User> findUsersByFirstnamePaginated(Pageable page, @Param(""firstname"") String firstname);

	// DATAJPA-629
	@Query(""select u from #{#entityName} u where u.firstname = ?#{[0]} and u.lastname = ?#{[1]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnlyWithEntityExpression(String firstname,
			String lastname);

	// DATAJPA-606
	List<User> findByAgeIn(Collection<Integer> ages);

	// DATAJPA-606
	List<User> queryByAgeIn(Integer[] ages);

	// DATAJPA-606
	List<User> queryByAgeInOrFirstname(Integer[] ages, String firstname);

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> findAllByCustomQueryAndStream();

	// DATAJPA-677
	Stream<User> readAllByFirstnameNotNull();

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> streamAllPaged(Pageable pageable);

	// DATAJPA-830
	List<User> findByLastnameNotContaining(String part);

	// DATAJPA-829
	List<User> findByRolesContaining(Role role);

	// DATAJPA-829
	List<User> findByRolesNotContaining(Role role);

	// DATAJPA-858
	List<User> findByRolesNameContaining(String name);

	// DATAJPA-1179
	@Query(""select u from User u where u.firstname = :#{#firstname} and u.firstname = :#{#firstname}"")
	List<User> findUsersByDuplicateSpel(@Param(""firstname"") String firstname);

	List<RolesAndFirstname> findRolesAndFirstnameBy();

	// DATAJPA-1172
	@Query(""select u from User u where u.age = :age"")
	List<User> findByStringAge(@Param(""age"") String age);

	// DATAJPA-1185
	<T> Stream<T> findAsStreamByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1185
	<T> List<T> findAsListByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-980
	@Query(value = ""SELECT firstname, lastname FROM SD_User WHERE id = ?1"", nativeQuery = true)
	NameOnly findByNativeQuery(Integer id);

	// DATAJPA-1248
	@Query(value = ""SELECT emailaddress FROM SD_User WHERE id = ?1"", nativeQuery = true)
	EmailOnly findEmailOnlyByNativeQuery(Integer id);

	// DATAJPA-1235
	@Query(""SELECT u FROM User u where u.firstname >= ?1 and u.lastname = '000:1'"")
	List<User> queryWithIndexedParameterAndColonFollowedByIntegerInString(String firstname);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u ORDER BY CASE WHEN (u.firstname  >= :name) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameSingleParam(@Param(""name"") String name, Pageable page);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u WHERE :other = 'x' ORDER BY CASE WHEN (u.firstname  >= :name) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameMultipleParams(@Param(""name"") String name, @Param(""other"") String other, Pageable page);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u WHERE ?2 = 'x' ORDER BY CASE WHEN (u.firstname  >= ?1) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameMultipleParamsIndexed(String name, String other, Pageable page);

	// DATAJPA-928
	Page<User> findByNativeNamedQueryWithPageable(Pageable pageable);

	// DATAJPA-928
	@Query(value = ""SELECT firstname FROM SD_User ORDER BY UCASE(firstname)"", countQuery = ""SELECT count(*) FROM SD_User"",
			nativeQuery = true)
	Page<String> findByNativeQueryWithPageable(@Param(""pageable"") Pageable pageable);

	// DATAJPA-1273
	List<NameOnly> findByNamedQueryWithAliasInInvertedOrder();

	// DATAJPA-1301
	@Query(""select firstname as firstname, lastname as lastname from User u where u.firstname = 'Oliver'"")
	Map<String, Object> findMapWithNullValues();

	// DATAJPA-1307
	@Query(value = ""select * from SD_User u where u.emailAddress = ?"", nativeQuery = true)
	User findByEmailNativeAddressJdbcStyleParameter(String emailAddress);

	// DATAJPA-1334
	List<NameOnlyDto> findByNamedQueryWithConstructorExpression();

	interface RolesAndFirstname {

		String getFirstname();

		Set<Role> getRoles();
	}

	interface NameOnly {

		String getFirstname();

		String getLastname();
	}

	interface EmailOnly {
		String getEmailAddress();
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java,"/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.sample;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;

import javax.persistence.EntityManager;
import javax.persistence.QueryHint;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.SpecialUser;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.QueryHints;
import org.springframework.data.jpa.repository.query.Procedure;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import com.google.common.base.Optional;

/**
 * Repository interface for {@code User}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Kevin Peters
 */
public interface UserRepository
		extends JpaRepository<User, Integer>, JpaSpecificationExecutor<User>, UserRepositoryCustom {

	/**
	 * Retrieve users by their lastname. The finder {@literal User.findByLastname} is declared in
	 * {@literal META-INF/orm.xml} .
	 * 
	 * @param lastname
	 * @return all users with the given lastname
	 */
	@QueryHints({ @QueryHint(name = ""foo"", value = ""bar"") })
	List<User> findByLastname(String lastname);

	/**
	 * Redeclaration of {@link CrudRepository#findById(java.io.Serializable)} to change transaction configuration.
	 */
	@Transactional
	java.util.Optional<User> findById(Integer primaryKey);

	/**
	 * Redeclaration of {@link CrudRepository#deleteById(java.io.Serializable)}. to make sure the transaction
	 * configuration of the original method is considered if the redeclaration does not carry a {@link Transactional}
	 * annotation.
	 */
	void deleteById(Integer id); // DATACMNS-649

	/**
	 * Retrieve users by their email address. The finder {@literal User.findByEmailAddress} is declared as annotation at
	 * {@code User}.
	 * 
	 * @param emailAddress
	 * @return the user with the given email address
	 */
	User findByEmailAddress(String emailAddress);

	@Query(""select u from User u left outer join u.manager as manager"")
	Page<User> findAllPaged(Pageable pageable);

	/**
	 * Retrieves users by the given email and lastname. Acts as a dummy method declaration to test finder query creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @return the user with the given email address and lastname
	 */
	User findByEmailAddressAndLastname(String emailAddress, String lastname);

	/**
	 * Retrieves users by email address and lastname or firstname. Acts as a dummy method declaration to test finder query
	 * creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @param username
	 * @return the users with the given email address and lastname or the given firstname
	 */
	List<User> findByEmailAddressAndLastnameOrFirstname(String emailAddress, String lastname, String username);

	/**
	 * Retrieves a user by its username using the query annotated to the method.
	 * 
	 * @param emailAddress
	 * @return
	 */
	@Query(""select u from User u where u.emailAddress = ?1"")
	@Transactional(readOnly = true)
	User findByAnnotatedQuery(String emailAddress);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * 
	 * @param pageable
	 * @param lastname
	 * @return
	 */
	Page<User> findByLastname(Pageable pageable, String lastname);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * Just returns the queried {@link Page}'s contents.
	 * 
	 * @param firstname
	 * @param pageable
	 * @return
	 */
	List<User> findByFirstname(String firstname, Pageable pageable);

	Page<User> findByFirstnameIn(Pageable pageable, String... firstnames);

	List<User> findByFirstnameNotIn(Collection<String> firstnames);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like ?1%"")
	List<User> findByFirstnameLike(String firstname);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like :firstname%"")
	List<User> findByFirstnameLikeNamed(@Param(""firstname"") String firstname);

	/**
	 * Manipulating query to set all {@link User}'s names to the given one.
	 * 
	 * @param lastname
	 */
	@Modifying
	@Query(""update User u set u.lastname = ?1"")
	void renameAllUsersTo(String lastname);

	@Query(""select count(u) from User u where u.firstname = ?1"")
	Long countWithFirstname(String firstname);

	/**
	 * Method where parameters will be applied by name. Note that the order of the parameters is then not crucial anymore.
	 * 
	 * @param foo
	 * @param bar
	 * @return
	 */
	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstname(@Param(""firstname"") String foo, @Param(""lastname"") String bar);

	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstnameUnannotated(String firstname, String lastname);

	/**
	 * Method to check query creation and named parameter usage go well hand in hand.
	 * 
	 * @param lastname
	 * @param firstname
	 * @return
	 */
	List<User> findByFirstnameOrLastname(@Param(""lastname"") String lastname, @Param(""firstname"") String firstname);

	List<User> findByLastnameLikeOrderByFirstnameDesc(String lastname);

	List<User> findByLastnameNotLike(String lastname);

	List<User> findByLastnameNot(String lastname);

	List<User> findByManagerLastname(String name);

	List<User> findByColleaguesLastname(String lastname);

	List<User> findByLastnameNotNull();

	List<User> findByLastnameNull();

	List<User> findByEmailAddressLike(String email, Sort sort);

	List<SpecialUser> findSpecialUsersByLastname(String lastname);

	List<User> findBySpringDataNamedQuery(String lastname);

	List<User> findByLastnameIgnoringCase(String lastname);

	Page<User> findByLastnameIgnoringCase(Pageable pageable, String lastname);

	List<User> findByLastnameIgnoringCaseLike(String lastname);

	List<User> findByLastnameAndFirstnameAllIgnoringCase(String lastname, String firstname);

	List<User> findByAgeGreaterThanEqual(int age);

	List<User> findByAgeLessThanEqual(int age);

	@Query(""select u.lastname from User u group by u.lastname"")
	Page<String> findByLastnameGrouped(Pageable pageable);

	// DATAJPA-117
	@Query(value = ""SELECT * FROM SD_User WHERE lastname = ?1"", nativeQuery = true)
	List<User> findNativeByLastname(String lastname);

	// DATAJPA-132
	List<User> findByActiveTrue();

	// DATAJPA-132
	List<User> findByActiveFalse();

	@Query(""select u.colleagues from User u where u = ?1"")
	List<User> findColleaguesFor(User user);

	// DATAJPA-188
	List<User> findByCreatedAtBefore(Date date);

	// DATAJPA-188
	List<User> findByCreatedAtAfter(Date date);

	// DATAJPA-180
	List<User> findByFirstnameStartingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameEndingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameContaining(String firstname);

	@Query(value = ""SELECT 1 FROM SD_User"", nativeQuery = true)
	List<Integer> findOnesByNativeQuery();

	// DATAJPA-231
	long countByLastname(String lastname);

	// DATAJPA-231
	int countUsersByFirstname(String firstname);

	// DATAJPA-920
	boolean existsByLastname(String lastname);

	// DATAJPA-391
	@Query(""select u.firstname from User u where u.lastname = ?1"")
	List<String> findFirstnamesByLastname(String lastname);

	// DATAJPA-415
	Collection<User> findByIdIn(@Param(""ids"") Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in ?1"")
	Collection<User> findByIdsCustomWithPositionalVarArgs(Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in :ids"")
	Collection<User> findByIdsCustomWithNamedVarArgs(@Param(""ids"") Integer... ids);

	// DATAJPA-415
	@Modifying
	@Query(""update #{#entityName} u set u.active = :activeState where u.id in :ids"")
	void updateUserActiveState(@Param(""activeState"") boolean activeState, @Param(""ids"") Integer... ids);

	// DATAJPA-405
	List<User> findAllByOrderByLastnameAsc();

	// DATAJPA-454
	List<User> findByBinaryData(byte[] data);

	// DATAJPA-486
	Slice<User> findSliceByLastname(String lastname, Pageable pageable);

	// DATAJPA-496
	List<User> findByAttributesIn(Set<String> attributes);

	// DATAJPA-460
	Long removeByLastname(String lastname);

	// DATAJPA-460
	List<User> deleteByLastname(String lastname);

	/**
	 * @see <a href=""https://issues.apache.org/jira/browse/OPENJPA-2484"">OPENJPA-2484</a>
	 */
	// DATAJPA-505
	// @Query(value = ""select u.binaryData from User u where u.id = :id"")
	// byte[] findBinaryDataByIdJpaQl(@Param(""id"") Integer id);

	/**
	 * Explicitly mapped to a procedure with name ""plus1inout"" in database.
	 */
	@Procedure(""plus1inout"") // DATAJPA-455
	Integer explicitlyNamedPlus1inout(Integer arg);

	/**
	 * Implicitly mapped to a procedure with name ""plus1inout"" in database via alias.
	 */
	@Procedure(procedureName = ""plus1inout"") // DATAJPA-455
	Integer plus1inout(Integer arg);

	/**
	 * Explicitly mapped to named stored procedure ""User.plus1IO"" in {@link EntityManager}.
	 */
	@Procedure(name = ""User.plus1IO"") // DATAJPA-455
	Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param(""arg"") Integer arg);

	/**
	 * Implicitly mapped to named stored procedure ""User.plus1"" in {@link EntityManager}.
	 */
	@Procedure // DATAJPA-455
	Integer plus1(@Param(""arg"") Integer arg);

	// DATAJPA-456
	@Query(value = ""select u from User u where u.firstname like ?1%"", countProjection = ""u.firstname"")
	Page<User> findAllByFirstnameLike(String firstname, Pageable page);

	// DATAJPA-456
	@Query(name = ""User.findBySpringDataNamedQuery"", countProjection = ""u.firstname"")
	Page<User> findByNamedQueryAndCountProjection(String firstname, Pageable page);

	// DATAJPA-551
	User findFirstByOrderByAgeDesc();

	// DATAJPA-551
	User findFirst1ByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeAsc();

	// DATAJPA-551
	User findTop1ByOrderByAgeAsc();

	// DATAJPA-551
	List<User> findTop2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2UsersBy(Sort sort);

	// DATAJPA-551
	List<User> findTop2UsersBy(Sort sort);

	// DATAJPA-551
	Page<User> findFirst3UsersBy(Pageable page);

	// DATAJPA-551
	Page<User> findFirst2UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop3UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop2UsersBy(Pageable page);

	// DATAJPA-506
	@Query(value = ""select u.binaryData from SD_User u where u.id = ?1"", nativeQuery = true)
	byte[] findBinaryDataByIdNative(Integer id);

	// DATAJPA-506
	@Query(""select u from User u where u.emailAddress = ?1"")
	Optional<User> findOptionalByEmailAddress(String emailAddress);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]} and u.firstname = ?1 and u.lastname like %?#{[1]}% and u.lastname like %?2%"")
	List<User> findByFirstnameAndLastnameWithSpelExpression(String firstname, String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%"")
	List<User> findByLastnameWithSpelExpression(@Param(""lastname"") String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithQuestionmark();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithColon();

	// DATAJPA-564
	@Query(""select u from User u where u.age = ?#{[0]}"")
	List<User> findUsersByAgeForSpELExpressionByIndexedParameter(int age);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :firstname and u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpression(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findCurrentUserWithCustomQuery();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findByFirstnameAndCurrentUserWithCustomQuery(String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterVariableOnly(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnly(String firstname);

	// DATAJPA-564
	@Query(
			value = ""select * from ("" +
					""select u.*, rownum() as RN from ("" +
					""select * from SD_User ORDER BY ucase(firstname)"" +
					"") u"" +
					"") where RN between ?#{ #pageable.offset +1 } and ?#{#pageable.offset + #pageable.pageSize}"",
			countQuery = ""select count(u.id) from SD_User u"", nativeQuery = true)
	Page<User> findUsersInNativeQueryWithPagination(Pageable pageable);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#user.firstname} and u.lastname =:lastname"")
	List<User> findUsersByUserFirstnameAsSpELExpressionAndLastnameAsString(@Param(""user"") User user,
			@Param(""lastname"") String lastname);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:firstname and u.lastname =:#{#user.lastname}"")
	List<User> findUsersByFirstnameAsStringAndUserLastnameAsSpELExpression(@Param(""firstname"") String firstname,
			@Param(""user"") User user);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#user.firstname} and u.lastname =:#{#lastname}"")
	List<User> findUsersByUserFirstnameAsSpELExpressionAndLastnameAsFakeSpELExpression(@Param(""user"") User user,
			@Param(""lastname"") String lastname);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#firstname} and u.lastname =:#{#user.lastname}"")
	List<User> findUsersByFirstnameAsFakeSpELExpressionAndUserLastnameAsSpELExpression(
			@Param(""firstname"") String firstname, @Param(""user"") User user);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:firstname"")
	List<User> findUsersByFirstnamePaginated(Pageable page, @Param(""firstname"") String firstname);

	// DATAJPA-629
	@Query(""select u from #{#entityName} u where u.firstname = ?#{[0]} and u.lastname = ?#{[1]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnlyWithEntityExpression(String firstname,
			String lastname);

	// DATAJPA-606
	List<User> findByAgeIn(Collection<Integer> ages);

	// DATAJPA-606
	List<User> queryByAgeIn(Integer[] ages);

	// DATAJPA-606
	List<User> queryByAgeInOrFirstname(Integer[] ages, String firstname);

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> findAllByCustomQueryAndStream();

	// DATAJPA-677
	Stream<User> readAllByFirstnameNotNull();

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> streamAllPaged(Pageable pageable);

	// DATAJPA-830
	List<User> findByLastnameNotContaining(String part);

	// DATAJPA-829
	List<User> findByRolesContaining(Role role);

	// DATAJPA-829
	List<User> findByRolesNotContaining(Role role);

	// DATAJPA-858
	List<User> findByRolesNameContaining(String name);

	// DATAJPA-1179
	@Query(""select u from User u where u.firstname = :#{#firstname} and u.firstname = :#{#firstname}"")
	List<User> findUsersByDuplicateSpel(@Param(""firstname"") String firstname);

	List<RolesAndFirstname> findRolesAndFirstnameBy();

	// DATAJPA-1172
	@Query(""select u from User u where u.age = :age"")
	List<User> findByStringAge(@Param(""age"") String age);

	// DATAJPA-1185
	<T> Stream<T> findAsStreamByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1185
	<T> List<T> findAsListByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-980
	@Query(value = ""SELECT firstname, lastname FROM SD_User WHERE id = ?1"", nativeQuery = true)
	NameOnly findByNativeQuery(Integer id);

	// DATAJPA-1248
	@Query(value = ""SELECT emailaddress FROM SD_User WHERE id = ?1"", nativeQuery = true)
	EmailOnly findEmailOnlyByNativeQuery(Integer id);

	// DATAJPA-1235
	@Query(""SELECT u FROM User u where u.firstname >= ?1 and u.lastname = '000:1'"")
	List<User> queryWithIndexedParameterAndColonFollowedByIntegerInString(String firstname);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u ORDER BY CASE WHEN (u.firstname  >= :name) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameSingleParam(@Param(""name"") String name, Pageable page);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u WHERE :other = 'x' ORDER BY CASE WHEN (u.firstname  >= :name) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameMultipleParams(@Param(""name"") String name, @Param(""other"") String other, Pageable page);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u WHERE ?2 = 'x' ORDER BY CASE WHEN (u.firstname  >= ?1) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameMultipleParamsIndexed(String name, String other, Pageable page);

	// DATAJPA-928
	Page<User> findByNativeNamedQueryWithPageable(Pageable pageable);

	// DATAJPA-928
	@Query(value = ""SELECT firstname FROM SD_User ORDER BY UCASE(firstname)"", countQuery = ""SELECT count(*) FROM SD_User"",
			nativeQuery = true)
	Page<String> findByNativeQueryWithPageable(@Param(""pageable"") Pageable pageable);

	// DATAJPA-1273
	List<NameOnly> findByNamedQueryWithAliasInInvertedOrder();

	// DATAJPA-1301
	@Query(""select firstname as firstname, lastname as lastname from User u where u.firstname = 'Oliver'"")
	Map<String, Object> findMapWithNullValues();

	// DATAJPA-1307
	@Query(value = ""select * from SD_User u where u.emailAddress = ?"", nativeQuery = true)
	User findByEmailNativeAddressJdbcStyleParameter(String emailAddress);

	// DATAJPA-1334
	List<NameOnlyDto> findByNamedQueryWithConstructorExpression();

	// DATAJPA-1519
	@Query(""select u from User u where u.firstname like %?#{#escape([0],'#')}% escape '#'"")
	List<User> findContainingEscaped(String namePart);

	interface RolesAndFirstname {

		String getFirstname();

		Set<Role> getRoles();
	}

	interface NameOnly {

		String getFirstname();

		String getLastname();
	}

	interface EmailOnly {
		String getEmailAddress();
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/config/JpaRepositoryConfigExtension.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.config;

import static org.springframework.data.jpa.repository.config.BeanDefinitionNames.*;

import lombok.experimental.UtilityClass;

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Optional;
import java.util.Set;

import javax.persistence.Entity;
import javax.persistence.MappedSuperclass;
import javax.persistence.PersistenceContext;
import javax.persistence.PersistenceUnit;

import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.core.annotation.AnnotationAttributes;
import org.springframework.core.io.ResourceLoader;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.support.DefaultJpaContext;
import org.springframework.data.jpa.repository.support.EntityManagerBeanDefinitionRegistrarPostProcessor;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
import org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource;
import org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport;
import org.springframework.data.repository.config.RepositoryConfigurationSource;
import org.springframework.data.repository.config.XmlRepositoryConfigurationSource;
import org.springframework.lang.Nullable;
import org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor;
import org.springframework.util.ClassUtils;
import org.springframework.util.StringUtils;

/**
 * JPA specific configuration extension parsing custom attributes from the XML namespace and
 * {@link EnableJpaRepositories} annotation. Also, it registers bean definitions for a
 * {@link PersistenceAnnotationBeanPostProcessor} (to trigger injection into {@link PersistenceContext}/
 * {@link PersistenceUnit} annotated properties and methods) as well as
 * {@link PersistenceExceptionTranslationPostProcessor} to enable exception translation of persistence specific
 * exceptions into Spring's {@link DataAccessException} hierarchy.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Gil Markham
 * @author Thomas Darimont
 * @author Christoph Strobl
 * @author Mark Paluch
 */
public class JpaRepositoryConfigExtension extends RepositoryConfigurationExtensionSupport {

	private static final Class<?> PAB_POST_PROCESSOR = PersistenceAnnotationBeanPostProcessor.class;
	private static final String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = ""transactionManager"";
	private static final String ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE = ""enableDefaultTransactions"";
	private static final String JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME = ""org.springframework.data.jpa.util.JpaMetamodelCacheCleanup"";

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getModuleName()
	 */
	@Override
	public String getModuleName() {
		return ""JPA"";
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtension#getRepositoryFactoryBeanClassName()
	 */
	@Override
	public String getRepositoryFactoryBeanClassName() {
		return JpaRepositoryFactoryBean.class.getName();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config14.RepositoryConfigurationExtensionSupport#getModulePrefix()
	 */
	@Override
	protected String getModulePrefix() {
		return getModuleName().toLowerCase(Locale.US);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingAnnotations()
	 */
	@Override
	protected Collection<Class<? extends Annotation>> getIdentifyingAnnotations() {
		return Arrays.asList(Entity.class, MappedSuperclass.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingTypes()
	 */
	@Override
	protected Collection<Class<?>> getIdentifyingTypes() {
		return Collections.<Class<?>> singleton(JpaRepository.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, RepositoryConfigurationSource source) {

		Optional<String> transactionManagerRef = source.getAttribute(""transactionManagerRef"");
		builder.addPropertyValue(""transactionManager"", transactionManagerRef.orElse(DEFAULT_TRANSACTION_MANAGER_BEAN_NAME));
		builder.addPropertyValue(""entityManager"", getEntityManagerBeanDefinitionFor(source, source.getSource()));
		builder.addPropertyValue(""escapeCharacter"", getEscapeCharacter(source).orElse('\\'));
		builder.addPropertyReference(""mappingContext"", JPA_MAPPING_CONTEXT_BEAN_NAME);
	}

	/**
	 * XML configurations do not support {@link Character} values. This method catches the exception thrown and returns an {@link Optional#empty()} instead.
	 */
	private static Optional<Character> getEscapeCharacter(RepositoryConfigurationSource source) {

		try {
			return source.getAttribute(""escapeCharacter"", Character.class);
		} catch (IllegalArgumentException ___) {
			return Optional.empty();
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, AnnotationRepositoryConfigurationSource config) {

		AnnotationAttributes attributes = config.getAttributes();

		builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE,
				attributes.getBoolean(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.XmlRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, XmlRepositoryConfigurationSource config) {

		Optional<String> enableDefaultTransactions = config.getAttribute(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE);

		if (enableDefaultTransactions.isPresent() && StringUtils.hasText(enableDefaultTransactions.get())) {
			builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE, enableDefaultTransactions.get());
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#registerBeansForRoot(org.springframework.beans.factory.support.BeanDefinitionRegistry, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void registerBeansForRoot(BeanDefinitionRegistry registry, RepositoryConfigurationSource config) {

		super.registerBeansForRoot(registry, config);

		Object source = config.getSource();

		registerIfNotAlreadyRegistered(new RootBeanDefinition(EntityManagerBeanDefinitionRegistrarPostProcessor.class),
				registry, EM_BEAN_DEFINITION_REGISTRAR_POST_PROCESSOR_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(JpaMetamodelMappingContextFactoryBean.class), registry,
				JPA_MAPPING_CONTEXT_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(PAB_POST_PROCESSOR), registry,
				AnnotationConfigUtils.PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME, source);

		// Register bean definition for DefaultJpaContext

		RootBeanDefinition contextDefinition = new RootBeanDefinition(DefaultJpaContext.class);
		contextDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);

		registerIfNotAlreadyRegistered(contextDefinition, registry, JPA_CONTEXT_BEAN_NAME, source);
		registerIfNotAlreadyRegistered(new RootBeanDefinition(JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME), registry,
				JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME, source);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getConfigurationInspectionClassLoader(org.springframework.core.io.ResourceLoader)
	 */
	protected ClassLoader getConfigurationInspectionClassLoader(ResourceLoader loader) {

		ClassLoader classLoader = loader.getClassLoader();

		return classLoader != null && LazyJvmAgent.isActive(loader.getClassLoader())
				? new InspectionClassLoader(loader.getClassLoader())
				: loader.getClassLoader();
	}

	/**
	 * Creates an anonymous factory to extract the actual {@link javax.persistence.EntityManager} from the
	 * {@link javax.persistence.EntityManagerFactory} bean name reference.
	 *
	 * @param config
	 * @param source
	 * @return
	 */
	private static AbstractBeanDefinition getEntityManagerBeanDefinitionFor(RepositoryConfigurationSource config,
			@Nullable Object source) {

		BeanDefinitionBuilder builder = BeanDefinitionBuilder
				.rootBeanDefinition(""org.springframework.orm.jpa.SharedEntityManagerCreator"");
		builder.setFactoryMethod(""createSharedEntityManager"");
		builder.addConstructorArgReference(getEntityManagerBeanRef(config));

		AbstractBeanDefinition bean = builder.getRawBeanDefinition();
		bean.setSource(source);

		return bean;
	}

	private static String getEntityManagerBeanRef(RepositoryConfigurationSource config) {

		Optional<String> entityManagerFactoryRef = config.getAttribute(""entityManagerFactoryRef"");
		return entityManagerFactoryRef.orElse(""entityManagerFactory"");
	}

	/**
	 * Utility to determine if a lazy Java agent is being used that might transform classes at a later time.
	 *
	 * @author Mark Paluch
	 * @since 2.1
	 */
	@UtilityClass
	static class LazyJvmAgent {

		private static final Set<String> AGENT_CLASSES;

		static {

			Set<String> agentClasses = new LinkedHashSet<>();

			agentClasses.add(""org.springframework.instrument.InstrumentationSavingAgent"");
			agentClasses.add(""org.eclipse.persistence.internal.jpa.deployment.JavaSECMPInitializerAgent"");

			AGENT_CLASSES = Collections.unmodifiableSet(agentClasses);
		}

		/**
		 * Determine if any agent is active.
		 *
		 * @return {@literal true} if an agent is active.
		 */
		static boolean isActive(@Nullable ClassLoader classLoader) {

			return AGENT_CLASSES.stream() //
					.anyMatch(agentClass -> ClassUtils.isPresent(agentClass, classLoader));
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/config/JpaRepositoryConfigExtension.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.config;

import static org.springframework.data.jpa.repository.config.BeanDefinitionNames.*;

import lombok.experimental.UtilityClass;

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Optional;
import java.util.Set;

import javax.persistence.Entity;
import javax.persistence.MappedSuperclass;
import javax.persistence.PersistenceContext;
import javax.persistence.PersistenceUnit;

import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.core.annotation.AnnotationAttributes;
import org.springframework.core.io.ResourceLoader;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.support.DefaultJpaContext;
import org.springframework.data.jpa.repository.support.EntityManagerBeanDefinitionRegistrarPostProcessor;
import org.springframework.data.jpa.repository.support.JpaEvaluationContextExtension;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
import org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource;
import org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport;
import org.springframework.data.repository.config.RepositoryConfigurationSource;
import org.springframework.data.repository.config.XmlRepositoryConfigurationSource;
import org.springframework.lang.Nullable;
import org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor;
import org.springframework.util.ClassUtils;
import org.springframework.util.StringUtils;

/**
 * JPA specific configuration extension parsing custom attributes from the XML namespace and
 * {@link EnableJpaRepositories} annotation. Also, it registers bean definitions for a
 * {@link PersistenceAnnotationBeanPostProcessor} (to trigger injection into {@link PersistenceContext}/
 * {@link PersistenceUnit} annotated properties and methods) as well as
 * {@link PersistenceExceptionTranslationPostProcessor} to enable exception translation of persistence specific
 * exceptions into Spring's {@link DataAccessException} hierarchy.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Gil Markham
 * @author Thomas Darimont
 * @author Christoph Strobl
 * @author Mark Paluch
 */
public class JpaRepositoryConfigExtension extends RepositoryConfigurationExtensionSupport {

	private static final Class<?> PAB_POST_PROCESSOR = PersistenceAnnotationBeanPostProcessor.class;
	private static final String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = ""transactionManager"";
	private static final String ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE = ""enableDefaultTransactions"";
	private static final String JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME = ""org.springframework.data.jpa.util.JpaMetamodelCacheCleanup"";
	private static final String ESCAPE_CHARACTER_PROPERTY = ""escapeCharacter"";

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getModuleName()
	 */
	@Override
	public String getModuleName() {
		return ""JPA"";
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtension#getRepositoryFactoryBeanClassName()
	 */
	@Override
	public String getRepositoryFactoryBeanClassName() {
		return JpaRepositoryFactoryBean.class.getName();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config14.RepositoryConfigurationExtensionSupport#getModulePrefix()
	 */
	@Override
	protected String getModulePrefix() {
		return getModuleName().toLowerCase(Locale.US);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingAnnotations()
	 */
	@Override
	protected Collection<Class<? extends Annotation>> getIdentifyingAnnotations() {
		return Arrays.asList(Entity.class, MappedSuperclass.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingTypes()
	 */
	@Override
	protected Collection<Class<?>> getIdentifyingTypes() {
		return Collections.<Class<?>> singleton(JpaRepository.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, RepositoryConfigurationSource source) {

		Optional<String> transactionManagerRef = source.getAttribute(""transactionManagerRef"");
		builder.addPropertyValue(""transactionManager"", transactionManagerRef.orElse(DEFAULT_TRANSACTION_MANAGER_BEAN_NAME));
		builder.addPropertyValue(""entityManager"", getEntityManagerBeanDefinitionFor(source, source.getSource()));
		builder.addPropertyValue(ESCAPE_CHARACTER_PROPERTY, getEscapeCharacter(source).orElse('\\'));
		builder.addPropertyReference(""mappingContext"", JPA_MAPPING_CONTEXT_BEAN_NAME);
	}

	/**
	 * XML configurations do not support {@link Character} values. This method catches the exception thrown and returns an
	 * {@link Optional#empty()} instead.
	 */
	private static Optional<Character> getEscapeCharacter(RepositoryConfigurationSource source) {

		try {

			return AnnotationRepositoryConfigurationSource.class.isInstance(source) //
					? Optional.ofNullable((Character) AnnotationRepositoryConfigurationSource.class.cast(source).getAttributes()
							.get(ESCAPE_CHARACTER_PROPERTY)) //
					: source.getAttribute(ESCAPE_CHARACTER_PROPERTY).map(it -> it.toCharArray()[0]);

		} catch (IllegalArgumentException ___) {
			return Optional.empty();
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, AnnotationRepositoryConfigurationSource config) {

		AnnotationAttributes attributes = config.getAttributes();

		builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE,
				attributes.getBoolean(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.XmlRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, XmlRepositoryConfigurationSource config) {

		Optional<String> enableDefaultTransactions = config.getAttribute(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE);

		if (enableDefaultTransactions.isPresent() && StringUtils.hasText(enableDefaultTransactions.get())) {
			builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE, enableDefaultTransactions.get());
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#registerBeansForRoot(org.springframework.beans.factory.support.BeanDefinitionRegistry, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void registerBeansForRoot(BeanDefinitionRegistry registry, RepositoryConfigurationSource config) {

		super.registerBeansForRoot(registry, config);

		Object source = config.getSource();

		registerIfNotAlreadyRegistered(new RootBeanDefinition(EntityManagerBeanDefinitionRegistrarPostProcessor.class),
				registry, EM_BEAN_DEFINITION_REGISTRAR_POST_PROCESSOR_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(JpaMetamodelMappingContextFactoryBean.class), registry,
				JPA_MAPPING_CONTEXT_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(PAB_POST_PROCESSOR), registry,
				AnnotationConfigUtils.PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME, source);

		// Register bean definition for DefaultJpaContext

		RootBeanDefinition contextDefinition = new RootBeanDefinition(DefaultJpaContext.class);
		contextDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);

		registerIfNotAlreadyRegistered(contextDefinition, registry, JPA_CONTEXT_BEAN_NAME, source);
		registerIfNotAlreadyRegistered(new RootBeanDefinition(JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME), registry,
				JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME, source);

		// EvaluationContextExtension for JPA specific SpEL functions

		registerIfNotAlreadyRegistered(() -> {

			Object value = getEscapeCharacter(config).orElse('\\');

			BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(JpaEvaluationContextExtension.class);
			builder.addConstructorArgValue(value);

			return builder.getBeanDefinition();

		}, registry, JpaEvaluationContextExtension.class.getName(), source);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getConfigurationInspectionClassLoader(org.springframework.core.io.ResourceLoader)
	 */
	@Override
	protected ClassLoader getConfigurationInspectionClassLoader(ResourceLoader loader) {

		ClassLoader classLoader = loader.getClassLoader();

		return classLoader != null && LazyJvmAgent.isActive(loader.getClassLoader())
				? new InspectionClassLoader(loader.getClassLoader())
				: loader.getClassLoader();
	}

	/**
	 * Creates an anonymous factory to extract the actual {@link javax.persistence.EntityManager} from the
	 * {@link javax.persistence.EntityManagerFactory} bean name reference.
	 *
	 * @param config
	 * @param source
	 * @return
	 */
	private static AbstractBeanDefinition getEntityManagerBeanDefinitionFor(RepositoryConfigurationSource config,
			@Nullable Object source) {

		BeanDefinitionBuilder builder = BeanDefinitionBuilder
				.rootBeanDefinition(""org.springframework.orm.jpa.SharedEntityManagerCreator"");
		builder.setFactoryMethod(""createSharedEntityManager"");
		builder.addConstructorArgReference(getEntityManagerBeanRef(config));

		AbstractBeanDefinition bean = builder.getRawBeanDefinition();
		bean.setSource(source);

		return bean;
	}

	private static String getEntityManagerBeanRef(RepositoryConfigurationSource config) {

		Optional<String> entityManagerFactoryRef = config.getAttribute(""entityManagerFactoryRef"");
		return entityManagerFactoryRef.orElse(""entityManagerFactory"");
	}

	/**
	 * Utility to determine if a lazy Java agent is being used that might transform classes at a later time.
	 *
	 * @author Mark Paluch
	 * @since 2.1
	 */
	@UtilityClass
	static class LazyJvmAgent {

		private static final Set<String> AGENT_CLASSES;

		static {

			Set<String> agentClasses = new LinkedHashSet<>();

			agentClasses.add(""org.springframework.instrument.InstrumentationSavingAgent"");
			agentClasses.add(""org.eclipse.persistence.internal.jpa.deployment.JavaSECMPInitializerAgent"");

			AGENT_CLASSES = Collections.unmodifiableSet(agentClasses);
		}

		/**
		 * Determine if any agent is active.
		 *
		 * @return {@literal true} if an agent is active.
		 */
		static boolean isActive(@Nullable ClassLoader classLoader) {

			return AGENT_CLASSES.stream() //
					.anyMatch(agentClass -> ClassUtils.isPresent(agentClass, classLoader));
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryCreator.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.springframework.data.jpa.repository.query.QueryUtils.*;
import static org.springframework.data.repository.query.parser.Part.Type.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.ParameterExpression;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Selection;
import javax.persistence.metamodel.SingularAttribute;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.mapping.PropertyPath;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.AbstractQueryCreator;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Query creator to create a {@link CriteriaQuery} from a {@link PartTree}.
 *
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Michael Cramer
 * @author Mark Paluch
 * @author Reda.Housni-Alaoui
 */
public class JpaQueryCreator extends AbstractQueryCreator<CriteriaQuery<? extends Object>, Predicate> {

	private final CriteriaBuilder builder;
	private final Root<?> root;
	private final CriteriaQuery<? extends Object> query;
	private final ParameterMetadataProvider provider;
	private final ReturnedType returnedType;
	private final PartTree tree;
	private final EscapeCharacter escape;

	/**
	 * Create a new {@link JpaQueryCreator}.
	 *
	 * @param tree must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param builder must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public JpaQueryCreator(PartTree tree, ReturnedType type, CriteriaBuilder builder,
			ParameterMetadataProvider provider) {

		super(tree);
		this.tree = tree;

		CriteriaQuery<?> criteriaQuery = createCriteriaQuery(builder, type);

		this.builder = builder;
		this.query = criteriaQuery.distinct(tree.isDistinct());
		this.root = query.from(type.getDomainType());
		this.provider = provider;
		this.returnedType = type;
		this.escape = provider.getEscape();
	}

	/**
	 * Creates the {@link CriteriaQuery} to apply predicates on.
	 *
	 * @param builder will never be {@literal null}.
	 * @param type will never be {@literal null}.
	 * @return must not be {@literal null}.
	 */
	protected CriteriaQuery<? extends Object> createCriteriaQuery(CriteriaBuilder builder, ReturnedType type) {

		Class<?> typeToRead = type.getTypeToRead();

		return typeToRead == null || tree.isExistsProjection() ? builder.createTupleQuery()
				: builder.createQuery(typeToRead);
	}

	/**
	 * Returns all {@link javax.persistence.criteria.ParameterExpression} created when creating the query.
	 *
	 * @return the parameterExpressions
	 */
	public List<ParameterMetadata<?>> getParameterExpressions() {
		return provider.getExpressions();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#create(org.springframework.data.repository.query.parser.Part, java.util.Iterator)
	 */
	@Override
	protected Predicate create(Part part, Iterator<Object> iterator) {

		return toPredicate(part, root);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#and(org.springframework.data.repository.query.parser.Part, java.lang.Object, java.util.Iterator)
	 */
	@Override
	protected Predicate and(Part part, Predicate base, Iterator<Object> iterator) {
		return builder.and(base, toPredicate(part, root));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#or(java.lang.Object, java.lang.Object)
	 */
	@Override
	protected Predicate or(Predicate base, Predicate predicate) {
		return builder.or(base, predicate);
	}

	/**
	 * Finalizes the given {@link Predicate} and applies the given sort. Delegates to
	 * {@link #complete(Predicate, Sort, CriteriaQuery, CriteriaBuilder, Root)} and hands it the current {@link CriteriaQuery}
	 * and {@link CriteriaBuilder}.
	 */
	@Override
	protected final CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort) {
		return complete(predicate, sort, query, builder, root);
	}

	/**
	 * Template method to finalize the given {@link Predicate} using the given {@link CriteriaQuery} and
	 * {@link CriteriaBuilder}.
	 *
	 * @param predicate
	 * @param sort
	 * @param query
	 * @param builder
	 * @return
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	protected CriteriaQuery<? extends Object> complete(@Nullable Predicate predicate, Sort sort,
			CriteriaQuery<? extends Object> query, CriteriaBuilder builder, Root<?> root) {

		if (returnedType.needsCustomConstruction()) {

			List<Selection<?>> selections = new ArrayList<>();

			for (String property : returnedType.getInputProperties()) {

				PropertyPath path = PropertyPath.from(property, returnedType.getDomainType());
				selections.add(toExpressionRecursively(root, path, true).alias(property));
			}

			query = query.multiselect(selections);

		} else if (tree.isExistsProjection()) {

			if (root.getModel().hasSingleIdAttribute()) {

				SingularAttribute<?, ?> id = root.getModel().getId(root.getModel().getIdType().getJavaType());
				query = query.multiselect(root.get((SingularAttribute) id).alias(id.getName()));

			} else {

				query = query.multiselect(root.getModel().getIdClassAttributes().stream()//
						.map(it -> (Selection<?>) root.get((SingularAttribute) it).alias(it.getName()))
						.collect(Collectors.toList()));
			}

		} else {
			query = query.select((Root) root);
		}

		CriteriaQuery<? extends Object> select = query.orderBy(QueryUtils.toOrders(sort, root, builder));
		return predicate == null ? select : select.where(predicate);
	}

	/**
	 * Creates a {@link Predicate} from the given {@link Part}.
	 *
	 * @param part
	 * @param root
	 * @return
	 */
	private Predicate toPredicate(Part part, Root<?> root) {
		return new PredicateBuilder(part, root).build();
	}

	/**
	 * Simple builder to contain logic to create JPA {@link Predicate}s from {@link Part}s.
	 *
	 * @author Phil Webb
	 * @author Oliver Gierke
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private class PredicateBuilder {

		private final Part part;
		private final Root<?> root;

		/**
		 * Creates a new {@link PredicateBuilder} for the given {@link Part} and {@link Root}.
		 *
		 * @param part must not be {@literal null}.
		 * @param root must not be {@literal null}.
		 */
		public PredicateBuilder(Part part, Root<?> root) {

			Assert.notNull(part, ""Part must not be null!"");
			Assert.notNull(root, ""Root must not be null!"");
			this.part = part;
			this.root = root;
		}

		/**
		 * Builds a JPA {@link Predicate} from the underlying {@link Part}.
		 *
		 * @return
		 */
		public Predicate build() {

			PropertyPath property = part.getProperty();
			Type type = part.getType();

			switch (type) {
				case BETWEEN:
					ParameterMetadata<Comparable> first = provider.next(part);
					ParameterMetadata<Comparable> second = provider.next(part);
					return builder.between(getComparablePath(root, part), first.getExpression(), second.getExpression());
				case AFTER:
				case GREATER_THAN:
					return builder.greaterThan(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case GREATER_THAN_EQUAL:
					return builder.greaterThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case BEFORE:
				case LESS_THAN:
					return builder.lessThan(getComparablePath(root, part), provider.next(part, Comparable.class).getExpression());
				case LESS_THAN_EQUAL:
					return builder.lessThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case IS_NULL:
					return getTypedPath(root, part).isNull();
				case IS_NOT_NULL:
					return getTypedPath(root, part).isNotNull();
				case NOT_IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression()).not();
				case IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression());
				case STARTING_WITH:
				case ENDING_WITH:
				case CONTAINING:
				case NOT_CONTAINING:

					if (property.getLeafProperty().isCollection()) {

						Expression<Collection<Object>> propertyExpression = traversePath(root, property);
						ParameterExpression<Object> parameterExpression = provider.next(part).getExpression();

						// Can't just call .not() in case of negation as EclipseLink chokes on that.
						return type.equals(NOT_CONTAINING) ? isNotMember(builder, parameterExpression, propertyExpression)
								: isMember(builder, parameterExpression, propertyExpression);
					}

				case LIKE:
				case NOT_LIKE:
					Expression<String> stringPath = getTypedPath(root, part);
					Expression<String> propertyExpression = upperIfIgnoreCase(stringPath);
					Expression<String> parameterExpression = upperIfIgnoreCase(provider.next(part, String.class).getExpression());
					Predicate like = builder.like(propertyExpression, parameterExpression, escape.getValue());
					return type.equals(NOT_LIKE) || type.equals(NOT_CONTAINING) ? like.not() : like;
				case TRUE:
					Expression<Boolean> truePath = getTypedPath(root, part);
					return builder.isTrue(truePath);
				case FALSE:
					Expression<Boolean> falsePath = getTypedPath(root, part);
					return builder.isFalse(falsePath);
				case SIMPLE_PROPERTY:
					ParameterMetadata<Object> expression = provider.next(part);
					Expression<Object> path = getTypedPath(root, part);
					return expression.isIsNullParameter() ? path.isNull()
							: builder.equal(upperIfIgnoreCase(path), upperIfIgnoreCase(expression.getExpression()));
				case NEGATING_SIMPLE_PROPERTY:
					return builder.notEqual(upperIfIgnoreCase(getTypedPath(root, part)),
							upperIfIgnoreCase(provider.next(part).getExpression()));
				case IS_EMPTY:
				case IS_NOT_EMPTY:

					if (!property.getLeafProperty().isCollection()) {
						throw new IllegalArgumentException(""IsEmpty / IsNotEmpty can only be used on collection properties!"");
					}

					Expression<Collection<Object>> collectionPath = traversePath(root, property);
					return type.equals(IS_NOT_EMPTY) ? builder.isNotEmpty(collectionPath) : builder.isEmpty(collectionPath);

				default:
					throw new IllegalArgumentException(""Unsupported keyword "" + type);
			}
		}

		private <T> Predicate isMember(CriteriaBuilder builder, Expression<T> parameter,
				Expression<Collection<T>> property) {
			return builder.isMember(parameter, property);
		}

		private <T> Predicate isNotMember(CriteriaBuilder builder, Expression<T> parameter,
				Expression<Collection<T>> property) {
			return builder.isNotMember(parameter, property);
		}

		/**
		 * Applies an {@code UPPERCASE} conversion to the given {@link Expression} in case the underlying {@link Part}
		 * requires ignoring case.
		 *
		 * @param expression must not be {@literal null}.
		 * @return
		 */
		private <T> Expression<T> upperIfIgnoreCase(Expression<? extends T> expression) {

			switch (part.shouldIgnoreCase()) {

				case ALWAYS:

					Assert.state(canUpperCase(expression), ""Unable to ignore case of "" + expression.getJavaType().getName()
							+ "" types, the property '"" + part.getProperty().getSegment() + ""' must reference a String"");
					return (Expression<T>) builder.upper((Expression<String>) expression);

				case WHEN_POSSIBLE:

					if (canUpperCase(expression)) {
						return (Expression<T>) builder.upper((Expression<String>) expression);
					}

				case NEVER:
				default:

					return (Expression<T>) expression;
			}
		}

		private boolean canUpperCase(Expression<?> expression) {
			return String.class.equals(expression.getJavaType());
		}

		/**
		 * Returns a path to a {@link Comparable}.
		 *
		 * @param root
		 * @param part
		 * @return
		 */
		private Expression<? extends Comparable> getComparablePath(Root<?> root, Part part) {
			return getTypedPath(root, part);
		}

		private <T> Expression<T> getTypedPath(Root<?> root, Part part) {
			return toExpressionRecursively(root, part.getProperty());
		}

		private <T> Expression<T> traversePath(Path<?> root, PropertyPath path) {

			Path<Object> result = root.get(path.getSegment());
			return (Expression<T>) (path.hasNext() ? traversePath(result, path.next()) : result);
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryCreator.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.springframework.data.jpa.repository.query.QueryUtils.*;
import static org.springframework.data.repository.query.parser.Part.Type.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.ParameterExpression;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Selection;
import javax.persistence.metamodel.SingularAttribute;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.mapping.PropertyPath;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.AbstractQueryCreator;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Query creator to create a {@link CriteriaQuery} from a {@link PartTree}.
 *
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Michael Cramer
 * @author Mark Paluch
 * @author Reda.Housni-Alaoui
 */
public class JpaQueryCreator extends AbstractQueryCreator<CriteriaQuery<? extends Object>, Predicate> {

	private final CriteriaBuilder builder;
	private final Root<?> root;
	private final CriteriaQuery<? extends Object> query;
	private final ParameterMetadataProvider provider;
	private final ReturnedType returnedType;
	private final PartTree tree;
	private final EscapeCharacter escape;

	/**
	 * Create a new {@link JpaQueryCreator}.
	 *
	 * @param tree must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param builder must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public JpaQueryCreator(PartTree tree, ReturnedType type, CriteriaBuilder builder,
			ParameterMetadataProvider provider) {

		super(tree);
		this.tree = tree;

		CriteriaQuery<?> criteriaQuery = createCriteriaQuery(builder, type);

		this.builder = builder;
		this.query = criteriaQuery.distinct(tree.isDistinct());
		this.root = query.from(type.getDomainType());
		this.provider = provider;
		this.returnedType = type;
		this.escape = provider.getEscape();
	}

	/**
	 * Creates the {@link CriteriaQuery} to apply predicates on.
	 *
	 * @param builder will never be {@literal null}.
	 * @param type will never be {@literal null}.
	 * @return must not be {@literal null}.
	 */
	protected CriteriaQuery<? extends Object> createCriteriaQuery(CriteriaBuilder builder, ReturnedType type) {

		Class<?> typeToRead = type.getTypeToRead();

		return typeToRead == null || tree.isExistsProjection() ? builder.createTupleQuery()
				: builder.createQuery(typeToRead);
	}

	/**
	 * Returns all {@link javax.persistence.criteria.ParameterExpression} created when creating the query.
	 *
	 * @return the parameterExpressions
	 */
	public List<ParameterMetadata<?>> getParameterExpressions() {
		return provider.getExpressions();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#create(org.springframework.data.repository.query.parser.Part, java.util.Iterator)
	 */
	@Override
	protected Predicate create(Part part, Iterator<Object> iterator) {

		return toPredicate(part, root);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#and(org.springframework.data.repository.query.parser.Part, java.lang.Object, java.util.Iterator)
	 */
	@Override
	protected Predicate and(Part part, Predicate base, Iterator<Object> iterator) {
		return builder.and(base, toPredicate(part, root));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#or(java.lang.Object, java.lang.Object)
	 */
	@Override
	protected Predicate or(Predicate base, Predicate predicate) {
		return builder.or(base, predicate);
	}

	/**
	 * Finalizes the given {@link Predicate} and applies the given sort. Delegates to
	 * {@link #complete(Predicate, Sort, CriteriaQuery, CriteriaBuilder, Root)} and hands it the current {@link CriteriaQuery}
	 * and {@link CriteriaBuilder}.
	 */
	@Override
	protected final CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort) {
		return complete(predicate, sort, query, builder, root);
	}

	/**
	 * Template method to finalize the given {@link Predicate} using the given {@link CriteriaQuery} and
	 * {@link CriteriaBuilder}.
	 *
	 * @param predicate
	 * @param sort
	 * @param query
	 * @param builder
	 * @return
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	protected CriteriaQuery<? extends Object> complete(@Nullable Predicate predicate, Sort sort,
			CriteriaQuery<? extends Object> query, CriteriaBuilder builder, Root<?> root) {

		if (returnedType.needsCustomConstruction()) {

			List<Selection<?>> selections = new ArrayList<>();

			for (String property : returnedType.getInputProperties()) {

				PropertyPath path = PropertyPath.from(property, returnedType.getDomainType());
				selections.add(toExpressionRecursively(root, path, true).alias(property));
			}

			query = query.multiselect(selections);

		} else if (tree.isExistsProjection()) {

			if (root.getModel().hasSingleIdAttribute()) {

				SingularAttribute<?, ?> id = root.getModel().getId(root.getModel().getIdType().getJavaType());
				query = query.multiselect(root.get((SingularAttribute) id).alias(id.getName()));

			} else {

				query = query.multiselect(root.getModel().getIdClassAttributes().stream()//
						.map(it -> (Selection<?>) root.get((SingularAttribute) it).alias(it.getName()))
						.collect(Collectors.toList()));
			}

		} else {
			query = query.select((Root) root);
		}

		CriteriaQuery<? extends Object> select = query.orderBy(QueryUtils.toOrders(sort, root, builder));
		return predicate == null ? select : select.where(predicate);
	}

	/**
	 * Creates a {@link Predicate} from the given {@link Part}.
	 *
	 * @param part
	 * @param root
	 * @return
	 */
	private Predicate toPredicate(Part part, Root<?> root) {
		return new PredicateBuilder(part, root).build();
	}

	/**
	 * Simple builder to contain logic to create JPA {@link Predicate}s from {@link Part}s.
	 *
	 * @author Phil Webb
	 * @author Oliver Gierke
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private class PredicateBuilder {

		private final Part part;
		private final Root<?> root;

		/**
		 * Creates a new {@link PredicateBuilder} for the given {@link Part} and {@link Root}.
		 *
		 * @param part must not be {@literal null}.
		 * @param root must not be {@literal null}.
		 */
		public PredicateBuilder(Part part, Root<?> root) {

			Assert.notNull(part, ""Part must not be null!"");
			Assert.notNull(root, ""Root must not be null!"");
			this.part = part;
			this.root = root;
		}

		/**
		 * Builds a JPA {@link Predicate} from the underlying {@link Part}.
		 *
		 * @return
		 */
		public Predicate build() {

			PropertyPath property = part.getProperty();
			Type type = part.getType();

			switch (type) {
				case BETWEEN:
					ParameterMetadata<Comparable> first = provider.next(part);
					ParameterMetadata<Comparable> second = provider.next(part);
					return builder.between(getComparablePath(root, part), first.getExpression(), second.getExpression());
				case AFTER:
				case GREATER_THAN:
					return builder.greaterThan(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case GREATER_THAN_EQUAL:
					return builder.greaterThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case BEFORE:
				case LESS_THAN:
					return builder.lessThan(getComparablePath(root, part), provider.next(part, Comparable.class).getExpression());
				case LESS_THAN_EQUAL:
					return builder.lessThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case IS_NULL:
					return getTypedPath(root, part).isNull();
				case IS_NOT_NULL:
					return getTypedPath(root, part).isNotNull();
				case NOT_IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression()).not();
				case IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression());
				case STARTING_WITH:
				case ENDING_WITH:
				case CONTAINING:
				case NOT_CONTAINING:

					if (property.getLeafProperty().isCollection()) {

						Expression<Collection<Object>> propertyExpression = traversePath(root, property);
						ParameterExpression<Object> parameterExpression = provider.next(part).getExpression();

						// Can't just call .not() in case of negation as EclipseLink chokes on that.
						return type.equals(NOT_CONTAINING) ? isNotMember(builder, parameterExpression, propertyExpression)
								: isMember(builder, parameterExpression, propertyExpression);
					}

				case LIKE:
				case NOT_LIKE:
					Expression<String> stringPath = getTypedPath(root, part);
					Expression<String> propertyExpression = upperIfIgnoreCase(stringPath);
					Expression<String> parameterExpression = upperIfIgnoreCase(provider.next(part, String.class).getExpression());
					Predicate like = builder.like(propertyExpression, parameterExpression, escape.getValue());
					return type.equals(NOT_LIKE) || type.equals(NOT_CONTAINING) ? like.not() : like;
				case TRUE:
					Expression<Boolean> truePath = getTypedPath(root, part);
					return builder.isTrue(truePath);
				case FALSE:
					Expression<Boolean> falsePath = getTypedPath(root, part);
					return builder.isFalse(falsePath);
				case SIMPLE_PROPERTY:
					ParameterMetadata<Object> expression = provider.next(part);
					Expression<Object> path = getTypedPath(root, part);
					return expression.isIsNullParameter() ? path.isNull()
							: builder.equal(upperIfIgnoreCase(path), upperIfIgnoreCase(expression.getExpression()));
				case NEGATING_SIMPLE_PROPERTY:
					return builder.notEqual(upperIfIgnoreCase(getTypedPath(root, part)),
							upperIfIgnoreCase(provider.next(part).getExpression()));
				case IS_EMPTY:
				case IS_NOT_EMPTY:

					if (!property.getLeafProperty().isCollection()) {
						throw new IllegalArgumentException(""IsEmpty / IsNotEmpty can only be used on collection properties!"");
					}

					Expression<Collection<Object>> collectionPath = traversePath(root, property);
					return type.equals(IS_NOT_EMPTY) ? builder.isNotEmpty(collectionPath) : builder.isEmpty(collectionPath);

				default:
					throw new IllegalArgumentException(""Unsupported keyword "" + type);
			}
		}

		private <T> Predicate isMember(CriteriaBuilder builder, Expression<T> parameter,
				Expression<Collection<T>> property) {
			return builder.isMember(parameter, property);
		}

		private <T> Predicate isNotMember(CriteriaBuilder builder, Expression<T> parameter,
				Expression<Collection<T>> property) {
			return builder.isNotMember(parameter, property);
		}

		/**
		 * Applies an {@code UPPERCASE} conversion to the given {@link Expression} in case the underlying {@link Part}
		 * requires ignoring case.
		 *
		 * @param expression must not be {@literal null}.
		 * @return
		 */
		private <T> Expression<T> upperIfIgnoreCase(Expression<? extends T> expression) {

			switch (part.shouldIgnoreCase()) {

				case ALWAYS:

					Assert.state(canUpperCase(expression), ""Unable to ignore case of "" + expression.getJavaType().getName()
							+ "" types, the property '"" + part.getProperty().getSegment() + ""' must reference a String"");
					return (Expression<T>) builder.upper((Expression<String>) expression);

				case WHEN_POSSIBLE:

					if (canUpperCase(expression)) {
						return (Expression<T>) builder.upper((Expression<String>) expression);
					}

				case NEVER:
				default:

					return (Expression<T>) expression;
			}
		}

		private boolean canUpperCase(Expression<?> expression) {
			return String.class.equals(expression.getJavaType());
		}

		/**
		 * Returns a path to a {@link Comparable}.
		 *
		 * @param root
		 * @param part
		 * @return
		 */
		private Expression<? extends Comparable> getComparablePath(Root<?> root, Part part) {
			return getTypedPath(root, part);
		}

		private <T> Expression<T> getTypedPath(Root<?> root, Part part) {
			return toExpressionRecursively(root, part.getProperty());
		}

		private <T> Expression<T> traversePath(Path<?> root, PropertyPath path) {

			Path<Object> result = root.get(path.getSegment());
			return (Expression<T>) (path.hasNext() ? traversePath(result, path.next()) : result);
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.RepositoryQuery;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Query lookup strategy to execute finders.
 *
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Mark Paluch
 */
public final class JpaQueryLookupStrategy {

	/**
	 * Private constructor to prevent instantiation.
	 */
	private JpaQueryLookupStrategy() {}

	/**
	 * Base class for {@link QueryLookupStrategy} implementations that need access to an {@link EntityManager}.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private abstract static class AbstractQueryLookupStrategy implements QueryLookupStrategy {

		private final EntityManager em;
		private final QueryExtractor provider;

		/**
		 * Creates a new {@link AbstractQueryLookupStrategy}.
		 *
		 * @param em
		 * @param extractor
		 */
		public AbstractQueryLookupStrategy(EntityManager em, QueryExtractor extractor) {

			this.em = em;
			this.provider = extractor;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.query.QueryLookupStrategy#resolveQuery(java.lang.reflect.Method, org.springframework.data.repository.core.RepositoryMetadata, org.springframework.data.projection.ProjectionFactory, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		public final RepositoryQuery resolveQuery(Method method, RepositoryMetadata metadata, ProjectionFactory factory,
				NamedQueries namedQueries) {
			return resolveQuery(new JpaQueryMethod(method, metadata, factory, provider), em, namedQueries);
		}

		protected abstract RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries);
	}

	/**
	 * {@link QueryLookupStrategy} to create a query from the method name.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final PersistenceProvider persistenceProvider;
		private final EscapeCharacter escape;

		public CreateQueryLookupStrategy(EntityManager em, QueryExtractor extractor, EscapeCharacter escape) {

			super(em, extractor);

			this.persistenceProvider = PersistenceProvider.fromEntityManager(em);
			this.escape = escape;
		}

		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {
			return new PartTreeJpaQuery(method, em, persistenceProvider, escape);
		}
	}

	/**
	 * {@link QueryLookupStrategy} that tries to detect a declared query declared via {@link Query} annotation followed by
	 * a JPA named query lookup.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class DeclaredQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final EvaluationContextProvider evaluationContextProvider;

		/**
		 * Creates a new {@link DeclaredQueryLookupStrategy}.
		 *
		 * @param em
		 * @param extractor
		 * @param evaluationContextProvider
		 */
		public DeclaredQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				EvaluationContextProvider evaluationContextProvider) {

			super(em, extractor);
			this.evaluationContextProvider = evaluationContextProvider;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			RepositoryQuery query = JpaQueryFactory.INSTANCE.fromQueryAnnotation(method, em, evaluationContextProvider);

			if (null != query) {
				return query;
			}

			query = JpaQueryFactory.INSTANCE.fromProcedureAnnotation(method, em);

			if (null != query) {
				return query;
			}

			String name = method.getNamedQueryName();
			if (namedQueries.hasQuery(name)) {
				return JpaQueryFactory.INSTANCE.fromMethodWithQueryString(method, em, namedQueries.getQuery(name),
						evaluationContextProvider);
			}

			query = NamedQuery.lookupFrom(method, em);

			if (null != query) {
				return query;
			}

			throw new IllegalStateException(
					String.format(""Did neither find a NamedQuery nor an annotated query for method %s!"", method));
		}
	}

	/**
	 * {@link QueryLookupStrategy} to try to detect a declared query first (
	 * {@link org.springframework.data.jpa.repository.Query}, JPA named query). In case none is found we fall back on
	 * query creation.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateIfNotFoundQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final DeclaredQueryLookupStrategy lookupStrategy;
		private final CreateQueryLookupStrategy createStrategy;

		/**
		 * Creates a new {@link CreateIfNotFoundQueryLookupStrategy}.
		 *
		 * @param em
		 * @param extractor
		 * @param createStrategy
		 * @param lookupStrategy
		 */
		public CreateIfNotFoundQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				CreateQueryLookupStrategy createStrategy, DeclaredQueryLookupStrategy lookupStrategy) {

			super(em, extractor);

			this.createStrategy = createStrategy;
			this.lookupStrategy = lookupStrategy;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			try {
				return lookupStrategy.resolveQuery(method, em, namedQueries);
			} catch (IllegalStateException e) {
				return createStrategy.resolveQuery(method, em, namedQueries);
			}
		}
	}

	/**
	 * Creates a {@link QueryLookupStrategy} for the given {@link EntityManager} and {@link Key}.
	 *
	 * @param em must not be {@literal null}.
	 * @param key may be {@literal null}.
	 * @param extractor must not be {@literal null}.
	 * @param evaluationContextProvider must not be {@literal null}.
	 * @param escape
	 * @return
	 */
	public static QueryLookupStrategy create(EntityManager em, @Nullable Key key, QueryExtractor extractor,
			EvaluationContextProvider evaluationContextProvider, EscapeCharacter escape) {

		Assert.notNull(em, ""EntityManager must not be null!"");
		Assert.notNull(extractor, ""QueryExtractor must not be null!"");
		Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");

		switch (key != null ? key : Key.CREATE_IF_NOT_FOUND) {
			case CREATE:
				return new CreateQueryLookupStrategy(em, extractor, escape);
			case USE_DECLARED_QUERY:
				return new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider);
			case CREATE_IF_NOT_FOUND:
				return new CreateIfNotFoundQueryLookupStrategy(em, extractor,
						new CreateQueryLookupStrategy(em, extractor, escape),
						new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider));
			default:
				throw new IllegalArgumentException(String.format(""Unsupported query lookup strategy %s!"", key));
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.RepositoryQuery;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Query lookup strategy to execute finders.
 *
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Mark Paluch
 */
public final class JpaQueryLookupStrategy {

	/**
	 * Private constructor to prevent instantiation.
	 */
	private JpaQueryLookupStrategy() {}

	/**
	 * Base class for {@link QueryLookupStrategy} implementations that need access to an {@link EntityManager}.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private abstract static class AbstractQueryLookupStrategy implements QueryLookupStrategy {

		private final EntityManager em;
		private final QueryExtractor provider;

		/**
		 * Creates a new {@link AbstractQueryLookupStrategy}.
		 *
		 * @param em
		 * @param extractor
		 */
		public AbstractQueryLookupStrategy(EntityManager em, QueryExtractor extractor) {

			this.em = em;
			this.provider = extractor;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.query.QueryLookupStrategy#resolveQuery(java.lang.reflect.Method, org.springframework.data.repository.core.RepositoryMetadata, org.springframework.data.projection.ProjectionFactory, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		public final RepositoryQuery resolveQuery(Method method, RepositoryMetadata metadata, ProjectionFactory factory,
				NamedQueries namedQueries) {
			return resolveQuery(new JpaQueryMethod(method, metadata, factory, provider), em, namedQueries);
		}

		protected abstract RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries);
	}

	/**
	 * {@link QueryLookupStrategy} to create a query from the method name.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final PersistenceProvider persistenceProvider;
		private final EscapeCharacter escape;

		public CreateQueryLookupStrategy(EntityManager em, QueryExtractor extractor, EscapeCharacter escape) {

			super(em, extractor);

			this.persistenceProvider = PersistenceProvider.fromEntityManager(em);
			this.escape = escape;
		}

		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {
			return new PartTreeJpaQuery(method, em, persistenceProvider, escape);
		}
	}

	/**
	 * {@link QueryLookupStrategy} that tries to detect a declared query declared via {@link Query} annotation followed by
	 * a JPA named query lookup.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class DeclaredQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final EvaluationContextProvider evaluationContextProvider;

		/**
		 * Creates a new {@link DeclaredQueryLookupStrategy}.
		 *
		 * @param em
		 * @param extractor
		 * @param evaluationContextProvider
		 */
		public DeclaredQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				EvaluationContextProvider evaluationContextProvider) {

			super(em, extractor);
			this.evaluationContextProvider = evaluationContextProvider;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			RepositoryQuery query = JpaQueryFactory.INSTANCE.fromQueryAnnotation(method, em, evaluationContextProvider);

			if (null != query) {
				return query;
			}

			query = JpaQueryFactory.INSTANCE.fromProcedureAnnotation(method, em);

			if (null != query) {
				return query;
			}

			String name = method.getNamedQueryName();
			if (namedQueries.hasQuery(name)) {
				return JpaQueryFactory.INSTANCE.fromMethodWithQueryString(method, em, namedQueries.getQuery(name),
						evaluationContextProvider);
			}

			query = NamedQuery.lookupFrom(method, em);

			if (null != query) {
				return query;
			}

			throw new IllegalStateException(
					String.format(""Did neither find a NamedQuery nor an annotated query for method %s!"", method));
		}
	}

	/**
	 * {@link QueryLookupStrategy} to try to detect a declared query first (
	 * {@link org.springframework.data.jpa.repository.Query}, JPA named query). In case none is found we fall back on
	 * query creation.
	 *
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private static class CreateIfNotFoundQueryLookupStrategy extends AbstractQueryLookupStrategy {

		private final DeclaredQueryLookupStrategy lookupStrategy;
		private final CreateQueryLookupStrategy createStrategy;

		/**
		 * Creates a new {@link CreateIfNotFoundQueryLookupStrategy}.
		 *
		 * @param em
		 * @param extractor
		 * @param createStrategy
		 * @param lookupStrategy
		 */
		public CreateIfNotFoundQueryLookupStrategy(EntityManager em, QueryExtractor extractor,
				CreateQueryLookupStrategy createStrategy, DeclaredQueryLookupStrategy lookupStrategy) {

			super(em, extractor);

			this.createStrategy = createStrategy;
			this.lookupStrategy = lookupStrategy;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.AbstractQueryLookupStrategy#resolveQuery(org.springframework.data.jpa.repository.query.JpaQueryMethod, javax.persistence.EntityManager, org.springframework.data.repository.core.NamedQueries)
		 */
		@Override
		protected RepositoryQuery resolveQuery(JpaQueryMethod method, EntityManager em, NamedQueries namedQueries) {

			try {
				return lookupStrategy.resolveQuery(method, em, namedQueries);
			} catch (IllegalStateException e) {
				return createStrategy.resolveQuery(method, em, namedQueries);
			}
		}
	}

	/**
	 * Creates a {@link QueryLookupStrategy} for the given {@link EntityManager} and {@link Key}.
	 *
	 * @param em must not be {@literal null}.
	 * @param key may be {@literal null}.
	 * @param extractor must not be {@literal null}.
	 * @param evaluationContextProvider must not be {@literal null}.
	 * @param escape
	 * @return
	 */
	public static QueryLookupStrategy create(EntityManager em, @Nullable Key key, QueryExtractor extractor,
			EvaluationContextProvider evaluationContextProvider, EscapeCharacter escape) {

		Assert.notNull(em, ""EntityManager must not be null!"");
		Assert.notNull(extractor, ""QueryExtractor must not be null!"");
		Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");

		switch (key != null ? key : Key.CREATE_IF_NOT_FOUND) {
			case CREATE:
				return new CreateQueryLookupStrategy(em, extractor, escape);
			case USE_DECLARED_QUERY:
				return new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider);
			case CREATE_IF_NOT_FOUND:
				return new CreateIfNotFoundQueryLookupStrategy(em, extractor,
						new CreateQueryLookupStrategy(em, extractor, escape),
						new DeclaredQueryLookupStrategy(em, extractor, evaluationContextProvider));
			default:
				throw new IllegalArgumentException(String.format(""Unsupported query lookup strategy %s!"", key));
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/ParameterMetadataProvider.java,"/*
 * Copyright 2011-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.function.Supplier;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.Parameter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.expression.Expression;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;

/**
 * Helper class to allow easy creation of {@link ParameterMetadata}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Mark Paluch
 * @author Christoph Strobl
 * @author Jens Schauder
 */
class ParameterMetadataProvider {

	private final CriteriaBuilder builder;
	private final Iterator<? extends Parameter> parameters;
	private final List<ParameterMetadata<?>> expressions;
	private final @Nullable Iterator<Object> bindableParameterValues;
	private final PersistenceProvider persistenceProvider;
	private final EscapeCharacter escape;

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and
	 * {@link ParametersParameterAccessor} with support for parameter value customizations via {@link PersistenceProvider}
	 * .
	 * 
	 * @param builder must not be {@literal null}.
	 * @param accessor must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, ParametersParameterAccessor accessor,
									 PersistenceProvider provider, EscapeCharacter escape) {
		this(builder, accessor.iterator(), accessor.getParameters(), provider, escape);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and {@link Parameters} with
	 * support for parameter value customizations via {@link PersistenceProvider}.
	 * 
	 *  @param builder must not be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, Parameters<?, ?> parameters, PersistenceProvider provider, EscapeCharacter escape) {
		this(builder, null, parameters, provider, escape);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} an {@link Iterable} of all
	 * bindable parameter values, and {@link Parameters} with support for parameter value customizations via
	 * {@link PersistenceProvider}.
	 * 
	 * @param builder must not be {@literal null}.
	 * @param bindableParameterValues may be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	private ParameterMetadataProvider(CriteriaBuilder builder, @Nullable Iterator<Object> bindableParameterValues,
									  Parameters<?, ?> parameters, PersistenceProvider provider, EscapeCharacter escape) {

		Assert.notNull(builder, ""CriteriaBuilder must not be null!"");
		Assert.notNull(parameters, ""Parameters must not be null!"");
		Assert.notNull(provider, ""PesistenceProvider must not be null!"");

		this.builder = builder;
		this.parameters = parameters.getBindableParameters().iterator();
		this.expressions = new ArrayList<>();
		this.bindableParameterValues = bindableParameterValues;
		this.persistenceProvider = provider;
		this.escape = escape;
	}

	/**
	 * Returns all {@link ParameterMetadata}s built.
	 * 
	 * @return the expressions
	 */
	public List<ParameterMetadata<?>> getExpressions() {
		return Collections.unmodifiableList(expressions);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for given {@link Part} and the next {@link Parameter}.
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<T> next(Part part) {

		Assert.isTrue(parameters.hasNext(), () -> String.format(""No parameter available for part %s."", part));

		Parameter parameter = parameters.next();
		return (ParameterMetadata<T>) next(part, parameter.getType(), parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} of the given {@link Part} and type. Forwards the underlying
	 * {@link Parameters} as well.
	 * 
	 * @param <T> is the type parameter of the returend {@link ParameterMetadata}.
	 * @param type must not be {@literal null}.
	 * @return ParameterMetadata for the next parameter.
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<? extends T> next(Part part, Class<T> type) {

		Parameter parameter = parameters.next();
		Class<?> typeToUse = ClassUtils.isAssignable(type, parameter.getType()) ? parameter.getType() : type;
		return (ParameterMetadata<? extends T>) next(part, typeToUse, parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for the given type and name.
	 * 
	 * @param <T> type parameter for the returned {@link ParameterMetadata}.
	 * @param part must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param parameter providing the name for the returned {@link ParameterMetadata}.
	 * @return a new {@link ParameterMetadata} for the given type and name.
	 */
	private <T> ParameterMetadata<T> next(Part part, Class<T> type, Parameter parameter) {

		Assert.notNull(type, ""Type must not be null!"");

		/*
		 * We treat Expression types as Object vales since the real value to be bound as a parameter is determined at query time.
		 */
		@SuppressWarnings(""unchecked"")
		Class<T> reifiedType = Expression.class.equals(type) ? (Class<T>) Object.class : type;

		Supplier<String> name = () -> parameter.getName()
				.orElseThrow(() -> new IllegalArgumentException(""o_O Parameter needs to be named""));

		ParameterExpression<T> expression = parameter.isExplicitlyNamed() //
				? builder.parameter(reifiedType, name.get()) //
				: builder.parameter(reifiedType);

		Object value = bindableParameterValues == null ? ParameterMetadata.PLACEHOLDER : bindableParameterValues.next();

		ParameterMetadata<T> metadata = new ParameterMetadata<>(expression, part.getType(), value, persistenceProvider, escape);
		expressions.add(metadata);

		return metadata;
	}

	EscapeCharacter getEscape() {
		return escape;
	}

	/**
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 * @param <T>
	 */
	static class ParameterMetadata<T> {

		static final Object PLACEHOLDER = new Object();

		private final Type type;
		private final ParameterExpression<T> expression;
		private final PersistenceProvider persistenceProvider;
		private final EscapeCharacter escape;

		/**
		 * Creates a new {@link ParameterMetadata}.
		 */
		public ParameterMetadata(ParameterExpression<T> expression, Type type, @Nullable Object value,
								 PersistenceProvider provider, EscapeCharacter escape) {

			this.expression = expression;
			this.persistenceProvider = provider;
			this.type = value == null && Type.SIMPLE_PROPERTY.equals(type) ? Type.IS_NULL : type;
			this.escape = escape;
		}

		/**
		 * Returns the {@link ParameterExpression}.
		 * 
		 * @return the expression
		 */
		public ParameterExpression<T> getExpression() {
			return expression;
		}

		/**
		 * Returns whether the parameter shall be considered an {@literal IS NULL} parameter.
		 */
		public boolean isIsNullParameter() {
			return Type.IS_NULL.equals(type);
		}

		/**
		 * Prepares the object before it's actually bound to the {@link javax.persistence.Query;}.
		 * 
		 * @param value must not be {@literal null}.
		 */
		@Nullable
		public Object prepare(Object value) {

			Assert.notNull(value, ""Value must not be null!"");

			Class<? extends T> expressionType = expression.getJavaType();

			if (String.class.equals(expressionType)) {

				switch (type) {
					case STARTING_WITH:
						return String.format(""%s%%"", escape.escape(value.toString()));
					case ENDING_WITH:
						return String.format(""%%%s"", escape.escape(value.toString()));
					case CONTAINING:
					case NOT_CONTAINING:
						return String.format(""%%%s%%"", escape.escape(value.toString()));
					default:
						return value;
				}
			}

			return Collection.class.isAssignableFrom(expressionType) //
					? persistenceProvider.potentiallyConvertEmptyCollection(toCollection(value)) //
					: value;
		}

		/**
		 * Returns the given argument as {@link Collection} which means it will return it as is if it's a
		 * {@link Collections}, turn an array into an {@link ArrayList} or simply wrap any other value into a single element
		 * {@link Collections}.
		 * 
		 * @param value the value to be converted to a {@link Collection}.
		 * @return the object itself as a {@link Collection} or a {@link Collection} constructed from the value.
		 */
		@Nullable
		private static Collection<?> toCollection(@Nullable Object value) {

			if (value == null) {
				return null;
			}

			if (value instanceof Collection) {
				return (Collection<?>) value;
			}

			if (ObjectUtils.isArray(value)) {
				return Arrays.asList(ObjectUtils.toObjectArray(value));
			}

			return Collections.singleton(value);
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/ParameterMetadataProvider.java,"/*
 * Copyright 2011-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.function.Supplier;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.repository.query.Parameter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.expression.Expression;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;

/**
 * Helper class to allow easy creation of {@link ParameterMetadata}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Mark Paluch
 * @author Christoph Strobl
 * @author Jens Schauder
 */
class ParameterMetadataProvider {

	private final CriteriaBuilder builder;
	private final Iterator<? extends Parameter> parameters;
	private final List<ParameterMetadata<?>> expressions;
	private final @Nullable Iterator<Object> bindableParameterValues;
	private final PersistenceProvider persistenceProvider;
	private final EscapeCharacter escape;

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and
	 * {@link ParametersParameterAccessor} with support for parameter value customizations via {@link PersistenceProvider}
	 * .
	 * 
	 * @param builder must not be {@literal null}.
	 * @param accessor must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, ParametersParameterAccessor accessor,
									 PersistenceProvider provider, EscapeCharacter escape) {
		this(builder, accessor.iterator(), accessor.getParameters(), provider, escape);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} and {@link Parameters} with
	 * support for parameter value customizations via {@link PersistenceProvider}.
	 * 
	 *  @param builder must not be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	public ParameterMetadataProvider(CriteriaBuilder builder, Parameters<?, ?> parameters, PersistenceProvider provider, EscapeCharacter escape) {
		this(builder, null, parameters, provider, escape);
	}

	/**
	 * Creates a new {@link ParameterMetadataProvider} from the given {@link CriteriaBuilder} an {@link Iterable} of all
	 * bindable parameter values, and {@link Parameters} with support for parameter value customizations via
	 * {@link PersistenceProvider}.
	 * 
	 * @param builder must not be {@literal null}.
	 * @param bindableParameterValues may be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 * @param escape
	 */
	private ParameterMetadataProvider(CriteriaBuilder builder, @Nullable Iterator<Object> bindableParameterValues,
									  Parameters<?, ?> parameters, PersistenceProvider provider, EscapeCharacter escape) {

		Assert.notNull(builder, ""CriteriaBuilder must not be null!"");
		Assert.notNull(parameters, ""Parameters must not be null!"");
		Assert.notNull(provider, ""PesistenceProvider must not be null!"");

		this.builder = builder;
		this.parameters = parameters.getBindableParameters().iterator();
		this.expressions = new ArrayList<>();
		this.bindableParameterValues = bindableParameterValues;
		this.persistenceProvider = provider;
		this.escape = escape;
	}

	/**
	 * Returns all {@link ParameterMetadata}s built.
	 * 
	 * @return the expressions
	 */
	public List<ParameterMetadata<?>> getExpressions() {
		return Collections.unmodifiableList(expressions);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for given {@link Part} and the next {@link Parameter}.
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<T> next(Part part) {

		Assert.isTrue(parameters.hasNext(), () -> String.format(""No parameter available for part %s."", part));

		Parameter parameter = parameters.next();
		return (ParameterMetadata<T>) next(part, parameter.getType(), parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} of the given {@link Part} and type. Forwards the underlying
	 * {@link Parameters} as well.
	 * 
	 * @param <T> is the type parameter of the returend {@link ParameterMetadata}.
	 * @param type must not be {@literal null}.
	 * @return ParameterMetadata for the next parameter.
	 */
	@SuppressWarnings(""unchecked"")
	public <T> ParameterMetadata<? extends T> next(Part part, Class<T> type) {

		Parameter parameter = parameters.next();
		Class<?> typeToUse = ClassUtils.isAssignable(type, parameter.getType()) ? parameter.getType() : type;
		return (ParameterMetadata<? extends T>) next(part, typeToUse, parameter);
	}

	/**
	 * Builds a new {@link ParameterMetadata} for the given type and name.
	 * 
	 * @param <T> type parameter for the returned {@link ParameterMetadata}.
	 * @param part must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param parameter providing the name for the returned {@link ParameterMetadata}.
	 * @return a new {@link ParameterMetadata} for the given type and name.
	 */
	private <T> ParameterMetadata<T> next(Part part, Class<T> type, Parameter parameter) {

		Assert.notNull(type, ""Type must not be null!"");

		/*
		 * We treat Expression types as Object vales since the real value to be bound as a parameter is determined at query time.
		 */
		@SuppressWarnings(""unchecked"")
		Class<T> reifiedType = Expression.class.equals(type) ? (Class<T>) Object.class : type;

		Supplier<String> name = () -> parameter.getName()
				.orElseThrow(() -> new IllegalArgumentException(""o_O Parameter needs to be named""));

		ParameterExpression<T> expression = parameter.isExplicitlyNamed() //
				? builder.parameter(reifiedType, name.get()) //
				: builder.parameter(reifiedType);

		Object value = bindableParameterValues == null ? ParameterMetadata.PLACEHOLDER : bindableParameterValues.next();

		ParameterMetadata<T> metadata = new ParameterMetadata<>(expression, part.getType(), value, persistenceProvider, escape);
		expressions.add(metadata);

		return metadata;
	}

	EscapeCharacter getEscape() {
		return escape;
	}

	/**
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 * @param <T>
	 */
	static class ParameterMetadata<T> {

		static final Object PLACEHOLDER = new Object();

		private final Type type;
		private final ParameterExpression<T> expression;
		private final PersistenceProvider persistenceProvider;
		private final EscapeCharacter escape;

		/**
		 * Creates a new {@link ParameterMetadata}.
		 */
		public ParameterMetadata(ParameterExpression<T> expression, Type type, @Nullable Object value,
								 PersistenceProvider provider, EscapeCharacter escape) {

			this.expression = expression;
			this.persistenceProvider = provider;
			this.type = value == null && Type.SIMPLE_PROPERTY.equals(type) ? Type.IS_NULL : type;
			this.escape = escape;
		}

		/**
		 * Returns the {@link ParameterExpression}.
		 * 
		 * @return the expression
		 */
		public ParameterExpression<T> getExpression() {
			return expression;
		}

		/**
		 * Returns whether the parameter shall be considered an {@literal IS NULL} parameter.
		 */
		public boolean isIsNullParameter() {
			return Type.IS_NULL.equals(type);
		}

		/**
		 * Prepares the object before it's actually bound to the {@link javax.persistence.Query;}.
		 * 
		 * @param value must not be {@literal null}.
		 */
		@Nullable
		public Object prepare(Object value) {

			Assert.notNull(value, ""Value must not be null!"");

			Class<? extends T> expressionType = expression.getJavaType();

			if (String.class.equals(expressionType)) {

				switch (type) {
					case STARTING_WITH:
						return String.format(""%s%%"", escape.escape(value.toString()));
					case ENDING_WITH:
						return String.format(""%%%s"", escape.escape(value.toString()));
					case CONTAINING:
					case NOT_CONTAINING:
						return String.format(""%%%s%%"", escape.escape(value.toString()));
					default:
						return value;
				}
			}

			return Collection.class.isAssignableFrom(expressionType) //
					? persistenceProvider.potentiallyConvertEmptyCollection(toCollection(value)) //
					: value;
		}

		/**
		 * Returns the given argument as {@link Collection} which means it will return it as is if it's a
		 * {@link Collections}, turn an array into an {@link ArrayList} or simply wrap any other value into a single element
		 * {@link Collections}.
		 * 
		 * @param value the value to be converted to a {@link Collection}.
		 * @return the object itself as a {@link Collection} or a {@link Collection} constructed from the value.
		 */
		@Nullable
		private static Collection<?> toCollection(@Nullable Object value) {

			if (value == null) {
				return null;
			}

			if (value instanceof Collection) {
				return (Collection<?>) value;
			}

			if (ObjectUtils.isArray(value)) {
				return Arrays.asList(ObjectUtils.toObjectArray(value));
			}

			return Collections.singleton(value);
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/PartTreeJpaQuery.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.List;
import java.util.Optional;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.DeleteExecution;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.ExistsExecution;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.ResultProcessor;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.lang.Nullable;

/**
 * A {@link AbstractJpaQuery} implementation based on a {@link PartTree}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Christoph Strobl
 * @author Jens Schauder
 * @author Mark Paluch
 * @author Сергей Цыпанов
 */
public class PartTreeJpaQuery extends AbstractJpaQuery {

	private final PartTree tree;
	private final JpaParameters parameters;

	private final QueryPreparer query;
	private final QueryPreparer countQuery;
	private final EntityManager em;
	private final EscapeCharacter escape;

	/**
	 * Creates a new {@link PartTreeJpaQuery}.
	 * 
	 * @param method must not be {@literal null}.
	 * @param em must not be {@literal null}.
	 * @param persistenceProvider must not be {@literal null}.
	 * @param escape
	 */
	PartTreeJpaQuery(JpaQueryMethod method, EntityManager em, PersistenceProvider persistenceProvider, EscapeCharacter escape) {

		super(method, em);

		this.em = em;
		this.escape = escape;
		Class<?> domainClass = method.getEntityInformation().getJavaType();
		this.parameters = method.getParameters();

		boolean recreationRequired = parameters.hasDynamicProjection() || parameters.potentiallySortsDynamically();

		try {

			this.tree = new PartTree(method.getName(), domainClass);
			this.countQuery = new CountQueryPreparer(persistenceProvider, recreationRequired);
			this.query = tree.isCountProjection() ? countQuery : new QueryPreparer(persistenceProvider, recreationRequired);

		} catch (Exception o_O) {
			throw new IllegalArgumentException(
					String.format(""Failed to create query for method %s! %s"", method, o_O.getMessage()), o_O);
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateQuery(java.lang.Object[])
	 */
	@Override
	public Query doCreateQuery(Object[] values) {
		return query.createQuery(values);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateCountQuery(java.lang.Object[])
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public TypedQuery<Long> doCreateCountQuery(Object[] values) {
		return (TypedQuery<Long>) countQuery.createQuery(values);
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#getExecution()
	 */
	@Override
	protected JpaQueryExecution getExecution() {

		if (this.tree.isDelete()) {
			return new DeleteExecution(em);
		} else if (this.tree.isExistsProjection()) {
			return new ExistsExecution();
		}

		return super.getExecution();
	}

	/**
	 * Query preparer to create {@link CriteriaQuery} instances and potentially cache them.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class QueryPreparer {

		private final @Nullable CriteriaQuery<?> cachedCriteriaQuery;
		private final @Nullable ParameterBinder cachedParameterBinder;
		private final @Nullable List<ParameterMetadata<?>> expressions;
		private final PersistenceProvider persistenceProvider;

		QueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {

			this.persistenceProvider = persistenceProvider;

			JpaQueryCreator creator = createCreator(persistenceProvider, Optional.empty());

			if (recreateQueries) {
				this.cachedCriteriaQuery = null;
				this.expressions = null;
				this.cachedParameterBinder = null;
			} else {
				this.cachedCriteriaQuery = creator.createQuery();
				this.expressions = creator.getParameterExpressions();
				this.cachedParameterBinder = getBinder(expressions);
			}
		}

		/**
		 * Creates a new {@link Query} for the given parameter values.
		 */
		public Query createQuery(Object[] values) {

			CriteriaQuery<?> criteriaQuery = cachedCriteriaQuery;
			ParameterBinder parameterBinder = cachedParameterBinder;
			ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, values);

			if (cachedCriteriaQuery == null || accessor.hasBindableNullValue()) {
				JpaQueryCreator creator = createCreator(persistenceProvider, Optional.of(accessor));
				criteriaQuery = creator.createQuery(getDynamicSort(values));
				List<ParameterMetadata<?>> expressions = creator.getParameterExpressions();
				parameterBinder = getBinder(expressions);
			}

			if (parameterBinder == null) {
				throw new IllegalStateException(""ParameterBinder is null!"");
			}

			return restrictMaxResultsIfNecessary(invokeBinding(parameterBinder, createQuery(criteriaQuery), values));
		}

		/**
		 * Restricts the max results of the given {@link Query} if the current {@code tree} marks this {@code query} as
		 * limited.
		 */
		private Query restrictMaxResultsIfNecessary(Query query) {

			if (tree.isLimiting()) {

				if (query.getMaxResults() != Integer.MAX_VALUE) {
					/*
					 * In order to return the correct results, we have to adjust the first result offset to be returned if:
					 * - a Pageable parameter is present 
					 * - AND the requested page number > 0
					 * - AND the requested page size was bigger than the derived result limitation via the First/Top keyword.
					 */
					if (query.getMaxResults() > tree.getMaxResults() && query.getFirstResult() > 0) {
						query.setFirstResult(query.getFirstResult() - (query.getMaxResults() - tree.getMaxResults()));
					}
				}

				query.setMaxResults(tree.getMaxResults());
			}

			if (tree.isExistsProjection()) {
				query.setMaxResults(1);
			}

			return query;
		}

		/**
		 * Checks whether we are working with a cached {@link CriteriaQuery} and synchronizes the creation of a
		 * {@link TypedQuery} instance from it. This is due to non-thread-safety in the {@link CriteriaQuery} implementation
		 * of some persistence providers (i.e. Hibernate in this case), see DATAJPA-396.
		 * 
		 * @param criteriaQuery must not be {@literal null}.
		 */
		private TypedQuery<?> createQuery(CriteriaQuery<?> criteriaQuery) {

			if (this.cachedCriteriaQuery != null) {
				synchronized (this.cachedCriteriaQuery) {
					return getEntityManager().createQuery(criteriaQuery);
				}
			}

			return getEntityManager().createQuery(criteriaQuery);
		}

		protected JpaQueryCreator createCreator(PersistenceProvider persistenceProvider,
				Optional<ParametersParameterAccessor> accessor) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor
					.map(it -> new ParameterMetadataProvider(builder, it, persistenceProvider, escape))//
					.orElseGet(() -> new ParameterMetadataProvider(builder, parameters, persistenceProvider, escape));

			ResultProcessor processor = getQueryMethod().getResultProcessor();
			ReturnedType returnedType = accessor.map(processor::withDynamicProjection)//
					.orElse(processor).getReturnedType();

			return new JpaQueryCreator(tree, returnedType, builder, provider);
		}

		/**
		 * Invokes parameter binding on the given {@link TypedQuery}.
		 */
		protected Query invokeBinding(ParameterBinder binder, TypedQuery<?> query, Object[] values) {

			return binder.bindAndPrepare(query, values);
		}

		private ParameterBinder getBinder(List<ParameterMetadata<?>> expressions) {
			return ParameterBinderFactory.createCriteriaBinder(parameters, expressions);
		}

		private Sort getDynamicSort(Object[] values) {

			return parameters.potentiallySortsDynamically() //
					? new ParametersParameterAccessor(parameters, values).getSort() //
					: Sort.unsorted();
		}
	}

	/**
	 * Special {@link QueryPreparer} to create count queries.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class CountQueryPreparer extends QueryPreparer {

		CountQueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {
			super(persistenceProvider, recreateQueries);
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#createCreator(org.springframework.data.repository.query.ParametersParameterAccessor, org.springframework.data.jpa.provider.PersistenceProvider)
		 */
		@Override
		protected JpaQueryCreator createCreator(PersistenceProvider persistenceProvider,
				Optional<ParametersParameterAccessor> accessor) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor
					.map(it -> new ParameterMetadataProvider(builder, it, persistenceProvider, escape))//
					.orElseGet(() -> new ParameterMetadataProvider(builder, parameters, persistenceProvider, escape));

			return new JpaCountQueryCreator(tree, getQueryMethod().getResultProcessor().getReturnedType(), builder, provider);
		}

		/**
		 * Customizes binding by skipping the pagination.
		 * 
		 * @see QueryPreparer#invokeBinding(ParameterBinder, TypedQuery, Object[])
		 */
		@Override
		protected Query invokeBinding(ParameterBinder binder, TypedQuery<?> query, Object[] values) {
			return binder.bind(query, values);
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/PartTreeJpaQuery.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.List;
import java.util.Optional;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.DeleteExecution;
import org.springframework.data.jpa.repository.query.JpaQueryExecution.ExistsExecution;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.ResultProcessor;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.lang.Nullable;

/**
 * A {@link AbstractJpaQuery} implementation based on a {@link PartTree}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Christoph Strobl
 * @author Jens Schauder
 * @author Mark Paluch
 * @author Сергей Цыпанов
 */
public class PartTreeJpaQuery extends AbstractJpaQuery {

	private final PartTree tree;
	private final JpaParameters parameters;

	private final QueryPreparer query;
	private final QueryPreparer countQuery;
	private final EntityManager em;
	private final EscapeCharacter escape;

	/**
	 * Creates a new {@link PartTreeJpaQuery}.
	 * 
	 * @param method must not be {@literal null}.
	 * @param em must not be {@literal null}.
	 * @param persistenceProvider must not be {@literal null}.
	 * @param escape
	 */
	PartTreeJpaQuery(JpaQueryMethod method, EntityManager em, PersistenceProvider persistenceProvider, EscapeCharacter escape) {

		super(method, em);

		this.em = em;
		this.escape = escape;
		Class<?> domainClass = method.getEntityInformation().getJavaType();
		this.parameters = method.getParameters();

		boolean recreationRequired = parameters.hasDynamicProjection() || parameters.potentiallySortsDynamically();

		try {

			this.tree = new PartTree(method.getName(), domainClass);
			this.countQuery = new CountQueryPreparer(persistenceProvider, recreationRequired);
			this.query = tree.isCountProjection() ? countQuery : new QueryPreparer(persistenceProvider, recreationRequired);

		} catch (Exception o_O) {
			throw new IllegalArgumentException(
					String.format(""Failed to create query for method %s! %s"", method, o_O.getMessage()), o_O);
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateQuery(java.lang.Object[])
	 */
	@Override
	public Query doCreateQuery(Object[] values) {
		return query.createQuery(values);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#doCreateCountQuery(java.lang.Object[])
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public TypedQuery<Long> doCreateCountQuery(Object[] values) {
		return (TypedQuery<Long>) countQuery.createQuery(values);
	}

	/* 
	 * (non-Javadoc)
	 * @see org.springframework.data.jpa.repository.query.AbstractJpaQuery#getExecution()
	 */
	@Override
	protected JpaQueryExecution getExecution() {

		if (this.tree.isDelete()) {
			return new DeleteExecution(em);
		} else if (this.tree.isExistsProjection()) {
			return new ExistsExecution();
		}

		return super.getExecution();
	}

	/**
	 * Query preparer to create {@link CriteriaQuery} instances and potentially cache them.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class QueryPreparer {

		private final @Nullable CriteriaQuery<?> cachedCriteriaQuery;
		private final @Nullable ParameterBinder cachedParameterBinder;
		private final @Nullable List<ParameterMetadata<?>> expressions;
		private final PersistenceProvider persistenceProvider;

		QueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {

			this.persistenceProvider = persistenceProvider;

			JpaQueryCreator creator = createCreator(persistenceProvider, Optional.empty());

			if (recreateQueries) {
				this.cachedCriteriaQuery = null;
				this.expressions = null;
				this.cachedParameterBinder = null;
			} else {
				this.cachedCriteriaQuery = creator.createQuery();
				this.expressions = creator.getParameterExpressions();
				this.cachedParameterBinder = getBinder(expressions);
			}
		}

		/**
		 * Creates a new {@link Query} for the given parameter values.
		 */
		public Query createQuery(Object[] values) {

			CriteriaQuery<?> criteriaQuery = cachedCriteriaQuery;
			ParameterBinder parameterBinder = cachedParameterBinder;
			ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, values);

			if (cachedCriteriaQuery == null || accessor.hasBindableNullValue()) {
				JpaQueryCreator creator = createCreator(persistenceProvider, Optional.of(accessor));
				criteriaQuery = creator.createQuery(getDynamicSort(values));
				List<ParameterMetadata<?>> expressions = creator.getParameterExpressions();
				parameterBinder = getBinder(expressions);
			}

			if (parameterBinder == null) {
				throw new IllegalStateException(""ParameterBinder is null!"");
			}

			return restrictMaxResultsIfNecessary(invokeBinding(parameterBinder, createQuery(criteriaQuery), values));
		}

		/**
		 * Restricts the max results of the given {@link Query} if the current {@code tree} marks this {@code query} as
		 * limited.
		 */
		private Query restrictMaxResultsIfNecessary(Query query) {

			if (tree.isLimiting()) {

				if (query.getMaxResults() != Integer.MAX_VALUE) {
					/*
					 * In order to return the correct results, we have to adjust the first result offset to be returned if:
					 * - a Pageable parameter is present 
					 * - AND the requested page number > 0
					 * - AND the requested page size was bigger than the derived result limitation via the First/Top keyword.
					 */
					if (query.getMaxResults() > tree.getMaxResults() && query.getFirstResult() > 0) {
						query.setFirstResult(query.getFirstResult() - (query.getMaxResults() - tree.getMaxResults()));
					}
				}

				query.setMaxResults(tree.getMaxResults());
			}

			if (tree.isExistsProjection()) {
				query.setMaxResults(1);
			}

			return query;
		}

		/**
		 * Checks whether we are working with a cached {@link CriteriaQuery} and synchronizes the creation of a
		 * {@link TypedQuery} instance from it. This is due to non-thread-safety in the {@link CriteriaQuery} implementation
		 * of some persistence providers (i.e. Hibernate in this case), see DATAJPA-396.
		 * 
		 * @param criteriaQuery must not be {@literal null}.
		 */
		private TypedQuery<?> createQuery(CriteriaQuery<?> criteriaQuery) {

			if (this.cachedCriteriaQuery != null) {
				synchronized (this.cachedCriteriaQuery) {
					return getEntityManager().createQuery(criteriaQuery);
				}
			}

			return getEntityManager().createQuery(criteriaQuery);
		}

		protected JpaQueryCreator createCreator(PersistenceProvider persistenceProvider,
				Optional<ParametersParameterAccessor> accessor) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor
					.map(it -> new ParameterMetadataProvider(builder, it, persistenceProvider, escape))//
					.orElseGet(() -> new ParameterMetadataProvider(builder, parameters, persistenceProvider, escape));

			ResultProcessor processor = getQueryMethod().getResultProcessor();
			ReturnedType returnedType = accessor.map(processor::withDynamicProjection)//
					.orElse(processor).getReturnedType();

			return new JpaQueryCreator(tree, returnedType, builder, provider);
		}

		/**
		 * Invokes parameter binding on the given {@link TypedQuery}.
		 */
		protected Query invokeBinding(ParameterBinder binder, TypedQuery<?> query, Object[] values) {

			return binder.bindAndPrepare(query, values);
		}

		private ParameterBinder getBinder(List<ParameterMetadata<?>> expressions) {
			return ParameterBinderFactory.createCriteriaBinder(parameters, expressions);
		}

		private Sort getDynamicSort(Object[] values) {

			return parameters.potentiallySortsDynamically() //
					? new ParametersParameterAccessor(parameters, values).getSort() //
					: Sort.unsorted();
		}
	}

	/**
	 * Special {@link QueryPreparer} to create count queries.
	 * 
	 * @author Oliver Gierke
	 * @author Thomas Darimont
	 */
	private class CountQueryPreparer extends QueryPreparer {

		CountQueryPreparer(PersistenceProvider persistenceProvider, boolean recreateQueries) {
			super(persistenceProvider, recreateQueries);
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.PartTreeJpaQuery.QueryPreparer#createCreator(org.springframework.data.repository.query.ParametersParameterAccessor, org.springframework.data.jpa.provider.PersistenceProvider)
		 */
		@Override
		protected JpaQueryCreator createCreator(PersistenceProvider persistenceProvider,
				Optional<ParametersParameterAccessor> accessor) {

			EntityManager entityManager = getEntityManager();
			CriteriaBuilder builder = entityManager.getCriteriaBuilder();

			ParameterMetadataProvider provider = accessor
					.map(it -> new ParameterMetadataProvider(builder, it, persistenceProvider, escape))//
					.orElseGet(() -> new ParameterMetadataProvider(builder, parameters, persistenceProvider, escape));

			return new JpaCountQueryCreator(tree, getQueryMethod().getResultProcessor().getReturnedType(), builder, provider);
		}

		/**
		 * Customizes binding by skipping the pagination.
		 * 
		 * @see QueryPreparer#invokeBinding(ParameterBinder, TypedQuery, Object[])
		 */
		@Override
		protected Query invokeBinding(ParameterBinder binder, TypedQuery<?> query, Object[] values) {
			return binder.bind(query, values);
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/QueryParameterSetterFactory.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.lang.reflect.Method;
import java.util.List;
import java.util.function.Function;

import javax.persistence.Query;
import javax.persistence.TemporalType;

import org.springframework.data.jpa.repository.query.JpaParameters.JpaParameter;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.query.QueryParameterSetter.NamedOrIndexedQueryParameterSetter;
import org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.Parameter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.expression.EvaluationContext;
import org.springframework.expression.Expression;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ReflectionUtils;

/**
 * Encapsulates different strategies for the creation of a {@link QueryParameterSetter} from a {@link Query} and a
 * {@link ParameterBinding}
 *
 * @author Jens Schauder
 * @author Oliver Gierke
 * @author Mark Paluch
 * @since 2.0
 */
abstract class QueryParameterSetterFactory {

	@Nullable
	abstract QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery);

	/**
	 * Creates a new {@link QueryParameterSetterFactory} for the given {@link JpaParameters}.
	 *
	 * @param parameters must not be {@literal null}.
	 * @return a basic {@link QueryParameterSetterFactory} that can handle named and index parameters.
	 */
	static QueryParameterSetterFactory basic(JpaParameters parameters) {

		Assert.notNull(parameters, ""JpaParameters must not be null!"");

		return new BasicQueryParameterSetterFactory(parameters);
	}

	/**
	 * Creates a new {@link QueryParameterSetterFactory} using the given {@link JpaParameters} and
	 * {@link ParameterMetadata}.
	 *
	 * @param parameters must not be {@literal null}.
	 * @param metadata must not be {@literal null}.
	 * @return a {@link QueryParameterSetterFactory} for criteria Queries.
	 */
	static QueryParameterSetterFactory forCriteriaQuery(JpaParameters parameters, List<ParameterMetadata<?>> metadata) {

		Assert.notNull(parameters, ""JpaParameters must not be null!"");
		Assert.notNull(metadata, ""ParameterMetadata must not be null!"");

		return new CriteriaQueryParameterSetterFactory(parameters, metadata);
	}

	/**
	 * Creates a new {@link QueryParameterSetterFactory} for the given {@link SpelExpressionParser},
	 * {@link EvaluationContextProvider} and {@link Parameters}.
	 *
	 * @param parser must not be {@literal null}.
	 * @param evaluationContextProvider must not be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @return a {@link QueryParameterSetterFactory} that can handle
	 *         {@link org.springframework.expression.spel.standard.SpelExpression}s.
	 */
	static QueryParameterSetterFactory parsing(SpelExpressionParser parser,
			EvaluationContextProvider evaluationContextProvider, Parameters<?, ?> parameters) {

		Assert.notNull(parser, ""SpelExpressionParser must not be null!"");
		Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");
		Assert.notNull(parameters, ""Parameters must not be null!"");

		return new ExpressionBasedQueryParameterSetterFactory(parser, evaluationContextProvider, parameters);
	}

	/**
	 * Creates a {@link QueryParameterSetter} from a {@link JpaParameter}. Handles named and indexed parameters,
	 * TemporalType annotations and might ignore certain exception when requested to do so.
	 *
	 * @param valueExtractor extracts the relevant value from an array of method parameter values.
	 * @param binding the binding of the query parameter to be set.
	 * @param parameter the method parameter to bind.
	 */
	private static QueryParameterSetter createSetter(Function<Object[], Object> valueExtractor, ParameterBinding binding,
			@Nullable JpaParameter parameter) {

		TemporalType temporalType = parameter != null && parameter.isTemporalParameter() //
				? parameter.getRequiredTemporalType() //
				: null;

		return new NamedOrIndexedQueryParameterSetter(valueExtractor.andThen(binding::prepare),
				ParameterImpl.of(parameter, binding), temporalType);
	}

	/**
	 * Handles bindings that are SpEL expressions by evaluating the expression to obtain a value.
	 *
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @since 2.0
	 */
	private static class ExpressionBasedQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final SpelExpressionParser parser;
		private final EvaluationContextProvider evaluationContextProvider;
		private final Parameters<?, ?> parameters;

		/**
		 * @param parser must not be {@literal null}.
		 * @param evaluationContextProvider must not be {@literal null}.
		 * @param parameters must not be {@literal null}.
		 */
		ExpressionBasedQueryParameterSetterFactory(SpelExpressionParser parser,
				EvaluationContextProvider evaluationContextProvider, Parameters<?, ?> parameters) {

			Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");
			Assert.notNull(parser, ""SpelExpressionParser must not be null!"");
			Assert.notNull(parameters, ""Parameters must not be null!"");

			this.evaluationContextProvider = evaluationContextProvider;
			this.parser = parser;
			this.parameters = parameters;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Nullable
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			if (!binding.isExpression()) {
				return null;
			}

			Expression expression = parser.parseExpression(binding.getExpression());

			return createSetter(values -> evaluateExpression(expression, values), binding, null);
		}

		/**
		 * Evaluates the given {@link Expression} against the given values.
		 *
		 * @param expression must not be {@literal null}.
		 * @param values must not be {@literal null}.
		 * @return the result of the evaluation.
		 */
		@Nullable
		private Object evaluateExpression(Expression expression, Object[] values) {

			EvaluationContext context = evaluationContextProvider.getEvaluationContext(parameters, values);
			Method escapeMethod = ReflectionUtils.findMethod(EscapeCharacter.class, ""escape"", String.class, String.class);

			Assert.notNull(escapeMethod, ""Escape method must not be null."");

			context.setVariable(""escape"", escapeMethod);
			return expression.getValue(context, Object.class);
		}
	}

	/**
	 * Extracts values for parameter bindings from method parameters. It handles named as well as indexed parameters.
	 *
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @since 2.0
	 */
	private static class BasicQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final JpaParameters parameters;

		/**
		 * @param parameters must not be {@literal null}.
		 */
		BasicQueryParameterSetterFactory(JpaParameters parameters) {

			Assert.notNull(parameters, ""JpaParameters must not be null!"");

			this.parameters = parameters;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			Assert.notNull(binding, ""Binding must not be null."");

			JpaParameter parameter;

			if (declaredQuery.hasNamedParameter()) {
				parameter = findParameterForBinding(binding);
			} else {

				int parameterIndex = binding.getRequiredPosition() - 1;
				JpaParameters bindableParameters = parameters.getBindableParameters();

				Assert.isTrue( //
						parameterIndex < bindableParameters.getNumberOfParameters(), //
						() -> String.format( //
								""At least %s parameter(s) provided but only %s parameter(s) present in query."", //
								binding.getRequiredPosition(), //
								bindableParameters.getNumberOfParameters() //
						) //
				);

				parameter = bindableParameters.getParameter(binding.getRequiredPosition() - 1);
			}

			return parameter == null //
					? QueryParameterSetter.NOOP //
					: createSetter(values -> getValue(values, parameter), binding, parameter);
		}

		@Nullable
		private JpaParameter findParameterForBinding(ParameterBinding binding) {

			return parameters.getBindableParameters().stream() //
					.filter(candidate -> binding.getRequiredName().equals(getName(candidate))) //
					.findFirst().orElse(null);
		}

		private Object getValue(Object[] values, Parameter parameter) {
			return new JpaParametersParameterAccessor(parameters, values).getValue(parameter);
		}

		private static String getName(JpaParameter p) {
			return p.getName().orElseThrow(() -> new IllegalStateException(ParameterBinder.PARAMETER_NEEDS_TO_BE_NAMED));
		}
	}

	/**
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @see QueryParameterSetterFactory
	 */
	private static class CriteriaQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final JpaParameters parameters;
		private final List<ParameterMetadata<?>> expressions;

		/**
		 * Creates a new {@link QueryParameterSetterFactory} from the given {@link JpaParameters} and
		 * {@link ParameterMetadata}.
		 *
		 * @param parameters must not be {@literal null}.
		 * @param metadata must not be {@literal null}.
		 */
		CriteriaQueryParameterSetterFactory(JpaParameters parameters, List<ParameterMetadata<?>> metadata) {

			Assert.notNull(parameters, ""JpaParameters must not be null!"");
			Assert.notNull(metadata, ""Expressions must not be null!"");

			this.parameters = parameters;
			this.expressions = metadata;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			int parameterIndex = binding.getRequiredPosition() - 1;

			Assert.isTrue( //
					parameterIndex < expressions.size(), //
					() -> String.format( //
							""At least %s parameter(s) provided but only %s parameter(s) present in query."", //
							binding.getRequiredPosition(), //
							expressions.size() //
					) //
			);

			ParameterMetadata<?> metadata = expressions.get(parameterIndex);

			if (metadata.isIsNullParameter()) {
				return QueryParameterSetter.NOOP;
			}

			JpaParameter parameter = parameters.getBindableParameter(parameterIndex);
			TemporalType temporalType = parameter.isTemporalParameter() ? parameter.getRequiredTemporalType() : null;

			return new NamedOrIndexedQueryParameterSetter(values -> getAndPrepare(parameter, metadata, values),
					metadata.getExpression(), temporalType);
		}

		@Nullable
		private Object getAndPrepare(JpaParameter parameter, ParameterMetadata<?> metadata, Object[] values) {

			JpaParametersParameterAccessor accessor = new JpaParametersParameterAccessor(parameters, values);

			return metadata.prepare(accessor.getValue(parameter));
		}
	}

	private static class ParameterImpl<T> implements javax.persistence.Parameter<T> {

		private final Class<T> parameterType;
		private final @Nullable String name;
		private final @Nullable Integer position;

		/**
		 * Creates a new {@link ParameterImpl} for the given {@link JpaParameter} and {@link ParameterBinding}.
		 *
		 * @param parameter can be {@literal null}.
		 * @param binding must not be {@literal null}.
		 * @return a {@link javax.persistence.Parameter} object based on the information from the arguments.
		 */
		static javax.persistence.Parameter<?> of(@Nullable JpaParameter parameter, ParameterBinding binding) {

			Class<?> type = parameter == null ? Object.class : parameter.getType();

			return new ParameterImpl<>(type, getName(parameter, binding), binding.getPosition());
		}

		/**
		 * Creates a new {@link ParameterImpl} for the given name, position and parameter type.
		 *
		 * @param parameterType must not be {@literal null}.
		 * @param name can be {@literal null}.
		 * @param position can be {@literal null}.
		 */
		private ParameterImpl(Class<T> parameterType, @Nullable String name, @Nullable Integer position) {

			this.name = name;
			this.position = position;
			this.parameterType = parameterType;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getName()
		 */
		@Nullable
		@Override
		public String getName() {
			return name;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getPosition()
		 */
		@Nullable
		@Override
		public Integer getPosition() {
			return position;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getParameterType()
		 */
		@Override
		public Class<T> getParameterType() {
			return parameterType;
		}

		@Nullable
		private static String getName(@Nullable JpaParameter parameter, ParameterBinding binding) {

			if (parameter == null) {
				return binding.getName();
			}

			return parameter.isNamedParameter() //
					? parameter.getName().orElseThrow(() -> new IllegalArgumentException(""o_O parameter needs to have a name!"")) //
					: null;
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/QueryParameterSetterFactory.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.List;
import java.util.function.Function;

import javax.persistence.Query;
import javax.persistence.TemporalType;

import org.springframework.data.jpa.repository.query.JpaParameters.JpaParameter;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.query.QueryParameterSetter.NamedOrIndexedQueryParameterSetter;
import org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.Parameter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.expression.EvaluationContext;
import org.springframework.expression.Expression;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Encapsulates different strategies for the creation of a {@link QueryParameterSetter} from a {@link Query} and a
 * {@link ParameterBinding}
 *
 * @author Jens Schauder
 * @author Oliver Gierke
 * @author Mark Paluch
 * @since 2.0
 */
abstract class QueryParameterSetterFactory {

	@Nullable
	abstract QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery);

	/**
	 * Creates a new {@link QueryParameterSetterFactory} for the given {@link JpaParameters}.
	 *
	 * @param parameters must not be {@literal null}.
	 * @return a basic {@link QueryParameterSetterFactory} that can handle named and index parameters.
	 */
	static QueryParameterSetterFactory basic(JpaParameters parameters) {

		Assert.notNull(parameters, ""JpaParameters must not be null!"");

		return new BasicQueryParameterSetterFactory(parameters);
	}

	/**
	 * Creates a new {@link QueryParameterSetterFactory} using the given {@link JpaParameters} and
	 * {@link ParameterMetadata}.
	 *
	 * @param parameters must not be {@literal null}.
	 * @param metadata must not be {@literal null}.
	 * @return a {@link QueryParameterSetterFactory} for criteria Queries.
	 */
	static QueryParameterSetterFactory forCriteriaQuery(JpaParameters parameters, List<ParameterMetadata<?>> metadata) {

		Assert.notNull(parameters, ""JpaParameters must not be null!"");
		Assert.notNull(metadata, ""ParameterMetadata must not be null!"");

		return new CriteriaQueryParameterSetterFactory(parameters, metadata);
	}

	/**
	 * Creates a new {@link QueryParameterSetterFactory} for the given {@link SpelExpressionParser},
	 * {@link EvaluationContextProvider} and {@link Parameters}.
	 *
	 * @param parser must not be {@literal null}.
	 * @param evaluationContextProvider must not be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @return a {@link QueryParameterSetterFactory} that can handle
	 *         {@link org.springframework.expression.spel.standard.SpelExpression}s.
	 */
	static QueryParameterSetterFactory parsing(SpelExpressionParser parser,
			EvaluationContextProvider evaluationContextProvider, Parameters<?, ?> parameters) {

		Assert.notNull(parser, ""SpelExpressionParser must not be null!"");
		Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");
		Assert.notNull(parameters, ""Parameters must not be null!"");

		return new ExpressionBasedQueryParameterSetterFactory(parser, evaluationContextProvider, parameters);
	}

	/**
	 * Creates a {@link QueryParameterSetter} from a {@link JpaParameter}. Handles named and indexed parameters,
	 * TemporalType annotations and might ignore certain exception when requested to do so.
	 *
	 * @param valueExtractor extracts the relevant value from an array of method parameter values.
	 * @param binding the binding of the query parameter to be set.
	 * @param parameter the method parameter to bind.
	 */
	private static QueryParameterSetter createSetter(Function<Object[], Object> valueExtractor, ParameterBinding binding,
			@Nullable JpaParameter parameter) {

		TemporalType temporalType = parameter != null && parameter.isTemporalParameter() //
				? parameter.getRequiredTemporalType() //
				: null;

		return new NamedOrIndexedQueryParameterSetter(valueExtractor.andThen(binding::prepare),
				ParameterImpl.of(parameter, binding), temporalType);
	}

	/**
	 * Handles bindings that are SpEL expressions by evaluating the expression to obtain a value.
	 *
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @since 2.0
	 */
	private static class ExpressionBasedQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final SpelExpressionParser parser;
		private final EvaluationContextProvider evaluationContextProvider;
		private final Parameters<?, ?> parameters;

		/**
		 * @param parser must not be {@literal null}.
		 * @param evaluationContextProvider must not be {@literal null}.
		 * @param parameters must not be {@literal null}.
		 */
		ExpressionBasedQueryParameterSetterFactory(SpelExpressionParser parser,
				EvaluationContextProvider evaluationContextProvider, Parameters<?, ?> parameters) {

			Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");
			Assert.notNull(parser, ""SpelExpressionParser must not be null!"");
			Assert.notNull(parameters, ""Parameters must not be null!"");

			this.evaluationContextProvider = evaluationContextProvider;
			this.parser = parser;
			this.parameters = parameters;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Nullable
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			if (!binding.isExpression()) {
				return null;
			}

			Expression expression = parser.parseExpression(binding.getExpression());

			return createSetter(values -> evaluateExpression(expression, values), binding, null);
		}

		/**
		 * Evaluates the given {@link Expression} against the given values.
		 *
		 * @param expression must not be {@literal null}.
		 * @param values must not be {@literal null}.
		 * @return the result of the evaluation.
		 */
		@Nullable
		private Object evaluateExpression(Expression expression, Object[] values) {

			EvaluationContext context = evaluationContextProvider.getEvaluationContext(parameters, values);

			return expression.getValue(context, Object.class);
		}
	}

	/**
	 * Extracts values for parameter bindings from method parameters. It handles named as well as indexed parameters.
	 *
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @since 2.0
	 */
	private static class BasicQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final JpaParameters parameters;

		/**
		 * @param parameters must not be {@literal null}.
		 */
		BasicQueryParameterSetterFactory(JpaParameters parameters) {

			Assert.notNull(parameters, ""JpaParameters must not be null!"");

			this.parameters = parameters;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			Assert.notNull(binding, ""Binding must not be null."");

			JpaParameter parameter;

			if (declaredQuery.hasNamedParameter()) {
				parameter = findParameterForBinding(binding);
			} else {

				int parameterIndex = binding.getRequiredPosition() - 1;
				JpaParameters bindableParameters = parameters.getBindableParameters();

				Assert.isTrue( //
						parameterIndex < bindableParameters.getNumberOfParameters(), //
						() -> String.format( //
								""At least %s parameter(s) provided but only %s parameter(s) present in query."", //
								binding.getRequiredPosition(), //
								bindableParameters.getNumberOfParameters() //
						) //
				);

				parameter = bindableParameters.getParameter(binding.getRequiredPosition() - 1);
			}

			return parameter == null //
					? QueryParameterSetter.NOOP //
					: createSetter(values -> getValue(values, parameter), binding, parameter);
		}

		@Nullable
		private JpaParameter findParameterForBinding(ParameterBinding binding) {

			return parameters.getBindableParameters().stream() //
					.filter(candidate -> binding.getRequiredName().equals(getName(candidate))) //
					.findFirst().orElse(null);
		}

		private Object getValue(Object[] values, Parameter parameter) {
			return new JpaParametersParameterAccessor(parameters, values).getValue(parameter);
		}

		private static String getName(JpaParameter p) {
			return p.getName().orElseThrow(() -> new IllegalStateException(ParameterBinder.PARAMETER_NEEDS_TO_BE_NAMED));
		}
	}

	/**
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @see QueryParameterSetterFactory
	 */
	private static class CriteriaQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final JpaParameters parameters;
		private final List<ParameterMetadata<?>> expressions;

		/**
		 * Creates a new {@link QueryParameterSetterFactory} from the given {@link JpaParameters} and
		 * {@link ParameterMetadata}.
		 *
		 * @param parameters must not be {@literal null}.
		 * @param metadata must not be {@literal null}.
		 */
		CriteriaQueryParameterSetterFactory(JpaParameters parameters, List<ParameterMetadata<?>> metadata) {

			Assert.notNull(parameters, ""JpaParameters must not be null!"");
			Assert.notNull(metadata, ""Expressions must not be null!"");

			this.parameters = parameters;
			this.expressions = metadata;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			int parameterIndex = binding.getRequiredPosition() - 1;

			Assert.isTrue( //
					parameterIndex < expressions.size(), //
					() -> String.format( //
							""At least %s parameter(s) provided but only %s parameter(s) present in query."", //
							binding.getRequiredPosition(), //
							expressions.size() //
					) //
			);

			ParameterMetadata<?> metadata = expressions.get(parameterIndex);

			if (metadata.isIsNullParameter()) {
				return QueryParameterSetter.NOOP;
			}

			JpaParameter parameter = parameters.getBindableParameter(parameterIndex);
			TemporalType temporalType = parameter.isTemporalParameter() ? parameter.getRequiredTemporalType() : null;

			return new NamedOrIndexedQueryParameterSetter(values -> getAndPrepare(parameter, metadata, values),
					metadata.getExpression(), temporalType);
		}

		@Nullable
		private Object getAndPrepare(JpaParameter parameter, ParameterMetadata<?> metadata, Object[] values) {

			JpaParametersParameterAccessor accessor = new JpaParametersParameterAccessor(parameters, values);

			return metadata.prepare(accessor.getValue(parameter));
		}
	}

	private static class ParameterImpl<T> implements javax.persistence.Parameter<T> {

		private final Class<T> parameterType;
		private final @Nullable String name;
		private final @Nullable Integer position;

		/**
		 * Creates a new {@link ParameterImpl} for the given {@link JpaParameter} and {@link ParameterBinding}.
		 *
		 * @param parameter can be {@literal null}.
		 * @param binding must not be {@literal null}.
		 * @return a {@link javax.persistence.Parameter} object based on the information from the arguments.
		 */
		static javax.persistence.Parameter<?> of(@Nullable JpaParameter parameter, ParameterBinding binding) {

			Class<?> type = parameter == null ? Object.class : parameter.getType();

			return new ParameterImpl<>(type, getName(parameter, binding), binding.getPosition());
		}

		/**
		 * Creates a new {@link ParameterImpl} for the given name, position and parameter type.
		 *
		 * @param parameterType must not be {@literal null}.
		 * @param name can be {@literal null}.
		 * @param position can be {@literal null}.
		 */
		private ParameterImpl(Class<T> parameterType, @Nullable String name, @Nullable Integer position) {

			this.name = name;
			this.position = position;
			this.parameterType = parameterType;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getName()
		 */
		@Nullable
		@Override
		public String getName() {
			return name;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getPosition()
		 */
		@Nullable
		@Override
		public Integer getPosition() {
			return position;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getParameterType()
		 */
		@Override
		public Class<T> getParameterType() {
			return parameterType;
		}

		@Nullable
		private static String getName(@Nullable JpaParameter parameter, ParameterBinding binding) {

			if (parameter == null) {
				return binding.getName();
			}

			return parameter.isNamedParameter() //
					? parameter.getName().orElseThrow(() -> new IllegalArgumentException(""o_O parameter needs to have a name!"")) //
					: null;
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactory.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import static org.springframework.data.querydsl.QuerydslUtils.*;

import lombok.extern.slf4j.Slf4j;

import java.util.Optional;

import javax.persistence.EntityManager;
import javax.persistence.Tuple;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.data.jpa.projection.CollectionAwareProjectionFactory;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.query.AbstractJpaQuery;
import org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy;
import org.springframework.data.jpa.repository.query.JpaQueryMethod;
import org.springframework.data.jpa.util.JpaMetamodel;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.querydsl.QuerydslPredicateExecutor;
import org.springframework.data.repository.core.RepositoryInformation;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.QueryCreationListener;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * JPA specific generic repository factory.
 *
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Christoph Strobl
 * @author Jens Schauder
 */
public class JpaRepositoryFactory extends RepositoryFactorySupport {

	private final EntityManager entityManager;
	private final QueryExtractor extractor;
	private final CrudMethodMetadataPostProcessor crudMethodMetadataPostProcessor;

	private EscapeCharacter escapeCharacter = EscapeCharacter.of('\\');

	/**
	 * Creates a new {@link JpaRepositoryFactory}.
	 *
	 * @param entityManager must not be {@literal null}
	 */
	public JpaRepositoryFactory(EntityManager entityManager) {

		Assert.notNull(entityManager, ""EntityManager must not be null!"");

		this.entityManager = entityManager;
		this.extractor = PersistenceProvider.fromEntityManager(entityManager);
		this.crudMethodMetadataPostProcessor = new CrudMethodMetadataPostProcessor();

		addRepositoryProxyPostProcessor(crudMethodMetadataPostProcessor);

		if (extractor.equals(PersistenceProvider.ECLIPSELINK)) {
			addQueryCreationListener(new EclipseLinkProjectionQueryCreationListener(entityManager));
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#setBeanClassLoader(java.lang.ClassLoader)
	 */
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {

		super.setBeanClassLoader(classLoader);
		this.crudMethodMetadataPostProcessor.setBeanClassLoader(classLoader);
	}

	/**
	 * Configures the escape character to be used for like-expressions created for derived queries.
	 *
	 * @param escapeCharacter a character used for escaping in certain like expressions.
	 */
	public void setEscapeCharacter(EscapeCharacter escapeCharacter) {
		this.escapeCharacter = escapeCharacter;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getTargetRepository(org.springframework.data.repository.core.RepositoryMetadata)
	 */
	@Override
	protected Object getTargetRepository(RepositoryInformation information) {

		SimpleJpaRepository<?, ?> repository = getTargetRepository(information, entityManager);
		repository.setRepositoryMethodMetadata(crudMethodMetadataPostProcessor.getCrudMethodMetadata());

		return repository;
	}

	/**
	 * Callback to create a {@link JpaRepository} instance with the given {@link EntityManager}
	 *
	 * @param <T>
	 * @param <ID>
	 * @param entityManager
	 * @return
	 */
	protected SimpleJpaRepository<?, ?> getTargetRepository(RepositoryInformation information,
			EntityManager entityManager) {

		JpaEntityInformation<?, ?> entityInformation = getEntityInformation(information.getDomainType());

		return getTargetRepositoryViaReflection(information, entityInformation, entityManager);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getRepositoryBaseClass(org.springframework.data.repository.core.RepositoryMetadata)
	 */
	@Override
	protected Class<?> getRepositoryBaseClass(RepositoryMetadata metadata) {

		if (isQueryDslExecutor(metadata.getRepositoryInterface())) {
			return QuerydslJpaRepository.class;
		} else {
			return SimpleJpaRepository.class;
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getProjectionFactory(java.lang.ClassLoader, org.springframework.beans.factory.BeanFactory)
	 */
	@Override
	protected ProjectionFactory getProjectionFactory(ClassLoader classLoader, BeanFactory beanFactory) {

		CollectionAwareProjectionFactory factory = new CollectionAwareProjectionFactory();
		factory.setBeanClassLoader(classLoader);
		factory.setBeanFactory(beanFactory);

		return factory;
	}

	/**
	 * Returns whether the given repository interface requires a QueryDsl specific implementation to be chosen.
	 *
	 * @param repositoryInterface
	 * @return
	 */
	private boolean isQueryDslExecutor(Class<?> repositoryInterface) {

		return QUERY_DSL_PRESENT && QuerydslPredicateExecutor.class.isAssignableFrom(repositoryInterface);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getQueryLookupStrategy(org.springframework.data.repository.query.QueryLookupStrategy.Key, org.springframework.data.repository.query.EvaluationContextProvider)
	 */
	@Override
	protected Optional<QueryLookupStrategy> getQueryLookupStrategy(@Nullable Key key,
			EvaluationContextProvider evaluationContextProvider) {
		return Optional
				.of(JpaQueryLookupStrategy.create(entityManager, key, extractor, evaluationContextProvider, escapeCharacter));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getEntityInformation(java.lang.Class)
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public <T, ID> JpaEntityInformation<T, ID> getEntityInformation(Class<T> domainClass) {

		return (JpaEntityInformation<T, ID>) JpaEntityInformationSupport.getEntityInformation(domainClass, entityManager);
	}

	/**
	 * Query creation listener that informs EclipseLink users that they have to be extra careful when defining repository
	 * query methods using projections as we have to rely on the declaration order of the accessors in projection
	 * interfaces matching the order in columns. Alias-based mapping doesn't work with EclipseLink as it doesn't support
	 * {@link Tuple} based queries yet.
	 *
	 * @author Oliver Gierke
	 * @since 2.0.5
	 * @see https://bugs.eclipse.org/bugs/show_bug.cgi?id=289141
	 */
	@Slf4j
	private static class EclipseLinkProjectionQueryCreationListener implements QueryCreationListener<AbstractJpaQuery> {

		private static final String ECLIPSELINK_PROJECTIONS = ""Usage of Spring Data projections detected on persistence provider EclipseLink. Make sure the following query methods declare result columns in exactly the order the accessors are declared in the projecting interface or the order of parameters for DTOs:"";

		private final JpaMetamodel metamodel;

		private boolean warningLogged = false;

		/**
		 * Creates a new {@link EclipseLinkProjectionQueryCreationListener} for the given {@link EntityManager}.
		 *
		 * @param em must not be {@literal null}.
		 */
		public EclipseLinkProjectionQueryCreationListener(EntityManager em) {

			Assert.notNull(em, ""EntityManager must not be null!"");

			this.metamodel = JpaMetamodel.of(em.getMetamodel());
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.core.support.QueryCreationListener#onCreation(org.springframework.data.repository.query.RepositoryQuery)
		 */
		@Override
		public void onCreation(AbstractJpaQuery query) {

			JpaQueryMethod queryMethod = query.getQueryMethod();
			ReturnedType type = queryMethod.getResultProcessor().getReturnedType();

			if (type.isProjecting() && !metamodel.isJpaManaged(type.getReturnedType())) {

				if (!warningLogged) {
					log.info(ECLIPSELINK_PROJECTIONS);
					this.warningLogged = true;
				}

				log.info("" - {}"", queryMethod);
			}
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactory.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import static org.springframework.data.querydsl.QuerydslUtils.*;

import lombok.extern.slf4j.Slf4j;

import java.util.Optional;

import javax.persistence.EntityManager;
import javax.persistence.Tuple;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.data.jpa.projection.CollectionAwareProjectionFactory;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.query.AbstractJpaQuery;
import org.springframework.data.jpa.repository.query.EscapeCharacter;
import org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy;
import org.springframework.data.jpa.repository.query.JpaQueryMethod;
import org.springframework.data.jpa.util.JpaMetamodel;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.querydsl.QuerydslPredicateExecutor;
import org.springframework.data.repository.core.RepositoryInformation;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.QueryCreationListener;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * JPA specific generic repository factory.
 *
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Christoph Strobl
 * @author Jens Schauder
 */
public class JpaRepositoryFactory extends RepositoryFactorySupport {

	private final EntityManager entityManager;
	private final QueryExtractor extractor;
	private final CrudMethodMetadataPostProcessor crudMethodMetadataPostProcessor;

	private EscapeCharacter escapeCharacter = EscapeCharacter.of('\\');

	/**
	 * Creates a new {@link JpaRepositoryFactory}.
	 *
	 * @param entityManager must not be {@literal null}
	 */
	public JpaRepositoryFactory(EntityManager entityManager) {

		Assert.notNull(entityManager, ""EntityManager must not be null!"");

		this.entityManager = entityManager;
		this.extractor = PersistenceProvider.fromEntityManager(entityManager);
		this.crudMethodMetadataPostProcessor = new CrudMethodMetadataPostProcessor();

		addRepositoryProxyPostProcessor(crudMethodMetadataPostProcessor);

		if (extractor.equals(PersistenceProvider.ECLIPSELINK)) {
			addQueryCreationListener(new EclipseLinkProjectionQueryCreationListener(entityManager));
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#setBeanClassLoader(java.lang.ClassLoader)
	 */
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {

		super.setBeanClassLoader(classLoader);
		this.crudMethodMetadataPostProcessor.setBeanClassLoader(classLoader);
	}

	/**
	 * Configures the escape character to be used for like-expressions created for derived queries.
	 *
	 * @param escapeCharacter a character used for escaping in certain like expressions.
	 */
	public void setEscapeCharacter(EscapeCharacter escapeCharacter) {
		this.escapeCharacter = escapeCharacter;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getTargetRepository(org.springframework.data.repository.core.RepositoryMetadata)
	 */
	@Override
	protected Object getTargetRepository(RepositoryInformation information) {

		SimpleJpaRepository<?, ?> repository = getTargetRepository(information, entityManager);
		repository.setRepositoryMethodMetadata(crudMethodMetadataPostProcessor.getCrudMethodMetadata());

		return repository;
	}

	/**
	 * Callback to create a {@link JpaRepository} instance with the given {@link EntityManager}
	 *
	 * @param <T>
	 * @param <ID>
	 * @param entityManager
	 * @return
	 */
	protected SimpleJpaRepository<?, ?> getTargetRepository(RepositoryInformation information,
			EntityManager entityManager) {

		JpaEntityInformation<?, ?> entityInformation = getEntityInformation(information.getDomainType());

		return getTargetRepositoryViaReflection(information, entityInformation, entityManager);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getRepositoryBaseClass(org.springframework.data.repository.core.RepositoryMetadata)
	 */
	@Override
	protected Class<?> getRepositoryBaseClass(RepositoryMetadata metadata) {

		if (isQueryDslExecutor(metadata.getRepositoryInterface())) {
			return QuerydslJpaRepository.class;
		} else {
			return SimpleJpaRepository.class;
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getProjectionFactory(java.lang.ClassLoader, org.springframework.beans.factory.BeanFactory)
	 */
	@Override
	protected ProjectionFactory getProjectionFactory(ClassLoader classLoader, BeanFactory beanFactory) {

		CollectionAwareProjectionFactory factory = new CollectionAwareProjectionFactory();
		factory.setBeanClassLoader(classLoader);
		factory.setBeanFactory(beanFactory);

		return factory;
	}

	/**
	 * Returns whether the given repository interface requires a QueryDsl specific implementation to be chosen.
	 *
	 * @param repositoryInterface
	 * @return
	 */
	private boolean isQueryDslExecutor(Class<?> repositoryInterface) {

		return QUERY_DSL_PRESENT && QuerydslPredicateExecutor.class.isAssignableFrom(repositoryInterface);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getQueryLookupStrategy(org.springframework.data.repository.query.QueryLookupStrategy.Key, org.springframework.data.repository.query.EvaluationContextProvider)
	 */
	@Override
	protected Optional<QueryLookupStrategy> getQueryLookupStrategy(@Nullable Key key,
			EvaluationContextProvider evaluationContextProvider) {
		return Optional
				.of(JpaQueryLookupStrategy.create(entityManager, key, extractor, evaluationContextProvider, escapeCharacter));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactorySupport#getEntityInformation(java.lang.Class)
	 */
	@Override
	@SuppressWarnings(""unchecked"")
	public <T, ID> JpaEntityInformation<T, ID> getEntityInformation(Class<T> domainClass) {

		return (JpaEntityInformation<T, ID>) JpaEntityInformationSupport.getEntityInformation(domainClass, entityManager);
	}

	/**
	 * Query creation listener that informs EclipseLink users that they have to be extra careful when defining repository
	 * query methods using projections as we have to rely on the declaration order of the accessors in projection
	 * interfaces matching the order in columns. Alias-based mapping doesn't work with EclipseLink as it doesn't support
	 * {@link Tuple} based queries yet.
	 *
	 * @author Oliver Gierke
	 * @since 2.0.5
	 * @see https://bugs.eclipse.org/bugs/show_bug.cgi?id=289141
	 */
	@Slf4j
	private static class EclipseLinkProjectionQueryCreationListener implements QueryCreationListener<AbstractJpaQuery> {

		private static final String ECLIPSELINK_PROJECTIONS = ""Usage of Spring Data projections detected on persistence provider EclipseLink. Make sure the following query methods declare result columns in exactly the order the accessors are declared in the projecting interface or the order of parameters for DTOs:"";

		private final JpaMetamodel metamodel;

		private boolean warningLogged = false;

		/**
		 * Creates a new {@link EclipseLinkProjectionQueryCreationListener} for the given {@link EntityManager}.
		 *
		 * @param em must not be {@literal null}.
		 */
		public EclipseLinkProjectionQueryCreationListener(EntityManager em) {

			Assert.notNull(em, ""EntityManager must not be null!"");

			this.metamodel = JpaMetamodel.of(em.getMetamodel());
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.repository.core.support.QueryCreationListener#onCreation(org.springframework.data.repository.query.RepositoryQuery)
		 */
		@Override
		public void onCreation(AbstractJpaQuery query) {

			JpaQueryMethod queryMethod = query.getQueryMethod();
			ReturnedType type = queryMethod.getResultProcessor().getReturnedType();

			if (type.isProjecting() && !metamodel.isJpaManaged(type.getReturnedType())) {

				if (!warningLogged) {
					log.info(ECLIPSELINK_PROJECTIONS);
					this.warningLogged = true;
				}

				log.info("" - {}"", queryMethod);
			}
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryBean.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.springframework.data.mapping.context.MappingContext;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.core.support.TransactionalRepositoryFactoryBeanSupport;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Special adapter for Springs {@link org.springframework.beans.factory.FactoryBean} interface to allow easy setup of
 * repository factories via Spring configuration.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Mark Paluch
 * @param <T> the type of the repository
 */
public class JpaRepositoryFactoryBean<T extends Repository<S, ID>, S, ID>
		extends TransactionalRepositoryFactoryBeanSupport<T, S, ID> {

	private @Nullable EntityManager entityManager;
	/**
	 * Creates a new {@link JpaRepositoryFactoryBean} for the given repository interface.
	 *
	 * @param repositoryInterface must not be {@literal null}.
	 */
	public JpaRepositoryFactoryBean(Class<? extends T> repositoryInterface) {
		super(repositoryInterface);
	}

	/**
	 * The {@link EntityManager} to be used.
	 *
	 * @param entityManager the entityManager to set
	 */
	@PersistenceContext
	public void setEntityManager(EntityManager entityManager) {
		this.entityManager = entityManager;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport#setMappingContext(org.springframework.data.mapping.context.MappingContext)
	 */
	@Override
	public void setMappingContext(MappingContext<?, ?> mappingContext) {
		super.setMappingContext(mappingContext);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.springframework.data.repository.support.
	 * TransactionalRepositoryFactoryBeanSupport#doCreateRepositoryFactory()
	 */
	@Override
	protected RepositoryFactorySupport doCreateRepositoryFactory() {

		Assert.state(entityManager != null,""EntityManager must not be null!"");

		return createRepositoryFactory(entityManager);
	}

	/**
	 * Returns a {@link RepositoryFactorySupport}.
	 *
	 * @param entityManager
	 * @return
	 */
	protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {

		JpaRepositoryFactory jpaRepositoryFactory = new JpaRepositoryFactory(entityManager);
		jpaRepositoryFactory.setEscapeCharacter(escapeCharacter);

		return jpaRepositoryFactory;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() {

		Assert.state(entityManager != null,""EntityManager must not be null!"");
		super.afterPropertiesSet();
	}

	public void setEscapeCharacter(char escapeCharacter) {

		this.escapeCharacter = EscapeCharacter.of(escapeCharacter);
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryBean.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.springframework.data.mapping.context.MappingContext;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.core.support.TransactionalRepositoryFactoryBeanSupport;
import org.springframework.data.jpa.repository.query.EscapeCharacter;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Special adapter for Springs {@link org.springframework.beans.factory.FactoryBean} interface to allow easy setup of
 * repository factories via Spring configuration.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Mark Paluch
 * @param <T> the type of the repository
 */
public class JpaRepositoryFactoryBean<T extends Repository<S, ID>, S, ID>
		extends TransactionalRepositoryFactoryBeanSupport<T, S, ID> {

	private @Nullable EntityManager entityManager;
	/**
	 * Creates a new {@link JpaRepositoryFactoryBean} for the given repository interface.
	 *
	 * @param repositoryInterface must not be {@literal null}.
	 */
	public JpaRepositoryFactoryBean(Class<? extends T> repositoryInterface) {
		super(repositoryInterface);
	}

	/**
	 * The {@link EntityManager} to be used.
	 *
	 * @param entityManager the entityManager to set
	 */
	@PersistenceContext
	public void setEntityManager(EntityManager entityManager) {
		this.entityManager = entityManager;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport#setMappingContext(org.springframework.data.mapping.context.MappingContext)
	 */
	@Override
	public void setMappingContext(MappingContext<?, ?> mappingContext) {
		super.setMappingContext(mappingContext);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.springframework.data.repository.support.
	 * TransactionalRepositoryFactoryBeanSupport#doCreateRepositoryFactory()
	 */
	@Override
	protected RepositoryFactorySupport doCreateRepositoryFactory() {

		Assert.state(entityManager != null,""EntityManager must not be null!"");

		return createRepositoryFactory(entityManager);
	}

	/**
	 * Returns a {@link RepositoryFactorySupport}.
	 *
	 * @param entityManager
	 * @return
	 */
	protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {

		JpaRepositoryFactory jpaRepositoryFactory = new JpaRepositoryFactory(entityManager);
		jpaRepositoryFactory.setEscapeCharacter(escapeCharacter);

		return jpaRepositoryFactory;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() {

		Assert.state(entityManager != null,""EntityManager must not be null!"");
		super.afterPropertiesSet();
	}

	public void setEscapeCharacter(char escapeCharacter) {

		this.escapeCharacter = EscapeCharacter.of(escapeCharacter);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaCountQueryCreatorIntegrationTests.java,"/*
 * Copyright 2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.AbstractRepositoryMetadata;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link JpaCountQueryCreator}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class JpaCountQueryCreatorIntegrationTests {

	@PersistenceContext EntityManager entityManager;

	@Test // DATAJPA-1044
	public void distinctFlagOnCountQueryIssuesCountDistinct() throws Exception {

		Method method = SomeRepository.class.getMethod(""findDistinctByRolesIn"", List.class);

		PersistenceProvider provider = PersistenceProvider.fromEntityManager(entityManager);
		JpaQueryMethod queryMethod = new JpaQueryMethod(method,
				AbstractRepositoryMetadata.getMetadata(SomeRepository.class), new SpelAwareProxyProjectionFactory(), provider);

		PartTree tree = new PartTree(""findDistinctByRolesIn"", User.class);
		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(entityManager.getCriteriaBuilder(),
				queryMethod.getParameters(), provider, EscapeCharacter.of('\\'));

		JpaCountQueryCreator creator = new JpaCountQueryCreator(tree, queryMethod.getResultProcessor().getReturnedType(),
				entityManager.getCriteriaBuilder(), metadataProvider);

		TypedQuery<? extends Object> query = entityManager.createQuery(creator.createQuery());

		assertThat(HibernateUtils.getHibernateQuery(query), startsWith(""select distinct count(distinct""));
	}

	interface SomeRepository extends Repository<User, Long> {
		void findDistinctByRolesIn(List<Role> roles);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaCountQueryCreatorIntegrationTests.java,"/*
 * Copyright 2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.AbstractRepositoryMetadata;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link JpaCountQueryCreator}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class JpaCountQueryCreatorIntegrationTests {

	@PersistenceContext EntityManager entityManager;

	@Test // DATAJPA-1044
	public void distinctFlagOnCountQueryIssuesCountDistinct() throws Exception {

		Method method = SomeRepository.class.getMethod(""findDistinctByRolesIn"", List.class);

		PersistenceProvider provider = PersistenceProvider.fromEntityManager(entityManager);
		JpaQueryMethod queryMethod = new JpaQueryMethod(method,
				AbstractRepositoryMetadata.getMetadata(SomeRepository.class), new SpelAwareProxyProjectionFactory(), provider);

		PartTree tree = new PartTree(""findDistinctByRolesIn"", User.class);
		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(entityManager.getCriteriaBuilder(),
				queryMethod.getParameters(), provider, EscapeCharacter.of('\\'));

		JpaCountQueryCreator creator = new JpaCountQueryCreator(tree, queryMethod.getResultProcessor().getReturnedType(),
				entityManager.getCriteriaBuilder(), metadataProvider);

		TypedQuery<? extends Object> query = entityManager.createQuery(creator.createQuery());

		assertThat(HibernateUtils.getHibernateQuery(query), startsWith(""select distinct count(distinct""));
	}

	interface SomeRepository extends Repository<User, Long> {
		void findDistinctByRolesIn(List<Role> roles);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategyUnitTests.java,"/*
 * Copyright 2012-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.metamodel.Metamodel;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.DefaultEvaluationContextProvider;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;

/**
 * Unit tests for {@link JpaQueryLookupStrategy}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Jens Schauder
 */
@RunWith(MockitoJUnitRunner.class)
public class JpaQueryLookupStrategyUnitTests {

	private static final EvaluationContextProvider EVALUATION_CONTEXT_PROVIDER = DefaultEvaluationContextProvider.INSTANCE;
	@Mock EntityManager em;
	@Mock EntityManagerFactory emf;
	@Mock QueryExtractor extractor;
	@Mock NamedQueries namedQueries;
	@Mock Metamodel metamodel;
	@Mock ProjectionFactory projectionFactory;

	@Before
	public void setUp() {

		when(em.getMetamodel()).thenReturn(metamodel);
		when(em.getEntityManagerFactory()).thenReturn(emf);
		when(emf.createEntityManager()).thenReturn(em);
		when(em.getDelegate()).thenReturn(em);
	}

	@Test // DATAJPA-226
	public void invalidAnnotatedQueryCausesException() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER, EscapeCharacter.of('\\'));
		Method method = UserRepository.class.getMethod(""findByFoo"", String.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		Throwable reference = new RuntimeException();
		when(em.createQuery(anyString())).thenThrow(reference);

		assertThatExceptionOfType(IllegalArgumentException.class)
				.isThrownBy(() -> strategy.resolveQuery(method, metadata, projectionFactory, namedQueries))
				.withCause(reference);
	}

	@Test // DATAJPA-554
	public void sholdThrowMorePreciseExceptionIfTryingToUsePaginationInNativeQueries() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER, EscapeCharacter.of('\\'));
		Method method = UserRepository.class.getMethod(""findByInvalidNativeQuery"", String.class, Sort.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		assertThatExceptionOfType(InvalidJpaQueryMethodException.class)
				.isThrownBy(() -> strategy.resolveQuery(method, metadata, projectionFactory, namedQueries))
				.withMessageContaining(""Cannot use native queries with dynamic sorting in method"")
				.withMessageContaining(method.toString());
	}

	interface UserRepository extends Repository<User, Long> {

		@Query(""something absurd"")
		User findByFoo(String foo);

		@Query(value = ""select u.* from User u"", nativeQuery = true)
		List<User> findByInvalidNativeQuery(String param, Sort sort);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategyUnitTests.java,"/*
 * Copyright 2012-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.metamodel.Metamodel;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.QueryExtractor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.projection.ProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.NamedQueries;
import org.springframework.data.repository.core.RepositoryMetadata;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.DefaultEvaluationContextProvider;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.QueryLookupStrategy;
import org.springframework.data.repository.query.QueryLookupStrategy.Key;

/**
 * Unit tests for {@link JpaQueryLookupStrategy}.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Jens Schauder
 */
@RunWith(MockitoJUnitRunner.class)
public class JpaQueryLookupStrategyUnitTests {

	private static final EvaluationContextProvider EVALUATION_CONTEXT_PROVIDER = DefaultEvaluationContextProvider.INSTANCE;
	@Mock EntityManager em;
	@Mock EntityManagerFactory emf;
	@Mock QueryExtractor extractor;
	@Mock NamedQueries namedQueries;
	@Mock Metamodel metamodel;
	@Mock ProjectionFactory projectionFactory;

	@Before
	public void setUp() {

		when(em.getMetamodel()).thenReturn(metamodel);
		when(em.getEntityManagerFactory()).thenReturn(emf);
		when(emf.createEntityManager()).thenReturn(em);
		when(em.getDelegate()).thenReturn(em);
	}

	@Test // DATAJPA-226
	public void invalidAnnotatedQueryCausesException() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER, EscapeCharacter.of('\\'));
		Method method = UserRepository.class.getMethod(""findByFoo"", String.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		Throwable reference = new RuntimeException();
		when(em.createQuery(anyString())).thenThrow(reference);

		assertThatExceptionOfType(IllegalArgumentException.class)
				.isThrownBy(() -> strategy.resolveQuery(method, metadata, projectionFactory, namedQueries))
				.withCause(reference);
	}

	@Test // DATAJPA-554
	public void sholdThrowMorePreciseExceptionIfTryingToUsePaginationInNativeQueries() throws Exception {

		QueryLookupStrategy strategy = JpaQueryLookupStrategy.create(em, Key.CREATE_IF_NOT_FOUND, extractor,
				EVALUATION_CONTEXT_PROVIDER, EscapeCharacter.of('\\'));
		Method method = UserRepository.class.getMethod(""findByInvalidNativeQuery"", String.class, Sort.class);
		RepositoryMetadata metadata = new DefaultRepositoryMetadata(UserRepository.class);

		assertThatExceptionOfType(InvalidJpaQueryMethodException.class)
				.isThrownBy(() -> strategy.resolveQuery(method, metadata, projectionFactory, namedQueries))
				.withMessageContaining(""Cannot use native queries with dynamic sorting in method"")
				.withMessageContaining(method.toString());
	}

	interface UserRepository extends Repository<User, Long> {

		@Query(""something absurd"")
		User findByFoo(String foo);

		@Query(value = ""select u.* from User u"", nativeQuery = true)
		List<User> findByInvalidNativeQuery(String param, Sort sort);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterExpressionProviderTests.java,"/*
 * Copyright 2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.DefaultParameters;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterExpressionProviderTests {

	@PersistenceContext EntityManager em;

	@Test // DATADOC-99
	@SuppressWarnings(""rawtypes"")
	public void createsParameterExpressionWithMostConcreteType() throws Exception {

		Method method = SampleRepository.class.getMethod(""findByIdGreaterThan"", int.class);
		Parameters<?, ?> parameters = new DefaultParameters(method);
		ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, new Object[] { 1 });
		Part part = new Part(""IdGreaterThan"", User.class);

		CriteriaBuilder builder = em.getCriteriaBuilder();
		PersistenceProvider persistenceProvider = PersistenceProvider.fromEntityManager(em);
		ParameterMetadataProvider provider = new ParameterMetadataProvider(builder, accessor, persistenceProvider, EscapeCharacter.of('\\'));
		ParameterExpression<? extends Comparable> expression = provider.next(part, Comparable.class).getExpression();
		assertThat(expression.getParameterType(), is(typeCompatibleWith(int.class)));
	}

	interface SampleRepository {

		User findByIdGreaterThan(int id);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterExpressionProviderTests.java,"/*
 * Copyright 2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;

import java.lang.reflect.Method;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.ParameterExpression;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.repository.query.DefaultParameters;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.ParametersParameterAccessor;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterExpressionProviderTests {

	@PersistenceContext EntityManager em;

	@Test // DATADOC-99
	@SuppressWarnings(""rawtypes"")
	public void createsParameterExpressionWithMostConcreteType() throws Exception {

		Method method = SampleRepository.class.getMethod(""findByIdGreaterThan"", int.class);
		Parameters<?, ?> parameters = new DefaultParameters(method);
		ParametersParameterAccessor accessor = new ParametersParameterAccessor(parameters, new Object[] { 1 });
		Part part = new Part(""IdGreaterThan"", User.class);

		CriteriaBuilder builder = em.getCriteriaBuilder();
		PersistenceProvider persistenceProvider = PersistenceProvider.fromEntityManager(em);
		ParameterMetadataProvider provider = new ParameterMetadataProvider(builder, accessor, persistenceProvider, EscapeCharacter.of('\\'));
		ParameterExpression<? extends Comparable> expression = provider.next(part, Comparable.class).getExpression();
		assertThat(expression.getParameterType(), is(typeCompatibleWith(int.class)));
	}

	interface SampleRepository {

		User findByIdGreaterThan(int id);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderIntegrationTests.java,"/*
 * Copyright 2015-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.Param;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.util.ReflectionTestUtils;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 * @author Jens Schauder
 * @soundtrack Elephants Crossing - We are (Irrelephant)
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterMetadataProviderIntegrationTests {

	@PersistenceContext EntityManager em;

	@Test // DATAJPA-758
	public void forwardsParameterNameIfTransparentlyNamed() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByFirstname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""firstname"", User.class));

		assertThat(metadata.getExpression().getName()).isEqualTo(""name"");
	}

	@Test // DATAJPA-758
	public void forwardsParameterNameIfExplicitlyAnnotated() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByLastname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""lastname"", User.class));

		assertThat(metadata.getExpression().getName()).isNull();
	}

	@Test // DATAJPA-772
	public void doesNotApplyLikeExpansionOnNonStringProperties() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByAgeContaining"", Integer.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""ageContaining"", User.class));

		assertThat(metadata.prepare(1)).isEqualTo(1);
	}

	private ParameterMetadataProvider createProvider(Method method) {

		JpaParameters parameters = new JpaParameters(method);
		simulateDiscoveredParametername(parameters);

		return new ParameterMetadataProvider(em.getCriteriaBuilder(), parameters,
				PersistenceProvider.fromEntityManager(em), EscapeCharacter.of('\\'));
	}

	@SuppressWarnings({ ""unchecked"", ""ConstantConditions"" })
	private static void simulateDiscoveredParametername(Parameters<?, ?> parameters) {

		List<Object> list = (List<Object>) ReflectionTestUtils.getField(parameters, ""parameters"");
		Object parameter = ReflectionTestUtils.getField(list.get(0), ""parameter"");
		ReflectionTestUtils.setField(parameter, ""parameterName"", ""name"");
	}

	interface Sample {

		User findByFirstname(@Param(""name"") String firstname);

		User findByLastname(String lastname);

		User findByAgeContaining(@Param(""age"") Integer age);
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderIntegrationTests.java,"/*
 * Copyright 2015-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.*;

import java.lang.reflect.Method;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.repository.query.Param;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.util.ReflectionTestUtils;

/**
 * Integration tests for {@link ParameterMetadataProvider}.
 * 
 * @author Oliver Gierke
 * @author Jens Schauder
 * @soundtrack Elephants Crossing - We are (Irrelephant)
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class ParameterMetadataProviderIntegrationTests {

	@PersistenceContext EntityManager em;

	@Test // DATAJPA-758
	public void forwardsParameterNameIfTransparentlyNamed() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByFirstname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""firstname"", User.class));

		assertThat(metadata.getExpression().getName()).isEqualTo(""name"");
	}

	@Test // DATAJPA-758
	public void forwardsParameterNameIfExplicitlyAnnotated() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByLastname"", String.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""lastname"", User.class));

		assertThat(metadata.getExpression().getName()).isNull();
	}

	@Test // DATAJPA-772
	public void doesNotApplyLikeExpansionOnNonStringProperties() throws Exception {

		ParameterMetadataProvider provider = createProvider(Sample.class.getMethod(""findByAgeContaining"", Integer.class));
		ParameterMetadata<Object> metadata = provider.next(new Part(""ageContaining"", User.class));

		assertThat(metadata.prepare(1)).isEqualTo(1);
	}

	private ParameterMetadataProvider createProvider(Method method) {

		JpaParameters parameters = new JpaParameters(method);
		simulateDiscoveredParametername(parameters);

		return new ParameterMetadataProvider(em.getCriteriaBuilder(), parameters,
				PersistenceProvider.fromEntityManager(em), EscapeCharacter.of('\\'));
	}

	@SuppressWarnings({ ""unchecked"", ""ConstantConditions"" })
	private static void simulateDiscoveredParametername(Parameters<?, ?> parameters) {

		List<Object> list = (List<Object>) ReflectionTestUtils.getField(parameters, ""parameters"");
		Object parameter = ReflectionTestUtils.getField(list.get(0), ""parameter"");
		ReflectionTestUtils.setField(parameter, ""parameterName"", ""name"");
	}

	interface Sample {

		User findByFirstname(@Param(""name"") String firstname);

		User findByLastname(String lastname);

		User findByAgeContaining(@Param(""age"") Integer age);
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderUnitTests.java,"/*
 * Copyright 2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.Collections;

import javax.persistence.criteria.CriteriaBuilder;

import org.junit.Test;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;

/**
 * Unit tests for {@link ParameterMetadataProvider}.
 *
 * @author Jens Schauder
 */
public class ParameterMetadataProviderUnitTests {

	@Test // DATAJPA-863
	public void errorMessageMentionesParametersWhenParametersAreExhausted() {

		PersistenceProvider persistenceProvider = mock(PersistenceProvider.class);
		CriteriaBuilder builder = mock(CriteriaBuilder.class);

		Parameters<?, ?> parameters = mock(Parameters.class, RETURNS_DEEP_STUBS);
		when(parameters.getBindableParameters().iterator()).thenReturn(Collections.emptyListIterator());

		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(builder, parameters,
				persistenceProvider, EscapeCharacter.of('\\'));

		assertThatExceptionOfType(RuntimeException.class) //
				.isThrownBy(() -> metadataProvider.next(mock(Part.class))) //
                .withMessageContaining(""parameter"");
	}

}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/ParameterMetadataProviderUnitTests.java,"/*
 * Copyright 2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.Collections;

import javax.persistence.criteria.CriteriaBuilder;

import org.junit.Test;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.repository.query.parser.Part;

/**
 * Unit tests for {@link ParameterMetadataProvider}.
 *
 * @author Jens Schauder
 */
public class ParameterMetadataProviderUnitTests {

	@Test // DATAJPA-863
	public void errorMessageMentionesParametersWhenParametersAreExhausted() {

		PersistenceProvider persistenceProvider = mock(PersistenceProvider.class);
		CriteriaBuilder builder = mock(CriteriaBuilder.class);

		Parameters<?, ?> parameters = mock(Parameters.class, RETURNS_DEEP_STUBS);
		when(parameters.getBindableParameters().iterator()).thenReturn(Collections.emptyListIterator());

		ParameterMetadataProvider metadataProvider = new ParameterMetadataProvider(builder, parameters,
				persistenceProvider, EscapeCharacter.of('\\'));

		assertThatExceptionOfType(RuntimeException.class) //
				.isThrownBy(() -> metadataProvider.next(mock(Part.class))) //
                .withMessageContaining(""parameter"");
	}

}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/PartTreeJpaQueryIntegrationTests.java,"/*
 * Copyright 2011-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License
import org.springframework.aop.framework.Advised;
"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.*;
import static org.springframework.test.util.ReflectionTestUtils.*;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.TemporalType;

import org.hibernate.Version;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.Temporal;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.Param;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.util.Assert;

/**
 * Integration tests for {@link PartTreeJpaQuery}.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Michael Cramer
 * @author Jens Schauder
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class PartTreeJpaQueryIntegrationTests {

	private static String PROPERTY = ""h.target."" + getQueryProperty();

	@Rule public ExpectedException thrown = ExpectedException.none();

	@PersistenceContext EntityManager entityManager;

	PersistenceProvider provider;

	@Before
	public void setUp() {
		this.provider = PersistenceProvider.fromEntityManager(entityManager);
	}

	@Test // DATADOC-90
	public void test() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		jpaQuery.createQuery(new Object[] { ""Matthews"", PageRequest.of(0, 1) });
		jpaQuery.createQuery(new Object[] { ""Matthews"", PageRequest.of(0, 1) });
	}

	@Test
	public void cannotIgnoreCaseIfNotString() throws Exception {

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""Unable to ignore case of java.lang.Integer types, the property 'id' must reference a String"");
		testIgnoreCase(""findByIdIgnoringCase"", 3);
	}

	@Test
	public void cannotIgnoreCaseIfNotStringUnlessIgnoringAll() throws Exception {

		testIgnoreCase(""findByIdAllIgnoringCase"", 3);
	}

	@Test // DATAJPA-121
	public void recreatesQueryIfNullValueIsGiven() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"", PageRequest.of(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""firstname=:param0"");

		query = jpaQuery.createQuery(new Object[] { null, PageRequest.of(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""firstname is null"");
	}

	@Test // DATAJPA-920
	public void shouldLimitExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(query.getMaxResults()).isEqualTo(1);
	}

	@Test // DATAJPA-920
	public void shouldSelectAliasedIdForExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).contains("".id from User as"");
	}

	@Test // DATAJPA-1074
	public void isEmptyCollection() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByRolesIsEmpty"");
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] {});

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""roles is empty"");
	}

	@Test // DATAJPA-1074
	public void isNotEmptyCollection() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByRolesIsNotEmpty"");
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] {});

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""roles is not empty"");
	}

	@Test(expected = IllegalArgumentException.class) // DATAJPA-1074
	public void rejectsIsEmptyOnNonCollectionProperty() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByFirstnameIsEmpty"");
		AbstractJpaQuery jpaQuery = new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'));

		jpaQuery.createQuery(new Object[] { ""Oliver"" });
	}

	@Test // DATAJPA-863
	public void errorsDueToMismatchOfParametersContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByFirstname"");

		assertThatExceptionOfType(IllegalArgumentException.class) //
				.isThrownBy(() -> new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'))) //
				.withMessageContaining(""findByFirstname"") // the method being analyzed
				.withMessageContaining("" firstname "") // the property we are looking for
				.withMessageContaining(""UserRepository""); // the repository
	}

	@Test // DATAJPA-863
	public void errorsDueToMissingPropertyContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByNoSuchProperty"", String.class);

		assertThatExceptionOfType(IllegalArgumentException.class) //
				.isThrownBy(() -> new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'))) //
				.withMessageContaining(""findByNoSuchProperty"") // the method being analyzed
				.withMessageContaining("" noSuchProperty "") // the property we are looking for
				.withMessageContaining(""UserRepository""); // the repository
	}

	private void testIgnoreCase(String methodName, Object... values) throws Exception {

		Class<?>[] parameterTypes = new Class[values.length];

		for (int i = 0; i < values.length; i++) {
			parameterTypes[i] = values[i].getClass();
		}

		JpaQueryMethod queryMethod = getQueryMethod(methodName, parameterTypes);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager,
				PersistenceProvider.fromEntityManager(entityManager), EscapeCharacter.of('\\'));
		jpaQuery.createQuery(values);
	}

	private JpaQueryMethod getQueryMethod(String methodName, Class<?>... parameterTypes) throws Exception {
		Method method = UserRepository.class.getMethod(methodName, parameterTypes);
		return new JpaQueryMethod(method, new DefaultRepositoryMetadata(UserRepository.class),
				new SpelAwareProxyProjectionFactory(), PersistenceProvider.fromEntityManager(entityManager));
	}

	@SuppressWarnings(""unchecked"")
	private static <T> T getValue(Object source, String path) {

		Iterator<String> split = Arrays.asList(path.split(""\\."")).iterator();
		Object result = source;

		while (split.hasNext()) {

			Assert.notNull(source, ""result must not be null."");
			result = getField(result, split.next());
		}

		Assert.notNull(result, ""result must not be null."");
		return (T) result;
	}

	private static String getQueryProperty() {
		return isHibernate43() || isHibernate5() ? ""jpqlQuery"" : ""val$jpaqlQuery"";
	}

	private static boolean isHibernate43() {
		return Version.getVersionString().startsWith(""4.3"");
	}

	private static boolean isHibernate5() {
		return Version.getVersionString().startsWith(""5."");
	}

	@SuppressWarnings(""unused"")
	interface UserRepository extends Repository<User, Long> {

		Page<User> findByFirstname(String firstname, Pageable pageable);

		User findByIdIgnoringCase(Integer id);

		User findByIdAllIgnoringCase(Integer id);

		boolean existsByFirstname(String firstname);

		List<User> findByCreatedAtAfter(@Temporal(TemporalType.TIMESTAMP) @Param(""refDate"") Date refDate);

		List<User> findByRolesIsEmpty();

		List<User> findByRolesIsNotEmpty();

		List<User> findByFirstnameIsEmpty();

		// Wrong number of parameters
		User findByFirstname();

		// Wrong property name
		User findByNoSuchProperty(String x);
	}

}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/query/PartTreeJpaQueryIntegrationTests.java,"/*
 * Copyright 2011-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License
import org.springframework.aop.framework.Advised;
"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.assertj.core.api.Assertions.*;
import static org.springframework.test.util.ReflectionTestUtils.*;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.TemporalType;

import org.hibernate.Version;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.provider.HibernateUtils;
import org.springframework.data.jpa.provider.PersistenceProvider;
import org.springframework.data.jpa.repository.Temporal;
import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
import org.springframework.data.repository.query.Param;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.util.Assert;

/**
 * Integration tests for {@link PartTreeJpaQuery}.
 * 
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Michael Cramer
 * @author Jens Schauder
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(""classpath:infrastructure.xml"")
public class PartTreeJpaQueryIntegrationTests {

	private static String PROPERTY = ""h.target."" + getQueryProperty();

	@Rule public ExpectedException thrown = ExpectedException.none();

	@PersistenceContext EntityManager entityManager;

	PersistenceProvider provider;

	@Before
	public void setUp() {
		this.provider = PersistenceProvider.fromEntityManager(entityManager);
	}

	@Test // DATADOC-90
	public void test() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		jpaQuery.createQuery(new Object[] { ""Matthews"", PageRequest.of(0, 1) });
		jpaQuery.createQuery(new Object[] { ""Matthews"", PageRequest.of(0, 1) });
	}

	@Test
	public void cannotIgnoreCaseIfNotString() throws Exception {

		thrown.expect(IllegalArgumentException.class);
		thrown.expectMessage(""Unable to ignore case of java.lang.Integer types, the property 'id' must reference a String"");
		testIgnoreCase(""findByIdIgnoringCase"", 3);
	}

	@Test
	public void cannotIgnoreCaseIfNotStringUnlessIgnoringAll() throws Exception {

		testIgnoreCase(""findByIdAllIgnoringCase"", 3);
	}

	@Test // DATAJPA-121
	public void recreatesQueryIfNullValueIsGiven() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByFirstname"", String.class, Pageable.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"", PageRequest.of(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""firstname=:param0"");

		query = jpaQuery.createQuery(new Object[] { null, PageRequest.of(0, 1) });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""firstname is null"");
	}

	@Test // DATAJPA-920
	public void shouldLimitExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(query.getMaxResults()).isEqualTo(1);
	}

	@Test // DATAJPA-920
	public void shouldSelectAliasedIdForExistsProjectionQueries() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""existsByFirstname"", String.class);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] { ""Matthews"" });

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).contains("".id from User as"");
	}

	@Test // DATAJPA-1074
	public void isEmptyCollection() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByRolesIsEmpty"");
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] {});

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""roles is empty"");
	}

	@Test // DATAJPA-1074
	public void isNotEmptyCollection() throws Exception {

		JpaQueryMethod queryMethod = getQueryMethod(""findByRolesIsNotEmpty"");
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager, provider, EscapeCharacter.of('\\'));

		Query query = jpaQuery.createQuery(new Object[] {});

		assertThat(HibernateUtils.getHibernateQuery(getValue(query, PROPERTY))).endsWith(""roles is not empty"");
	}

	@Test(expected = IllegalArgumentException.class) // DATAJPA-1074
	public void rejectsIsEmptyOnNonCollectionProperty() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByFirstnameIsEmpty"");
		AbstractJpaQuery jpaQuery = new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'));

		jpaQuery.createQuery(new Object[] { ""Oliver"" });
	}

	@Test // DATAJPA-863
	public void errorsDueToMismatchOfParametersContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByFirstname"");

		assertThatExceptionOfType(IllegalArgumentException.class) //
				.isThrownBy(() -> new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'))) //
				.withMessageContaining(""findByFirstname"") // the method being analyzed
				.withMessageContaining("" firstname "") // the property we are looking for
				.withMessageContaining(""UserRepository""); // the repository
	}

	@Test // DATAJPA-863
	public void errorsDueToMissingPropertyContainNameOfMethodAndInterface() throws Exception {

		JpaQueryMethod method = getQueryMethod(""findByNoSuchProperty"", String.class);

		assertThatExceptionOfType(IllegalArgumentException.class) //
				.isThrownBy(() -> new PartTreeJpaQuery(method, entityManager, provider, EscapeCharacter.of('\\'))) //
				.withMessageContaining(""findByNoSuchProperty"") // the method being analyzed
				.withMessageContaining("" noSuchProperty "") // the property we are looking for
				.withMessageContaining(""UserRepository""); // the repository
	}

	private void testIgnoreCase(String methodName, Object... values) throws Exception {

		Class<?>[] parameterTypes = new Class[values.length];

		for (int i = 0; i < values.length; i++) {
			parameterTypes[i] = values[i].getClass();
		}

		JpaQueryMethod queryMethod = getQueryMethod(methodName, parameterTypes);
		PartTreeJpaQuery jpaQuery = new PartTreeJpaQuery(queryMethod, entityManager,
				PersistenceProvider.fromEntityManager(entityManager), EscapeCharacter.of('\\'));
		jpaQuery.createQuery(values);
	}

	private JpaQueryMethod getQueryMethod(String methodName, Class<?>... parameterTypes) throws Exception {
		Method method = UserRepository.class.getMethod(methodName, parameterTypes);
		return new JpaQueryMethod(method, new DefaultRepositoryMetadata(UserRepository.class),
				new SpelAwareProxyProjectionFactory(), PersistenceProvider.fromEntityManager(entityManager));
	}

	@SuppressWarnings(""unchecked"")
	private static <T> T getValue(Object source, String path) {

		Iterator<String> split = Arrays.asList(path.split(""\\."")).iterator();
		Object result = source;

		while (split.hasNext()) {

			Assert.notNull(source, ""result must not be null."");
			result = getField(result, split.next());
		}

		Assert.notNull(result, ""result must not be null."");
		return (T) result;
	}

	private static String getQueryProperty() {
		return isHibernate43() || isHibernate5() ? ""jpqlQuery"" : ""val$jpaqlQuery"";
	}

	private static boolean isHibernate43() {
		return Version.getVersionString().startsWith(""4.3"");
	}

	private static boolean isHibernate5() {
		return Version.getVersionString().startsWith(""5."");
	}

	@SuppressWarnings(""unused"")
	interface UserRepository extends Repository<User, Long> {

		Page<User> findByFirstname(String firstname, Pageable pageable);

		User findByIdIgnoringCase(Integer id);

		User findByIdAllIgnoringCase(Integer id);

		boolean existsByFirstname(String firstname);

		List<User> findByCreatedAtAfter(@Temporal(TemporalType.TIMESTAMP) @Param(""refDate"") Date refDate);

		List<User> findByRolesIsEmpty();

		List<User> findByRolesIsNotEmpty();

		List<User> findByFirstnameIsEmpty();

		// Wrong number of parameters
		User findByFirstname();

		// Wrong property name
		User findByNoSuchProperty(String x);
	}

}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java,"/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.sample;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;

import javax.persistence.EntityManager;
import javax.persistence.QueryHint;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.SpecialUser;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.QueryHints;
import org.springframework.data.jpa.repository.query.Procedure;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import com.google.common.base.Optional;

/**
 * Repository interface for {@code User}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Kevin Peters
 */
public interface UserRepository
		extends JpaRepository<User, Integer>, JpaSpecificationExecutor<User>, UserRepositoryCustom {

	/**
	 * Retrieve users by their lastname. The finder {@literal User.findByLastname} is declared in
	 * {@literal META-INF/orm.xml} .
	 * 
	 * @param lastname
	 * @return all users with the given lastname
	 */
	@QueryHints({ @QueryHint(name = ""foo"", value = ""bar"") })
	List<User> findByLastname(String lastname);

	/**
	 * Redeclaration of {@link CrudRepository#findById(java.io.Serializable)} to change transaction configuration.
	 */
	@Transactional
	java.util.Optional<User> findById(Integer primaryKey);

	/**
	 * Redeclaration of {@link CrudRepository#deleteById(java.io.Serializable)}. to make sure the transaction
	 * configuration of the original method is considered if the redeclaration does not carry a {@link Transactional}
	 * annotation.
	 */
	void deleteById(Integer id); // DATACMNS-649

	/**
	 * Retrieve users by their email address. The finder {@literal User.findByEmailAddress} is declared as annotation at
	 * {@code User}.
	 * 
	 * @param emailAddress
	 * @return the user with the given email address
	 */
	User findByEmailAddress(String emailAddress);

	@Query(""select u from User u left outer join u.manager as manager"")
	Page<User> findAllPaged(Pageable pageable);

	/**
	 * Retrieves users by the given email and lastname. Acts as a dummy method declaration to test finder query creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @return the user with the given email address and lastname
	 */
	User findByEmailAddressAndLastname(String emailAddress, String lastname);

	/**
	 * Retrieves users by email address and lastname or firstname. Acts as a dummy method declaration to test finder query
	 * creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @param username
	 * @return the users with the given email address and lastname or the given firstname
	 */
	List<User> findByEmailAddressAndLastnameOrFirstname(String emailAddress, String lastname, String username);

	/**
	 * Retrieves a user by its username using the query annotated to the method.
	 * 
	 * @param emailAddress
	 * @return
	 */
	@Query(""select u from User u where u.emailAddress = ?1"")
	@Transactional(readOnly = true)
	User findByAnnotatedQuery(String emailAddress);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * 
	 * @param pageable
	 * @param lastname
	 * @return
	 */
	Page<User> findByLastname(Pageable pageable, String lastname);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * Just returns the queried {@link Page}'s contents.
	 * 
	 * @param firstname
	 * @param pageable
	 * @return
	 */
	List<User> findByFirstname(String firstname, Pageable pageable);

	Page<User> findByFirstnameIn(Pageable pageable, String... firstnames);

	List<User> findByFirstnameNotIn(Collection<String> firstnames);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like ?1%"")
	List<User> findByFirstnameLike(String firstname);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like :firstname%"")
	List<User> findByFirstnameLikeNamed(@Param(""firstname"") String firstname);

	/**
	 * Manipulating query to set all {@link User}'s names to the given one.
	 * 
	 * @param lastname
	 */
	@Modifying
	@Query(""update User u set u.lastname = ?1"")
	void renameAllUsersTo(String lastname);

	@Query(""select count(u) from User u where u.firstname = ?1"")
	Long countWithFirstname(String firstname);

	/**
	 * Method where parameters will be applied by name. Note that the order of the parameters is then not crucial anymore.
	 * 
	 * @param foo
	 * @param bar
	 * @return
	 */
	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstname(@Param(""firstname"") String foo, @Param(""lastname"") String bar);

	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstnameUnannotated(String firstname, String lastname);

	/**
	 * Method to check query creation and named parameter usage go well hand in hand.
	 * 
	 * @param lastname
	 * @param firstname
	 * @return
	 */
	List<User> findByFirstnameOrLastname(@Param(""lastname"") String lastname, @Param(""firstname"") String firstname);

	List<User> findByLastnameLikeOrderByFirstnameDesc(String lastname);

	List<User> findByLastnameNotLike(String lastname);

	List<User> findByLastnameNot(String lastname);

	List<User> findByManagerLastname(String name);

	List<User> findByColleaguesLastname(String lastname);

	List<User> findByLastnameNotNull();

	List<User> findByLastnameNull();

	List<User> findByEmailAddressLike(String email, Sort sort);

	List<SpecialUser> findSpecialUsersByLastname(String lastname);

	List<User> findBySpringDataNamedQuery(String lastname);

	List<User> findByLastnameIgnoringCase(String lastname);

	Page<User> findByLastnameIgnoringCase(Pageable pageable, String lastname);

	List<User> findByLastnameIgnoringCaseLike(String lastname);

	List<User> findByLastnameAndFirstnameAllIgnoringCase(String lastname, String firstname);

	List<User> findByAgeGreaterThanEqual(int age);

	List<User> findByAgeLessThanEqual(int age);

	@Query(""select u.lastname from User u group by u.lastname"")
	Page<String> findByLastnameGrouped(Pageable pageable);

	// DATAJPA-117
	@Query(value = ""SELECT * FROM SD_User WHERE lastname = ?1"", nativeQuery = true)
	List<User> findNativeByLastname(String lastname);

	// DATAJPA-132
	List<User> findByActiveTrue();

	// DATAJPA-132
	List<User> findByActiveFalse();

	@Query(""select u.colleagues from User u where u = ?1"")
	List<User> findColleaguesFor(User user);

	// DATAJPA-188
	List<User> findByCreatedAtBefore(Date date);

	// DATAJPA-188
	List<User> findByCreatedAtAfter(Date date);

	// DATAJPA-180
	List<User> findByFirstnameStartingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameEndingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameContaining(String firstname);

	@Query(value = ""SELECT 1 FROM SD_User"", nativeQuery = true)
	List<Integer> findOnesByNativeQuery();

	// DATAJPA-231
	long countByLastname(String lastname);

	// DATAJPA-231
	int countUsersByFirstname(String firstname);

	// DATAJPA-920
	boolean existsByLastname(String lastname);

	// DATAJPA-391
	@Query(""select u.firstname from User u where u.lastname = ?1"")
	List<String> findFirstnamesByLastname(String lastname);

	// DATAJPA-415
	Collection<User> findByIdIn(@Param(""ids"") Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in ?1"")
	Collection<User> findByIdsCustomWithPositionalVarArgs(Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in :ids"")
	Collection<User> findByIdsCustomWithNamedVarArgs(@Param(""ids"") Integer... ids);

	// DATAJPA-415
	@Modifying
	@Query(""update #{#entityName} u set u.active = :activeState where u.id in :ids"")
	void updateUserActiveState(@Param(""activeState"") boolean activeState, @Param(""ids"") Integer... ids);

	// DATAJPA-405
	List<User> findAllByOrderByLastnameAsc();

	// DATAJPA-454
	List<User> findByBinaryData(byte[] data);

	// DATAJPA-486
	Slice<User> findSliceByLastname(String lastname, Pageable pageable);

	// DATAJPA-496
	List<User> findByAttributesIn(Set<String> attributes);

	// DATAJPA-460
	Long removeByLastname(String lastname);

	// DATAJPA-460
	List<User> deleteByLastname(String lastname);

	/**
	 * @see <a href=""https://issues.apache.org/jira/browse/OPENJPA-2484"">OPENJPA-2484</a>
	 */
	// DATAJPA-505
	// @Query(value = ""select u.binaryData from User u where u.id = :id"")
	// byte[] findBinaryDataByIdJpaQl(@Param(""id"") Integer id);

	/**
	 * Explicitly mapped to a procedure with name ""plus1inout"" in database.
	 */
	@Procedure(""plus1inout"") // DATAJPA-455
	Integer explicitlyNamedPlus1inout(Integer arg);

	/**
	 * Implicitly mapped to a procedure with name ""plus1inout"" in database via alias.
	 */
	@Procedure(procedureName = ""plus1inout"") // DATAJPA-455
	Integer plus1inout(Integer arg);

	/**
	 * Explicitly mapped to named stored procedure ""User.plus1IO"" in {@link EntityManager}.
	 */
	@Procedure(name = ""User.plus1IO"") // DATAJPA-455
	Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param(""arg"") Integer arg);

	/**
	 * Implicitly mapped to named stored procedure ""User.plus1"" in {@link EntityManager}.
	 */
	@Procedure // DATAJPA-455
	Integer plus1(@Param(""arg"") Integer arg);

	// DATAJPA-456
	@Query(value = ""select u from User u where u.firstname like ?1%"", countProjection = ""u.firstname"")
	Page<User> findAllByFirstnameLike(String firstname, Pageable page);

	// DATAJPA-456
	@Query(name = ""User.findBySpringDataNamedQuery"", countProjection = ""u.firstname"")
	Page<User> findByNamedQueryAndCountProjection(String firstname, Pageable page);

	// DATAJPA-551
	User findFirstByOrderByAgeDesc();

	// DATAJPA-551
	User findFirst1ByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeAsc();

	// DATAJPA-551
	User findTop1ByOrderByAgeAsc();

	// DATAJPA-551
	List<User> findTop2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2UsersBy(Sort sort);

	// DATAJPA-551
	List<User> findTop2UsersBy(Sort sort);

	// DATAJPA-551
	Page<User> findFirst3UsersBy(Pageable page);

	// DATAJPA-551
	Page<User> findFirst2UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop3UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop2UsersBy(Pageable page);

	// DATAJPA-506
	@Query(value = ""select u.binaryData from SD_User u where u.id = ?1"", nativeQuery = true)
	byte[] findBinaryDataByIdNative(Integer id);

	// DATAJPA-506
	@Query(""select u from User u where u.emailAddress = ?1"")
	Optional<User> findOptionalByEmailAddress(String emailAddress);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]} and u.firstname = ?1 and u.lastname like %?#{[1]}% and u.lastname like %?2%"")
	List<User> findByFirstnameAndLastnameWithSpelExpression(String firstname, String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%"")
	List<User> findByLastnameWithSpelExpression(@Param(""lastname"") String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithQuestionmark();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithColon();

	// DATAJPA-564
	@Query(""select u from User u where u.age = ?#{[0]}"")
	List<User> findUsersByAgeForSpELExpressionByIndexedParameter(int age);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :firstname and u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpression(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findCurrentUserWithCustomQuery();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findByFirstnameAndCurrentUserWithCustomQuery(String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterVariableOnly(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnly(String firstname);

	// DATAJPA-564
	@Query(
			value = ""select * from ("" +
					""select u.*, rownum() as RN from ("" +
					""select * from SD_User ORDER BY ucase(firstname)"" +
					"") u"" +
					"") where RN between ?#{ #pageable.offset +1 } and ?#{#pageable.offset + #pageable.pageSize}"",
			countQuery = ""select count(u.id) from SD_User u"", nativeQuery = true)
	Page<User> findUsersInNativeQueryWithPagination(Pageable pageable);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#user.firstname} and u.lastname =:lastname"")
	List<User> findUsersByUserFirstnameAsSpELExpressionAndLastnameAsString(@Param(""user"") User user,
			@Param(""lastname"") String lastname);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:firstname and u.lastname =:#{#user.lastname}"")
	List<User> findUsersByFirstnameAsStringAndUserLastnameAsSpELExpression(@Param(""firstname"") String firstname,
			@Param(""user"") User user);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#user.firstname} and u.lastname =:#{#lastname}"")
	List<User> findUsersByUserFirstnameAsSpELExpressionAndLastnameAsFakeSpELExpression(@Param(""user"") User user,
			@Param(""lastname"") String lastname);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#firstname} and u.lastname =:#{#user.lastname}"")
	List<User> findUsersByFirstnameAsFakeSpELExpressionAndUserLastnameAsSpELExpression(
			@Param(""firstname"") String firstname, @Param(""user"") User user);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:firstname"")
	List<User> findUsersByFirstnamePaginated(Pageable page, @Param(""firstname"") String firstname);

	// DATAJPA-629
	@Query(""select u from #{#entityName} u where u.firstname = ?#{[0]} and u.lastname = ?#{[1]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnlyWithEntityExpression(String firstname,
			String lastname);

	// DATAJPA-606
	List<User> findByAgeIn(Collection<Integer> ages);

	// DATAJPA-606
	List<User> queryByAgeIn(Integer[] ages);

	// DATAJPA-606
	List<User> queryByAgeInOrFirstname(Integer[] ages, String firstname);

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> findAllByCustomQueryAndStream();

	// DATAJPA-677
	Stream<User> readAllByFirstnameNotNull();

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> streamAllPaged(Pageable pageable);

	// DATAJPA-830
	List<User> findByLastnameNotContaining(String part);

	// DATAJPA-829
	List<User> findByRolesContaining(Role role);

	// DATAJPA-829
	List<User> findByRolesNotContaining(Role role);

	// DATAJPA-858
	List<User> findByRolesNameContaining(String name);

	// DATAJPA-1179
	@Query(""select u from User u where u.firstname = :#{#firstname} and u.firstname = :#{#firstname}"")
	List<User> findUsersByDuplicateSpel(@Param(""firstname"") String firstname);

	List<RolesAndFirstname> findRolesAndFirstnameBy();

	// DATAJPA-1172
	@Query(""select u from User u where u.age = :age"")
	List<User> findByStringAge(@Param(""age"") String age);

	// DATAJPA-1185
	<T> Stream<T> findAsStreamByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1185
	<T> List<T> findAsListByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-980
	@Query(value = ""SELECT firstname, lastname FROM SD_User WHERE id = ?1"", nativeQuery = true)
	NameOnly findByNativeQuery(Integer id);

	// DATAJPA-1248
	@Query(value = ""SELECT emailaddress FROM SD_User WHERE id = ?1"", nativeQuery = true)
	EmailOnly findEmailOnlyByNativeQuery(Integer id);

	// DATAJPA-1235
	@Query(""SELECT u FROM User u where u.firstname >= ?1 and u.lastname = '000:1'"")
	List<User> queryWithIndexedParameterAndColonFollowedByIntegerInString(String firstname);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u ORDER BY CASE WHEN (u.firstname  >= :name) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameSingleParam(@Param(""name"") String name, Pageable page);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u WHERE :other = 'x' ORDER BY CASE WHEN (u.firstname  >= :name) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameMultipleParams(@Param(""name"") String name, @Param(""other"") String other, Pageable page);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u WHERE ?2 = 'x' ORDER BY CASE WHEN (u.firstname  >= ?1) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameMultipleParamsIndexed(String name, String other, Pageable page);

	// DATAJPA-928
	Page<User> findByNativeNamedQueryWithPageable(Pageable pageable);

	// DATAJPA-928
	@Query(value = ""SELECT firstname FROM SD_User ORDER BY UCASE(firstname)"", countQuery = ""SELECT count(*) FROM SD_User"",
			nativeQuery = true)
	Page<String> findByNativeQueryWithPageable(@Param(""pageable"") Pageable pageable);

	// DATAJPA-1273
	List<NameOnly> findByNamedQueryWithAliasInInvertedOrder();

	// DATAJPA-1301
	@Query(""select firstname as firstname, lastname as lastname from User u where u.firstname = 'Oliver'"")
	Map<String, Object> findMapWithNullValues();

	// DATAJPA-1307
	@Query(value = ""select * from SD_User u where u.emailAddress = ?"", nativeQuery = true)
	User findByEmailNativeAddressJdbcStyleParameter(String emailAddress);

	// DATAJPA-1334
	List<NameOnlyDto> findByNamedQueryWithConstructorExpression();

	// DATAJPA-1519
	@Query(""select u from User u where u.firstname like %?#{#escape([0],'#')}% escape '#'"")
	List<User> findContainingEscaped(String namePart);

	interface RolesAndFirstname {

		String getFirstname();

		Set<Role> getRoles();
	}

	interface NameOnly {

		String getFirstname();

		String getLastname();
	}

	interface EmailOnly {
		String getEmailAddress();
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java,"/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.sample;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;

import javax.persistence.EntityManager;
import javax.persistence.QueryHint;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.SpecialUser;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.QueryHints;
import org.springframework.data.jpa.repository.query.Procedure;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import com.google.common.base.Optional;

/**
 * Repository interface for {@code User}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Kevin Peters
 */
public interface UserRepository
		extends JpaRepository<User, Integer>, JpaSpecificationExecutor<User>, UserRepositoryCustom {

	/**
	 * Retrieve users by their lastname. The finder {@literal User.findByLastname} is declared in
	 * {@literal META-INF/orm.xml} .
	 * 
	 * @param lastname
	 * @return all users with the given lastname
	 */
	@QueryHints({ @QueryHint(name = ""foo"", value = ""bar"") })
	List<User> findByLastname(String lastname);

	/**
	 * Redeclaration of {@link CrudRepository#findById(java.io.Serializable)} to change transaction configuration.
	 */
	@Transactional
	java.util.Optional<User> findById(Integer primaryKey);

	/**
	 * Redeclaration of {@link CrudRepository#deleteById(java.io.Serializable)}. to make sure the transaction
	 * configuration of the original method is considered if the redeclaration does not carry a {@link Transactional}
	 * annotation.
	 */
	void deleteById(Integer id); // DATACMNS-649

	/**
	 * Retrieve users by their email address. The finder {@literal User.findByEmailAddress} is declared as annotation at
	 * {@code User}.
	 * 
	 * @param emailAddress
	 * @return the user with the given email address
	 */
	User findByEmailAddress(String emailAddress);

	@Query(""select u from User u left outer join u.manager as manager"")
	Page<User> findAllPaged(Pageable pageable);

	/**
	 * Retrieves users by the given email and lastname. Acts as a dummy method declaration to test finder query creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @return the user with the given email address and lastname
	 */
	User findByEmailAddressAndLastname(String emailAddress, String lastname);

	/**
	 * Retrieves users by email address and lastname or firstname. Acts as a dummy method declaration to test finder query
	 * creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @param username
	 * @return the users with the given email address and lastname or the given firstname
	 */
	List<User> findByEmailAddressAndLastnameOrFirstname(String emailAddress, String lastname, String username);

	/**
	 * Retrieves a user by its username using the query annotated to the method.
	 * 
	 * @param emailAddress
	 * @return
	 */
	@Query(""select u from User u where u.emailAddress = ?1"")
	@Transactional(readOnly = true)
	User findByAnnotatedQuery(String emailAddress);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * 
	 * @param pageable
	 * @param lastname
	 * @return
	 */
	Page<User> findByLastname(Pageable pageable, String lastname);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * Just returns the queried {@link Page}'s contents.
	 * 
	 * @param firstname
	 * @param pageable
	 * @return
	 */
	List<User> findByFirstname(String firstname, Pageable pageable);

	Page<User> findByFirstnameIn(Pageable pageable, String... firstnames);

	List<User> findByFirstnameNotIn(Collection<String> firstnames);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like ?1%"")
	List<User> findByFirstnameLike(String firstname);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like :firstname%"")
	List<User> findByFirstnameLikeNamed(@Param(""firstname"") String firstname);

	/**
	 * Manipulating query to set all {@link User}'s names to the given one.
	 * 
	 * @param lastname
	 */
	@Modifying
	@Query(""update User u set u.lastname = ?1"")
	void renameAllUsersTo(String lastname);

	@Query(""select count(u) from User u where u.firstname = ?1"")
	Long countWithFirstname(String firstname);

	/**
	 * Method where parameters will be applied by name. Note that the order of the parameters is then not crucial anymore.
	 * 
	 * @param foo
	 * @param bar
	 * @return
	 */
	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstname(@Param(""firstname"") String foo, @Param(""lastname"") String bar);

	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstnameUnannotated(String firstname, String lastname);

	/**
	 * Method to check query creation and named parameter usage go well hand in hand.
	 * 
	 * @param lastname
	 * @param firstname
	 * @return
	 */
	List<User> findByFirstnameOrLastname(@Param(""lastname"") String lastname, @Param(""firstname"") String firstname);

	List<User> findByLastnameLikeOrderByFirstnameDesc(String lastname);

	List<User> findByLastnameNotLike(String lastname);

	List<User> findByLastnameNot(String lastname);

	List<User> findByManagerLastname(String name);

	List<User> findByColleaguesLastname(String lastname);

	List<User> findByLastnameNotNull();

	List<User> findByLastnameNull();

	List<User> findByEmailAddressLike(String email, Sort sort);

	List<SpecialUser> findSpecialUsersByLastname(String lastname);

	List<User> findBySpringDataNamedQuery(String lastname);

	List<User> findByLastnameIgnoringCase(String lastname);

	Page<User> findByLastnameIgnoringCase(Pageable pageable, String lastname);

	List<User> findByLastnameIgnoringCaseLike(String lastname);

	List<User> findByLastnameAndFirstnameAllIgnoringCase(String lastname, String firstname);

	List<User> findByAgeGreaterThanEqual(int age);

	List<User> findByAgeLessThanEqual(int age);

	@Query(""select u.lastname from User u group by u.lastname"")
	Page<String> findByLastnameGrouped(Pageable pageable);

	// DATAJPA-117
	@Query(value = ""SELECT * FROM SD_User WHERE lastname = ?1"", nativeQuery = true)
	List<User> findNativeByLastname(String lastname);

	// DATAJPA-132
	List<User> findByActiveTrue();

	// DATAJPA-132
	List<User> findByActiveFalse();

	@Query(""select u.colleagues from User u where u = ?1"")
	List<User> findColleaguesFor(User user);

	// DATAJPA-188
	List<User> findByCreatedAtBefore(Date date);

	// DATAJPA-188
	List<User> findByCreatedAtAfter(Date date);

	// DATAJPA-180
	List<User> findByFirstnameStartingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameEndingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameContaining(String firstname);

	@Query(value = ""SELECT 1 FROM SD_User"", nativeQuery = true)
	List<Integer> findOnesByNativeQuery();

	// DATAJPA-231
	long countByLastname(String lastname);

	// DATAJPA-231
	int countUsersByFirstname(String firstname);

	// DATAJPA-920
	boolean existsByLastname(String lastname);

	// DATAJPA-391
	@Query(""select u.firstname from User u where u.lastname = ?1"")
	List<String> findFirstnamesByLastname(String lastname);

	// DATAJPA-415
	Collection<User> findByIdIn(@Param(""ids"") Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in ?1"")
	Collection<User> findByIdsCustomWithPositionalVarArgs(Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in :ids"")
	Collection<User> findByIdsCustomWithNamedVarArgs(@Param(""ids"") Integer... ids);

	// DATAJPA-415
	@Modifying
	@Query(""update #{#entityName} u set u.active = :activeState where u.id in :ids"")
	void updateUserActiveState(@Param(""activeState"") boolean activeState, @Param(""ids"") Integer... ids);

	// DATAJPA-405
	List<User> findAllByOrderByLastnameAsc();

	// DATAJPA-454
	List<User> findByBinaryData(byte[] data);

	// DATAJPA-486
	Slice<User> findSliceByLastname(String lastname, Pageable pageable);

	// DATAJPA-496
	List<User> findByAttributesIn(Set<String> attributes);

	// DATAJPA-460
	Long removeByLastname(String lastname);

	// DATAJPA-460
	List<User> deleteByLastname(String lastname);

	/**
	 * @see <a href=""https://issues.apache.org/jira/browse/OPENJPA-2484"">OPENJPA-2484</a>
	 */
	// DATAJPA-505
	// @Query(value = ""select u.binaryData from User u where u.id = :id"")
	// byte[] findBinaryDataByIdJpaQl(@Param(""id"") Integer id);

	/**
	 * Explicitly mapped to a procedure with name ""plus1inout"" in database.
	 */
	@Procedure(""plus1inout"") // DATAJPA-455
	Integer explicitlyNamedPlus1inout(Integer arg);

	/**
	 * Implicitly mapped to a procedure with name ""plus1inout"" in database via alias.
	 */
	@Procedure(procedureName = ""plus1inout"") // DATAJPA-455
	Integer plus1inout(Integer arg);

	/**
	 * Explicitly mapped to named stored procedure ""User.plus1IO"" in {@link EntityManager}.
	 */
	@Procedure(name = ""User.plus1IO"") // DATAJPA-455
	Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param(""arg"") Integer arg);

	/**
	 * Implicitly mapped to named stored procedure ""User.plus1"" in {@link EntityManager}.
	 */
	@Procedure // DATAJPA-455
	Integer plus1(@Param(""arg"") Integer arg);

	// DATAJPA-456
	@Query(value = ""select u from User u where u.firstname like ?1%"", countProjection = ""u.firstname"")
	Page<User> findAllByFirstnameLike(String firstname, Pageable page);

	// DATAJPA-456
	@Query(name = ""User.findBySpringDataNamedQuery"", countProjection = ""u.firstname"")
	Page<User> findByNamedQueryAndCountProjection(String firstname, Pageable page);

	// DATAJPA-551
	User findFirstByOrderByAgeDesc();

	// DATAJPA-551
	User findFirst1ByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeAsc();

	// DATAJPA-551
	User findTop1ByOrderByAgeAsc();

	// DATAJPA-551
	List<User> findTop2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2UsersBy(Sort sort);

	// DATAJPA-551
	List<User> findTop2UsersBy(Sort sort);

	// DATAJPA-551
	Page<User> findFirst3UsersBy(Pageable page);

	// DATAJPA-551
	Page<User> findFirst2UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop3UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop2UsersBy(Pageable page);

	// DATAJPA-506
	@Query(value = ""select u.binaryData from SD_User u where u.id = ?1"", nativeQuery = true)
	byte[] findBinaryDataByIdNative(Integer id);

	// DATAJPA-506
	@Query(""select u from User u where u.emailAddress = ?1"")
	Optional<User> findOptionalByEmailAddress(String emailAddress);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]} and u.firstname = ?1 and u.lastname like %?#{[1]}% and u.lastname like %?2%"")
	List<User> findByFirstnameAndLastnameWithSpelExpression(String firstname, String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%"")
	List<User> findByLastnameWithSpelExpression(@Param(""lastname"") String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithQuestionmark();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithColon();

	// DATAJPA-564
	@Query(""select u from User u where u.age = ?#{[0]}"")
	List<User> findUsersByAgeForSpELExpressionByIndexedParameter(int age);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :firstname and u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpression(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findCurrentUserWithCustomQuery();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findByFirstnameAndCurrentUserWithCustomQuery(String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterVariableOnly(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnly(String firstname);

	// DATAJPA-564
	@Query(
			value = ""select * from ("" +
					""select u.*, rownum() as RN from ("" +
					""select * from SD_User ORDER BY ucase(firstname)"" +
					"") u"" +
					"") where RN between ?#{ #pageable.offset +1 } and ?#{#pageable.offset + #pageable.pageSize}"",
			countQuery = ""select count(u.id) from SD_User u"", nativeQuery = true)
	Page<User> findUsersInNativeQueryWithPagination(Pageable pageable);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#user.firstname} and u.lastname =:lastname"")
	List<User> findUsersByUserFirstnameAsSpELExpressionAndLastnameAsString(@Param(""user"") User user,
			@Param(""lastname"") String lastname);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:firstname and u.lastname =:#{#user.lastname}"")
	List<User> findUsersByFirstnameAsStringAndUserLastnameAsSpELExpression(@Param(""firstname"") String firstname,
			@Param(""user"") User user);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#user.firstname} and u.lastname =:#{#lastname}"")
	List<User> findUsersByUserFirstnameAsSpELExpressionAndLastnameAsFakeSpELExpression(@Param(""user"") User user,
			@Param(""lastname"") String lastname);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#firstname} and u.lastname =:#{#user.lastname}"")
	List<User> findUsersByFirstnameAsFakeSpELExpressionAndUserLastnameAsSpELExpression(
			@Param(""firstname"") String firstname, @Param(""user"") User user);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:firstname"")
	List<User> findUsersByFirstnamePaginated(Pageable page, @Param(""firstname"") String firstname);

	// DATAJPA-629
	@Query(""select u from #{#entityName} u where u.firstname = ?#{[0]} and u.lastname = ?#{[1]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnlyWithEntityExpression(String firstname,
			String lastname);

	// DATAJPA-606
	List<User> findByAgeIn(Collection<Integer> ages);

	// DATAJPA-606
	List<User> queryByAgeIn(Integer[] ages);

	// DATAJPA-606
	List<User> queryByAgeInOrFirstname(Integer[] ages, String firstname);

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> findAllByCustomQueryAndStream();

	// DATAJPA-677
	Stream<User> readAllByFirstnameNotNull();

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> streamAllPaged(Pageable pageable);

	// DATAJPA-830
	List<User> findByLastnameNotContaining(String part);

	// DATAJPA-829
	List<User> findByRolesContaining(Role role);

	// DATAJPA-829
	List<User> findByRolesNotContaining(Role role);

	// DATAJPA-858
	List<User> findByRolesNameContaining(String name);

	// DATAJPA-1179
	@Query(""select u from User u where u.firstname = :#{#firstname} and u.firstname = :#{#firstname}"")
	List<User> findUsersByDuplicateSpel(@Param(""firstname"") String firstname);

	List<RolesAndFirstname> findRolesAndFirstnameBy();

	// DATAJPA-1172
	@Query(""select u from User u where u.age = :age"")
	List<User> findByStringAge(@Param(""age"") String age);

	// DATAJPA-1185
	<T> Stream<T> findAsStreamByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1185
	<T> List<T> findAsListByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-980
	@Query(value = ""SELECT firstname, lastname FROM SD_User WHERE id = ?1"", nativeQuery = true)
	NameOnly findByNativeQuery(Integer id);

	// DATAJPA-1248
	@Query(value = ""SELECT emailaddress FROM SD_User WHERE id = ?1"", nativeQuery = true)
	EmailOnly findEmailOnlyByNativeQuery(Integer id);

	// DATAJPA-1235
	@Query(""SELECT u FROM User u where u.firstname >= ?1 and u.lastname = '000:1'"")
	List<User> queryWithIndexedParameterAndColonFollowedByIntegerInString(String firstname);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u ORDER BY CASE WHEN (u.firstname  >= :name) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameSingleParam(@Param(""name"") String name, Pageable page);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u WHERE :other = 'x' ORDER BY CASE WHEN (u.firstname  >= :name) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameMultipleParams(@Param(""name"") String name, @Param(""other"") String other, Pageable page);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u WHERE ?2 = 'x' ORDER BY CASE WHEN (u.firstname  >= ?1) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameMultipleParamsIndexed(String name, String other, Pageable page);

	// DATAJPA-928
	Page<User> findByNativeNamedQueryWithPageable(Pageable pageable);

	// DATAJPA-928
	@Query(value = ""SELECT firstname FROM SD_User ORDER BY UCASE(firstname)"", countQuery = ""SELECT count(*) FROM SD_User"",
			nativeQuery = true)
	Page<String> findByNativeQueryWithPageable(@Param(""pageable"") Pageable pageable);

	// DATAJPA-1273
	List<NameOnly> findByNamedQueryWithAliasInInvertedOrder();

	// DATAJPA-1301
	@Query(""select firstname as firstname, lastname as lastname from User u where u.firstname = 'Oliver'"")
	Map<String, Object> findMapWithNullValues();

	// DATAJPA-1307
	@Query(value = ""select * from SD_User u where u.emailAddress = ?"", nativeQuery = true)
	User findByEmailNativeAddressJdbcStyleParameter(String emailAddress);

	// DATAJPA-1334
	List<NameOnlyDto> findByNamedQueryWithConstructorExpression();

	// DATAJPA-1519
	@Query(""select u from User u where u.firstname like %?#{escape([0])}% escape '\\'"")
	List<User> findContainingEscaped(String namePart);

	interface RolesAndFirstname {

		String getFirstname();

		Set<Role> getRoles();
	}

	interface NameOnly {

		String getFirstname();

		String getLastname();
	}

	interface EmailOnly {
		String getEmailAddress();
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/EscapeCharacter.java,"/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import lombok.Value;

import java.util.Arrays;
import java.util.List;

import org.springframework.util.Assert;

/**
 * A value type encapsulating an escape character for LIKE queries and the actually usage of it in escaping
 * {@link String}s.
 *
 * @author Jens Schauder
 * @author Oliver Drotbohm
 */
@Value(staticConstructor = ""of"")
public class EscapeCharacter {

	private static final List<String> TO_REPLACE = Arrays.asList(""_"", ""%"");

	char value;

	/**
	 * Escapes all special like characters ({@code _}, {@code %}) using the configured escape character.
	 *
	 * @param value must not be {@literal null}.
	 * @return
	 */
	public String escape(String value) {

		Assert.notNull(value, ""Value must be not null."");

		return TO_REPLACE.stream() //
				.reduce(value, (it, character) -> it.replace(character, this.value + character));
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/EscapeCharacter.java,"/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import lombok.Value;

import java.util.Arrays;
import java.util.List;

import org.springframework.lang.Nullable;

/**
 * A value type encapsulating an escape character for LIKE queries and the actually usage of it in escaping
 * {@link String}s.
 *
 * @author Jens Schauder
 * @author Oliver Drotbohm
 */
@Value(staticConstructor = ""of"")
public class EscapeCharacter {

	private static final List<String> TO_REPLACE = Arrays.asList(""_"", ""%"");

	char value;

	/**
	 * Escapes all special like characters ({@code _}, {@code %}) using the configured escape character.
	 *
	 * @param value May be {@literal null}.
	 * @return
	 */
	@Nullable
	public String escape(String value) {

		if (value == null) {
			return null;
		}
		return TO_REPLACE.stream() //
				.reduce(value, (it, character) -> it.replace(character, this.value + character));
	}

	/**
	 * Makes the underlying character available.
	 *
	 * @return the value
	 */
	public char escapeCharacter() {
		return value;
	}
}
",1
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java,"/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.sample;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;

import javax.persistence.EntityManager;
import javax.persistence.QueryHint;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.SpecialUser;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.QueryHints;
import org.springframework.data.jpa.repository.query.Procedure;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import com.google.common.base.Optional;

/**
 * Repository interface for {@code User}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Kevin Peters
 */
public interface UserRepository
		extends JpaRepository<User, Integer>, JpaSpecificationExecutor<User>, UserRepositoryCustom {

	/**
	 * Retrieve users by their lastname. The finder {@literal User.findByLastname} is declared in
	 * {@literal META-INF/orm.xml} .
	 * 
	 * @param lastname
	 * @return all users with the given lastname
	 */
	@QueryHints({ @QueryHint(name = ""foo"", value = ""bar"") })
	List<User> findByLastname(String lastname);

	/**
	 * Redeclaration of {@link CrudRepository#findById(java.io.Serializable)} to change transaction configuration.
	 */
	@Transactional
	java.util.Optional<User> findById(Integer primaryKey);

	/**
	 * Redeclaration of {@link CrudRepository#deleteById(java.io.Serializable)}. to make sure the transaction
	 * configuration of the original method is considered if the redeclaration does not carry a {@link Transactional}
	 * annotation.
	 */
	void deleteById(Integer id); // DATACMNS-649

	/**
	 * Retrieve users by their email address. The finder {@literal User.findByEmailAddress} is declared as annotation at
	 * {@code User}.
	 * 
	 * @param emailAddress
	 * @return the user with the given email address
	 */
	User findByEmailAddress(String emailAddress);

	@Query(""select u from User u left outer join u.manager as manager"")
	Page<User> findAllPaged(Pageable pageable);

	/**
	 * Retrieves users by the given email and lastname. Acts as a dummy method declaration to test finder query creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @return the user with the given email address and lastname
	 */
	User findByEmailAddressAndLastname(String emailAddress, String lastname);

	/**
	 * Retrieves users by email address and lastname or firstname. Acts as a dummy method declaration to test finder query
	 * creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @param username
	 * @return the users with the given email address and lastname or the given firstname
	 */
	List<User> findByEmailAddressAndLastnameOrFirstname(String emailAddress, String lastname, String username);

	/**
	 * Retrieves a user by its username using the query annotated to the method.
	 * 
	 * @param emailAddress
	 * @return
	 */
	@Query(""select u from User u where u.emailAddress = ?1"")
	@Transactional(readOnly = true)
	User findByAnnotatedQuery(String emailAddress);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * 
	 * @param pageable
	 * @param lastname
	 * @return
	 */
	Page<User> findByLastname(Pageable pageable, String lastname);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * Just returns the queried {@link Page}'s contents.
	 * 
	 * @param firstname
	 * @param pageable
	 * @return
	 */
	List<User> findByFirstname(String firstname, Pageable pageable);

	Page<User> findByFirstnameIn(Pageable pageable, String... firstnames);

	List<User> findByFirstnameNotIn(Collection<String> firstnames);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like ?1%"")
	List<User> findByFirstnameLike(String firstname);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like :firstname%"")
	List<User> findByFirstnameLikeNamed(@Param(""firstname"") String firstname);

	/**
	 * Manipulating query to set all {@link User}'s names to the given one.
	 * 
	 * @param lastname
	 */
	@Modifying
	@Query(""update User u set u.lastname = ?1"")
	void renameAllUsersTo(String lastname);

	@Query(""select count(u) from User u where u.firstname = ?1"")
	Long countWithFirstname(String firstname);

	/**
	 * Method where parameters will be applied by name. Note that the order of the parameters is then not crucial anymore.
	 * 
	 * @param foo
	 * @param bar
	 * @return
	 */
	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstname(@Param(""firstname"") String foo, @Param(""lastname"") String bar);

	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstnameUnannotated(String firstname, String lastname);

	/**
	 * Method to check query creation and named parameter usage go well hand in hand.
	 * 
	 * @param lastname
	 * @param firstname
	 * @return
	 */
	List<User> findByFirstnameOrLastname(@Param(""lastname"") String lastname, @Param(""firstname"") String firstname);

	List<User> findByLastnameLikeOrderByFirstnameDesc(String lastname);

	List<User> findByLastnameNotLike(String lastname);

	List<User> findByLastnameNot(String lastname);

	List<User> findByManagerLastname(String name);

	List<User> findByColleaguesLastname(String lastname);

	List<User> findByLastnameNotNull();

	List<User> findByLastnameNull();

	List<User> findByEmailAddressLike(String email, Sort sort);

	List<SpecialUser> findSpecialUsersByLastname(String lastname);

	List<User> findBySpringDataNamedQuery(String lastname);

	List<User> findByLastnameIgnoringCase(String lastname);

	Page<User> findByLastnameIgnoringCase(Pageable pageable, String lastname);

	List<User> findByLastnameIgnoringCaseLike(String lastname);

	List<User> findByLastnameAndFirstnameAllIgnoringCase(String lastname, String firstname);

	List<User> findByAgeGreaterThanEqual(int age);

	List<User> findByAgeLessThanEqual(int age);

	@Query(""select u.lastname from User u group by u.lastname"")
	Page<String> findByLastnameGrouped(Pageable pageable);

	// DATAJPA-117
	@Query(value = ""SELECT * FROM SD_User WHERE lastname = ?1"", nativeQuery = true)
	List<User> findNativeByLastname(String lastname);

	// DATAJPA-132
	List<User> findByActiveTrue();

	// DATAJPA-132
	List<User> findByActiveFalse();

	@Query(""select u.colleagues from User u where u = ?1"")
	List<User> findColleaguesFor(User user);

	// DATAJPA-188
	List<User> findByCreatedAtBefore(Date date);

	// DATAJPA-188
	List<User> findByCreatedAtAfter(Date date);

	// DATAJPA-180
	List<User> findByFirstnameStartingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameEndingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameContaining(String firstname);

	@Query(value = ""SELECT 1 FROM SD_User"", nativeQuery = true)
	List<Integer> findOnesByNativeQuery();

	// DATAJPA-231
	long countByLastname(String lastname);

	// DATAJPA-231
	int countUsersByFirstname(String firstname);

	// DATAJPA-920
	boolean existsByLastname(String lastname);

	// DATAJPA-391
	@Query(""select u.firstname from User u where u.lastname = ?1"")
	List<String> findFirstnamesByLastname(String lastname);

	// DATAJPA-415
	Collection<User> findByIdIn(@Param(""ids"") Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in ?1"")
	Collection<User> findByIdsCustomWithPositionalVarArgs(Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in :ids"")
	Collection<User> findByIdsCustomWithNamedVarArgs(@Param(""ids"") Integer... ids);

	// DATAJPA-415
	@Modifying
	@Query(""update #{#entityName} u set u.active = :activeState where u.id in :ids"")
	void updateUserActiveState(@Param(""activeState"") boolean activeState, @Param(""ids"") Integer... ids);

	// DATAJPA-405
	List<User> findAllByOrderByLastnameAsc();

	// DATAJPA-454
	List<User> findByBinaryData(byte[] data);

	// DATAJPA-486
	Slice<User> findSliceByLastname(String lastname, Pageable pageable);

	// DATAJPA-496
	List<User> findByAttributesIn(Set<String> attributes);

	// DATAJPA-460
	Long removeByLastname(String lastname);

	// DATAJPA-460
	List<User> deleteByLastname(String lastname);

	/**
	 * @see <a href=""https://issues.apache.org/jira/browse/OPENJPA-2484"">OPENJPA-2484</a>
	 */
	// DATAJPA-505
	// @Query(value = ""select u.binaryData from User u where u.id = :id"")
	// byte[] findBinaryDataByIdJpaQl(@Param(""id"") Integer id);

	/**
	 * Explicitly mapped to a procedure with name ""plus1inout"" in database.
	 */
	@Procedure(""plus1inout"") // DATAJPA-455
	Integer explicitlyNamedPlus1inout(Integer arg);

	/**
	 * Implicitly mapped to a procedure with name ""plus1inout"" in database via alias.
	 */
	@Procedure(procedureName = ""plus1inout"") // DATAJPA-455
	Integer plus1inout(Integer arg);

	/**
	 * Explicitly mapped to named stored procedure ""User.plus1IO"" in {@link EntityManager}.
	 */
	@Procedure(name = ""User.plus1IO"") // DATAJPA-455
	Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param(""arg"") Integer arg);

	/**
	 * Implicitly mapped to named stored procedure ""User.plus1"" in {@link EntityManager}.
	 */
	@Procedure // DATAJPA-455
	Integer plus1(@Param(""arg"") Integer arg);

	// DATAJPA-456
	@Query(value = ""select u from User u where u.firstname like ?1%"", countProjection = ""u.firstname"")
	Page<User> findAllByFirstnameLike(String firstname, Pageable page);

	// DATAJPA-456
	@Query(name = ""User.findBySpringDataNamedQuery"", countProjection = ""u.firstname"")
	Page<User> findByNamedQueryAndCountProjection(String firstname, Pageable page);

	// DATAJPA-551
	User findFirstByOrderByAgeDesc();

	// DATAJPA-551
	User findFirst1ByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeAsc();

	// DATAJPA-551
	User findTop1ByOrderByAgeAsc();

	// DATAJPA-551
	List<User> findTop2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2UsersBy(Sort sort);

	// DATAJPA-551
	List<User> findTop2UsersBy(Sort sort);

	// DATAJPA-551
	Page<User> findFirst3UsersBy(Pageable page);

	// DATAJPA-551
	Page<User> findFirst2UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop3UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop2UsersBy(Pageable page);

	// DATAJPA-506
	@Query(value = ""select u.binaryData from SD_User u where u.id = ?1"", nativeQuery = true)
	byte[] findBinaryDataByIdNative(Integer id);

	// DATAJPA-506
	@Query(""select u from User u where u.emailAddress = ?1"")
	Optional<User> findOptionalByEmailAddress(String emailAddress);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]} and u.firstname = ?1 and u.lastname like %?#{[1]}% and u.lastname like %?2%"")
	List<User> findByFirstnameAndLastnameWithSpelExpression(String firstname, String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%"")
	List<User> findByLastnameWithSpelExpression(@Param(""lastname"") String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithQuestionmark();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithColon();

	// DATAJPA-564
	@Query(""select u from User u where u.age = ?#{[0]}"")
	List<User> findUsersByAgeForSpELExpressionByIndexedParameter(int age);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :firstname and u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpression(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findCurrentUserWithCustomQuery();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findByFirstnameAndCurrentUserWithCustomQuery(String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterVariableOnly(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnly(String firstname);

	// DATAJPA-564
	@Query(
			value = ""select * from ("" +
					""select u.*, rownum() as RN from ("" +
					""select * from SD_User ORDER BY ucase(firstname)"" +
					"") u"" +
					"") where RN between ?#{ #pageable.offset +1 } and ?#{#pageable.offset + #pageable.pageSize}"",
			countQuery = ""select count(u.id) from SD_User u"", nativeQuery = true)
	Page<User> findUsersInNativeQueryWithPagination(Pageable pageable);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#user.firstname} and u.lastname =:lastname"")
	List<User> findUsersByUserFirstnameAsSpELExpressionAndLastnameAsString(@Param(""user"") User user,
			@Param(""lastname"") String lastname);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:firstname and u.lastname =:#{#user.lastname}"")
	List<User> findUsersByFirstnameAsStringAndUserLastnameAsSpELExpression(@Param(""firstname"") String firstname,
			@Param(""user"") User user);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#user.firstname} and u.lastname =:#{#lastname}"")
	List<User> findUsersByUserFirstnameAsSpELExpressionAndLastnameAsFakeSpELExpression(@Param(""user"") User user,
			@Param(""lastname"") String lastname);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#firstname} and u.lastname =:#{#user.lastname}"")
	List<User> findUsersByFirstnameAsFakeSpELExpressionAndUserLastnameAsSpELExpression(
			@Param(""firstname"") String firstname, @Param(""user"") User user);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:firstname"")
	List<User> findUsersByFirstnamePaginated(Pageable page, @Param(""firstname"") String firstname);

	// DATAJPA-629
	@Query(""select u from #{#entityName} u where u.firstname = ?#{[0]} and u.lastname = ?#{[1]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnlyWithEntityExpression(String firstname,
			String lastname);

	// DATAJPA-606
	List<User> findByAgeIn(Collection<Integer> ages);

	// DATAJPA-606
	List<User> queryByAgeIn(Integer[] ages);

	// DATAJPA-606
	List<User> queryByAgeInOrFirstname(Integer[] ages, String firstname);

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> findAllByCustomQueryAndStream();

	// DATAJPA-677
	Stream<User> readAllByFirstnameNotNull();

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> streamAllPaged(Pageable pageable);

	// DATAJPA-830
	List<User> findByLastnameNotContaining(String part);

	// DATAJPA-829
	List<User> findByRolesContaining(Role role);

	// DATAJPA-829
	List<User> findByRolesNotContaining(Role role);

	// DATAJPA-858
	List<User> findByRolesNameContaining(String name);

	// DATAJPA-1179
	@Query(""select u from User u where u.firstname = :#{#firstname} and u.firstname = :#{#firstname}"")
	List<User> findUsersByDuplicateSpel(@Param(""firstname"") String firstname);

	List<RolesAndFirstname> findRolesAndFirstnameBy();

	// DATAJPA-1172
	@Query(""select u from User u where u.age = :age"")
	List<User> findByStringAge(@Param(""age"") String age);

	// DATAJPA-1185
	<T> Stream<T> findAsStreamByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1185
	<T> List<T> findAsListByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-980
	@Query(value = ""SELECT firstname, lastname FROM SD_User WHERE id = ?1"", nativeQuery = true)
	NameOnly findByNativeQuery(Integer id);

	// DATAJPA-1248
	@Query(value = ""SELECT emailaddress FROM SD_User WHERE id = ?1"", nativeQuery = true)
	EmailOnly findEmailOnlyByNativeQuery(Integer id);

	// DATAJPA-1235
	@Query(""SELECT u FROM User u where u.firstname >= ?1 and u.lastname = '000:1'"")
	List<User> queryWithIndexedParameterAndColonFollowedByIntegerInString(String firstname);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u ORDER BY CASE WHEN (u.firstname  >= :name) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameSingleParam(@Param(""name"") String name, Pageable page);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u WHERE :other = 'x' ORDER BY CASE WHEN (u.firstname  >= :name) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameMultipleParams(@Param(""name"") String name, @Param(""other"") String other, Pageable page);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u WHERE ?2 = 'x' ORDER BY CASE WHEN (u.firstname  >= ?1) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameMultipleParamsIndexed(String name, String other, Pageable page);

	// DATAJPA-928
	Page<User> findByNativeNamedQueryWithPageable(Pageable pageable);

	// DATAJPA-928
	@Query(value = ""SELECT firstname FROM SD_User ORDER BY UCASE(firstname)"", countQuery = ""SELECT count(*) FROM SD_User"",
			nativeQuery = true)
	Page<String> findByNativeQueryWithPageable(@Param(""pageable"") Pageable pageable);

	// DATAJPA-1273
	List<NameOnly> findByNamedQueryWithAliasInInvertedOrder();

	// DATAJPA-1301
	@Query(""select firstname as firstname, lastname as lastname from User u where u.firstname = 'Oliver'"")
	Map<String, Object> findMapWithNullValues();

	// DATAJPA-1307
	@Query(value = ""select * from SD_User u where u.emailAddress = ?"", nativeQuery = true)
	User findByEmailNativeAddressJdbcStyleParameter(String emailAddress);

	// DATAJPA-1334
	List<NameOnlyDto> findByNamedQueryWithConstructorExpression();

	// DATAJPA-1519
	@Query(""select u from User u where u.firstname like %?#{escape([0])}% escape '\\'"")
	List<User> findContainingEscaped(String namePart);

	interface RolesAndFirstname {

		String getFirstname();

		Set<Role> getRoles();
	}

	interface NameOnly {

		String getFirstname();

		String getLastname();
	}

	interface EmailOnly {
		String getEmailAddress();
	}
}
",0
CVE-2019-3797,src/test/java/org/springframework/data/jpa/repository/sample/UserRepository.java,"/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.sample;

import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;

import javax.persistence.EntityManager;
import javax.persistence.QueryHint;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.sample.Role;
import org.springframework.data.jpa.domain.sample.SpecialUser;
import org.springframework.data.jpa.domain.sample.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.QueryHints;
import org.springframework.data.jpa.repository.query.Procedure;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import com.google.common.base.Optional;

/**
 * Repository interface for {@code User}s.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 * @author Kevin Peters
 */
public interface UserRepository
		extends JpaRepository<User, Integer>, JpaSpecificationExecutor<User>, UserRepositoryCustom {

	/**
	 * Retrieve users by their lastname. The finder {@literal User.findByLastname} is declared in
	 * {@literal META-INF/orm.xml} .
	 * 
	 * @param lastname
	 * @return all users with the given lastname
	 */
	@QueryHints({ @QueryHint(name = ""foo"", value = ""bar"") })
	List<User> findByLastname(String lastname);

	/**
	 * Redeclaration of {@link CrudRepository#findById(java.io.Serializable)} to change transaction configuration.
	 */
	@Transactional
	java.util.Optional<User> findById(Integer primaryKey);

	/**
	 * Redeclaration of {@link CrudRepository#deleteById(java.io.Serializable)}. to make sure the transaction
	 * configuration of the original method is considered if the redeclaration does not carry a {@link Transactional}
	 * annotation.
	 */
	void deleteById(Integer id); // DATACMNS-649

	/**
	 * Retrieve users by their email address. The finder {@literal User.findByEmailAddress} is declared as annotation at
	 * {@code User}.
	 * 
	 * @param emailAddress
	 * @return the user with the given email address
	 */
	User findByEmailAddress(String emailAddress);

	@Query(""select u from User u left outer join u.manager as manager"")
	Page<User> findAllPaged(Pageable pageable);

	/**
	 * Retrieves users by the given email and lastname. Acts as a dummy method declaration to test finder query creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @return the user with the given email address and lastname
	 */
	User findByEmailAddressAndLastname(String emailAddress, String lastname);

	/**
	 * Retrieves users by email address and lastname or firstname. Acts as a dummy method declaration to test finder query
	 * creation.
	 * 
	 * @param emailAddress
	 * @param lastname
	 * @param username
	 * @return the users with the given email address and lastname or the given firstname
	 */
	List<User> findByEmailAddressAndLastnameOrFirstname(String emailAddress, String lastname, String username);

	/**
	 * Retrieves a user by its username using the query annotated to the method.
	 * 
	 * @param emailAddress
	 * @return
	 */
	@Query(""select u from User u where u.emailAddress = ?1"")
	@Transactional(readOnly = true)
	User findByAnnotatedQuery(String emailAddress);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * 
	 * @param pageable
	 * @param lastname
	 * @return
	 */
	Page<User> findByLastname(Pageable pageable, String lastname);

	/**
	 * Method to directly create query from and adding a {@link Pageable} parameter to be regarded on query execution.
	 * Just returns the queried {@link Page}'s contents.
	 * 
	 * @param firstname
	 * @param pageable
	 * @return
	 */
	List<User> findByFirstname(String firstname, Pageable pageable);

	Page<User> findByFirstnameIn(Pageable pageable, String... firstnames);

	List<User> findByFirstnameNotIn(Collection<String> firstnames);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like ?1%"")
	List<User> findByFirstnameLike(String firstname);

	// DATAJPA-292
	@Query(""select u from User u where u.firstname like :firstname%"")
	List<User> findByFirstnameLikeNamed(@Param(""firstname"") String firstname);

	/**
	 * Manipulating query to set all {@link User}'s names to the given one.
	 * 
	 * @param lastname
	 */
	@Modifying
	@Query(""update User u set u.lastname = ?1"")
	void renameAllUsersTo(String lastname);

	@Query(""select count(u) from User u where u.firstname = ?1"")
	Long countWithFirstname(String firstname);

	/**
	 * Method where parameters will be applied by name. Note that the order of the parameters is then not crucial anymore.
	 * 
	 * @param foo
	 * @param bar
	 * @return
	 */
	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstname(@Param(""firstname"") String foo, @Param(""lastname"") String bar);

	@Query(""select u from User u where u.lastname = :lastname or u.firstname = :firstname"")
	List<User> findByLastnameOrFirstnameUnannotated(String firstname, String lastname);

	/**
	 * Method to check query creation and named parameter usage go well hand in hand.
	 * 
	 * @param lastname
	 * @param firstname
	 * @return
	 */
	List<User> findByFirstnameOrLastname(@Param(""lastname"") String lastname, @Param(""firstname"") String firstname);

	List<User> findByLastnameLikeOrderByFirstnameDesc(String lastname);

	List<User> findByLastnameNotLike(String lastname);

	List<User> findByLastnameNot(String lastname);

	List<User> findByManagerLastname(String name);

	List<User> findByColleaguesLastname(String lastname);

	List<User> findByLastnameNotNull();

	List<User> findByLastnameNull();

	List<User> findByEmailAddressLike(String email, Sort sort);

	List<SpecialUser> findSpecialUsersByLastname(String lastname);

	List<User> findBySpringDataNamedQuery(String lastname);

	List<User> findByLastnameIgnoringCase(String lastname);

	Page<User> findByLastnameIgnoringCase(Pageable pageable, String lastname);

	List<User> findByLastnameIgnoringCaseLike(String lastname);

	List<User> findByLastnameAndFirstnameAllIgnoringCase(String lastname, String firstname);

	List<User> findByAgeGreaterThanEqual(int age);

	List<User> findByAgeLessThanEqual(int age);

	@Query(""select u.lastname from User u group by u.lastname"")
	Page<String> findByLastnameGrouped(Pageable pageable);

	// DATAJPA-117
	@Query(value = ""SELECT * FROM SD_User WHERE lastname = ?1"", nativeQuery = true)
	List<User> findNativeByLastname(String lastname);

	// DATAJPA-132
	List<User> findByActiveTrue();

	// DATAJPA-132
	List<User> findByActiveFalse();

	@Query(""select u.colleagues from User u where u = ?1"")
	List<User> findColleaguesFor(User user);

	// DATAJPA-188
	List<User> findByCreatedAtBefore(Date date);

	// DATAJPA-188
	List<User> findByCreatedAtAfter(Date date);

	// DATAJPA-180
	List<User> findByFirstnameStartingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameEndingWith(String firstname);

	// DATAJPA-180
	List<User> findByFirstnameContaining(String firstname);

	@Query(value = ""SELECT 1 FROM SD_User"", nativeQuery = true)
	List<Integer> findOnesByNativeQuery();

	// DATAJPA-231
	long countByLastname(String lastname);

	// DATAJPA-231
	int countUsersByFirstname(String firstname);

	// DATAJPA-920
	boolean existsByLastname(String lastname);

	// DATAJPA-391
	@Query(""select u.firstname from User u where u.lastname = ?1"")
	List<String> findFirstnamesByLastname(String lastname);

	// DATAJPA-415
	Collection<User> findByIdIn(@Param(""ids"") Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in ?1"")
	Collection<User> findByIdsCustomWithPositionalVarArgs(Integer... ids);

	// DATAJPA-461
	@Query(""select u from User u where u.id in :ids"")
	Collection<User> findByIdsCustomWithNamedVarArgs(@Param(""ids"") Integer... ids);

	// DATAJPA-415
	@Modifying
	@Query(""update #{#entityName} u set u.active = :activeState where u.id in :ids"")
	void updateUserActiveState(@Param(""activeState"") boolean activeState, @Param(""ids"") Integer... ids);

	// DATAJPA-405
	List<User> findAllByOrderByLastnameAsc();

	// DATAJPA-454
	List<User> findByBinaryData(byte[] data);

	// DATAJPA-486
	Slice<User> findSliceByLastname(String lastname, Pageable pageable);

	// DATAJPA-496
	List<User> findByAttributesIn(Set<String> attributes);

	// DATAJPA-460
	Long removeByLastname(String lastname);

	// DATAJPA-460
	List<User> deleteByLastname(String lastname);

	/**
	 * @see <a href=""https://issues.apache.org/jira/browse/OPENJPA-2484"">OPENJPA-2484</a>
	 */
	// DATAJPA-505
	// @Query(value = ""select u.binaryData from User u where u.id = :id"")
	// byte[] findBinaryDataByIdJpaQl(@Param(""id"") Integer id);

	/**
	 * Explicitly mapped to a procedure with name ""plus1inout"" in database.
	 */
	@Procedure(""plus1inout"") // DATAJPA-455
	Integer explicitlyNamedPlus1inout(Integer arg);

	/**
	 * Implicitly mapped to a procedure with name ""plus1inout"" in database via alias.
	 */
	@Procedure(procedureName = ""plus1inout"") // DATAJPA-455
	Integer plus1inout(Integer arg);

	/**
	 * Explicitly mapped to named stored procedure ""User.plus1IO"" in {@link EntityManager}.
	 */
	@Procedure(name = ""User.plus1IO"") // DATAJPA-455
	Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param(""arg"") Integer arg);

	/**
	 * Implicitly mapped to named stored procedure ""User.plus1"" in {@link EntityManager}.
	 */
	@Procedure // DATAJPA-455
	Integer plus1(@Param(""arg"") Integer arg);

	// DATAJPA-456
	@Query(value = ""select u from User u where u.firstname like ?1%"", countProjection = ""u.firstname"")
	Page<User> findAllByFirstnameLike(String firstname, Pageable page);

	// DATAJPA-456
	@Query(name = ""User.findBySpringDataNamedQuery"", countProjection = ""u.firstname"")
	Page<User> findByNamedQueryAndCountProjection(String firstname, Pageable page);

	// DATAJPA-551
	User findFirstByOrderByAgeDesc();

	// DATAJPA-551
	User findFirst1ByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeDesc();

	// DATAJPA-551
	User findTopByOrderByAgeAsc();

	// DATAJPA-551
	User findTop1ByOrderByAgeAsc();

	// DATAJPA-551
	List<User> findTop2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2ByOrderByAgeDesc();

	// DATAJPA-551
	List<User> findFirst2UsersBy(Sort sort);

	// DATAJPA-551
	List<User> findTop2UsersBy(Sort sort);

	// DATAJPA-551
	Page<User> findFirst3UsersBy(Pageable page);

	// DATAJPA-551
	Page<User> findFirst2UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop3UsersBy(Pageable page);

	// DATAJPA-551
	Slice<User> findTop2UsersBy(Pageable page);

	// DATAJPA-506
	@Query(value = ""select u.binaryData from SD_User u where u.id = ?1"", nativeQuery = true)
	byte[] findBinaryDataByIdNative(Integer id);

	// DATAJPA-506
	@Query(""select u from User u where u.emailAddress = ?1"")
	Optional<User> findOptionalByEmailAddress(String emailAddress);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]} and u.firstname = ?1 and u.lastname like %?#{[1]}% and u.lastname like %?2%"")
	List<User> findByFirstnameAndLastnameWithSpelExpression(String firstname, String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%"")
	List<User> findByLastnameWithSpelExpression(@Param(""lastname"") String lastname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithQuestionmark();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{'Oliver'}"")
	List<User> findOliverBySpELExpressionWithoutArgumentsWithColon();

	// DATAJPA-564
	@Query(""select u from User u where u.age = ?#{[0]}"")
	List<User> findUsersByAgeForSpELExpressionByIndexedParameter(int age);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :firstname and u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpression(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findCurrentUserWithCustomQuery();

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}"")
	List<User> findByFirstnameAndCurrentUserWithCustomQuery(String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = :#{#firstname}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterVariableOnly(@Param(""firstname"") String firstname);

	// DATAJPA-564
	@Query(""select u from User u where u.firstname = ?#{[0]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnly(String firstname);

	// DATAJPA-564
	@Query(
			value = ""select * from ("" +
					""select u.*, rownum() as RN from ("" +
					""select * from SD_User ORDER BY ucase(firstname)"" +
					"") u"" +
					"") where RN between ?#{ #pageable.offset +1 } and ?#{#pageable.offset + #pageable.pageSize}"",
			countQuery = ""select count(u.id) from SD_User u"", nativeQuery = true)
	Page<User> findUsersInNativeQueryWithPagination(Pageable pageable);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#user.firstname} and u.lastname =:lastname"")
	List<User> findUsersByUserFirstnameAsSpELExpressionAndLastnameAsString(@Param(""user"") User user,
			@Param(""lastname"") String lastname);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:firstname and u.lastname =:#{#user.lastname}"")
	List<User> findUsersByFirstnameAsStringAndUserLastnameAsSpELExpression(@Param(""firstname"") String firstname,
			@Param(""user"") User user);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#user.firstname} and u.lastname =:#{#lastname}"")
	List<User> findUsersByUserFirstnameAsSpELExpressionAndLastnameAsFakeSpELExpression(@Param(""user"") User user,
			@Param(""lastname"") String lastname);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:#{#firstname} and u.lastname =:#{#user.lastname}"")
	List<User> findUsersByFirstnameAsFakeSpELExpressionAndUserLastnameAsSpELExpression(
			@Param(""firstname"") String firstname, @Param(""user"") User user);

	// DATAJPA-1140
	@Query(""select u from User u where u.firstname =:firstname"")
	List<User> findUsersByFirstnamePaginated(Pageable page, @Param(""firstname"") String firstname);

	// DATAJPA-629
	@Query(""select u from #{#entityName} u where u.firstname = ?#{[0]} and u.lastname = ?#{[1]}"")
	List<User> findUsersByFirstnameForSpELExpressionWithParameterIndexOnlyWithEntityExpression(String firstname,
			String lastname);

	// DATAJPA-606
	List<User> findByAgeIn(Collection<Integer> ages);

	// DATAJPA-606
	List<User> queryByAgeIn(Integer[] ages);

	// DATAJPA-606
	List<User> queryByAgeInOrFirstname(Integer[] ages, String firstname);

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> findAllByCustomQueryAndStream();

	// DATAJPA-677
	Stream<User> readAllByFirstnameNotNull();

	// DATAJPA-677
	@Query(""select u from User u"")
	Stream<User> streamAllPaged(Pageable pageable);

	// DATAJPA-830
	List<User> findByLastnameNotContaining(String part);

	// DATAJPA-829
	List<User> findByRolesContaining(Role role);

	// DATAJPA-829
	List<User> findByRolesNotContaining(Role role);

	// DATAJPA-858
	List<User> findByRolesNameContaining(String name);

	// DATAJPA-1179
	@Query(""select u from User u where u.firstname = :#{#firstname} and u.firstname = :#{#firstname}"")
	List<User> findUsersByDuplicateSpel(@Param(""firstname"") String firstname);

	List<RolesAndFirstname> findRolesAndFirstnameBy();

	// DATAJPA-1172
	@Query(""select u from User u where u.age = :age"")
	List<User> findByStringAge(@Param(""age"") String age);

	// DATAJPA-1185
	<T> Stream<T> findAsStreamByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-1185
	<T> List<T> findAsListByFirstnameLike(String name, Class<T> projectionType);

	// DATAJPA-980
	@Query(value = ""SELECT firstname, lastname FROM SD_User WHERE id = ?1"", nativeQuery = true)
	NameOnly findByNativeQuery(Integer id);

	// DATAJPA-1248
	@Query(value = ""SELECT emailaddress FROM SD_User WHERE id = ?1"", nativeQuery = true)
	EmailOnly findEmailOnlyByNativeQuery(Integer id);

	// DATAJPA-1235
	@Query(""SELECT u FROM User u where u.firstname >= ?1 and u.lastname = '000:1'"")
	List<User> queryWithIndexedParameterAndColonFollowedByIntegerInString(String firstname);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u ORDER BY CASE WHEN (u.firstname  >= :name) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameSingleParam(@Param(""name"") String name, Pageable page);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u WHERE :other = 'x' ORDER BY CASE WHEN (u.firstname  >= :name) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameMultipleParams(@Param(""name"") String name, @Param(""other"") String other, Pageable page);

	// DATAJPA-1233
	@Query(value = ""SELECT u FROM User u WHERE ?2 = 'x' ORDER BY CASE WHEN (u.firstname  >= ?1) THEN 0 ELSE 1 END, u.firstname"")
	Page<User> findAllOrderedBySpecialNameMultipleParamsIndexed(String name, String other, Pageable page);

	// DATAJPA-928
	Page<User> findByNativeNamedQueryWithPageable(Pageable pageable);

	// DATAJPA-928
	@Query(value = ""SELECT firstname FROM SD_User ORDER BY UCASE(firstname)"", countQuery = ""SELECT count(*) FROM SD_User"",
			nativeQuery = true)
	Page<String> findByNativeQueryWithPageable(@Param(""pageable"") Pageable pageable);

	// DATAJPA-1273
	List<NameOnly> findByNamedQueryWithAliasInInvertedOrder();

	// DATAJPA-1301
	@Query(""select firstname as firstname, lastname as lastname from User u where u.firstname = 'Oliver'"")
	Map<String, Object> findMapWithNullValues();

	// DATAJPA-1307
	@Query(value = ""select * from SD_User u where u.emailAddress = ?"", nativeQuery = true)
	User findByEmailNativeAddressJdbcStyleParameter(String emailAddress);

	// DATAJPA-1334
	List<NameOnlyDto> findByNamedQueryWithConstructorExpression();

	// DATAJPA-1519
	@Query(""select u from User u where u.firstname like %?#{escape([0])}% escape ?#{escapeCharacter()}"")
	List<User> findContainingEscaped(String namePart);

	interface RolesAndFirstname {

		String getFirstname();

		Set<Role> getRoles();
	}

	interface NameOnly {

		String getFirstname();

		String getLastname();
	}

	interface EmailOnly {
		String getEmailAddress();
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/config/JpaRepositoryConfigExtension.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.config;

import static org.springframework.data.jpa.repository.config.BeanDefinitionNames.*;

import lombok.experimental.UtilityClass;

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Optional;
import java.util.Set;

import javax.persistence.Entity;
import javax.persistence.MappedSuperclass;
import javax.persistence.PersistenceContext;
import javax.persistence.PersistenceUnit;

import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.core.annotation.AnnotationAttributes;
import org.springframework.core.io.ResourceLoader;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.support.DefaultJpaContext;
import org.springframework.data.jpa.repository.support.EntityManagerBeanDefinitionRegistrarPostProcessor;
import org.springframework.data.jpa.repository.support.JpaEvaluationContextExtension;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
import org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource;
import org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport;
import org.springframework.data.repository.config.RepositoryConfigurationSource;
import org.springframework.data.repository.config.XmlRepositoryConfigurationSource;
import org.springframework.lang.Nullable;
import org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor;
import org.springframework.util.ClassUtils;
import org.springframework.util.StringUtils;

/**
 * JPA specific configuration extension parsing custom attributes from the XML namespace and
 * {@link EnableJpaRepositories} annotation. Also, it registers bean definitions for a
 * {@link PersistenceAnnotationBeanPostProcessor} (to trigger injection into {@link PersistenceContext}/
 * {@link PersistenceUnit} annotated properties and methods) as well as
 * {@link PersistenceExceptionTranslationPostProcessor} to enable exception translation of persistence specific
 * exceptions into Spring's {@link DataAccessException} hierarchy.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Gil Markham
 * @author Thomas Darimont
 * @author Christoph Strobl
 * @author Mark Paluch
 */
public class JpaRepositoryConfigExtension extends RepositoryConfigurationExtensionSupport {

	private static final Class<?> PAB_POST_PROCESSOR = PersistenceAnnotationBeanPostProcessor.class;
	private static final String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = ""transactionManager"";
	private static final String ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE = ""enableDefaultTransactions"";
	private static final String JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME = ""org.springframework.data.jpa.util.JpaMetamodelCacheCleanup"";
	private static final String ESCAPE_CHARACTER_PROPERTY = ""escapeCharacter"";

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getModuleName()
	 */
	@Override
	public String getModuleName() {
		return ""JPA"";
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtension#getRepositoryFactoryBeanClassName()
	 */
	@Override
	public String getRepositoryFactoryBeanClassName() {
		return JpaRepositoryFactoryBean.class.getName();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config14.RepositoryConfigurationExtensionSupport#getModulePrefix()
	 */
	@Override
	protected String getModulePrefix() {
		return getModuleName().toLowerCase(Locale.US);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingAnnotations()
	 */
	@Override
	protected Collection<Class<? extends Annotation>> getIdentifyingAnnotations() {
		return Arrays.asList(Entity.class, MappedSuperclass.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingTypes()
	 */
	@Override
	protected Collection<Class<?>> getIdentifyingTypes() {
		return Collections.<Class<?>> singleton(JpaRepository.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, RepositoryConfigurationSource source) {

		Optional<String> transactionManagerRef = source.getAttribute(""transactionManagerRef"");
		builder.addPropertyValue(""transactionManager"", transactionManagerRef.orElse(DEFAULT_TRANSACTION_MANAGER_BEAN_NAME));
		builder.addPropertyValue(""entityManager"", getEntityManagerBeanDefinitionFor(source, source.getSource()));
		builder.addPropertyValue(ESCAPE_CHARACTER_PROPERTY, getEscapeCharacter(source).orElse('\\'));
		builder.addPropertyReference(""mappingContext"", JPA_MAPPING_CONTEXT_BEAN_NAME);
	}

	/**
	 * XML configurations do not support {@link Character} values. This method catches the exception thrown and returns an
	 * {@link Optional#empty()} instead.
	 */
	private static Optional<Character> getEscapeCharacter(RepositoryConfigurationSource source) {

		try {

			return AnnotationRepositoryConfigurationSource.class.isInstance(source) //
					? Optional.ofNullable((Character) AnnotationRepositoryConfigurationSource.class.cast(source).getAttributes()
							.get(ESCAPE_CHARACTER_PROPERTY)) //
					: source.getAttribute(ESCAPE_CHARACTER_PROPERTY).map(it -> it.toCharArray()[0]);

		} catch (IllegalArgumentException ___) {
			return Optional.empty();
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, AnnotationRepositoryConfigurationSource config) {

		AnnotationAttributes attributes = config.getAttributes();

		builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE,
				attributes.getBoolean(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.XmlRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, XmlRepositoryConfigurationSource config) {

		Optional<String> enableDefaultTransactions = config.getAttribute(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE);

		if (enableDefaultTransactions.isPresent() && StringUtils.hasText(enableDefaultTransactions.get())) {
			builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE, enableDefaultTransactions.get());
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#registerBeansForRoot(org.springframework.beans.factory.support.BeanDefinitionRegistry, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void registerBeansForRoot(BeanDefinitionRegistry registry, RepositoryConfigurationSource config) {

		super.registerBeansForRoot(registry, config);

		Object source = config.getSource();

		registerIfNotAlreadyRegistered(new RootBeanDefinition(EntityManagerBeanDefinitionRegistrarPostProcessor.class),
				registry, EM_BEAN_DEFINITION_REGISTRAR_POST_PROCESSOR_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(JpaMetamodelMappingContextFactoryBean.class), registry,
				JPA_MAPPING_CONTEXT_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(PAB_POST_PROCESSOR), registry,
				AnnotationConfigUtils.PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME, source);

		// Register bean definition for DefaultJpaContext

		RootBeanDefinition contextDefinition = new RootBeanDefinition(DefaultJpaContext.class);
		contextDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);

		registerIfNotAlreadyRegistered(contextDefinition, registry, JPA_CONTEXT_BEAN_NAME, source);
		registerIfNotAlreadyRegistered(new RootBeanDefinition(JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME), registry,
				JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME, source);

		// EvaluationContextExtension for JPA specific SpEL functions

		registerIfNotAlreadyRegistered(() -> {

			Object value = getEscapeCharacter(config).orElse('\\');

			BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(JpaEvaluationContextExtension.class);
			builder.addConstructorArgValue(value);

			return builder.getBeanDefinition();

		}, registry, JpaEvaluationContextExtension.class.getName(), source);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getConfigurationInspectionClassLoader(org.springframework.core.io.ResourceLoader)
	 */
	@Override
	protected ClassLoader getConfigurationInspectionClassLoader(ResourceLoader loader) {

		ClassLoader classLoader = loader.getClassLoader();

		return classLoader != null && LazyJvmAgent.isActive(loader.getClassLoader())
				? new InspectionClassLoader(loader.getClassLoader())
				: loader.getClassLoader();
	}

	/**
	 * Creates an anonymous factory to extract the actual {@link javax.persistence.EntityManager} from the
	 * {@link javax.persistence.EntityManagerFactory} bean name reference.
	 *
	 * @param config
	 * @param source
	 * @return
	 */
	private static AbstractBeanDefinition getEntityManagerBeanDefinitionFor(RepositoryConfigurationSource config,
			@Nullable Object source) {

		BeanDefinitionBuilder builder = BeanDefinitionBuilder
				.rootBeanDefinition(""org.springframework.orm.jpa.SharedEntityManagerCreator"");
		builder.setFactoryMethod(""createSharedEntityManager"");
		builder.addConstructorArgReference(getEntityManagerBeanRef(config));

		AbstractBeanDefinition bean = builder.getRawBeanDefinition();
		bean.setSource(source);

		return bean;
	}

	private static String getEntityManagerBeanRef(RepositoryConfigurationSource config) {

		Optional<String> entityManagerFactoryRef = config.getAttribute(""entityManagerFactoryRef"");
		return entityManagerFactoryRef.orElse(""entityManagerFactory"");
	}

	/**
	 * Utility to determine if a lazy Java agent is being used that might transform classes at a later time.
	 *
	 * @author Mark Paluch
	 * @since 2.1
	 */
	@UtilityClass
	static class LazyJvmAgent {

		private static final Set<String> AGENT_CLASSES;

		static {

			Set<String> agentClasses = new LinkedHashSet<>();

			agentClasses.add(""org.springframework.instrument.InstrumentationSavingAgent"");
			agentClasses.add(""org.eclipse.persistence.internal.jpa.deployment.JavaSECMPInitializerAgent"");

			AGENT_CLASSES = Collections.unmodifiableSet(agentClasses);
		}

		/**
		 * Determine if any agent is active.
		 *
		 * @return {@literal true} if an agent is active.
		 */
		static boolean isActive(@Nullable ClassLoader classLoader) {

			return AGENT_CLASSES.stream() //
					.anyMatch(agentClass -> ClassUtils.isPresent(agentClass, classLoader));
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/config/JpaRepositoryConfigExtension.java,"/*
 * Copyright 2012-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.config;

import static org.springframework.data.jpa.repository.config.BeanDefinitionNames.*;

import lombok.experimental.UtilityClass;

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Optional;
import java.util.Set;

import javax.persistence.Entity;
import javax.persistence.MappedSuperclass;
import javax.persistence.PersistenceContext;
import javax.persistence.PersistenceUnit;

import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.context.annotation.AnnotationConfigUtils;
import org.springframework.core.annotation.AnnotationAttributes;
import org.springframework.core.io.ResourceLoader;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.support.DefaultJpaContext;
import org.springframework.data.jpa.repository.support.EntityManagerBeanDefinitionRegistrarPostProcessor;
import org.springframework.data.jpa.repository.support.JpaEvaluationContextExtension;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean;
import org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource;
import org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport;
import org.springframework.data.repository.config.RepositoryConfigurationSource;
import org.springframework.data.repository.config.XmlRepositoryConfigurationSource;
import org.springframework.lang.Nullable;
import org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor;
import org.springframework.util.ClassUtils;
import org.springframework.util.StringUtils;

/**
 * JPA specific configuration extension parsing custom attributes from the XML namespace and
 * {@link EnableJpaRepositories} annotation. Also, it registers bean definitions for a
 * {@link PersistenceAnnotationBeanPostProcessor} (to trigger injection into {@link PersistenceContext}/
 * {@link PersistenceUnit} annotated properties and methods) as well as
 * {@link PersistenceExceptionTranslationPostProcessor} to enable exception translation of persistence specific
 * exceptions into Spring's {@link DataAccessException} hierarchy.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Gil Markham
 * @author Thomas Darimont
 * @author Christoph Strobl
 * @author Mark Paluch
 */
public class JpaRepositoryConfigExtension extends RepositoryConfigurationExtensionSupport {

	private static final Class<?> PAB_POST_PROCESSOR = PersistenceAnnotationBeanPostProcessor.class;
	private static final String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = ""transactionManager"";
	private static final String ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE = ""enableDefaultTransactions"";
	private static final String JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME = ""org.springframework.data.jpa.util.JpaMetamodelCacheCleanup"";
	private static final String ESCAPE_CHARACTER_PROPERTY = ""escapeCharacter"";

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getModuleName()
	 */
	@Override
	public String getModuleName() {
		return ""JPA"";
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtension#getRepositoryFactoryBeanClassName()
	 */
	@Override
	public String getRepositoryFactoryBeanClassName() {
		return JpaRepositoryFactoryBean.class.getName();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config14.RepositoryConfigurationExtensionSupport#getModulePrefix()
	 */
	@Override
	protected String getModulePrefix() {
		return getModuleName().toLowerCase(Locale.US);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingAnnotations()
	 */
	@Override
	protected Collection<Class<? extends Annotation>> getIdentifyingAnnotations() {
		return Arrays.asList(Entity.class, MappedSuperclass.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getIdentifyingTypes()
	 */
	@Override
	protected Collection<Class<?>> getIdentifyingTypes() {
		return Collections.<Class<?>> singleton(JpaRepository.class);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, RepositoryConfigurationSource source) {

		Optional<String> transactionManagerRef = source.getAttribute(""transactionManagerRef"");
		builder.addPropertyValue(""transactionManager"", transactionManagerRef.orElse(DEFAULT_TRANSACTION_MANAGER_BEAN_NAME));
		builder.addPropertyValue(""entityManager"", getEntityManagerBeanDefinitionFor(source, source.getSource()));
		builder.addPropertyValue(ESCAPE_CHARACTER_PROPERTY, getEscapeCharacter(source).orElse('\\'));
		builder.addPropertyReference(""mappingContext"", JPA_MAPPING_CONTEXT_BEAN_NAME);
	}

	/**
	 * XML configurations do not support {@link Character} values. This method catches the exception thrown and returns an
	 * {@link Optional#empty()} instead.
	 */
	private static Optional<Character> getEscapeCharacter(RepositoryConfigurationSource source) {

		try {

			return AnnotationRepositoryConfigurationSource.class.isInstance(source) //
					? Optional.ofNullable((Character) AnnotationRepositoryConfigurationSource.class.cast(source).getAttributes()
							.get(ESCAPE_CHARACTER_PROPERTY)) //
					: source.getAttribute(ESCAPE_CHARACTER_PROPERTY).map(it -> it.toCharArray()[0]);

		} catch (IllegalArgumentException ___) {
			return Optional.empty();
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, AnnotationRepositoryConfigurationSource config) {

		AnnotationAttributes attributes = config.getAttributes();

		builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE,
				attributes.getBoolean(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#postProcess(org.springframework.beans.factory.support.BeanDefinitionBuilder, org.springframework.data.repository.config.XmlRepositoryConfigurationSource)
	 */
	@Override
	public void postProcess(BeanDefinitionBuilder builder, XmlRepositoryConfigurationSource config) {

		Optional<String> enableDefaultTransactions = config.getAttribute(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE);

		if (enableDefaultTransactions.isPresent() && StringUtils.hasText(enableDefaultTransactions.get())) {
			builder.addPropertyValue(ENABLE_DEFAULT_TRANSACTIONS_ATTRIBUTE, enableDefaultTransactions.get());
		}
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#registerBeansForRoot(org.springframework.beans.factory.support.BeanDefinitionRegistry, org.springframework.data.repository.config.RepositoryConfigurationSource)
	 */
	@Override
	public void registerBeansForRoot(BeanDefinitionRegistry registry, RepositoryConfigurationSource config) {

		super.registerBeansForRoot(registry, config);

		Object source = config.getSource();

		registerIfNotAlreadyRegistered(new RootBeanDefinition(EntityManagerBeanDefinitionRegistrarPostProcessor.class),
				registry, EM_BEAN_DEFINITION_REGISTRAR_POST_PROCESSOR_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(JpaMetamodelMappingContextFactoryBean.class), registry,
				JPA_MAPPING_CONTEXT_BEAN_NAME, source);

		registerIfNotAlreadyRegistered(new RootBeanDefinition(PAB_POST_PROCESSOR), registry,
				AnnotationConfigUtils.PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME, source);

		// Register bean definition for DefaultJpaContext

		RootBeanDefinition contextDefinition = new RootBeanDefinition(DefaultJpaContext.class);
		contextDefinition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);

		registerIfNotAlreadyRegistered(contextDefinition, registry, JPA_CONTEXT_BEAN_NAME, source);
		registerIfNotAlreadyRegistered(new RootBeanDefinition(JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME), registry,
				JPA_METAMODEL_CACHE_CLEANUP_CLASSNAME, source);

		// EvaluationContextExtension for JPA specific SpEL functions

		Object value = getEscapeCharacter(config).orElse('\\');

		BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(JpaEvaluationContextExtension.class);
		builder.addConstructorArgValue(value);

		registerIfNotAlreadyRegistered(builder.getBeanDefinition(), registry, JpaEvaluationContextExtension.class.getName(),
				source);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport#getConfigurationInspectionClassLoader(org.springframework.core.io.ResourceLoader)
	 */
	@Override
	protected ClassLoader getConfigurationInspectionClassLoader(ResourceLoader loader) {

		ClassLoader classLoader = loader.getClassLoader();

		return classLoader != null && LazyJvmAgent.isActive(loader.getClassLoader())
				? new InspectionClassLoader(loader.getClassLoader())
				: loader.getClassLoader();
	}

	/**
	 * Creates an anonymous factory to extract the actual {@link javax.persistence.EntityManager} from the
	 * {@link javax.persistence.EntityManagerFactory} bean name reference.
	 *
	 * @param config
	 * @param source
	 * @return
	 */
	private static AbstractBeanDefinition getEntityManagerBeanDefinitionFor(RepositoryConfigurationSource config,
			@Nullable Object source) {

		BeanDefinitionBuilder builder = BeanDefinitionBuilder
				.rootBeanDefinition(""org.springframework.orm.jpa.SharedEntityManagerCreator"");
		builder.setFactoryMethod(""createSharedEntityManager"");
		builder.addConstructorArgReference(getEntityManagerBeanRef(config));

		AbstractBeanDefinition bean = builder.getRawBeanDefinition();
		bean.setSource(source);

		return bean;
	}

	private static String getEntityManagerBeanRef(RepositoryConfigurationSource config) {

		Optional<String> entityManagerFactoryRef = config.getAttribute(""entityManagerFactoryRef"");
		return entityManagerFactoryRef.orElse(""entityManagerFactory"");
	}

	/**
	 * Utility to determine if a lazy Java agent is being used that might transform classes at a later time.
	 *
	 * @author Mark Paluch
	 * @since 2.1
	 */
	@UtilityClass
	static class LazyJvmAgent {

		private static final Set<String> AGENT_CLASSES;

		static {

			Set<String> agentClasses = new LinkedHashSet<>();

			agentClasses.add(""org.springframework.instrument.InstrumentationSavingAgent"");
			agentClasses.add(""org.eclipse.persistence.internal.jpa.deployment.JavaSECMPInitializerAgent"");

			AGENT_CLASSES = Collections.unmodifiableSet(agentClasses);
		}

		/**
		 * Determine if any agent is active.
		 *
		 * @return {@literal true} if an agent is active.
		 */
		static boolean isActive(@Nullable ClassLoader classLoader) {

			return AGENT_CLASSES.stream() //
					.anyMatch(agentClass -> ClassUtils.isPresent(agentClass, classLoader));
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/EscapeCharacter.java,"/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import lombok.Value;

import java.util.Arrays;
import java.util.List;

import org.springframework.lang.Nullable;

/**
 * A value type encapsulating an escape character for LIKE queries and the actually usage of it in escaping
 * {@link String}s.
 *
 * @author Jens Schauder
 * @author Oliver Drotbohm
 */
@Value(staticConstructor = ""of"")
public class EscapeCharacter {

	private static final List<String> TO_REPLACE = Arrays.asList(""_"", ""%"");

	char value;

	/**
	 * Escapes all special like characters ({@code _}, {@code %}) using the configured escape character.
	 *
	 * @param value May be {@literal null}.
	 * @return
	 */
	@Nullable
	public String escape(String value) {

		if (value == null) {
			return null;
		}
		return TO_REPLACE.stream() //
				.reduce(value, (it, character) -> it.replace(character, this.value + character));
	}

	/**
	 * Makes the underlying character available.
	 *
	 * @return the value
	 */
	public char escapeCharacter() {
		return value;
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/EscapeCharacter.java,"/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import lombok.Value;

import java.util.Arrays;
import java.util.List;

import org.springframework.lang.Nullable;

/**
 * A value type encapsulating an escape character for LIKE queries and the actually usage of it in escaping
 * {@link String}s.
 *
 * @author Jens Schauder
 * @author Oliver Drotbohm
 */
@Value(staticConstructor = ""of"")
public class EscapeCharacter {

	private static final List<String> TO_REPLACE = Arrays.asList(""_"", ""%"");

	char escapeCharacter;

	/**
	 * Escapes all special like characters ({@code _}, {@code %}) using the configured escape character.
	 *
	 * @param value may be {@literal null}.
	 * @return
	 */
	@Nullable
	public String escape(String value) {

		return value == null //
				? null //
				: TO_REPLACE.stream() //
						.reduce(value, (it, character) -> it.replace(character, this.escapeCharacter + character));
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryCreator.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.springframework.data.jpa.repository.query.QueryUtils.*;
import static org.springframework.data.repository.query.parser.Part.Type.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.ParameterExpression;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Selection;
import javax.persistence.metamodel.SingularAttribute;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.mapping.PropertyPath;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.AbstractQueryCreator;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Query creator to create a {@link CriteriaQuery} from a {@link PartTree}.
 *
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Michael Cramer
 * @author Mark Paluch
 * @author Reda.Housni-Alaoui
 */
public class JpaQueryCreator extends AbstractQueryCreator<CriteriaQuery<? extends Object>, Predicate> {

	private final CriteriaBuilder builder;
	private final Root<?> root;
	private final CriteriaQuery<? extends Object> query;
	private final ParameterMetadataProvider provider;
	private final ReturnedType returnedType;
	private final PartTree tree;
	private final EscapeCharacter escape;

	/**
	 * Create a new {@link JpaQueryCreator}.
	 *
	 * @param tree must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param builder must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public JpaQueryCreator(PartTree tree, ReturnedType type, CriteriaBuilder builder,
			ParameterMetadataProvider provider) {

		super(tree);
		this.tree = tree;

		CriteriaQuery<?> criteriaQuery = createCriteriaQuery(builder, type);

		this.builder = builder;
		this.query = criteriaQuery.distinct(tree.isDistinct());
		this.root = query.from(type.getDomainType());
		this.provider = provider;
		this.returnedType = type;
		this.escape = provider.getEscape();
	}

	/**
	 * Creates the {@link CriteriaQuery} to apply predicates on.
	 *
	 * @param builder will never be {@literal null}.
	 * @param type will never be {@literal null}.
	 * @return must not be {@literal null}.
	 */
	protected CriteriaQuery<? extends Object> createCriteriaQuery(CriteriaBuilder builder, ReturnedType type) {

		Class<?> typeToRead = type.getTypeToRead();

		return typeToRead == null || tree.isExistsProjection() ? builder.createTupleQuery()
				: builder.createQuery(typeToRead);
	}

	/**
	 * Returns all {@link javax.persistence.criteria.ParameterExpression} created when creating the query.
	 *
	 * @return the parameterExpressions
	 */
	public List<ParameterMetadata<?>> getParameterExpressions() {
		return provider.getExpressions();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#create(org.springframework.data.repository.query.parser.Part, java.util.Iterator)
	 */
	@Override
	protected Predicate create(Part part, Iterator<Object> iterator) {

		return toPredicate(part, root);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#and(org.springframework.data.repository.query.parser.Part, java.lang.Object, java.util.Iterator)
	 */
	@Override
	protected Predicate and(Part part, Predicate base, Iterator<Object> iterator) {
		return builder.and(base, toPredicate(part, root));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#or(java.lang.Object, java.lang.Object)
	 */
	@Override
	protected Predicate or(Predicate base, Predicate predicate) {
		return builder.or(base, predicate);
	}

	/**
	 * Finalizes the given {@link Predicate} and applies the given sort. Delegates to
	 * {@link #complete(Predicate, Sort, CriteriaQuery, CriteriaBuilder, Root)} and hands it the current {@link CriteriaQuery}
	 * and {@link CriteriaBuilder}.
	 */
	@Override
	protected final CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort) {
		return complete(predicate, sort, query, builder, root);
	}

	/**
	 * Template method to finalize the given {@link Predicate} using the given {@link CriteriaQuery} and
	 * {@link CriteriaBuilder}.
	 *
	 * @param predicate
	 * @param sort
	 * @param query
	 * @param builder
	 * @return
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	protected CriteriaQuery<? extends Object> complete(@Nullable Predicate predicate, Sort sort,
			CriteriaQuery<? extends Object> query, CriteriaBuilder builder, Root<?> root) {

		if (returnedType.needsCustomConstruction()) {

			List<Selection<?>> selections = new ArrayList<>();

			for (String property : returnedType.getInputProperties()) {

				PropertyPath path = PropertyPath.from(property, returnedType.getDomainType());
				selections.add(toExpressionRecursively(root, path, true).alias(property));
			}

			query = query.multiselect(selections);

		} else if (tree.isExistsProjection()) {

			if (root.getModel().hasSingleIdAttribute()) {

				SingularAttribute<?, ?> id = root.getModel().getId(root.getModel().getIdType().getJavaType());
				query = query.multiselect(root.get((SingularAttribute) id).alias(id.getName()));

			} else {

				query = query.multiselect(root.getModel().getIdClassAttributes().stream()//
						.map(it -> (Selection<?>) root.get((SingularAttribute) it).alias(it.getName()))
						.collect(Collectors.toList()));
			}

		} else {
			query = query.select((Root) root);
		}

		CriteriaQuery<? extends Object> select = query.orderBy(QueryUtils.toOrders(sort, root, builder));
		return predicate == null ? select : select.where(predicate);
	}

	/**
	 * Creates a {@link Predicate} from the given {@link Part}.
	 *
	 * @param part
	 * @param root
	 * @return
	 */
	private Predicate toPredicate(Part part, Root<?> root) {
		return new PredicateBuilder(part, root).build();
	}

	/**
	 * Simple builder to contain logic to create JPA {@link Predicate}s from {@link Part}s.
	 *
	 * @author Phil Webb
	 * @author Oliver Gierke
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private class PredicateBuilder {

		private final Part part;
		private final Root<?> root;

		/**
		 * Creates a new {@link PredicateBuilder} for the given {@link Part} and {@link Root}.
		 *
		 * @param part must not be {@literal null}.
		 * @param root must not be {@literal null}.
		 */
		public PredicateBuilder(Part part, Root<?> root) {

			Assert.notNull(part, ""Part must not be null!"");
			Assert.notNull(root, ""Root must not be null!"");
			this.part = part;
			this.root = root;
		}

		/**
		 * Builds a JPA {@link Predicate} from the underlying {@link Part}.
		 *
		 * @return
		 */
		public Predicate build() {

			PropertyPath property = part.getProperty();
			Type type = part.getType();

			switch (type) {
				case BETWEEN:
					ParameterMetadata<Comparable> first = provider.next(part);
					ParameterMetadata<Comparable> second = provider.next(part);
					return builder.between(getComparablePath(root, part), first.getExpression(), second.getExpression());
				case AFTER:
				case GREATER_THAN:
					return builder.greaterThan(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case GREATER_THAN_EQUAL:
					return builder.greaterThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case BEFORE:
				case LESS_THAN:
					return builder.lessThan(getComparablePath(root, part), provider.next(part, Comparable.class).getExpression());
				case LESS_THAN_EQUAL:
					return builder.lessThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case IS_NULL:
					return getTypedPath(root, part).isNull();
				case IS_NOT_NULL:
					return getTypedPath(root, part).isNotNull();
				case NOT_IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression()).not();
				case IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression());
				case STARTING_WITH:
				case ENDING_WITH:
				case CONTAINING:
				case NOT_CONTAINING:

					if (property.getLeafProperty().isCollection()) {

						Expression<Collection<Object>> propertyExpression = traversePath(root, property);
						ParameterExpression<Object> parameterExpression = provider.next(part).getExpression();

						// Can't just call .not() in case of negation as EclipseLink chokes on that.
						return type.equals(NOT_CONTAINING) ? isNotMember(builder, parameterExpression, propertyExpression)
								: isMember(builder, parameterExpression, propertyExpression);
					}

				case LIKE:
				case NOT_LIKE:
					Expression<String> stringPath = getTypedPath(root, part);
					Expression<String> propertyExpression = upperIfIgnoreCase(stringPath);
					Expression<String> parameterExpression = upperIfIgnoreCase(provider.next(part, String.class).getExpression());
					Predicate like = builder.like(propertyExpression, parameterExpression, escape.getValue());
					return type.equals(NOT_LIKE) || type.equals(NOT_CONTAINING) ? like.not() : like;
				case TRUE:
					Expression<Boolean> truePath = getTypedPath(root, part);
					return builder.isTrue(truePath);
				case FALSE:
					Expression<Boolean> falsePath = getTypedPath(root, part);
					return builder.isFalse(falsePath);
				case SIMPLE_PROPERTY:
					ParameterMetadata<Object> expression = provider.next(part);
					Expression<Object> path = getTypedPath(root, part);
					return expression.isIsNullParameter() ? path.isNull()
							: builder.equal(upperIfIgnoreCase(path), upperIfIgnoreCase(expression.getExpression()));
				case NEGATING_SIMPLE_PROPERTY:
					return builder.notEqual(upperIfIgnoreCase(getTypedPath(root, part)),
							upperIfIgnoreCase(provider.next(part).getExpression()));
				case IS_EMPTY:
				case IS_NOT_EMPTY:

					if (!property.getLeafProperty().isCollection()) {
						throw new IllegalArgumentException(""IsEmpty / IsNotEmpty can only be used on collection properties!"");
					}

					Expression<Collection<Object>> collectionPath = traversePath(root, property);
					return type.equals(IS_NOT_EMPTY) ? builder.isNotEmpty(collectionPath) : builder.isEmpty(collectionPath);

				default:
					throw new IllegalArgumentException(""Unsupported keyword "" + type);
			}
		}

		private <T> Predicate isMember(CriteriaBuilder builder, Expression<T> parameter,
				Expression<Collection<T>> property) {
			return builder.isMember(parameter, property);
		}

		private <T> Predicate isNotMember(CriteriaBuilder builder, Expression<T> parameter,
				Expression<Collection<T>> property) {
			return builder.isNotMember(parameter, property);
		}

		/**
		 * Applies an {@code UPPERCASE} conversion to the given {@link Expression} in case the underlying {@link Part}
		 * requires ignoring case.
		 *
		 * @param expression must not be {@literal null}.
		 * @return
		 */
		private <T> Expression<T> upperIfIgnoreCase(Expression<? extends T> expression) {

			switch (part.shouldIgnoreCase()) {

				case ALWAYS:

					Assert.state(canUpperCase(expression), ""Unable to ignore case of "" + expression.getJavaType().getName()
							+ "" types, the property '"" + part.getProperty().getSegment() + ""' must reference a String"");
					return (Expression<T>) builder.upper((Expression<String>) expression);

				case WHEN_POSSIBLE:

					if (canUpperCase(expression)) {
						return (Expression<T>) builder.upper((Expression<String>) expression);
					}

				case NEVER:
				default:

					return (Expression<T>) expression;
			}
		}

		private boolean canUpperCase(Expression<?> expression) {
			return String.class.equals(expression.getJavaType());
		}

		/**
		 * Returns a path to a {@link Comparable}.
		 *
		 * @param root
		 * @param part
		 * @return
		 */
		private Expression<? extends Comparable> getComparablePath(Root<?> root, Part part) {
			return getTypedPath(root, part);
		}

		private <T> Expression<T> getTypedPath(Root<?> root, Part part) {
			return toExpressionRecursively(root, part.getProperty());
		}

		private <T> Expression<T> traversePath(Path<?> root, PropertyPath path) {

			Path<Object> result = root.get(path.getSegment());
			return (Expression<T>) (path.hasNext() ? traversePath(result, path.next()) : result);
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/JpaQueryCreator.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import static org.springframework.data.jpa.repository.query.QueryUtils.*;
import static org.springframework.data.repository.query.parser.Part.Type.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.ParameterExpression;
import javax.persistence.criteria.Path;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Selection;
import javax.persistence.metamodel.SingularAttribute;

import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.mapping.PropertyPath;
import org.springframework.data.repository.query.ReturnedType;
import org.springframework.data.repository.query.parser.AbstractQueryCreator;
import org.springframework.data.repository.query.parser.Part;
import org.springframework.data.repository.query.parser.Part.Type;
import org.springframework.data.repository.query.parser.PartTree;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Query creator to create a {@link CriteriaQuery} from a {@link PartTree}.
 *
 * @author Oliver Gierke
 * @author Mark Paluch
 * @author Michael Cramer
 * @author Mark Paluch
 * @author Reda.Housni-Alaoui
 */
public class JpaQueryCreator extends AbstractQueryCreator<CriteriaQuery<? extends Object>, Predicate> {

	private final CriteriaBuilder builder;
	private final Root<?> root;
	private final CriteriaQuery<? extends Object> query;
	private final ParameterMetadataProvider provider;
	private final ReturnedType returnedType;
	private final PartTree tree;
	private final EscapeCharacter escape;

	/**
	 * Create a new {@link JpaQueryCreator}.
	 *
	 * @param tree must not be {@literal null}.
	 * @param type must not be {@literal null}.
	 * @param builder must not be {@literal null}.
	 * @param provider must not be {@literal null}.
	 */
	public JpaQueryCreator(PartTree tree, ReturnedType type, CriteriaBuilder builder,
			ParameterMetadataProvider provider) {

		super(tree);
		this.tree = tree;

		CriteriaQuery<?> criteriaQuery = createCriteriaQuery(builder, type);

		this.builder = builder;
		this.query = criteriaQuery.distinct(tree.isDistinct());
		this.root = query.from(type.getDomainType());
		this.provider = provider;
		this.returnedType = type;
		this.escape = provider.getEscape();
	}

	/**
	 * Creates the {@link CriteriaQuery} to apply predicates on.
	 *
	 * @param builder will never be {@literal null}.
	 * @param type will never be {@literal null}.
	 * @return must not be {@literal null}.
	 */
	protected CriteriaQuery<? extends Object> createCriteriaQuery(CriteriaBuilder builder, ReturnedType type) {

		Class<?> typeToRead = type.getTypeToRead();

		return typeToRead == null || tree.isExistsProjection() ? builder.createTupleQuery()
				: builder.createQuery(typeToRead);
	}

	/**
	 * Returns all {@link javax.persistence.criteria.ParameterExpression} created when creating the query.
	 *
	 * @return the parameterExpressions
	 */
	public List<ParameterMetadata<?>> getParameterExpressions() {
		return provider.getExpressions();
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#create(org.springframework.data.repository.query.parser.Part, java.util.Iterator)
	 */
	@Override
	protected Predicate create(Part part, Iterator<Object> iterator) {

		return toPredicate(part, root);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#and(org.springframework.data.repository.query.parser.Part, java.lang.Object, java.util.Iterator)
	 */
	@Override
	protected Predicate and(Part part, Predicate base, Iterator<Object> iterator) {
		return builder.and(base, toPredicate(part, root));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.query.parser.AbstractQueryCreator#or(java.lang.Object, java.lang.Object)
	 */
	@Override
	protected Predicate or(Predicate base, Predicate predicate) {
		return builder.or(base, predicate);
	}

	/**
	 * Finalizes the given {@link Predicate} and applies the given sort. Delegates to
	 * {@link #complete(Predicate, Sort, CriteriaQuery, CriteriaBuilder, Root)} and hands it the current {@link CriteriaQuery}
	 * and {@link CriteriaBuilder}.
	 */
	@Override
	protected final CriteriaQuery<? extends Object> complete(Predicate predicate, Sort sort) {
		return complete(predicate, sort, query, builder, root);
	}

	/**
	 * Template method to finalize the given {@link Predicate} using the given {@link CriteriaQuery} and
	 * {@link CriteriaBuilder}.
	 *
	 * @param predicate
	 * @param sort
	 * @param query
	 * @param builder
	 * @return
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	protected CriteriaQuery<? extends Object> complete(@Nullable Predicate predicate, Sort sort,
			CriteriaQuery<? extends Object> query, CriteriaBuilder builder, Root<?> root) {

		if (returnedType.needsCustomConstruction()) {

			List<Selection<?>> selections = new ArrayList<>();

			for (String property : returnedType.getInputProperties()) {

				PropertyPath path = PropertyPath.from(property, returnedType.getDomainType());
				selections.add(toExpressionRecursively(root, path, true).alias(property));
			}

			query = query.multiselect(selections);

		} else if (tree.isExistsProjection()) {

			if (root.getModel().hasSingleIdAttribute()) {

				SingularAttribute<?, ?> id = root.getModel().getId(root.getModel().getIdType().getJavaType());
				query = query.multiselect(root.get((SingularAttribute) id).alias(id.getName()));

			} else {

				query = query.multiselect(root.getModel().getIdClassAttributes().stream()//
						.map(it -> (Selection<?>) root.get((SingularAttribute) it).alias(it.getName()))
						.collect(Collectors.toList()));
			}

		} else {
			query = query.select((Root) root);
		}

		CriteriaQuery<? extends Object> select = query.orderBy(QueryUtils.toOrders(sort, root, builder));
		return predicate == null ? select : select.where(predicate);
	}

	/**
	 * Creates a {@link Predicate} from the given {@link Part}.
	 *
	 * @param part
	 * @param root
	 * @return
	 */
	private Predicate toPredicate(Part part, Root<?> root) {
		return new PredicateBuilder(part, root).build();
	}

	/**
	 * Simple builder to contain logic to create JPA {@link Predicate}s from {@link Part}s.
	 *
	 * @author Phil Webb
	 * @author Oliver Gierke
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private class PredicateBuilder {

		private final Part part;
		private final Root<?> root;

		/**
		 * Creates a new {@link PredicateBuilder} for the given {@link Part} and {@link Root}.
		 *
		 * @param part must not be {@literal null}.
		 * @param root must not be {@literal null}.
		 */
		public PredicateBuilder(Part part, Root<?> root) {

			Assert.notNull(part, ""Part must not be null!"");
			Assert.notNull(root, ""Root must not be null!"");
			this.part = part;
			this.root = root;
		}

		/**
		 * Builds a JPA {@link Predicate} from the underlying {@link Part}.
		 *
		 * @return
		 */
		public Predicate build() {

			PropertyPath property = part.getProperty();
			Type type = part.getType();

			switch (type) {
				case BETWEEN:
					ParameterMetadata<Comparable> first = provider.next(part);
					ParameterMetadata<Comparable> second = provider.next(part);
					return builder.between(getComparablePath(root, part), first.getExpression(), second.getExpression());
				case AFTER:
				case GREATER_THAN:
					return builder.greaterThan(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case GREATER_THAN_EQUAL:
					return builder.greaterThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case BEFORE:
				case LESS_THAN:
					return builder.lessThan(getComparablePath(root, part), provider.next(part, Comparable.class).getExpression());
				case LESS_THAN_EQUAL:
					return builder.lessThanOrEqualTo(getComparablePath(root, part),
							provider.next(part, Comparable.class).getExpression());
				case IS_NULL:
					return getTypedPath(root, part).isNull();
				case IS_NOT_NULL:
					return getTypedPath(root, part).isNotNull();
				case NOT_IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression()).not();
				case IN:
					return getTypedPath(root, part).in(provider.next(part, Collection.class).getExpression());
				case STARTING_WITH:
				case ENDING_WITH:
				case CONTAINING:
				case NOT_CONTAINING:

					if (property.getLeafProperty().isCollection()) {

						Expression<Collection<Object>> propertyExpression = traversePath(root, property);
						ParameterExpression<Object> parameterExpression = provider.next(part).getExpression();

						// Can't just call .not() in case of negation as EclipseLink chokes on that.
						return type.equals(NOT_CONTAINING) ? isNotMember(builder, parameterExpression, propertyExpression)
								: isMember(builder, parameterExpression, propertyExpression);
					}

				case LIKE:
				case NOT_LIKE:
					Expression<String> stringPath = getTypedPath(root, part);
					Expression<String> propertyExpression = upperIfIgnoreCase(stringPath);
					Expression<String> parameterExpression = upperIfIgnoreCase(provider.next(part, String.class).getExpression());
					Predicate like = builder.like(propertyExpression, parameterExpression, escape.getEscapeCharacter());
					return type.equals(NOT_LIKE) || type.equals(NOT_CONTAINING) ? like.not() : like;
				case TRUE:
					Expression<Boolean> truePath = getTypedPath(root, part);
					return builder.isTrue(truePath);
				case FALSE:
					Expression<Boolean> falsePath = getTypedPath(root, part);
					return builder.isFalse(falsePath);
				case SIMPLE_PROPERTY:
					ParameterMetadata<Object> expression = provider.next(part);
					Expression<Object> path = getTypedPath(root, part);
					return expression.isIsNullParameter() ? path.isNull()
							: builder.equal(upperIfIgnoreCase(path), upperIfIgnoreCase(expression.getExpression()));
				case NEGATING_SIMPLE_PROPERTY:
					return builder.notEqual(upperIfIgnoreCase(getTypedPath(root, part)),
							upperIfIgnoreCase(provider.next(part).getExpression()));
				case IS_EMPTY:
				case IS_NOT_EMPTY:

					if (!property.getLeafProperty().isCollection()) {
						throw new IllegalArgumentException(""IsEmpty / IsNotEmpty can only be used on collection properties!"");
					}

					Expression<Collection<Object>> collectionPath = traversePath(root, property);
					return type.equals(IS_NOT_EMPTY) ? builder.isNotEmpty(collectionPath) : builder.isEmpty(collectionPath);

				default:
					throw new IllegalArgumentException(""Unsupported keyword "" + type);
			}
		}

		private <T> Predicate isMember(CriteriaBuilder builder, Expression<T> parameter,
				Expression<Collection<T>> property) {
			return builder.isMember(parameter, property);
		}

		private <T> Predicate isNotMember(CriteriaBuilder builder, Expression<T> parameter,
				Expression<Collection<T>> property) {
			return builder.isNotMember(parameter, property);
		}

		/**
		 * Applies an {@code UPPERCASE} conversion to the given {@link Expression} in case the underlying {@link Part}
		 * requires ignoring case.
		 *
		 * @param expression must not be {@literal null}.
		 * @return
		 */
		private <T> Expression<T> upperIfIgnoreCase(Expression<? extends T> expression) {

			switch (part.shouldIgnoreCase()) {

				case ALWAYS:

					Assert.state(canUpperCase(expression), ""Unable to ignore case of "" + expression.getJavaType().getName()
							+ "" types, the property '"" + part.getProperty().getSegment() + ""' must reference a String"");
					return (Expression<T>) builder.upper((Expression<String>) expression);

				case WHEN_POSSIBLE:

					if (canUpperCase(expression)) {
						return (Expression<T>) builder.upper((Expression<String>) expression);
					}

				case NEVER:
				default:

					return (Expression<T>) expression;
			}
		}

		private boolean canUpperCase(Expression<?> expression) {
			return String.class.equals(expression.getJavaType());
		}

		/**
		 * Returns a path to a {@link Comparable}.
		 *
		 * @param root
		 * @param part
		 * @return
		 */
		private Expression<? extends Comparable> getComparablePath(Root<?> root, Part part) {
			return getTypedPath(root, part);
		}

		private <T> Expression<T> getTypedPath(Root<?> root, Part part) {
			return toExpressionRecursively(root, part.getProperty());
		}

		private <T> Expression<T> traversePath(Path<?> root, PropertyPath path) {

			Path<Object> result = root.get(path.getSegment());
			return (Expression<T>) (path.hasNext() ? traversePath(result, path.next()) : result);
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/QueryParameterSetterFactory.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.List;
import java.util.function.Function;

import javax.persistence.Query;
import javax.persistence.TemporalType;

import org.springframework.data.jpa.repository.query.JpaParameters.JpaParameter;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.query.QueryParameterSetter.NamedOrIndexedQueryParameterSetter;
import org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.Parameter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.data.jpa.repository.support.EscapeCharacter;
import org.springframework.expression.EvaluationContext;
import org.springframework.expression.Expression;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Encapsulates different strategies for the creation of a {@link QueryParameterSetter} from a {@link Query} and a
 * {@link ParameterBinding}
 *
 * @author Jens Schauder
 * @author Oliver Gierke
 * @author Mark Paluch
 * @since 2.0
 */
abstract class QueryParameterSetterFactory {

	@Nullable
	abstract QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery);

	/**
	 * Creates a new {@link QueryParameterSetterFactory} for the given {@link JpaParameters}.
	 *
	 * @param parameters must not be {@literal null}.
	 * @return a basic {@link QueryParameterSetterFactory} that can handle named and index parameters.
	 */
	static QueryParameterSetterFactory basic(JpaParameters parameters) {

		Assert.notNull(parameters, ""JpaParameters must not be null!"");

		return new BasicQueryParameterSetterFactory(parameters);
	}

	/**
	 * Creates a new {@link QueryParameterSetterFactory} using the given {@link JpaParameters} and
	 * {@link ParameterMetadata}.
	 *
	 * @param parameters must not be {@literal null}.
	 * @param metadata must not be {@literal null}.
	 * @return a {@link QueryParameterSetterFactory} for criteria Queries.
	 */
	static QueryParameterSetterFactory forCriteriaQuery(JpaParameters parameters, List<ParameterMetadata<?>> metadata) {

		Assert.notNull(parameters, ""JpaParameters must not be null!"");
		Assert.notNull(metadata, ""ParameterMetadata must not be null!"");

		return new CriteriaQueryParameterSetterFactory(parameters, metadata);
	}

	/**
	 * Creates a new {@link QueryParameterSetterFactory} for the given {@link SpelExpressionParser},
	 * {@link EvaluationContextProvider} and {@link Parameters}.
	 *
	 * @param parser must not be {@literal null}.
	 * @param evaluationContextProvider must not be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @return a {@link QueryParameterSetterFactory} that can handle
	 *         {@link org.springframework.expression.spel.standard.SpelExpression}s.
	 */
	static QueryParameterSetterFactory parsing(SpelExpressionParser parser,
			EvaluationContextProvider evaluationContextProvider, Parameters<?, ?> parameters) {

		Assert.notNull(parser, ""SpelExpressionParser must not be null!"");
		Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");
		Assert.notNull(parameters, ""Parameters must not be null!"");

		return new ExpressionBasedQueryParameterSetterFactory(parser, evaluationContextProvider, parameters);
	}

	/**
	 * Creates a {@link QueryParameterSetter} from a {@link JpaParameter}. Handles named and indexed parameters,
	 * TemporalType annotations and might ignore certain exception when requested to do so.
	 *
	 * @param valueExtractor extracts the relevant value from an array of method parameter values.
	 * @param binding the binding of the query parameter to be set.
	 * @param parameter the method parameter to bind.
	 */
	private static QueryParameterSetter createSetter(Function<Object[], Object> valueExtractor, ParameterBinding binding,
			@Nullable JpaParameter parameter) {

		TemporalType temporalType = parameter != null && parameter.isTemporalParameter() //
				? parameter.getRequiredTemporalType() //
				: null;

		return new NamedOrIndexedQueryParameterSetter(valueExtractor.andThen(binding::prepare),
				ParameterImpl.of(parameter, binding), temporalType);
	}

	/**
	 * Handles bindings that are SpEL expressions by evaluating the expression to obtain a value.
	 *
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @since 2.0
	 */
	private static class ExpressionBasedQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final SpelExpressionParser parser;
		private final EvaluationContextProvider evaluationContextProvider;
		private final Parameters<?, ?> parameters;

		/**
		 * @param parser must not be {@literal null}.
		 * @param evaluationContextProvider must not be {@literal null}.
		 * @param parameters must not be {@literal null}.
		 */
		ExpressionBasedQueryParameterSetterFactory(SpelExpressionParser parser,
				EvaluationContextProvider evaluationContextProvider, Parameters<?, ?> parameters) {

			Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");
			Assert.notNull(parser, ""SpelExpressionParser must not be null!"");
			Assert.notNull(parameters, ""Parameters must not be null!"");

			this.evaluationContextProvider = evaluationContextProvider;
			this.parser = parser;
			this.parameters = parameters;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Nullable
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			if (!binding.isExpression()) {
				return null;
			}

			Expression expression = parser.parseExpression(binding.getExpression());

			return createSetter(values -> evaluateExpression(expression, values), binding, null);
		}

		/**
		 * Evaluates the given {@link Expression} against the given values.
		 *
		 * @param expression must not be {@literal null}.
		 * @param values must not be {@literal null}.
		 * @return the result of the evaluation.
		 */
		@Nullable
		private Object evaluateExpression(Expression expression, Object[] values) {

			EvaluationContext context = evaluationContextProvider.getEvaluationContext(parameters, values);

			return expression.getValue(context, Object.class);
		}
	}

	/**
	 * Extracts values for parameter bindings from method parameters. It handles named as well as indexed parameters.
	 *
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @since 2.0
	 */
	private static class BasicQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final JpaParameters parameters;

		/**
		 * @param parameters must not be {@literal null}.
		 */
		BasicQueryParameterSetterFactory(JpaParameters parameters) {

			Assert.notNull(parameters, ""JpaParameters must not be null!"");

			this.parameters = parameters;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			Assert.notNull(binding, ""Binding must not be null."");

			JpaParameter parameter;

			if (declaredQuery.hasNamedParameter()) {
				parameter = findParameterForBinding(binding);
			} else {

				int parameterIndex = binding.getRequiredPosition() - 1;
				JpaParameters bindableParameters = parameters.getBindableParameters();

				Assert.isTrue( //
						parameterIndex < bindableParameters.getNumberOfParameters(), //
						() -> String.format( //
								""At least %s parameter(s) provided but only %s parameter(s) present in query."", //
								binding.getRequiredPosition(), //
								bindableParameters.getNumberOfParameters() //
						) //
				);

				parameter = bindableParameters.getParameter(binding.getRequiredPosition() - 1);
			}

			return parameter == null //
					? QueryParameterSetter.NOOP //
					: createSetter(values -> getValue(values, parameter), binding, parameter);
		}

		@Nullable
		private JpaParameter findParameterForBinding(ParameterBinding binding) {

			return parameters.getBindableParameters().stream() //
					.filter(candidate -> binding.getRequiredName().equals(getName(candidate))) //
					.findFirst().orElse(null);
		}

		private Object getValue(Object[] values, Parameter parameter) {
			return new JpaParametersParameterAccessor(parameters, values).getValue(parameter);
		}

		private static String getName(JpaParameter p) {
			return p.getName().orElseThrow(() -> new IllegalStateException(ParameterBinder.PARAMETER_NEEDS_TO_BE_NAMED));
		}
	}

	/**
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @see QueryParameterSetterFactory
	 */
	private static class CriteriaQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final JpaParameters parameters;
		private final List<ParameterMetadata<?>> expressions;

		/**
		 * Creates a new {@link QueryParameterSetterFactory} from the given {@link JpaParameters} and
		 * {@link ParameterMetadata}.
		 *
		 * @param parameters must not be {@literal null}.
		 * @param metadata must not be {@literal null}.
		 */
		CriteriaQueryParameterSetterFactory(JpaParameters parameters, List<ParameterMetadata<?>> metadata) {

			Assert.notNull(parameters, ""JpaParameters must not be null!"");
			Assert.notNull(metadata, ""Expressions must not be null!"");

			this.parameters = parameters;
			this.expressions = metadata;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			int parameterIndex = binding.getRequiredPosition() - 1;

			Assert.isTrue( //
					parameterIndex < expressions.size(), //
					() -> String.format( //
							""At least %s parameter(s) provided but only %s parameter(s) present in query."", //
							binding.getRequiredPosition(), //
							expressions.size() //
					) //
			);

			ParameterMetadata<?> metadata = expressions.get(parameterIndex);

			if (metadata.isIsNullParameter()) {
				return QueryParameterSetter.NOOP;
			}

			JpaParameter parameter = parameters.getBindableParameter(parameterIndex);
			TemporalType temporalType = parameter.isTemporalParameter() ? parameter.getRequiredTemporalType() : null;

			return new NamedOrIndexedQueryParameterSetter(values -> getAndPrepare(parameter, metadata, values),
					metadata.getExpression(), temporalType);
		}

		@Nullable
		private Object getAndPrepare(JpaParameter parameter, ParameterMetadata<?> metadata, Object[] values) {

			JpaParametersParameterAccessor accessor = new JpaParametersParameterAccessor(parameters, values);

			return metadata.prepare(accessor.getValue(parameter));
		}
	}

	private static class ParameterImpl<T> implements javax.persistence.Parameter<T> {

		private final Class<T> parameterType;
		private final @Nullable String name;
		private final @Nullable Integer position;

		/**
		 * Creates a new {@link ParameterImpl} for the given {@link JpaParameter} and {@link ParameterBinding}.
		 *
		 * @param parameter can be {@literal null}.
		 * @param binding must not be {@literal null}.
		 * @return a {@link javax.persistence.Parameter} object based on the information from the arguments.
		 */
		static javax.persistence.Parameter<?> of(@Nullable JpaParameter parameter, ParameterBinding binding) {

			Class<?> type = parameter == null ? Object.class : parameter.getType();

			return new ParameterImpl<>(type, getName(parameter, binding), binding.getPosition());
		}

		/**
		 * Creates a new {@link ParameterImpl} for the given name, position and parameter type.
		 *
		 * @param parameterType must not be {@literal null}.
		 * @param name can be {@literal null}.
		 * @param position can be {@literal null}.
		 */
		private ParameterImpl(Class<T> parameterType, @Nullable String name, @Nullable Integer position) {

			this.name = name;
			this.position = position;
			this.parameterType = parameterType;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getName()
		 */
		@Nullable
		@Override
		public String getName() {
			return name;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getPosition()
		 */
		@Nullable
		@Override
		public Integer getPosition() {
			return position;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getParameterType()
		 */
		@Override
		public Class<T> getParameterType() {
			return parameterType;
		}

		@Nullable
		private static String getName(@Nullable JpaParameter parameter, ParameterBinding binding) {

			if (parameter == null) {
				return binding.getName();
			}

			return parameter.isNamedParameter() //
					? parameter.getName().orElseThrow(() -> new IllegalArgumentException(""o_O parameter needs to have a name!"")) //
					: null;
		}
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/query/QueryParameterSetterFactory.java,"/*
 * Copyright 2017-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.query;

import java.util.List;
import java.util.function.Function;

import javax.persistence.Query;
import javax.persistence.TemporalType;

import org.springframework.data.jpa.repository.query.JpaParameters.JpaParameter;
import org.springframework.data.jpa.repository.query.ParameterMetadataProvider.ParameterMetadata;
import org.springframework.data.jpa.repository.query.QueryParameterSetter.NamedOrIndexedQueryParameterSetter;
import org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding;
import org.springframework.data.repository.query.EvaluationContextProvider;
import org.springframework.data.repository.query.Parameter;
import org.springframework.data.repository.query.Parameters;
import org.springframework.expression.EvaluationContext;
import org.springframework.expression.Expression;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Encapsulates different strategies for the creation of a {@link QueryParameterSetter} from a {@link Query} and a
 * {@link ParameterBinding}
 *
 * @author Jens Schauder
 * @author Oliver Gierke
 * @author Mark Paluch
 * @since 2.0
 */
abstract class QueryParameterSetterFactory {

	@Nullable
	abstract QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery);

	/**
	 * Creates a new {@link QueryParameterSetterFactory} for the given {@link JpaParameters}.
	 *
	 * @param parameters must not be {@literal null}.
	 * @return a basic {@link QueryParameterSetterFactory} that can handle named and index parameters.
	 */
	static QueryParameterSetterFactory basic(JpaParameters parameters) {

		Assert.notNull(parameters, ""JpaParameters must not be null!"");

		return new BasicQueryParameterSetterFactory(parameters);
	}

	/**
	 * Creates a new {@link QueryParameterSetterFactory} using the given {@link JpaParameters} and
	 * {@link ParameterMetadata}.
	 *
	 * @param parameters must not be {@literal null}.
	 * @param metadata must not be {@literal null}.
	 * @return a {@link QueryParameterSetterFactory} for criteria Queries.
	 */
	static QueryParameterSetterFactory forCriteriaQuery(JpaParameters parameters, List<ParameterMetadata<?>> metadata) {

		Assert.notNull(parameters, ""JpaParameters must not be null!"");
		Assert.notNull(metadata, ""ParameterMetadata must not be null!"");

		return new CriteriaQueryParameterSetterFactory(parameters, metadata);
	}

	/**
	 * Creates a new {@link QueryParameterSetterFactory} for the given {@link SpelExpressionParser},
	 * {@link EvaluationContextProvider} and {@link Parameters}.
	 *
	 * @param parser must not be {@literal null}.
	 * @param evaluationContextProvider must not be {@literal null}.
	 * @param parameters must not be {@literal null}.
	 * @return a {@link QueryParameterSetterFactory} that can handle
	 *         {@link org.springframework.expression.spel.standard.SpelExpression}s.
	 */
	static QueryParameterSetterFactory parsing(SpelExpressionParser parser,
			EvaluationContextProvider evaluationContextProvider, Parameters<?, ?> parameters) {

		Assert.notNull(parser, ""SpelExpressionParser must not be null!"");
		Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");
		Assert.notNull(parameters, ""Parameters must not be null!"");

		return new ExpressionBasedQueryParameterSetterFactory(parser, evaluationContextProvider, parameters);
	}

	/**
	 * Creates a {@link QueryParameterSetter} from a {@link JpaParameter}. Handles named and indexed parameters,
	 * TemporalType annotations and might ignore certain exception when requested to do so.
	 *
	 * @param valueExtractor extracts the relevant value from an array of method parameter values.
	 * @param binding the binding of the query parameter to be set.
	 * @param parameter the method parameter to bind.
	 */
	private static QueryParameterSetter createSetter(Function<Object[], Object> valueExtractor, ParameterBinding binding,
			@Nullable JpaParameter parameter) {

		TemporalType temporalType = parameter != null && parameter.isTemporalParameter() //
				? parameter.getRequiredTemporalType() //
				: null;

		return new NamedOrIndexedQueryParameterSetter(valueExtractor.andThen(binding::prepare),
				ParameterImpl.of(parameter, binding), temporalType);
	}

	/**
	 * Handles bindings that are SpEL expressions by evaluating the expression to obtain a value.
	 *
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @since 2.0
	 */
	private static class ExpressionBasedQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final SpelExpressionParser parser;
		private final EvaluationContextProvider evaluationContextProvider;
		private final Parameters<?, ?> parameters;

		/**
		 * @param parser must not be {@literal null}.
		 * @param evaluationContextProvider must not be {@literal null}.
		 * @param parameters must not be {@literal null}.
		 */
		ExpressionBasedQueryParameterSetterFactory(SpelExpressionParser parser,
				EvaluationContextProvider evaluationContextProvider, Parameters<?, ?> parameters) {

			Assert.notNull(evaluationContextProvider, ""EvaluationContextProvider must not be null!"");
			Assert.notNull(parser, ""SpelExpressionParser must not be null!"");
			Assert.notNull(parameters, ""Parameters must not be null!"");

			this.evaluationContextProvider = evaluationContextProvider;
			this.parser = parser;
			this.parameters = parameters;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Nullable
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			if (!binding.isExpression()) {
				return null;
			}

			Expression expression = parser.parseExpression(binding.getExpression());

			return createSetter(values -> evaluateExpression(expression, values), binding, null);
		}

		/**
		 * Evaluates the given {@link Expression} against the given values.
		 *
		 * @param expression must not be {@literal null}.
		 * @param values must not be {@literal null}.
		 * @return the result of the evaluation.
		 */
		@Nullable
		private Object evaluateExpression(Expression expression, Object[] values) {

			EvaluationContext context = evaluationContextProvider.getEvaluationContext(parameters, values);

			return expression.getValue(context, Object.class);
		}
	}

	/**
	 * Extracts values for parameter bindings from method parameters. It handles named as well as indexed parameters.
	 *
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @since 2.0
	 */
	private static class BasicQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final JpaParameters parameters;

		/**
		 * @param parameters must not be {@literal null}.
		 */
		BasicQueryParameterSetterFactory(JpaParameters parameters) {

			Assert.notNull(parameters, ""JpaParameters must not be null!"");

			this.parameters = parameters;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			Assert.notNull(binding, ""Binding must not be null."");

			JpaParameter parameter;

			if (declaredQuery.hasNamedParameter()) {
				parameter = findParameterForBinding(binding);
			} else {

				int parameterIndex = binding.getRequiredPosition() - 1;
				JpaParameters bindableParameters = parameters.getBindableParameters();

				Assert.isTrue( //
						parameterIndex < bindableParameters.getNumberOfParameters(), //
						() -> String.format( //
								""At least %s parameter(s) provided but only %s parameter(s) present in query."", //
								binding.getRequiredPosition(), //
								bindableParameters.getNumberOfParameters() //
						) //
				);

				parameter = bindableParameters.getParameter(binding.getRequiredPosition() - 1);
			}

			return parameter == null //
					? QueryParameterSetter.NOOP //
					: createSetter(values -> getValue(values, parameter), binding, parameter);
		}

		@Nullable
		private JpaParameter findParameterForBinding(ParameterBinding binding) {

			return parameters.getBindableParameters().stream() //
					.filter(candidate -> binding.getRequiredName().equals(getName(candidate))) //
					.findFirst().orElse(null);
		}

		private Object getValue(Object[] values, Parameter parameter) {
			return new JpaParametersParameterAccessor(parameters, values).getValue(parameter);
		}

		private static String getName(JpaParameter p) {
			return p.getName().orElseThrow(() -> new IllegalStateException(ParameterBinder.PARAMETER_NEEDS_TO_BE_NAMED));
		}
	}

	/**
	 * @author Jens Schauder
	 * @author Oliver Gierke
	 * @see QueryParameterSetterFactory
	 */
	private static class CriteriaQueryParameterSetterFactory extends QueryParameterSetterFactory {

		private final JpaParameters parameters;
		private final List<ParameterMetadata<?>> expressions;

		/**
		 * Creates a new {@link QueryParameterSetterFactory} from the given {@link JpaParameters} and
		 * {@link ParameterMetadata}.
		 *
		 * @param parameters must not be {@literal null}.
		 * @param metadata must not be {@literal null}.
		 */
		CriteriaQueryParameterSetterFactory(JpaParameters parameters, List<ParameterMetadata<?>> metadata) {

			Assert.notNull(parameters, ""JpaParameters must not be null!"");
			Assert.notNull(metadata, ""Expressions must not be null!"");

			this.parameters = parameters;
			this.expressions = metadata;
		}

		/*
		 * (non-Javadoc)
		 * @see org.springframework.data.jpa.repository.query.QueryParameterSetterFactory#create(org.springframework.data.jpa.repository.query.StringQuery.ParameterBinding, java.lang.String)
		 */
		@Override
		public QueryParameterSetter create(ParameterBinding binding, DeclaredQuery declaredQuery) {

			int parameterIndex = binding.getRequiredPosition() - 1;

			Assert.isTrue( //
					parameterIndex < expressions.size(), //
					() -> String.format( //
							""At least %s parameter(s) provided but only %s parameter(s) present in query."", //
							binding.getRequiredPosition(), //
							expressions.size() //
					) //
			);

			ParameterMetadata<?> metadata = expressions.get(parameterIndex);

			if (metadata.isIsNullParameter()) {
				return QueryParameterSetter.NOOP;
			}

			JpaParameter parameter = parameters.getBindableParameter(parameterIndex);
			TemporalType temporalType = parameter.isTemporalParameter() ? parameter.getRequiredTemporalType() : null;

			return new NamedOrIndexedQueryParameterSetter(values -> getAndPrepare(parameter, metadata, values),
					metadata.getExpression(), temporalType);
		}

		@Nullable
		private Object getAndPrepare(JpaParameter parameter, ParameterMetadata<?> metadata, Object[] values) {

			JpaParametersParameterAccessor accessor = new JpaParametersParameterAccessor(parameters, values);

			return metadata.prepare(accessor.getValue(parameter));
		}
	}

	private static class ParameterImpl<T> implements javax.persistence.Parameter<T> {

		private final Class<T> parameterType;
		private final @Nullable String name;
		private final @Nullable Integer position;

		/**
		 * Creates a new {@link ParameterImpl} for the given {@link JpaParameter} and {@link ParameterBinding}.
		 *
		 * @param parameter can be {@literal null}.
		 * @param binding must not be {@literal null}.
		 * @return a {@link javax.persistence.Parameter} object based on the information from the arguments.
		 */
		static javax.persistence.Parameter<?> of(@Nullable JpaParameter parameter, ParameterBinding binding) {

			Class<?> type = parameter == null ? Object.class : parameter.getType();

			return new ParameterImpl<>(type, getName(parameter, binding), binding.getPosition());
		}

		/**
		 * Creates a new {@link ParameterImpl} for the given name, position and parameter type.
		 *
		 * @param parameterType must not be {@literal null}.
		 * @param name can be {@literal null}.
		 * @param position can be {@literal null}.
		 */
		private ParameterImpl(Class<T> parameterType, @Nullable String name, @Nullable Integer position) {

			this.name = name;
			this.position = position;
			this.parameterType = parameterType;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getName()
		 */
		@Nullable
		@Override
		public String getName() {
			return name;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getPosition()
		 */
		@Nullable
		@Override
		public Integer getPosition() {
			return position;
		}

		/*
		 * (non-Javadoc)
		 * @see javax.persistence.Parameter#getParameterType()
		 */
		@Override
		public Class<T> getParameterType() {
			return parameterType;
		}

		@Nullable
		private static String getName(@Nullable JpaParameter parameter, ParameterBinding binding) {

			if (parameter == null) {
				return binding.getName();
			}

			return parameter.isNamedParameter() //
					? parameter.getName().orElseThrow(() -> new IllegalArgumentException(""o_O parameter needs to have a name!"")) //
					: null;
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaEvaluationContextExtension.java,"/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import org.springframework.data.jpa.repository.query.EscapeCharacter;
import org.springframework.data.spel.spi.EvaluationContextExtension;

/**
 * {@link EvaluationContextExtension} to register {@link EscapeCharacter} as root object to essentially expose an
 * {@code expose(â€¦)} function to SpEL.
 *
 * @author Oliver Drotbohm
 */
public class JpaEvaluationContextExtension implements EvaluationContextExtension {

	private final EscapeCharacter character;

	/**
	 * Creates a new {@link JpaEvaluationContextExtension} for the given escape character.
	 *
	 * @param escapeCharacter the character to be used to escape parameters for LIKE expression.
	 */
	public JpaEvaluationContextExtension(char escapeCharacter) {
		this.character = EscapeCharacter.of(escapeCharacter);
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.spel.spi.EvaluationContextExtension#getExtensionId()
	 */
	@Override
	public String getExtensionId() {
		return ""jpa"";
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.spel.spi.EvaluationContextExtension#getRootObject()
	 */
	@Override
	public Object getRootObject() {
		return character;
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaEvaluationContextExtension.java,"/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import lombok.RequiredArgsConstructor;

import org.springframework.data.jpa.repository.query.EscapeCharacter;
import org.springframework.data.repository.query.spi.EvaluationContextExtension;
import org.springframework.data.repository.query.spi.EvaluationContextExtensionSupport;

/**
 * {@link EvaluationContextExtension} to register {@link EscapeCharacter} as root object to essentially expose an
 * {@code expose(â€¦)} function to SpEL.
 *
 * @author Oliver Drotbohm
 */
public class JpaEvaluationContextExtension extends EvaluationContextExtensionSupport {

	private final JpaRootObject root;

	/**
	 * Creates a new {@link JpaEvaluationContextExtension} for the given escape character.
	 *
	 * @param escapeCharacter the character to be used to escape parameters for LIKE expression.
	 */
	public JpaEvaluationContextExtension(char escapeCharacter) {
		this.root = JpaRootObject.of(EscapeCharacter.of(escapeCharacter));
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.spel.spi.EvaluationContextExtension#getExtensionId()
	 */
	@Override
	public String getExtensionId() {
		return ""jpa"";
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.spel.spi.EvaluationContextExtension#getRootObject()
	 */
	@Override
	public Object getRootObject() {
		return root;
	}

	@RequiredArgsConstructor(staticName = ""of"")
	public static class JpaRootObject {

		private final EscapeCharacter character;

		/**
		 * Escapes the given source {@link String} for LIKE expressions.
		 *
		 * @param source can be {@literal null}.
		 * @return
		 * @see EscapeCharacter#escape(String)
		 */
		public String escape(String source) {
			return character.escape(source);
		}

		/**
		 * Returns the escape character being used to escape special characters for LIKE expressions.
		 *
		 * @return
		 */
		public char escapeCharacter() {
			return character.getEscapeCharacter();
		}
	}
}
",1
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryBean.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.springframework.data.mapping.context.MappingContext;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.core.support.TransactionalRepositoryFactoryBeanSupport;
import org.springframework.data.jpa.repository.query.EscapeCharacter;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Special adapter for Springs {@link org.springframework.beans.factory.FactoryBean} interface to allow easy setup of
 * repository factories via Spring configuration.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Mark Paluch
 * @param <T> the type of the repository
 */
public class JpaRepositoryFactoryBean<T extends Repository<S, ID>, S, ID>
		extends TransactionalRepositoryFactoryBeanSupport<T, S, ID> {

	private @Nullable EntityManager entityManager;
	/**
	 * Creates a new {@link JpaRepositoryFactoryBean} for the given repository interface.
	 *
	 * @param repositoryInterface must not be {@literal null}.
	 */
	public JpaRepositoryFactoryBean(Class<? extends T> repositoryInterface) {
		super(repositoryInterface);
	}

	/**
	 * The {@link EntityManager} to be used.
	 *
	 * @param entityManager the entityManager to set
	 */
	@PersistenceContext
	public void setEntityManager(EntityManager entityManager) {
		this.entityManager = entityManager;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport#setMappingContext(org.springframework.data.mapping.context.MappingContext)
	 */
	@Override
	public void setMappingContext(MappingContext<?, ?> mappingContext) {
		super.setMappingContext(mappingContext);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.springframework.data.repository.support.
	 * TransactionalRepositoryFactoryBeanSupport#doCreateRepositoryFactory()
	 */
	@Override
	protected RepositoryFactorySupport doCreateRepositoryFactory() {

		Assert.state(entityManager != null,""EntityManager must not be null!"");

		return createRepositoryFactory(entityManager);
	}

	/**
	 * Returns a {@link RepositoryFactorySupport}.
	 *
	 * @param entityManager
	 * @return
	 */
	protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {

		JpaRepositoryFactory jpaRepositoryFactory = new JpaRepositoryFactory(entityManager);
		jpaRepositoryFactory.setEscapeCharacter(escapeCharacter);

		return jpaRepositoryFactory;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() {

		Assert.state(entityManager != null,""EntityManager must not be null!"");
		super.afterPropertiesSet();
	}

	public void setEscapeCharacter(char escapeCharacter) {

		this.escapeCharacter = EscapeCharacter.of(escapeCharacter);
	}
}
",0
CVE-2019-3797,src/main/java/org/springframework/data/jpa/repository/support/JpaRepositoryFactoryBean.java,"/*
 * Copyright 2008-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jpa.repository.support;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.springframework.data.jpa.repository.query.EscapeCharacter;
import org.springframework.data.mapping.context.MappingContext;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.core.support.RepositoryFactorySupport;
import org.springframework.data.repository.core.support.TransactionalRepositoryFactoryBeanSupport;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Special adapter for Springs {@link org.springframework.beans.factory.FactoryBean} interface to allow easy setup of
 * repository factories via Spring configuration.
 *
 * @author Oliver Gierke
 * @author Eberhard Wolff
 * @author Mark Paluch
 * @param <T> the type of the repository
 */
public class JpaRepositoryFactoryBean<T extends Repository<S, ID>, S, ID>
		extends TransactionalRepositoryFactoryBeanSupport<T, S, ID> {

	private @Nullable EntityManager entityManager;
	private EscapeCharacter escapeCharacter = EscapeCharacter.of('\\');

	/**
	 * Creates a new {@link JpaRepositoryFactoryBean} for the given repository interface.
	 *
	 * @param repositoryInterface must not be {@literal null}.
	 */
	public JpaRepositoryFactoryBean(Class<? extends T> repositoryInterface) {
		super(repositoryInterface);
	}

	/**
	 * Configures the escape character to be used to escape reserved characters in LIKE expressions.
	 *
	 * @param escapeCharacter
	 */
	public void setEscapeCharacter(char escapeCharacter) {
		this.escapeCharacter = EscapeCharacter.of(escapeCharacter);
	}

	/**
	 * The {@link EntityManager} to be used.
	 *
	 * @param entityManager the entityManager to set
	 */
	@PersistenceContext
	public void setEntityManager(EntityManager entityManager) {
		this.entityManager = entityManager;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport#setMappingContext(org.springframework.data.mapping.context.MappingContext)
	 */
	@Override
	public void setMappingContext(MappingContext<?, ?> mappingContext) {
		super.setMappingContext(mappingContext);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.springframework.data.repository.support.
	 * TransactionalRepositoryFactoryBeanSupport#doCreateRepositoryFactory()
	 */
	@Override
	protected RepositoryFactorySupport doCreateRepositoryFactory() {

		Assert.state(entityManager != null, ""EntityManager must not be null!"");

		return createRepositoryFactory(entityManager);
	}

	/**
	 * Returns a {@link RepositoryFactorySupport}.
	 *
	 * @param entityManager
	 * @return
	 */
	protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {

		JpaRepositoryFactory jpaRepositoryFactory = new JpaRepositoryFactory(entityManager);
		jpaRepositoryFactory.setEscapeCharacter(escapeCharacter);

		return jpaRepositoryFactory;
	}

	/*
	 * (non-Javadoc)
	 * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() {

		Assert.state(entityManager != null, ""EntityManager must not be null!"");
		super.afterPropertiesSet();
	}
}
",1
CVE-2018-12418,src/main/java/com/github/junrar/Archive.java,"/*
 * Copyright (c) 2007 innoSysTec (R) GmbH, Germany. All rights reserved.
 * Original author: Edmund Wagner
 * Creation date: 22.05.2007
 *
 * Source: $HeadURL$
 * Last changed: $LastChangedDate$
 *
 * the unrar licence applies to all junrar source and binary distributions
 * you are not allowed to use this source to re-create the RAR compression
 * algorithm
 *
 * Here some html entities which can be used for escaping javadoc tags:
 * ""&"":  ""&#038;"" or ""&amp;""
 * ""<"":  ""&#060;"" or ""&lt;""
 * "">"":  ""&#062;"" or ""&gt;""
 * ""@"":  ""&#064;""
 */
package com.github.junrar;

import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.github.junrar.exception.RarException;
import com.github.junrar.exception.RarException.RarExceptionType;
import com.github.junrar.impl.FileVolumeManager;
import com.github.junrar.io.IReadOnlyAccess;
import com.github.junrar.rarfile.AVHeader;
import com.github.junrar.rarfile.BaseBlock;
import com.github.junrar.rarfile.BlockHeader;
import com.github.junrar.rarfile.CommentHeader;
import com.github.junrar.rarfile.EAHeader;
import com.github.junrar.rarfile.EndArcHeader;
import com.github.junrar.rarfile.FileHeader;
import com.github.junrar.rarfile.MacInfoHeader;
import com.github.junrar.rarfile.MainHeader;
import com.github.junrar.rarfile.MarkHeader;
import com.github.junrar.rarfile.ProtectHeader;
import com.github.junrar.rarfile.SignHeader;
import com.github.junrar.rarfile.SubBlockHeader;
import com.github.junrar.rarfile.UnixOwnersHeader;
import com.github.junrar.rarfile.UnrarHeadertype;
import com.github.junrar.unpack.ComprDataIO;
import com.github.junrar.unpack.Unpack;


/**
 * The Main Rar Class; represents a rar Archive
 * 
 * @author $LastChangedBy$
 * @version $LastChangedRevision$
 */
public class Archive implements Closeable {
	private static Logger logger = Logger.getLogger(Archive.class.getName());

	private IReadOnlyAccess rof;

	private final UnrarCallback unrarCallback;

	private final ComprDataIO dataIO;

	private final List<BaseBlock> headers = new ArrayList<BaseBlock>();

	private MarkHeader markHead = null;

	private MainHeader newMhd = null;

	private Unpack unpack;

	private int currentHeaderIndex;

	/** Size of packed data in current file. */
	private long totalPackedSize = 0L;

	/** Number of bytes of compressed data read from current file. */
	private long totalPackedRead = 0L;

	private VolumeManager volumeManager;
	private Volume volume;

	public Archive(VolumeManager volumeManager) throws RarException,
			IOException {
		this(volumeManager, null);
	}

	/**
	 * create a new archive object using the given {@link VolumeManager}
	 * 
	 * @param volumeManager
	 *            the the {@link VolumeManager} that will provide volume stream
	 *            data
	 * @throws RarException
	 */
	public Archive(VolumeManager volumeManager, UnrarCallback unrarCallback)
			throws RarException, IOException {
		this.volumeManager = volumeManager;
		this.unrarCallback = unrarCallback;

		setVolume(this.volumeManager.nextArchive(this, null));
		dataIO = new ComprDataIO(this);
	}

	public Archive(File firstVolume) throws RarException, IOException {
		this(new FileVolumeManager(firstVolume), null);
	}

	public Archive(File firstVolume, UnrarCallback unrarCallback)
			throws RarException, IOException {
		this(new FileVolumeManager(firstVolume), unrarCallback);
	}

	// public File getFile() {
	// return file;
	// }
	//
	// void setFile(File file) throws IOException {
	// this.file = file;
	// setFile(new ReadOnlyAccessFile(file), file.length());
	// }

	private void setFile(IReadOnlyAccess file, long length) throws IOException {
		totalPackedSize = 0L;
		totalPackedRead = 0L;
		close();
		rof = file;
		try {
			readHeaders(length);
		} catch (Exception e) {
			logger.log(Level.WARNING,
					""exception in archive constructor maybe file is encrypted ""
							+ ""or currupt"", e);
			// ignore exceptions to allow exraction of working files in
			// corrupt archive
		}
		// Calculate size of packed data
		for (BaseBlock block : headers) {
			if (block.getHeaderType() == UnrarHeadertype.FileHeader) {
				totalPackedSize += ((FileHeader) block).getFullPackSize();
			}
		}
		if (unrarCallback != null) {
			unrarCallback.volumeProgressChanged(totalPackedRead,
					totalPackedSize);
		}
	}

	public void bytesReadRead(int count) {
		if (count > 0) {
			totalPackedRead += count;
			if (unrarCallback != null) {
				unrarCallback.volumeProgressChanged(totalPackedRead,
						totalPackedSize);
			}
		}
	}

	public IReadOnlyAccess getRof() {
		return rof;
	}

	/**
	 * Gets all of the headers in the archive.
	 *
	 * @return returns the headers.
	 */
	public List<BaseBlock> getHeaders() {
		return new ArrayList<BaseBlock>(headers);
	}

	/**
	 * @return returns all file headers of the archive
	 */
	public List<FileHeader> getFileHeaders() {
		List<FileHeader> list = new ArrayList<FileHeader>();
		for (BaseBlock block : headers) {
			if (block.getHeaderType().equals(UnrarHeadertype.FileHeader)) {
				list.add((FileHeader) block);
			}
		}
		return list;
	}

	public FileHeader nextFileHeader() {
		int n = headers.size();
		while (currentHeaderIndex < n) {
			BaseBlock block = headers.get(currentHeaderIndex++);
			if (block.getHeaderType() == UnrarHeadertype.FileHeader) {
				return (FileHeader) block;
			}
		}
		return null;
	}

	public UnrarCallback getUnrarCallback() {
		return unrarCallback;
	}

	/**
	 * 
	 * @return whether the archive is encrypted
	 */
	public boolean isEncrypted() {
		if (newMhd != null) {
			return newMhd.isEncrypted();
		} else {
			throw new NullPointerException(""mainheader is null"");
		}
	}

	/**
	 * Read the headers of the archive
	 * 
	 * @param fileLength
	 *            Length of file.
	 * @throws RarException
	 */
	private void readHeaders(long fileLength) throws IOException, RarException {
		markHead = null;
		newMhd = null;
		headers.clear();
		currentHeaderIndex = 0;
		int toRead = 0;

		while (true) {
			int size = 0;
			long newpos = 0;
			byte[] baseBlockBuffer = new byte[BaseBlock.BaseBlockSize];

			long position = rof.getPosition();

			// Weird, but is trying to read beyond the end of the file
			if (position >= fileLength) {
				break;
			}

			// logger.info(""\n--------reading header--------"");
			size = rof.readFully(baseBlockBuffer, BaseBlock.BaseBlockSize);
			if (size == 0) {
				break;
			}
			BaseBlock block = new BaseBlock(baseBlockBuffer);

			block.setPositionInFile(position);

			switch (block.getHeaderType()) {

			case MarkHeader:
				markHead = new MarkHeader(block);
				if (!markHead.isSignature()) {
					throw new RarException(
							RarException.RarExceptionType.badRarArchive);
				}
				headers.add(markHead);
				// markHead.print();
				break;

			case MainHeader:
				toRead = block.hasEncryptVersion() ? MainHeader.mainHeaderSizeWithEnc
						: MainHeader.mainHeaderSize;
				byte[] mainbuff = new byte[toRead];
				rof.readFully(mainbuff, toRead);
				MainHeader mainhead = new MainHeader(block, mainbuff);
				headers.add(mainhead);
				this.newMhd = mainhead;
				if (newMhd.isEncrypted()) {
					throw new RarException(
							RarExceptionType.rarEncryptedException);
				}
				// mainhead.print();
				break;

			case SignHeader:
				toRead = SignHeader.signHeaderSize;
				byte[] signBuff = new byte[toRead];
				rof.readFully(signBuff, toRead);
				SignHeader signHead = new SignHeader(block, signBuff);
				headers.add(signHead);
				// logger.info(""HeaderType: SignHeader"");

				break;

			case AvHeader:
				toRead = AVHeader.avHeaderSize;
				byte[] avBuff = new byte[toRead];
				rof.readFully(avBuff, toRead);
				AVHeader avHead = new AVHeader(block, avBuff);
				headers.add(avHead);
				// logger.info(""headertype: AVHeader"");
				break;

			case CommHeader:
				toRead = CommentHeader.commentHeaderSize;
				byte[] commBuff = new byte[toRead];
				rof.readFully(commBuff, toRead);
				CommentHeader commHead = new CommentHeader(block, commBuff);
				headers.add(commHead);
				// logger.info(""method: ""+commHead.getUnpMethod()+""; 0x""+
				// Integer.toHexString(commHead.getUnpMethod()));
				newpos = commHead.getPositionInFile()
						+ commHead.getHeaderSize();
				rof.setPosition(newpos);

				break;
			case EndArcHeader:

				toRead = 0;
				if (block.hasArchiveDataCRC()) {
					toRead += EndArcHeader.endArcArchiveDataCrcSize;
				}
				if (block.hasVolumeNumber()) {
					toRead += EndArcHeader.endArcVolumeNumberSize;
				}
				EndArcHeader endArcHead;
				if (toRead > 0) {
					byte[] endArchBuff = new byte[toRead];
					rof.readFully(endArchBuff, toRead);
					endArcHead = new EndArcHeader(block, endArchBuff);
					// logger.info(""HeaderType: endarch\ndatacrc:""+
					// endArcHead.getArchiveDataCRC());
				} else {
					// logger.info(""HeaderType: endarch - no Data"");
					endArcHead = new EndArcHeader(block, null);
				}
				headers.add(endArcHead);
				// logger.info(""\n--------end header--------"");
				return;

			default:
				byte[] blockHeaderBuffer = new byte[BlockHeader.blockHeaderSize];
				rof.readFully(blockHeaderBuffer, BlockHeader.blockHeaderSize);
				BlockHeader blockHead = new BlockHeader(block,
						blockHeaderBuffer);

				switch (blockHead.getHeaderType()) {
				case NewSubHeader:
				case FileHeader:
					toRead = blockHead.getHeaderSize()
							- BlockHeader.BaseBlockSize
							- BlockHeader.blockHeaderSize;
					byte[] fileHeaderBuffer = new byte[toRead];
					rof.readFully(fileHeaderBuffer, toRead);

					FileHeader fh = new FileHeader(blockHead, fileHeaderBuffer);
					headers.add(fh);
					newpos = fh.getPositionInFile() + fh.getHeaderSize()
							+ fh.getFullPackSize();
					rof.setPosition(newpos);
					break;

				case ProtectHeader:
					toRead = blockHead.getHeaderSize()
							- BlockHeader.BaseBlockSize
							- BlockHeader.blockHeaderSize;
					byte[] protectHeaderBuffer = new byte[toRead];
					rof.readFully(protectHeaderBuffer, toRead);
					ProtectHeader ph = new ProtectHeader(blockHead,
							protectHeaderBuffer);

					newpos = ph.getPositionInFile() + ph.getHeaderSize()
							+ ph.getDataSize();
					rof.setPosition(newpos);
					break;

				case SubHeader: {
					byte[] subHeadbuffer = new byte[SubBlockHeader.SubBlockHeaderSize];
					rof.readFully(subHeadbuffer,
							SubBlockHeader.SubBlockHeaderSize);
					SubBlockHeader subHead = new SubBlockHeader(blockHead,
							subHeadbuffer);
					subHead.print();
					switch (subHead.getSubType()) {
					case MAC_HEAD: {
						byte[] macHeaderbuffer = new byte[MacInfoHeader.MacInfoHeaderSize];
						rof.readFully(macHeaderbuffer,
								MacInfoHeader.MacInfoHeaderSize);
						MacInfoHeader macHeader = new MacInfoHeader(subHead,
								macHeaderbuffer);
						macHeader.print();
						headers.add(macHeader);

						break;
					}
					// TODO implement other subheaders
					case BEEA_HEAD:
						break;
					case EA_HEAD: {
						byte[] eaHeaderBuffer = new byte[EAHeader.EAHeaderSize];
						rof.readFully(eaHeaderBuffer, EAHeader.EAHeaderSize);
						EAHeader eaHeader = new EAHeader(subHead,
								eaHeaderBuffer);
						eaHeader.print();
						headers.add(eaHeader);

						break;
					}
					case NTACL_HEAD:
						break;
					case STREAM_HEAD:
						break;
					case UO_HEAD:
						toRead = subHead.getHeaderSize();
						toRead -= BaseBlock.BaseBlockSize;
						toRead -= BlockHeader.blockHeaderSize;
						toRead -= SubBlockHeader.SubBlockHeaderSize;
						byte[] uoHeaderBuffer = new byte[toRead];
						rof.readFully(uoHeaderBuffer, toRead);
						UnixOwnersHeader uoHeader = new UnixOwnersHeader(
								subHead, uoHeaderBuffer);
						uoHeader.print();
						headers.add(uoHeader);
						break;
					default:
						break;
					}

					break;
				}
				default:
					logger.warning(""Unknown Header"");
					throw new RarException(RarExceptionType.notRarArchive);

				}
			}
			// logger.info(""\n--------end header--------"");
		}
	}

	/**
	 * Extract the file specified by the given header and write it to the
	 * supplied output stream
	 * 
	 * @param hd
	 *            the header to be extracted
	 * @param os
	 *            the outputstream
	 * @throws RarException
	 */
	public void extractFile(FileHeader hd, OutputStream os) throws RarException {
		if (!headers.contains(hd)) {
			throw new RarException(RarExceptionType.headerNotInArchive);
		}
		try {
			doExtractFile(hd, os);
		} catch (Exception e) {
			if (e instanceof RarException) {
				throw (RarException) e;
			} else {
				throw new RarException(e);
			}
		}
	}

	/**
	 * Returns an {@link InputStream} that will allow to read the file and
	 * stream it. Please note that this method will create a new Thread and an a
	 * pair of Pipe streams.
	 * 
	 * @param hd
	 *            the header to be extracted
	 * @throws RarException
	 * @throws IOException
	 *             if any IO error occur
	 */
	public InputStream getInputStream(final FileHeader hd) throws RarException,
			IOException {
		final PipedInputStream in = new PipedInputStream(32 * 1024);
		final PipedOutputStream out = new PipedOutputStream(in);

		// creates a new thread that will write data to the pipe. Data will be
		// available in another InputStream, connected to the OutputStream.
		new Thread(new Runnable() {
			public void run() {
				try {
					extractFile(hd, out);
				} catch (RarException e) {
				} finally {
					try {
						out.close();
					} catch (IOException e) {
					}
				}
			}
		}).start();

		return in;
	}

	private void doExtractFile(FileHeader hd, OutputStream os)
			throws RarException, IOException {
		dataIO.init(os);
		dataIO.init(hd);
		dataIO.setUnpFileCRC(this.isOldFormat() ? 0 : 0xffFFffFF);
		if (unpack == null) {
			unpack = new Unpack(dataIO);
		}
		if (!hd.isSolid()) {
			unpack.init(null);
		}
		unpack.setDestSize(hd.getFullUnpackSize());
		try {
			unpack.doUnpack(hd.getUnpVersion(), hd.isSolid());
			// Verify file CRC
			hd = dataIO.getSubHeader();
			long actualCRC = hd.isSplitAfter() ? ~dataIO.getPackedCRC()
					: ~dataIO.getUnpFileCRC();
			int expectedCRC = hd.getFileCRC();
			if (actualCRC != expectedCRC) {
				throw new RarException(RarExceptionType.crcError);
			}
			// if (!hd.isSplitAfter()) {
			// // Verify file CRC
			// if(~dataIO.getUnpFileCRC() != hd.getFileCRC()){
			// throw new RarException(RarExceptionType.crcError);
			// }
			// }
		} catch (Exception e) {
			unpack.cleanUp();
			if (e instanceof RarException) {
				// throw new RarException((RarException)e);
				throw (RarException) e;
			} else {
				throw new RarException(e);
			}
		}
	}

	/**
	 * @return returns the main header of this archive
	 */
	public MainHeader getMainHeader() {
		return newMhd;
	}

	/**
	 * @return whether the archive is old format
	 */
	public boolean isOldFormat() {
		return markHead.isOldFormat();
	}

	/** Close the underlying compressed file. */
	public void close() throws IOException {
		if (rof != null) {
			rof.close();
			rof = null;
		}
		if (unpack != null) {
			unpack.cleanUp();
		}
	}

	/**
	 * @return the volumeManager
	 */
	public VolumeManager getVolumeManager() {
		return volumeManager;
	}

	/**
	 * @param volumeManager
	 *            the volumeManager to set
	 */
	public void setVolumeManager(VolumeManager volumeManager) {
		this.volumeManager = volumeManager;
	}

	/**
	 * @return the volume
	 */
	public Volume getVolume() {
		return volume;
	}

	/**
	 * @param volume
	 *            the volume to set
	 * @throws IOException
	 */
	public void setVolume(Volume volume) throws IOException {
		this.volume = volume;
		setFile(volume.getReadOnlyAccess(), volume.getLength());
	}
}
",0
CVE-2018-12418,src/main/java/com/github/junrar/Archive.java,"/*
 * Copyright (c) 2007 innoSysTec (R) GmbH, Germany. All rights reserved.
 * Original author: Edmund Wagner
 * Creation date: 22.05.2007
 *
 * Source: $HeadURL$
 * Last changed: $LastChangedDate$
 *
 * the unrar licence applies to all junrar source and binary distributions
 * you are not allowed to use this source to re-create the RAR compression
 * algorithm
 *
 * Here some html entities which can be used for escaping javadoc tags:
 * ""&"":  ""&#038;"" or ""&amp;""
 * ""<"":  ""&#060;"" or ""&lt;""
 * "">"":  ""&#062;"" or ""&gt;""
 * ""@"":  ""&#064;""
 */
package com.github.junrar;

import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.github.junrar.exception.RarException;
import com.github.junrar.exception.RarException.RarExceptionType;
import com.github.junrar.impl.FileVolumeManager;
import com.github.junrar.io.IReadOnlyAccess;
import com.github.junrar.rarfile.AVHeader;
import com.github.junrar.rarfile.BaseBlock;
import com.github.junrar.rarfile.BlockHeader;
import com.github.junrar.rarfile.CommentHeader;
import com.github.junrar.rarfile.EAHeader;
import com.github.junrar.rarfile.EndArcHeader;
import com.github.junrar.rarfile.FileHeader;
import com.github.junrar.rarfile.MacInfoHeader;
import com.github.junrar.rarfile.MainHeader;
import com.github.junrar.rarfile.MarkHeader;
import com.github.junrar.rarfile.ProtectHeader;
import com.github.junrar.rarfile.SignHeader;
import com.github.junrar.rarfile.SubBlockHeader;
import com.github.junrar.rarfile.UnixOwnersHeader;
import com.github.junrar.rarfile.UnrarHeadertype;
import com.github.junrar.unpack.ComprDataIO;
import com.github.junrar.unpack.Unpack;


/**
 * The Main Rar Class; represents a rar Archive
 * 
 * @author $LastChangedBy$
 * @version $LastChangedRevision$
 */
public class Archive implements Closeable {
	private static Logger logger = Logger.getLogger(Archive.class.getName());

	private static int MAX_HEADER_SIZE = 20971520;//20MB

	private IReadOnlyAccess rof;

	private final UnrarCallback unrarCallback;

	private final ComprDataIO dataIO;

	private final List<BaseBlock> headers = new ArrayList<BaseBlock>();

	private MarkHeader markHead = null;

	private MainHeader newMhd = null;

	private Unpack unpack;

	private int currentHeaderIndex;

	/** Size of packed data in current file. */
	private long totalPackedSize = 0L;

	/** Number of bytes of compressed data read from current file. */
	private long totalPackedRead = 0L;

	private VolumeManager volumeManager;
	private Volume volume;

	public Archive(VolumeManager volumeManager) throws RarException,
			IOException {
		this(volumeManager, null);
	}

	/**
	 * create a new archive object using the given {@link VolumeManager}
	 * 
	 * @param volumeManager
	 *            the the {@link VolumeManager} that will provide volume stream
	 *            data
	 * @throws RarException
	 */
	public Archive(VolumeManager volumeManager, UnrarCallback unrarCallback)
			throws RarException, IOException {
		this.volumeManager = volumeManager;
		this.unrarCallback = unrarCallback;

		setVolume(this.volumeManager.nextArchive(this, null));
		dataIO = new ComprDataIO(this);
	}

	public Archive(File firstVolume) throws RarException, IOException {
		this(new FileVolumeManager(firstVolume), null);
	}

	public Archive(File firstVolume, UnrarCallback unrarCallback)
			throws RarException, IOException {
		this(new FileVolumeManager(firstVolume), unrarCallback);
	}

	// public File getFile() {
	// return file;
	// }
	//
	// void setFile(File file) throws IOException {
	// this.file = file;
	// setFile(new ReadOnlyAccessFile(file), file.length());
	// }

	private void setFile(IReadOnlyAccess file, long length) throws IOException {
		totalPackedSize = 0L;
		totalPackedRead = 0L;
		close();
		rof = file;
		try {
			readHeaders(length);
		} catch (Exception e) {
			logger.log(Level.WARNING,
					""exception in archive constructor maybe file is encrypted ""
							+ ""or currupt"", e);
			// ignore exceptions to allow exraction of working files in
			// corrupt archive
		}
		// Calculate size of packed data
		for (BaseBlock block : headers) {
			if (block.getHeaderType() == UnrarHeadertype.FileHeader) {
				totalPackedSize += ((FileHeader) block).getFullPackSize();
			}
		}
		if (unrarCallback != null) {
			unrarCallback.volumeProgressChanged(totalPackedRead,
					totalPackedSize);
		}
	}

	public void bytesReadRead(int count) {
		if (count > 0) {
			totalPackedRead += count;
			if (unrarCallback != null) {
				unrarCallback.volumeProgressChanged(totalPackedRead,
						totalPackedSize);
			}
		}
	}

	public IReadOnlyAccess getRof() {
		return rof;
	}

	/**
	 * Gets all of the headers in the archive.
	 *
	 * @return returns the headers.
	 */
	public List<BaseBlock> getHeaders() {
		return new ArrayList<BaseBlock>(headers);
	}

	/**
	 * @return returns all file headers of the archive
	 */
	public List<FileHeader> getFileHeaders() {
		List<FileHeader> list = new ArrayList<FileHeader>();
		for (BaseBlock block : headers) {
			if (block.getHeaderType().equals(UnrarHeadertype.FileHeader)) {
				list.add((FileHeader) block);
			}
		}
		return list;
	}

	public FileHeader nextFileHeader() {
		int n = headers.size();
		while (currentHeaderIndex < n) {
			BaseBlock block = headers.get(currentHeaderIndex++);
			if (block.getHeaderType() == UnrarHeadertype.FileHeader) {
				return (FileHeader) block;
			}
		}
		return null;
	}

	public UnrarCallback getUnrarCallback() {
		return unrarCallback;
	}

	/**
	 * 
	 * @return whether the archive is encrypted
	 */
	public boolean isEncrypted() {
		if (newMhd != null) {
			return newMhd.isEncrypted();
		} else {
			throw new NullPointerException(""mainheader is null"");
		}
	}

	/**
	 * Read the headers of the archive
	 * 
	 * @param fileLength
	 *            Length of file.
	 * @throws RarException
	 */
	private void readHeaders(long fileLength) throws IOException, RarException {
		markHead = null;
		newMhd = null;
		headers.clear();
		currentHeaderIndex = 0;
		int toRead = 0;
		//keep track of positions already processed for
		//more robustness against corrupt files
		Set<Long> processedPositions = new HashSet<Long>();
		while (true) {
			int size = 0;
			long newpos = 0;
			byte[] baseBlockBuffer = safelyAllocate(BaseBlock.BaseBlockSize, MAX_HEADER_SIZE);

			long position = rof.getPosition();

			// Weird, but is trying to read beyond the end of the file
			if (position >= fileLength) {
				break;
			}

			// logger.info(""\n--------reading header--------"");
			size = rof.readFully(baseBlockBuffer, BaseBlock.BaseBlockSize);
			if (size == 0) {
				break;
			}
			BaseBlock block = new BaseBlock(baseBlockBuffer);

			block.setPositionInFile(position);

			switch (block.getHeaderType()) {

			case MarkHeader:
				markHead = new MarkHeader(block);
				if (!markHead.isSignature()) {
					throw new RarException(
							RarException.RarExceptionType.badRarArchive);
				}
				headers.add(markHead);
				// markHead.print();
				break;

			case MainHeader:
				toRead = block.hasEncryptVersion() ? MainHeader.mainHeaderSizeWithEnc
						: MainHeader.mainHeaderSize;
				byte[] mainbuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
				rof.readFully(mainbuff, toRead);
				MainHeader mainhead = new MainHeader(block, mainbuff);
				headers.add(mainhead);
				this.newMhd = mainhead;
				if (newMhd.isEncrypted()) {
					throw new RarException(
							RarExceptionType.rarEncryptedException);
				}
				// mainhead.print();
				break;

			case SignHeader:
				toRead = SignHeader.signHeaderSize;
				byte[] signBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
				rof.readFully(signBuff, toRead);
				SignHeader signHead = new SignHeader(block, signBuff);
				headers.add(signHead);
				// logger.info(""HeaderType: SignHeader"");

				break;

			case AvHeader:
				toRead = AVHeader.avHeaderSize;
				byte[] avBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
				rof.readFully(avBuff, toRead);
				AVHeader avHead = new AVHeader(block, avBuff);
				headers.add(avHead);
				// logger.info(""headertype: AVHeader"");
				break;

			case CommHeader:
				toRead = CommentHeader.commentHeaderSize;
				byte[] commBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
				rof.readFully(commBuff, toRead);
				CommentHeader commHead = new CommentHeader(block, commBuff);
				headers.add(commHead);
				// logger.info(""method: ""+commHead.getUnpMethod()+""; 0x""+
				// Integer.toHexString(commHead.getUnpMethod()));
				newpos = commHead.getPositionInFile()
						+ commHead.getHeaderSize();
				if (processedPositions.contains(newpos)) {
					throw new RarException(RarExceptionType.badRarArchive);
				}
				processedPositions.add(newpos);
				rof.setPosition(newpos);

				break;
			case EndArcHeader:

				toRead = 0;
				if (block.hasArchiveDataCRC()) {
					toRead += EndArcHeader.endArcArchiveDataCrcSize;
				}
				if (block.hasVolumeNumber()) {
					toRead += EndArcHeader.endArcVolumeNumberSize;
				}
				EndArcHeader endArcHead;
				if (toRead > 0) {
					byte[] endArchBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
					rof.readFully(endArchBuff, toRead);
					endArcHead = new EndArcHeader(block, endArchBuff);
					// logger.info(""HeaderType: endarch\ndatacrc:""+
					// endArcHead.getArchiveDataCRC());
				} else {
					// logger.info(""HeaderType: endarch - no Data"");
					endArcHead = new EndArcHeader(block, null);
				}
				headers.add(endArcHead);
				// logger.info(""\n--------end header--------"");
				return;

			default:
				byte[] blockHeaderBuffer = safelyAllocate(BlockHeader.blockHeaderSize, MAX_HEADER_SIZE);
				rof.readFully(blockHeaderBuffer, BlockHeader.blockHeaderSize);
				BlockHeader blockHead = new BlockHeader(block,
						blockHeaderBuffer);

				switch (blockHead.getHeaderType()) {
				case NewSubHeader:
				case FileHeader:
					toRead = blockHead.getHeaderSize()
							- BlockHeader.BaseBlockSize
							- BlockHeader.blockHeaderSize;
					byte[] fileHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);
					rof.readFully(fileHeaderBuffer, toRead);

					FileHeader fh = new FileHeader(blockHead, fileHeaderBuffer);
					headers.add(fh);
					newpos = fh.getPositionInFile() + fh.getHeaderSize()
							+ fh.getFullPackSize();
					if (processedPositions.contains(newpos)) {
						throw new RarException(RarExceptionType.badRarArchive);
					}
					processedPositions.add(newpos);
					rof.setPosition(newpos);
					break;

				case ProtectHeader:
					toRead = blockHead.getHeaderSize()
							- BlockHeader.BaseBlockSize
							- BlockHeader.blockHeaderSize;
					byte[] protectHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);
					rof.readFully(protectHeaderBuffer, toRead);
					ProtectHeader ph = new ProtectHeader(blockHead,
							protectHeaderBuffer);
					newpos = ph.getPositionInFile() + ph.getHeaderSize()
							+ ph.getDataSize();
					if (processedPositions.contains(newpos)) {
						throw new RarException(RarExceptionType.badRarArchive);
					}
					processedPositions.add(newpos);
					rof.setPosition(newpos);
					break;

				case SubHeader: {
					byte[] subHeadbuffer = safelyAllocate(SubBlockHeader.SubBlockHeaderSize, MAX_HEADER_SIZE);
					rof.readFully(subHeadbuffer,
							SubBlockHeader.SubBlockHeaderSize);
					SubBlockHeader subHead = new SubBlockHeader(blockHead,
							subHeadbuffer);
					subHead.print();
					switch (subHead.getSubType()) {
					case MAC_HEAD: {
						byte[] macHeaderbuffer = safelyAllocate(MacInfoHeader.MacInfoHeaderSize, MAX_HEADER_SIZE);
						rof.readFully(macHeaderbuffer,
								MacInfoHeader.MacInfoHeaderSize);
						MacInfoHeader macHeader = new MacInfoHeader(subHead,
								macHeaderbuffer);
						macHeader.print();
						headers.add(macHeader);

						break;
					}
					// TODO implement other subheaders
					case BEEA_HEAD:
						break;
					case EA_HEAD: {
						byte[] eaHeaderBuffer = safelyAllocate(EAHeader.EAHeaderSize, MAX_HEADER_SIZE);
						rof.readFully(eaHeaderBuffer, EAHeader.EAHeaderSize);
						EAHeader eaHeader = new EAHeader(subHead,
								eaHeaderBuffer);
						eaHeader.print();
						headers.add(eaHeader);

						break;
					}
					case NTACL_HEAD:
						break;
					case STREAM_HEAD:
						break;
					case UO_HEAD:
						toRead = subHead.getHeaderSize();
						toRead -= BaseBlock.BaseBlockSize;
						toRead -= BlockHeader.blockHeaderSize;
						toRead -= SubBlockHeader.SubBlockHeaderSize;
						byte[] uoHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);
						rof.readFully(uoHeaderBuffer, toRead);
						UnixOwnersHeader uoHeader = new UnixOwnersHeader(
								subHead, uoHeaderBuffer);
						uoHeader.print();
						headers.add(uoHeader);
						break;
					default:
						break;
					}

					break;
				}
				default:
					logger.warning(""Unknown Header"");
					throw new RarException(RarExceptionType.notRarArchive);

				}
			}
			// logger.info(""\n--------end header--------"");
		}
	}

	private static byte[] safelyAllocate(long len, int maxSize) throws RarException {
		if (maxSize < 0) {
			throw new IllegalArgumentException(""maxsize must be >= 0"");
		}
		if (len < 0 || len > (long)maxSize) {
			throw new RarException(RarExceptionType.badRarArchive);
		}
		return new byte[(int)len];
	}

	/**
	 * Extract the file specified by the given header and write it to the
	 * supplied output stream
	 * 
	 * @param hd
	 *            the header to be extracted
	 * @param os
	 *            the outputstream
	 * @throws RarException
	 */
	public void extractFile(FileHeader hd, OutputStream os) throws RarException {
		if (!headers.contains(hd)) {
			throw new RarException(RarExceptionType.headerNotInArchive);
		}
		try {
			doExtractFile(hd, os);
		} catch (Exception e) {
			if (e instanceof RarException) {
				throw (RarException) e;
			} else {
				throw new RarException(e);
			}
		}
	}

	/**
	 * Returns an {@link InputStream} that will allow to read the file and
	 * stream it. Please note that this method will create a new Thread and an a
	 * pair of Pipe streams.
	 * 
	 * @param hd
	 *            the header to be extracted
	 * @throws RarException
	 * @throws IOException
	 *             if any IO error occur
	 */
	public InputStream getInputStream(final FileHeader hd) throws RarException,
			IOException {
		final PipedInputStream in = new PipedInputStream(32 * 1024);
		final PipedOutputStream out = new PipedOutputStream(in);

		// creates a new thread that will write data to the pipe. Data will be
		// available in another InputStream, connected to the OutputStream.
		new Thread(new Runnable() {
			public void run() {
				try {
					extractFile(hd, out);
				} catch (RarException e) {
				} finally {
					try {
						out.close();
					} catch (IOException e) {
					}
				}
			}
		}).start();

		return in;
	}

	private void doExtractFile(FileHeader hd, OutputStream os)
			throws RarException, IOException {
		dataIO.init(os);
		dataIO.init(hd);
		dataIO.setUnpFileCRC(this.isOldFormat() ? 0 : 0xffFFffFF);
		if (unpack == null) {
			unpack = new Unpack(dataIO);
		}
		if (!hd.isSolid()) {
			unpack.init(null);
		}
		unpack.setDestSize(hd.getFullUnpackSize());
		try {
			unpack.doUnpack(hd.getUnpVersion(), hd.isSolid());
			// Verify file CRC
			hd = dataIO.getSubHeader();
			long actualCRC = hd.isSplitAfter() ? ~dataIO.getPackedCRC()
					: ~dataIO.getUnpFileCRC();
			int expectedCRC = hd.getFileCRC();
			if (actualCRC != expectedCRC) {
				throw new RarException(RarExceptionType.crcError);
			}
			// if (!hd.isSplitAfter()) {
			// // Verify file CRC
			// if(~dataIO.getUnpFileCRC() != hd.getFileCRC()){
			// throw new RarException(RarExceptionType.crcError);
			// }
			// }
		} catch (Exception e) {
			unpack.cleanUp();
			if (e instanceof RarException) {
				// throw new RarException((RarException)e);
				throw (RarException) e;
			} else {
				throw new RarException(e);
			}
		}
	}

	/**
	 * @return returns the main header of this archive
	 */
	public MainHeader getMainHeader() {
		return newMhd;
	}

	/**
	 * @return whether the archive is old format
	 */
	public boolean isOldFormat() {
		return markHead.isOldFormat();
	}

	/** Close the underlying compressed file. */
	public void close() throws IOException {
		if (rof != null) {
			rof.close();
			rof = null;
		}
		if (unpack != null) {
			unpack.cleanUp();
		}
	}

	/**
	 * @return the volumeManager
	 */
	public VolumeManager getVolumeManager() {
		return volumeManager;
	}

	/**
	 * @param volumeManager
	 *            the volumeManager to set
	 */
	public void setVolumeManager(VolumeManager volumeManager) {
		this.volumeManager = volumeManager;
	}

	/**
	 * @return the volume
	 */
	public Volume getVolume() {
		return volume;
	}

	/**
	 * @param volume
	 *            the volume to set
	 * @throws IOException
	 */
	public void setVolume(Volume volume) throws IOException {
		this.volume = volume;
		setFile(volume.getReadOnlyAccess(), volume.getLength());
	}
}
",1
CVE-2019-10080,nifi-nar-bundles/nifi-standard-services/nifi-lookup-services-bundle/nifi-lookup-services/src/main/java/org/apache/nifi/lookup/configuration2/CommonsConfigurationLookupService.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.nifi.lookup.configuration2;

import java.io.File;
import java.lang.reflect.ParameterizedType;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.apache.commons.configuration2.Configuration;
import org.apache.commons.configuration2.FileBasedConfiguration;
import org.apache.commons.configuration2.builder.ConfigurationBuilderEvent;
import org.apache.commons.configuration2.builder.ReloadingFileBasedConfigurationBuilder;
import org.apache.commons.configuration2.builder.fluent.FileBasedBuilderParameters;
import org.apache.commons.configuration2.builder.fluent.Parameters;
import org.apache.commons.configuration2.event.EventListener;
import org.apache.commons.configuration2.ex.ConfigurationException;
import org.apache.commons.lang3.StringUtils;

import org.apache.nifi.annotation.lifecycle.OnEnabled;
import org.apache.nifi.components.PropertyDescriptor;
import org.apache.nifi.controller.AbstractControllerService;
import org.apache.nifi.controller.ControllerServiceInitializationContext;
import org.apache.nifi.expression.ExpressionLanguageScope;
import org.apache.nifi.controller.ConfigurationContext;
import org.apache.nifi.lookup.LookupFailureException;
import org.apache.nifi.lookup.StringLookupService;
import org.apache.nifi.processor.util.StandardValidators;
import org.apache.nifi.reporting.InitializationException;

/**
 * This abstract class defines a generic {@link LookupService} backed by an
 * Apache Commons Configuration {@link FileBasedConfiguration}.
 *
 */
public abstract class CommonsConfigurationLookupService<T extends FileBasedConfiguration> extends AbstractControllerService implements StringLookupService {

    private static final String KEY = ""key"";

    private static final Set<String> REQUIRED_KEYS = Collections.unmodifiableSet(Stream.of(KEY).collect(Collectors.toSet()));

    public static final PropertyDescriptor CONFIGURATION_FILE =
        new PropertyDescriptor.Builder()
            .name(""configuration-file"")
            .displayName(""Configuration File"")
            .description(""A configuration file"")
            .required(true)
            .addValidator(StandardValidators.FILE_EXISTS_VALIDATOR)
            .expressionLanguageSupported(ExpressionLanguageScope.VARIABLE_REGISTRY)
            .build();

    private final Class<T> resultClass = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];

    private List<PropertyDescriptor> properties;

    private volatile ReloadingFileBasedConfigurationBuilder<T> builder;

    private Configuration getConfiguration() throws LookupFailureException {
        try {
            if (builder != null) {
                return builder.getConfiguration();
            }
        } catch (final ConfigurationException e) {
            throw new LookupFailureException(""Failed to get configuration due to "" + e.getMessage(), e);
        }
        return null;
    }

    @Override
    protected List<PropertyDescriptor> getSupportedPropertyDescriptors() {
        return properties;
    }

    @Override
    protected void init(final ControllerServiceInitializationContext context) throws InitializationException {
        final List<PropertyDescriptor> properties = new ArrayList<>();
        properties.add(CONFIGURATION_FILE);
        this.properties = Collections.unmodifiableList(properties);
    }

    @OnEnabled
    public void onEnabled(final ConfigurationContext context) throws InitializationException {
        final String config = context.getProperty(CONFIGURATION_FILE).evaluateAttributeExpressions().getValue();
        final FileBasedBuilderParameters params = new Parameters().fileBased().setFile(new File(config));
        this.builder = new ReloadingFileBasedConfigurationBuilder<>(resultClass).configure(params);
        builder.addEventListener(ConfigurationBuilderEvent.CONFIGURATION_REQUEST,
            new EventListener<ConfigurationBuilderEvent>() {
                @Override
                public void onEvent(ConfigurationBuilderEvent event) {
                    if (builder.getReloadingController().checkForReloading(null)) {
                        getLogger().debug(""Reloading "" + config);
                    }
                }
            });

        try {
            // Try getting configuration to see if there is any issue, for example wrong file format.
            // Then throw InitializationException to keep this service in 'Enabling' state.
            builder.getConfiguration();
        } catch (ConfigurationException e) {
            throw new InitializationException(e);
        }
    }

    @Override
    public Optional<String> lookup(final Map<String, Object> coordinates) throws LookupFailureException {
        if (coordinates == null) {
            return Optional.empty();
        }

        final String key = coordinates.get(KEY).toString();
        if (StringUtils.isBlank(key)) {
            return Optional.empty();
        }

        final Configuration config = getConfiguration();
        if (config != null) {
            final Object value = config.getProperty(key);
            if (value != null) {
                return Optional.of(String.valueOf(value));
            }
        }

        return Optional.empty();
    }

    @Override
    public Set<String> getRequiredKeys() {
        return REQUIRED_KEYS;
    }

}
",0
CVE-2019-10080,nifi-nar-bundles/nifi-standard-services/nifi-lookup-services-bundle/nifi-lookup-services/src/main/java/org/apache/nifi/lookup/configuration2/CommonsConfigurationLookupService.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.nifi.lookup.configuration2;

import java.io.File;
import java.lang.reflect.ParameterizedType;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.apache.commons.configuration2.Configuration;
import org.apache.commons.configuration2.FileBasedConfiguration;
import org.apache.commons.configuration2.builder.ConfigurationBuilderEvent;
import org.apache.commons.configuration2.builder.ReloadingFileBasedConfigurationBuilder;
import org.apache.commons.configuration2.builder.fluent.FileBasedBuilderParameters;
import org.apache.commons.configuration2.builder.fluent.Parameters;
import org.apache.commons.configuration2.event.EventListener;
import org.apache.commons.configuration2.ex.ConfigurationException;
import org.apache.commons.lang3.StringUtils;

import org.apache.nifi.annotation.lifecycle.OnEnabled;
import org.apache.nifi.components.PropertyDescriptor;
import org.apache.nifi.controller.AbstractControllerService;
import org.apache.nifi.controller.ControllerServiceInitializationContext;
import org.apache.nifi.expression.ExpressionLanguageScope;
import org.apache.nifi.controller.ConfigurationContext;
import org.apache.nifi.lookup.LookupFailureException;
import org.apache.nifi.lookup.StringLookupService;
import org.apache.nifi.processor.util.StandardValidators;
import org.apache.nifi.reporting.InitializationException;
import org.apache.nifi.security.xml.XXEValidator;

/**
 * This abstract class defines a generic {@link LookupService} backed by an
 * Apache Commons Configuration {@link FileBasedConfiguration}.
 *
 */
public abstract class CommonsConfigurationLookupService<T extends FileBasedConfiguration> extends AbstractControllerService implements StringLookupService {

    private static final String KEY = ""key"";

    private static final Set<String> REQUIRED_KEYS = Collections.unmodifiableSet(Stream.of(KEY).collect(Collectors.toSet()));

    public static final PropertyDescriptor CONFIGURATION_FILE =
        new PropertyDescriptor.Builder()
            .name(""configuration-file"")
            .displayName(""Configuration File"")
            .description(""A configuration file"")
            .required(true)
            .addValidator(StandardValidators.FILE_EXISTS_VALIDATOR)
            .addValidator(new XXEValidator())
            .expressionLanguageSupported(ExpressionLanguageScope.VARIABLE_REGISTRY)
            .build();

    private final Class<T> resultClass = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];

    private List<PropertyDescriptor> properties;

    private volatile ReloadingFileBasedConfigurationBuilder<T> builder;

    private Configuration getConfiguration() throws LookupFailureException {
        try {
            if (builder != null) {
                return builder.getConfiguration();
            }
        } catch (final ConfigurationException e) {
            throw new LookupFailureException(""Failed to get configuration due to "" + e.getMessage(), e);
        }
        return null;
    }

    @Override
    protected List<PropertyDescriptor> getSupportedPropertyDescriptors() {
        return properties;
    }

    @Override
    protected void init(final ControllerServiceInitializationContext context) throws InitializationException {
        final List<PropertyDescriptor> properties = new ArrayList<>();
        properties.add(CONFIGURATION_FILE);
        this.properties = Collections.unmodifiableList(properties);
    }

    @OnEnabled
    public void onEnabled(final ConfigurationContext context) throws InitializationException {
        final String config = context.getProperty(CONFIGURATION_FILE).evaluateAttributeExpressions().getValue();
        final FileBasedBuilderParameters params = new Parameters().fileBased().setFile(new File(config));
        this.builder = new ReloadingFileBasedConfigurationBuilder<>(resultClass).configure(params);
        builder.addEventListener(ConfigurationBuilderEvent.CONFIGURATION_REQUEST,
            new EventListener<ConfigurationBuilderEvent>() {
                @Override
                public void onEvent(ConfigurationBuilderEvent event) {
                    if (builder.getReloadingController().checkForReloading(null)) {
                        getLogger().debug(""Reloading "" + config);
                    }
                }
            });

        try {
            // Try getting configuration to see if there is any issue, for example wrong file format.
            // Then throw InitializationException to keep this service in 'Enabling' state.
            builder.getConfiguration();
        } catch (ConfigurationException e) {
            throw new InitializationException(e);
        }
    }

    @Override
    public Optional<String> lookup(final Map<String, Object> coordinates) throws LookupFailureException {
        if (coordinates == null) {
            return Optional.empty();
        }

        final String key = coordinates.get(KEY).toString();
        if (StringUtils.isBlank(key)) {
            return Optional.empty();
        }

        final Configuration config = getConfiguration();
        if (config != null) {
            final Object value = config.getProperty(key);
            if (value != null) {
                return Optional.of(String.valueOf(value));
            }
        }

        return Optional.empty();
    }

    @Override
    public Set<String> getRequiredKeys() {
        return REQUIRED_KEYS;
    }

}
",1
CVE-2019-10080,nifi-nar-bundles/nifi-standard-services/nifi-lookup-services-bundle/nifi-lookup-services/src/test/java/org/apache/nifi/lookup/TestXMLFileLookupService.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.nifi.lookup;

import java.util.Collections;
import java.util.Optional;

import org.apache.nifi.reporting.InitializationException;
import org.apache.nifi.util.TestRunner;
import org.apache.nifi.util.TestRunners;

import org.junit.Test;

import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;

public class TestXMLFileLookupService {

    final static Optional<String> EMPTY_STRING = Optional.empty();

    @Test
    public void testXMLFileLookupService() throws InitializationException, LookupFailureException {
        final TestRunner runner = TestRunners.newTestRunner(TestProcessor.class);
        final XMLFileLookupService service = new XMLFileLookupService();

        runner.addControllerService(""xml-file-lookup-service"", service);
        runner.setProperty(service, XMLFileLookupService.CONFIGURATION_FILE, ""src/test/resources/test.xml"");
        runner.enableControllerService(service);
        runner.assertValid(service);

        final XMLFileLookupService lookupService =
            (XMLFileLookupService) runner.getProcessContext()
                .getControllerServiceLookup()
                .getControllerService(""xml-file-lookup-service"");

        assertThat(lookupService, instanceOf(LookupService.class));

        final Optional<String> property1 = lookupService.lookup(Collections.singletonMap(""key"", ""properties.property(0)""));
        assertEquals(Optional.of(""this is property 1""), property1);

        final Optional<String> property2 = lookupService.lookup(Collections.singletonMap(""key"", ""properties.property(1)""));
        assertEquals(Optional.of(""this is property 2""), property2);

        final Optional<String> property3 = lookupService.lookup(Collections.singletonMap(""key"", ""properties.property(2)[@value]""));
        assertEquals(Optional.of(""this is property 3""), property3);

        final Optional<String> property4 = lookupService.lookup(Collections.singletonMap(""key"", ""properties.property(3)""));
        assertEquals(EMPTY_STRING, property4);
    }

}
",0
CVE-2019-10080,nifi-nar-bundles/nifi-standard-services/nifi-lookup-services-bundle/nifi-lookup-services/src/test/java/org/apache/nifi/lookup/TestXMLFileLookupService.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.nifi.lookup;

import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;

import java.util.Collections;
import java.util.Optional;
import org.apache.nifi.reporting.InitializationException;
import org.apache.nifi.util.TestRunner;
import org.apache.nifi.util.TestRunners;
import org.junit.Test;

public class TestXMLFileLookupService {

    final static Optional<String> EMPTY_STRING = Optional.empty();

    @Test
    public void testXMLFileLookupService() throws InitializationException, LookupFailureException {
        final TestRunner runner = TestRunners.newTestRunner(TestProcessor.class);
        final XMLFileLookupService service = new XMLFileLookupService();

        runner.addControllerService(""xml-file-lookup-service"", service);
        runner.setProperty(service, XMLFileLookupService.CONFIGURATION_FILE, ""src/test/resources/test.xml"");
        runner.enableControllerService(service);
        runner.assertValid(service);

        final XMLFileLookupService lookupService =
            (XMLFileLookupService) runner.getProcessContext()
                .getControllerServiceLookup()
                .getControllerService(""xml-file-lookup-service"");

        assertThat(lookupService, instanceOf(LookupService.class));

        final Optional<String> property1 = lookupService.lookup(Collections.singletonMap(""key"", ""properties.property(0)""));
        assertEquals(Optional.of(""this is property 1""), property1);

        final Optional<String> property2 = lookupService.lookup(Collections.singletonMap(""key"", ""properties.property(1)""));
        assertEquals(Optional.of(""this is property 2""), property2);

        final Optional<String> property3 = lookupService.lookup(Collections.singletonMap(""key"", ""properties.property(2)[@value]""));
        assertEquals(Optional.of(""this is property 3""), property3);

        final Optional<String> property4 = lookupService.lookup(Collections.singletonMap(""key"", ""properties.property(3)""));
        assertEquals(EMPTY_STRING, property4);
    }

    @Test
    public void testXXEProtection() throws InitializationException {

        // Arrange
        final TestRunner runner = TestRunners.newTestRunner(TestProcessor.class);
        final XMLFileLookupService service = new XMLFileLookupService();
        runner.addControllerService(""xml-file-lookup-service"", service);
        runner.setProperty(service, XMLFileLookupService.CONFIGURATION_FILE, ""src/test/resources/test-xxe.xml"");

        try {
            // Act
            // Service will fail to enable because test-xxe.xml contains a DTD
            runner.enableControllerService(service);

        } catch (final Throwable e) {
            // Assert
            assertTrue(e.getMessage().contains(""contained an external entity. To prevent XXE vulnerabilities, NiFi has external entity processing disabled.""));
        }
    }
}
",1
CVE-2021-21330,aiohttp/web_middlewares.py,"import re
import warnings
from typing import TYPE_CHECKING, Awaitable, Callable, Tuple, Type, TypeVar

from .web_exceptions import HTTPMove, HTTPPermanentRedirect
from .web_request import Request
from .web_response import StreamResponse
from .web_urldispatcher import SystemRoute

__all__ = (
    ""middleware"",
    ""normalize_path_middleware"",
)

if TYPE_CHECKING:  # pragma: no cover
    from .web_app import Application

_Func = TypeVar(""_Func"")


async def _check_request_resolves(request: Request, path: str) -> Tuple[bool, Request]:
    alt_request = request.clone(rel_url=path)

    match_info = await request.app.router.resolve(alt_request)
    alt_request._match_info = match_info  # type: ignore[assignment]

    if match_info.http_exception is None:
        return True, alt_request

    return False, request


def middleware(f: _Func) -> _Func:
    warnings.warn(
        ""Middleware decorator is deprecated since 4.0 ""
        ""and its behaviour is default, ""
        ""you can simply remove this decorator."",
        DeprecationWarning,
        stacklevel=2,
    )
    return f


_Handler = Callable[[Request], Awaitable[StreamResponse]]
_Middleware = Callable[[Request, _Handler], Awaitable[StreamResponse]]


def normalize_path_middleware(
    *,
    append_slash: bool = True,
    remove_slash: bool = False,
    merge_slashes: bool = True,
    redirect_class: Type[HTTPMove] = HTTPPermanentRedirect,
) -> _Middleware:
    """"""
    Middleware factory which produces a middleware that normalizes
    the path of a request. By normalizing it means:

        - Add or remove a trailing slash to the path.
        - Double slashes are replaced by one.

    The middleware returns as soon as it finds a path that resolves
    correctly. The order if both merge and append/remove are enabled is
        1) merge slashes
        2) append/remove slash
        3) both merge slashes and append/remove slash.
    If the path resolves with at least one of those conditions, it will
    redirect to the new path.

    Only one of `append_slash` and `remove_slash` can be enabled. If both
    are `True` the factory will raise an assertion error

    If `append_slash` is `True` the middleware will append a slash when
    needed. If a resource is defined with trailing slash and the request
    comes without it, it will append it automatically.

    If `remove_slash` is `True`, `append_slash` must be `False`. When enabled
    the middleware will remove trailing slashes and redirect if the resource
    is defined

    If merge_slashes is True, merge multiple consecutive slashes in the
    path into one.
    """"""

    correct_configuration = not (append_slash and remove_slash)
    assert correct_configuration, ""Cannot both remove and append slash""

    async def impl(request: Request, handler: _Handler) -> StreamResponse:
        if isinstance(request.match_info.route, SystemRoute):
            paths_to_check = []
            if ""?"" in request.raw_path:
                path, query = request.raw_path.split(""?"", 1)
                query = ""?"" + query
            else:
                query = """"
                path = request.raw_path

            if merge_slashes:
                paths_to_check.append(re.sub(""//+"", ""/"", path))
            if append_slash and not request.path.endswith(""/""):
                paths_to_check.append(path + ""/"")
            if remove_slash and request.path.endswith(""/""):
                paths_to_check.append(path[:-1])
            if merge_slashes and append_slash:
                paths_to_check.append(re.sub(""//+"", ""/"", path + ""/""))
            if merge_slashes and remove_slash and path.endswith(""/""):
                merged_slashes = re.sub(""//+"", ""/"", path)
                paths_to_check.append(merged_slashes[:-1])

            for path in paths_to_check:
                resolves, request = await _check_request_resolves(request, path)
                if resolves:
                    raise redirect_class(request.raw_path + query)

        return await handler(request)

    return impl


def _fix_request_current_app(app: ""Application"") -> _Middleware:
    async def impl(request: Request, handler: _Handler) -> StreamResponse:
        with request.match_info.set_current_app(app):
            return await handler(request)

    return impl
",0
CVE-2021-21330,aiohttp/web_middlewares.py,"import re
import warnings
from typing import TYPE_CHECKING, Awaitable, Callable, Tuple, Type, TypeVar

from .web_exceptions import HTTPMove, HTTPPermanentRedirect
from .web_request import Request
from .web_response import StreamResponse
from .web_urldispatcher import SystemRoute

__all__ = (
    ""middleware"",
    ""normalize_path_middleware"",
)

if TYPE_CHECKING:  # pragma: no cover
    from .web_app import Application

_Func = TypeVar(""_Func"")


async def _check_request_resolves(request: Request, path: str) -> Tuple[bool, Request]:
    alt_request = request.clone(rel_url=path)

    match_info = await request.app.router.resolve(alt_request)
    alt_request._match_info = match_info  # type: ignore[assignment]

    if match_info.http_exception is None:
        return True, alt_request

    return False, request


def middleware(f: _Func) -> _Func:
    warnings.warn(
        ""Middleware decorator is deprecated since 4.0 ""
        ""and its behaviour is default, ""
        ""you can simply remove this decorator."",
        DeprecationWarning,
        stacklevel=2,
    )
    return f


_Handler = Callable[[Request], Awaitable[StreamResponse]]
_Middleware = Callable[[Request, _Handler], Awaitable[StreamResponse]]


def normalize_path_middleware(
    *,
    append_slash: bool = True,
    remove_slash: bool = False,
    merge_slashes: bool = True,
    redirect_class: Type[HTTPMove] = HTTPPermanentRedirect,
) -> _Middleware:
    """"""
    Middleware factory which produces a middleware that normalizes
    the path of a request. By normalizing it means:

        - Add or remove a trailing slash to the path.
        - Double slashes are replaced by one.

    The middleware returns as soon as it finds a path that resolves
    correctly. The order if both merge and append/remove are enabled is
        1) merge slashes
        2) append/remove slash
        3) both merge slashes and append/remove slash.
    If the path resolves with at least one of those conditions, it will
    redirect to the new path.

    Only one of `append_slash` and `remove_slash` can be enabled. If both
    are `True` the factory will raise an assertion error

    If `append_slash` is `True` the middleware will append a slash when
    needed. If a resource is defined with trailing slash and the request
    comes without it, it will append it automatically.

    If `remove_slash` is `True`, `append_slash` must be `False`. When enabled
    the middleware will remove trailing slashes and redirect if the resource
    is defined

    If merge_slashes is True, merge multiple consecutive slashes in the
    path into one.
    """"""

    correct_configuration = not (append_slash and remove_slash)
    assert correct_configuration, ""Cannot both remove and append slash""

    async def impl(request: Request, handler: _Handler) -> StreamResponse:
        if isinstance(request.match_info.route, SystemRoute):
            paths_to_check = []
            if ""?"" in request.raw_path:
                path, query = request.raw_path.split(""?"", 1)
                query = ""?"" + query
            else:
                query = """"
                path = request.raw_path

            if merge_slashes:
                paths_to_check.append(re.sub(""//+"", ""/"", path))
            if append_slash and not request.path.endswith(""/""):
                paths_to_check.append(path + ""/"")
            if remove_slash and request.path.endswith(""/""):
                paths_to_check.append(path[:-1])
            if merge_slashes and append_slash:
                paths_to_check.append(re.sub(""//+"", ""/"", path + ""/""))
            if merge_slashes and remove_slash and path.endswith(""/""):
                merged_slashes = re.sub(""//+"", ""/"", path)
                paths_to_check.append(merged_slashes[:-1])

            for path in paths_to_check:
                path = re.sub(""^//+"", ""/"", path)  # SECURITY: GHSA-v6wp-4m6f-gcjg
                resolves, request = await _check_request_resolves(request, path)
                if resolves:
                    raise redirect_class(request.raw_path + query)

        return await handler(request)

    return impl


def _fix_request_current_app(app: ""Application"") -> _Middleware:
    async def impl(request: Request, handler: _Handler) -> StreamResponse:
        with request.match_info.set_current_app(app):
            return await handler(request)

    return impl
",1
CVE-2021-21330,tests/test_web_middleware.py,"# type: ignore
from typing import Any

import pytest
from yarl import URL

from aiohttp import web


async def test_middleware_modifies_response(loop: Any, aiohttp_client: Any) -> None:
    async def handler(request):
        return web.Response(body=b""OK"")

    async def middleware(request, handler):
        resp = await handler(request)
        assert 200 == resp.status
        resp.set_status(201)
        resp.text = resp.text + ""[MIDDLEWARE]""
        return resp

    app = web.Application()
    app.middlewares.append(middleware)
    app.router.add_route(""GET"", ""/"", handler)
    client = await aiohttp_client(app)
    resp = await client.get(""/"")
    assert 201 == resp.status
    txt = await resp.text()
    assert ""OK[MIDDLEWARE]"" == txt


async def test_middleware_handles_exception(loop: Any, aiohttp_client: Any) -> None:
    async def handler(request):
        raise RuntimeError(""Error text"")

    async def middleware(request, handler):
        with pytest.raises(RuntimeError) as ctx:
            await handler(request)
        return web.Response(status=501, text=str(ctx.value) + ""[MIDDLEWARE]"")

    app = web.Application()
    app.middlewares.append(middleware)
    app.router.add_route(""GET"", ""/"", handler)
    client = await aiohttp_client(app)
    resp = await client.get(""/"")
    assert 501 == resp.status
    txt = await resp.text()
    assert ""Error text[MIDDLEWARE]"" == txt


async def test_middleware_chain(loop: Any, aiohttp_client: Any) -> None:
    async def handler(request):
        return web.Response(text=""OK"")

    handler.annotation = ""annotation_value""

    async def handler2(request):
        return web.Response(text=""OK"")

    middleware_annotation_seen_values = []

    def make_middleware(num):
        async def middleware(request, handler):
            middleware_annotation_seen_values.append(
                getattr(handler, ""annotation"", None)
            )
            resp = await handler(request)
            resp.text = resp.text + f""[{num}]""
            return resp

        return middleware

    app = web.Application()
    app.middlewares.append(make_middleware(1))
    app.middlewares.append(make_middleware(2))
    app.router.add_route(""GET"", ""/"", handler)
    app.router.add_route(""GET"", ""/r2"", handler2)
    client = await aiohttp_client(app)
    resp = await client.get(""/"")
    assert 200 == resp.status
    txt = await resp.text()
    assert ""OK[2][1]"" == txt
    assert middleware_annotation_seen_values == [""annotation_value"", ""annotation_value""]

    # check that attributes from handler are not applied to handler2
    resp = await client.get(""/r2"")
    assert 200 == resp.status
    assert middleware_annotation_seen_values == [
        ""annotation_value"",
        ""annotation_value"",
        None,
        None,
    ]


async def test_middleware_subapp(loop: Any, aiohttp_client: Any) -> None:
    async def sub_handler(request):
        return web.Response(text=""OK"")

    sub_handler.annotation = ""annotation_value""

    async def handler(request):
        return web.Response(text=""OK"")

    middleware_annotation_seen_values = []

    def make_middleware(num):
        async def middleware(request, handler):
            annotation = getattr(handler, ""annotation"", None)
            if annotation is not None:
                middleware_annotation_seen_values.append(f""{annotation}/{num}"")
            return await handler(request)

        return middleware

    app = web.Application()
    app.middlewares.append(make_middleware(1))
    app.router.add_route(""GET"", ""/r2"", handler)

    subapp = web.Application()
    subapp.middlewares.append(make_middleware(2))
    subapp.router.add_route(""GET"", ""/"", sub_handler)
    app.add_subapp(""/sub"", subapp)

    client = await aiohttp_client(app)
    resp = await client.get(""/sub/"")
    assert 200 == resp.status
    await resp.text()
    assert middleware_annotation_seen_values == [
        ""annotation_value/1"",
        ""annotation_value/2"",
    ]

    # check that attributes from sub_handler are not applied to handler
    del middleware_annotation_seen_values[:]
    resp = await client.get(""/r2"")
    assert 200 == resp.status
    assert middleware_annotation_seen_values == []


@pytest.fixture
def cli(loop: Any, aiohttp_client: Any):
    async def handler(request):
        return web.Response(text=""OK"")

    def wrapper(extra_middlewares):
        app = web.Application()
        app.router.add_route(""GET"", ""/resource1"", handler)
        app.router.add_route(""GET"", ""/resource2/"", handler)
        app.router.add_route(""GET"", ""/resource1/a/b"", handler)
        app.router.add_route(""GET"", ""/resource2/a/b/"", handler)
        app.router.add_route(""GET"", ""/resource2/a/b%2Fc/"", handler)
        app.middlewares.extend(extra_middlewares)
        return aiohttp_client(app, server_kwargs={""skip_url_asserts"": True})

    return wrapper


class TestNormalizePathMiddleware:
    @pytest.mark.parametrize(
        ""path, status"",
        [
            (""/resource1"", 200),
            (""/resource1/"", 404),
            (""/resource2"", 200),
            (""/resource2/"", 200),
            (""/resource1?p1=1&p2=2"", 200),
            (""/resource1/?p1=1&p2=2"", 404),
            (""/resource2?p1=1&p2=2"", 200),
            (""/resource2/?p1=1&p2=2"", 200),
            (""/resource2/a/b%2Fc"", 200),
            (""/resource2/a/b%2Fc/"", 200),
        ],
    )
    async def test_add_trailing_when_necessary(
        self, path: Any, status: Any, cli: Any
    ) -> None:
        extra_middlewares = [web.normalize_path_middleware(merge_slashes=False)]
        client = await cli(extra_middlewares)

        resp = await client.get(path)
        assert resp.status == status
        assert resp.url.query == URL(path).query

    @pytest.mark.parametrize(
        ""path, status"",
        [
            (""/resource1"", 200),
            (""/resource1/"", 200),
            (""/resource2"", 404),
            (""/resource2/"", 200),
            (""/resource1?p1=1&p2=2"", 200),
            (""/resource1/?p1=1&p2=2"", 200),
            (""/resource2?p1=1&p2=2"", 404),
            (""/resource2/?p1=1&p2=2"", 200),
            (""/resource2/a/b%2Fc"", 404),
            (""/resource2/a/b%2Fc/"", 200),
            (""/resource12"", 404),
            (""/resource12345"", 404),
        ],
    )
    async def test_remove_trailing_when_necessary(
        self, path: Any, status: Any, cli: Any
    ) -> None:
        extra_middlewares = [
            web.normalize_path_middleware(
                append_slash=False, remove_slash=True, merge_slashes=False
            )
        ]
        client = await cli(extra_middlewares)

        resp = await client.get(path)
        assert resp.status == status
        assert resp.url.query == URL(path).query

    @pytest.mark.parametrize(
        ""path, status"",
        [
            (""/resource1"", 200),
            (""/resource1/"", 404),
            (""/resource2"", 404),
            (""/resource2/"", 200),
            (""/resource1?p1=1&p2=2"", 200),
            (""/resource1/?p1=1&p2=2"", 404),
            (""/resource2?p1=1&p2=2"", 404),
            (""/resource2/?p1=1&p2=2"", 200),
            (""/resource2/a/b%2Fc"", 404),
            (""/resource2/a/b%2Fc/"", 200),
        ],
    )
    async def test_no_trailing_slash_when_disabled(
        self, path: Any, status: Any, cli: Any
    ) -> None:
        extra_middlewares = [
            web.normalize_path_middleware(append_slash=False, merge_slashes=False)
        ]
        client = await cli(extra_middlewares)

        resp = await client.get(path)
        assert resp.status == status
        assert resp.url.query == URL(path).query

    @pytest.mark.parametrize(
        ""path, status"",
        [
            (""/resource1/a/b"", 200),
            (""//resource1//a//b"", 200),
            (""//resource1//a//b/"", 404),
            (""///resource1//a//b"", 200),
            (""/////resource1/a///b"", 200),
            (""/////resource1/a//b/"", 404),
            (""/resource1/a/b?p=1"", 200),
            (""//resource1//a//b?p=1"", 200),
            (""//resource1//a//b/?p=1"", 404),
            (""///resource1//a//b?p=1"", 200),
            (""/////resource1/a///b?p=1"", 200),
            (""/////resource1/a//b/?p=1"", 404),
        ],
    )
    async def test_merge_slash(self, path: Any, status: Any, cli: Any) -> None:
        extra_middlewares = [web.normalize_path_middleware(append_slash=False)]
        client = await cli(extra_middlewares)

        resp = await client.get(path)
        assert resp.status == status
        assert resp.url.query == URL(path).query

    @pytest.mark.parametrize(
        ""path, status"",
        [
            (""/resource1/a/b"", 200),
            (""/resource1/a/b/"", 404),
            (""//resource2//a//b"", 200),
            (""//resource2//a//b/"", 200),
            (""///resource1//a//b"", 200),
            (""///resource1//a//b/"", 404),
            (""/////resource1/a///b"", 200),
            (""/////resource1/a///b/"", 404),
            (""/resource2/a/b"", 200),
            (""//resource2//a//b"", 200),
            (""//resource2//a//b/"", 200),
            (""///resource2//a//b"", 200),
            (""///resource2//a//b/"", 200),
            (""/////resource2/a///b"", 200),
            (""/////resource2/a///b/"", 200),
            (""/resource1/a/b?p=1"", 200),
            (""/resource1/a/b/?p=1"", 404),
            (""//resource2//a//b?p=1"", 200),
            (""//resource2//a//b/?p=1"", 200),
            (""///resource1//a//b?p=1"", 200),
            (""///resource1//a//b/?p=1"", 404),
            (""/////resource1/a///b?p=1"", 200),
            (""/////resource1/a///b/?p=1"", 404),
            (""/resource2/a/b?p=1"", 200),
            (""//resource2//a//b?p=1"", 200),
            (""//resource2//a//b/?p=1"", 200),
            (""///resource2//a//b?p=1"", 200),
            (""///resource2//a//b/?p=1"", 200),
            (""/////resource2/a///b?p=1"", 200),
            (""/////resource2/a///b/?p=1"", 200),
        ],
    )
    async def test_append_and_merge_slash(
        self, path: Any, status: Any, cli: Any
    ) -> None:
        extra_middlewares = [web.normalize_path_middleware()]

        client = await cli(extra_middlewares)
        resp = await client.get(path)
        assert resp.status == status
        assert resp.url.query == URL(path).query

    @pytest.mark.parametrize(
        ""path, status"",
        [
            (""/resource1/a/b"", 200),
            (""/resource1/a/b/"", 200),
            (""//resource2//a//b"", 404),
            (""//resource2//a//b/"", 200),
            (""///resource1//a//b"", 200),
            (""///resource1//a//b/"", 200),
            (""/////resource1/a///b"", 200),
            (""/////resource1/a///b/"", 200),
            (""/////resource1/a///b///"", 200),
            (""/resource2/a/b"", 404),
            (""//resource2//a//b"", 404),
            (""//resource2//a//b/"", 200),
            (""///resource2//a//b"", 404),
            (""///resource2//a//b/"", 200),
            (""/////resource2/a///b"", 404),
            (""/////resource2/a///b/"", 200),
            (""/resource1/a/b?p=1"", 200),
            (""/resource1/a/b/?p=1"", 200),
            (""//resource2//a//b?p=1"", 404),
            (""//resource2//a//b/?p=1"", 200),
            (""///resource1//a//b?p=1"", 200),
            (""///resource1//a//b/?p=1"", 200),
            (""/////resource1/a///b?p=1"", 200),
            (""/////resource1/a///b/?p=1"", 200),
            (""/resource2/a/b?p=1"", 404),
            (""//resource2//a//b?p=1"", 404),
            (""//resource2//a//b/?p=1"", 200),
            (""///resource2//a//b?p=1"", 404),
            (""///resource2//a//b/?p=1"", 200),
            (""/////resource2/a///b?p=1"", 404),
            (""/////resource2/a///b/?p=1"", 200),
        ],
    )
    async def test_remove_and_merge_slash(
        self, path: Any, status: Any, cli: Any
    ) -> None:
        extra_middlewares = [
            web.normalize_path_middleware(append_slash=False, remove_slash=True)
        ]

        client = await cli(extra_middlewares)
        resp = await client.get(path)
        assert resp.status == status
        assert resp.url.query == URL(path).query

    async def test_cannot_remove_and_add_slash(self) -> None:
        with pytest.raises(AssertionError):
            web.normalize_path_middleware(append_slash=True, remove_slash=True)


async def test_bug_3669(aiohttp_client: Any):
    async def paymethod(request):
        return web.Response(text=""OK"")

    app = web.Application()
    app.router.add_route(""GET"", ""/paymethod"", paymethod)
    app.middlewares.append(
        web.normalize_path_middleware(append_slash=False, remove_slash=True)
    )

    client = await aiohttp_client(app, server_kwargs={""skip_url_asserts"": True})

    resp = await client.get(""/paymethods"")
    assert resp.status == 404
    assert resp.url.path != ""/paymethod""


async def test_old_style_middleware(loop: Any, aiohttp_client: Any) -> None:
    async def view_handler(request):
        return web.Response(body=b""OK"")

    with pytest.warns(DeprecationWarning, match=""Middleware decorator is deprecated""):

        @web.middleware
        async def middleware(request, handler):
            resp = await handler(request)
            assert 200 == resp.status
            resp.set_status(201)
            resp.text = resp.text + ""[old style middleware]""
            return resp

    app = web.Application(middlewares=[middleware])
    app.router.add_route(""GET"", ""/"", view_handler)
    client = await aiohttp_client(app)
    resp = await client.get(""/"")
    assert 201 == resp.status
    txt = await resp.text()
    assert ""OK[old style middleware]"" == txt


async def test_new_style_middleware_class(loop: Any, aiohttp_client: Any) -> None:
    async def handler(request):
        return web.Response(body=b""OK"")

    class Middleware:
        async def __call__(self, request, handler):
            resp = await handler(request)
            assert 200 == resp.status
            resp.set_status(201)
            resp.text = resp.text + ""[new style middleware]""
            return resp

    with pytest.warns(None) as warning_checker:
        app = web.Application()
        app.middlewares.append(Middleware())
        app.router.add_route(""GET"", ""/"", handler)
        client = await aiohttp_client(app)
        resp = await client.get(""/"")
        assert 201 == resp.status
        txt = await resp.text()
        assert ""OK[new style middleware]"" == txt

    assert len(warning_checker) == 0


async def test_new_style_middleware_method(loop: Any, aiohttp_client: Any) -> None:
    async def handler(request):
        return web.Response(body=b""OK"")

    class Middleware:
        async def call(self, request, handler):
            resp = await handler(request)
            assert 200 == resp.status
            resp.set_status(201)
            resp.text = resp.text + ""[new style middleware]""
            return resp

    with pytest.warns(None) as warning_checker:
        app = web.Application()
        app.middlewares.append(Middleware().call)
        app.router.add_route(""GET"", ""/"", handler)
        client = await aiohttp_client(app)
        resp = await client.get(""/"")
        assert 201 == resp.status
        txt = await resp.text()
        assert ""OK[new style middleware]"" == txt

    assert len(warning_checker) == 0
",0
CVE-2021-21330,tests/test_web_middleware.py,"# type: ignore
from typing import Any

import pytest
from yarl import URL

from aiohttp import web


async def test_middleware_modifies_response(loop: Any, aiohttp_client: Any) -> None:
    async def handler(request):
        return web.Response(body=b""OK"")

    async def middleware(request, handler):
        resp = await handler(request)
        assert 200 == resp.status
        resp.set_status(201)
        resp.text = resp.text + ""[MIDDLEWARE]""
        return resp

    app = web.Application()
    app.middlewares.append(middleware)
    app.router.add_route(""GET"", ""/"", handler)
    client = await aiohttp_client(app)
    resp = await client.get(""/"")
    assert 201 == resp.status
    txt = await resp.text()
    assert ""OK[MIDDLEWARE]"" == txt


async def test_middleware_handles_exception(loop: Any, aiohttp_client: Any) -> None:
    async def handler(request):
        raise RuntimeError(""Error text"")

    async def middleware(request, handler):
        with pytest.raises(RuntimeError) as ctx:
            await handler(request)
        return web.Response(status=501, text=str(ctx.value) + ""[MIDDLEWARE]"")

    app = web.Application()
    app.middlewares.append(middleware)
    app.router.add_route(""GET"", ""/"", handler)
    client = await aiohttp_client(app)
    resp = await client.get(""/"")
    assert 501 == resp.status
    txt = await resp.text()
    assert ""Error text[MIDDLEWARE]"" == txt


async def test_middleware_chain(loop: Any, aiohttp_client: Any) -> None:
    async def handler(request):
        return web.Response(text=""OK"")

    handler.annotation = ""annotation_value""

    async def handler2(request):
        return web.Response(text=""OK"")

    middleware_annotation_seen_values = []

    def make_middleware(num):
        async def middleware(request, handler):
            middleware_annotation_seen_values.append(
                getattr(handler, ""annotation"", None)
            )
            resp = await handler(request)
            resp.text = resp.text + f""[{num}]""
            return resp

        return middleware

    app = web.Application()
    app.middlewares.append(make_middleware(1))
    app.middlewares.append(make_middleware(2))
    app.router.add_route(""GET"", ""/"", handler)
    app.router.add_route(""GET"", ""/r2"", handler2)
    client = await aiohttp_client(app)
    resp = await client.get(""/"")
    assert 200 == resp.status
    txt = await resp.text()
    assert ""OK[2][1]"" == txt
    assert middleware_annotation_seen_values == [""annotation_value"", ""annotation_value""]

    # check that attributes from handler are not applied to handler2
    resp = await client.get(""/r2"")
    assert 200 == resp.status
    assert middleware_annotation_seen_values == [
        ""annotation_value"",
        ""annotation_value"",
        None,
        None,
    ]


async def test_middleware_subapp(loop: Any, aiohttp_client: Any) -> None:
    async def sub_handler(request):
        return web.Response(text=""OK"")

    sub_handler.annotation = ""annotation_value""

    async def handler(request):
        return web.Response(text=""OK"")

    middleware_annotation_seen_values = []

    def make_middleware(num):
        async def middleware(request, handler):
            annotation = getattr(handler, ""annotation"", None)
            if annotation is not None:
                middleware_annotation_seen_values.append(f""{annotation}/{num}"")
            return await handler(request)

        return middleware

    app = web.Application()
    app.middlewares.append(make_middleware(1))
    app.router.add_route(""GET"", ""/r2"", handler)

    subapp = web.Application()
    subapp.middlewares.append(make_middleware(2))
    subapp.router.add_route(""GET"", ""/"", sub_handler)
    app.add_subapp(""/sub"", subapp)

    client = await aiohttp_client(app)
    resp = await client.get(""/sub/"")
    assert 200 == resp.status
    await resp.text()
    assert middleware_annotation_seen_values == [
        ""annotation_value/1"",
        ""annotation_value/2"",
    ]

    # check that attributes from sub_handler are not applied to handler
    del middleware_annotation_seen_values[:]
    resp = await client.get(""/r2"")
    assert 200 == resp.status
    assert middleware_annotation_seen_values == []


@pytest.fixture
def cli(loop: Any, aiohttp_client: Any):
    async def handler(request):
        return web.Response(text=""OK"")

    def wrapper(extra_middlewares):
        app = web.Application()
        app.router.add_route(""GET"", ""/resource1"", handler)
        app.router.add_route(""GET"", ""/resource2/"", handler)
        app.router.add_route(""GET"", ""/resource1/a/b"", handler)
        app.router.add_route(""GET"", ""/resource2/a/b/"", handler)
        app.router.add_route(""GET"", ""/resource2/a/b%2Fc/"", handler)
        app.middlewares.extend(extra_middlewares)
        return aiohttp_client(app, server_kwargs={""skip_url_asserts"": True})

    return wrapper


class TestNormalizePathMiddleware:
    @pytest.mark.parametrize(
        ""path, status"",
        [
            (""/resource1"", 200),
            (""/resource1/"", 404),
            (""/resource2"", 200),
            (""/resource2/"", 200),
            (""/resource1?p1=1&p2=2"", 200),
            (""/resource1/?p1=1&p2=2"", 404),
            (""/resource2?p1=1&p2=2"", 200),
            (""/resource2/?p1=1&p2=2"", 200),
            (""/resource2/a/b%2Fc"", 200),
            (""/resource2/a/b%2Fc/"", 200),
        ],
    )
    async def test_add_trailing_when_necessary(
        self, path: Any, status: Any, cli: Any
    ) -> None:
        extra_middlewares = [web.normalize_path_middleware(merge_slashes=False)]
        client = await cli(extra_middlewares)

        resp = await client.get(path)
        assert resp.status == status
        assert resp.url.query == URL(path).query

    @pytest.mark.parametrize(
        ""path, status"",
        [
            (""/resource1"", 200),
            (""/resource1/"", 200),
            (""/resource2"", 404),
            (""/resource2/"", 200),
            (""/resource1?p1=1&p2=2"", 200),
            (""/resource1/?p1=1&p2=2"", 200),
            (""/resource2?p1=1&p2=2"", 404),
            (""/resource2/?p1=1&p2=2"", 200),
            (""/resource2/a/b%2Fc"", 404),
            (""/resource2/a/b%2Fc/"", 200),
            (""/resource12"", 404),
            (""/resource12345"", 404),
        ],
    )
    async def test_remove_trailing_when_necessary(
        self, path: Any, status: Any, cli: Any
    ) -> None:
        extra_middlewares = [
            web.normalize_path_middleware(
                append_slash=False, remove_slash=True, merge_slashes=False
            )
        ]
        client = await cli(extra_middlewares)

        resp = await client.get(path)
        assert resp.status == status
        assert resp.url.query == URL(path).query

    @pytest.mark.parametrize(
        ""path, status"",
        [
            (""/resource1"", 200),
            (""/resource1/"", 404),
            (""/resource2"", 404),
            (""/resource2/"", 200),
            (""/resource1?p1=1&p2=2"", 200),
            (""/resource1/?p1=1&p2=2"", 404),
            (""/resource2?p1=1&p2=2"", 404),
            (""/resource2/?p1=1&p2=2"", 200),
            (""/resource2/a/b%2Fc"", 404),
            (""/resource2/a/b%2Fc/"", 200),
        ],
    )
    async def test_no_trailing_slash_when_disabled(
        self, path: Any, status: Any, cli: Any
    ) -> None:
        extra_middlewares = [
            web.normalize_path_middleware(append_slash=False, merge_slashes=False)
        ]
        client = await cli(extra_middlewares)

        resp = await client.get(path)
        assert resp.status == status
        assert resp.url.query == URL(path).query

    @pytest.mark.parametrize(
        ""path, status"",
        [
            (""/resource1/a/b"", 200),
            (""//resource1//a//b"", 200),
            (""//resource1//a//b/"", 404),
            (""///resource1//a//b"", 200),
            (""/////resource1/a///b"", 200),
            (""/////resource1/a//b/"", 404),
            (""/resource1/a/b?p=1"", 200),
            (""//resource1//a//b?p=1"", 200),
            (""//resource1//a//b/?p=1"", 404),
            (""///resource1//a//b?p=1"", 200),
            (""/////resource1/a///b?p=1"", 200),
            (""/////resource1/a//b/?p=1"", 404),
        ],
    )
    async def test_merge_slash(self, path: Any, status: Any, cli: Any) -> None:
        extra_middlewares = [web.normalize_path_middleware(append_slash=False)]
        client = await cli(extra_middlewares)

        resp = await client.get(path)
        assert resp.status == status
        assert resp.url.query == URL(path).query

    @pytest.mark.parametrize(
        ""path, status"",
        [
            (""/resource1/a/b"", 200),
            (""/resource1/a/b/"", 404),
            (""//resource2//a//b"", 200),
            (""//resource2//a//b/"", 200),
            (""///resource1//a//b"", 200),
            (""///resource1//a//b/"", 404),
            (""/////resource1/a///b"", 200),
            (""/////resource1/a///b/"", 404),
            (""/resource2/a/b"", 200),
            (""//resource2//a//b"", 200),
            (""//resource2//a//b/"", 200),
            (""///resource2//a//b"", 200),
            (""///resource2//a//b/"", 200),
            (""/////resource2/a///b"", 200),
            (""/////resource2/a///b/"", 200),
            (""/resource1/a/b?p=1"", 200),
            (""/resource1/a/b/?p=1"", 404),
            (""//resource2//a//b?p=1"", 200),
            (""//resource2//a//b/?p=1"", 200),
            (""///resource1//a//b?p=1"", 200),
            (""///resource1//a//b/?p=1"", 404),
            (""/////resource1/a///b?p=1"", 200),
            (""/////resource1/a///b/?p=1"", 404),
            (""/resource2/a/b?p=1"", 200),
            (""//resource2//a//b?p=1"", 200),
            (""//resource2//a//b/?p=1"", 200),
            (""///resource2//a//b?p=1"", 200),
            (""///resource2//a//b/?p=1"", 200),
            (""/////resource2/a///b?p=1"", 200),
            (""/////resource2/a///b/?p=1"", 200),
        ],
    )
    async def test_append_and_merge_slash(
        self, path: Any, status: Any, cli: Any
    ) -> None:
        extra_middlewares = [web.normalize_path_middleware()]

        client = await cli(extra_middlewares)
        resp = await client.get(path)
        assert resp.status == status
        assert resp.url.query == URL(path).query

    @pytest.mark.parametrize(
        ""path, status"",
        [
            (""/resource1/a/b"", 200),
            (""/resource1/a/b/"", 200),
            (""//resource2//a//b"", 404),
            (""//resource2//a//b/"", 200),
            (""///resource1//a//b"", 200),
            (""///resource1//a//b/"", 200),
            (""/////resource1/a///b"", 200),
            (""/////resource1/a///b/"", 200),
            (""/////resource1/a///b///"", 200),
            (""/resource2/a/b"", 404),
            (""//resource2//a//b"", 404),
            (""//resource2//a//b/"", 200),
            (""///resource2//a//b"", 404),
            (""///resource2//a//b/"", 200),
            (""/////resource2/a///b"", 404),
            (""/////resource2/a///b/"", 200),
            (""/resource1/a/b?p=1"", 200),
            (""/resource1/a/b/?p=1"", 200),
            (""//resource2//a//b?p=1"", 404),
            (""//resource2//a//b/?p=1"", 200),
            (""///resource1//a//b?p=1"", 200),
            (""///resource1//a//b/?p=1"", 200),
            (""/////resource1/a///b?p=1"", 200),
            (""/////resource1/a///b/?p=1"", 200),
            (""/resource2/a/b?p=1"", 404),
            (""//resource2//a//b?p=1"", 404),
            (""//resource2//a//b/?p=1"", 200),
            (""///resource2//a//b?p=1"", 404),
            (""///resource2//a//b/?p=1"", 200),
            (""/////resource2/a///b?p=1"", 404),
            (""/////resource2/a///b/?p=1"", 200),
        ],
    )
    async def test_remove_and_merge_slash(
        self, path: Any, status: Any, cli: Any
    ) -> None:
        extra_middlewares = [
            web.normalize_path_middleware(append_slash=False, remove_slash=True)
        ]

        client = await cli(extra_middlewares)
        resp = await client.get(path)
        assert resp.status == status
        assert resp.url.query == URL(path).query

    async def test_cannot_remove_and_add_slash(self) -> None:
        with pytest.raises(AssertionError):
            web.normalize_path_middleware(append_slash=True, remove_slash=True)

    @pytest.mark.parametrize(
        [""append_slash"", ""remove_slash""],
        [
            (True, False),
            (False, True),
            (False, False),
        ],
    )
    async def test_open_redirects(
        self, append_slash: bool, remove_slash: bool, aiohttp_client: Any
    ) -> None:
        async def handle(request: web.Request) -> web.StreamResponse:
            pytest.fail(
                msg=""Security advisory 'GHSA-v6wp-4m6f-gcjg' test handler ""
                ""matched unexpectedly"",
                pytrace=False,
            )

        app = web.Application(
            middlewares=[
                web.normalize_path_middleware(
                    append_slash=append_slash, remove_slash=remove_slash
                )
            ]
        )
        app.add_routes([web.get(""/"", handle), web.get(""/google.com"", handle)])
        client = await aiohttp_client(app, server_kwargs={""skip_url_asserts"": True})
        resp = await client.get(""//google.com"", allow_redirects=False)
        assert resp.status == 308
        assert resp.headers[""Location""] == ""/google.com""
        assert resp.url.query == URL(""//google.com"").query


async def test_bug_3669(aiohttp_client: Any):
    async def paymethod(request):
        return web.Response(text=""OK"")

    app = web.Application()
    app.router.add_route(""GET"", ""/paymethod"", paymethod)
    app.middlewares.append(
        web.normalize_path_middleware(append_slash=False, remove_slash=True)
    )

    client = await aiohttp_client(app, server_kwargs={""skip_url_asserts"": True})

    resp = await client.get(""/paymethods"")
    assert resp.status == 404
    assert resp.url.path != ""/paymethod""


async def test_old_style_middleware(loop: Any, aiohttp_client: Any) -> None:
    async def view_handler(request):
        return web.Response(body=b""OK"")

    with pytest.warns(DeprecationWarning, match=""Middleware decorator is deprecated""):

        @web.middleware
        async def middleware(request, handler):
            resp = await handler(request)
            assert 200 == resp.status
            resp.set_status(201)
            resp.text = resp.text + ""[old style middleware]""
            return resp

    app = web.Application(middlewares=[middleware])
    app.router.add_route(""GET"", ""/"", view_handler)
    client = await aiohttp_client(app)
    resp = await client.get(""/"")
    assert 201 == resp.status
    txt = await resp.text()
    assert ""OK[old style middleware]"" == txt


async def test_new_style_middleware_class(loop: Any, aiohttp_client: Any) -> None:
    async def handler(request):
        return web.Response(body=b""OK"")

    class Middleware:
        async def __call__(self, request, handler):
            resp = await handler(request)
            assert 200 == resp.status
            resp.set_status(201)
            resp.text = resp.text + ""[new style middleware]""
            return resp

    with pytest.warns(None) as warning_checker:
        app = web.Application()
        app.middlewares.append(Middleware())
        app.router.add_route(""GET"", ""/"", handler)
        client = await aiohttp_client(app)
        resp = await client.get(""/"")
        assert 201 == resp.status
        txt = await resp.text()
        assert ""OK[new style middleware]"" == txt

    assert len(warning_checker) == 0


async def test_new_style_middleware_method(loop: Any, aiohttp_client: Any) -> None:
    async def handler(request):
        return web.Response(body=b""OK"")

    class Middleware:
        async def call(self, request, handler):
            resp = await handler(request)
            assert 200 == resp.status
            resp.set_status(201)
            resp.text = resp.text + ""[new style middleware]""
            return resp

    with pytest.warns(None) as warning_checker:
        app = web.Application()
        app.middlewares.append(Middleware().call)
        app.router.add_route(""GET"", ""/"", handler)
        client = await aiohttp_client(app)
        resp = await client.get(""/"")
        assert 201 == resp.status
        txt = await resp.text()
        assert ""OK[new style middleware]"" == txt

    assert len(warning_checker) == 0
",1
CVE-2020-14060,src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java,"package com.fasterxml.jackson.databind.jsontype.impl;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import com.fasterxml.jackson.databind.BeanDescription;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonMappingException;

/**
 * Helper class used to encapsulate rules that determine subtypes that
 * are invalid to use, even with default typing, mostly due to security
 * concerns.
 * Used by <code>BeanDeserializerFacotry</code>
 *
 * @since 2.8.11
 */
public class SubTypeValidator
{
    protected final static String PREFIX_SPRING = ""org.springframework."";

    protected final static String PREFIX_C3P0 = ""com.mchange.v2.c3p0."";

    /**
     * Set of well-known ""nasty classes"", deserialization of which is considered dangerous
     * and should (and is) prevented by default.
     */
    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;
    static {
        Set<String> s = new HashSet<String>();
        // Courtesy of [https://github.com/kantega/notsoserial]:
        // (and wrt [databind#1599])
        s.add(""org.apache.commons.collections.functors.InvokerTransformer"");
        s.add(""org.apache.commons.collections.functors.InstantiateTransformer"");
        s.add(""org.apache.commons.collections4.functors.InvokerTransformer"");
        s.add(""org.apache.commons.collections4.functors.InstantiateTransformer"");
        s.add(""org.codehaus.groovy.runtime.ConvertedClosure"");
        s.add(""org.codehaus.groovy.runtime.MethodClosure"");
        s.add(""org.springframework.beans.factory.ObjectFactory"");
        s.add(""com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"");
        s.add(""org.apache.xalan.xsltc.trax.TemplatesImpl"");
        // [databind#1680]: may or may not be problem, take no chance
        s.add(""com.sun.rowset.JdbcRowSetImpl"");
        // [databind#1737]; JDK provided
        s.add(""java.util.logging.FileHandler"");
        s.add(""java.rmi.server.UnicastRemoteObject"");
        // [databind#1737]; 3rd party
//s.add(""org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor""); // deprecated by [databind#1855]
        s.add(""org.springframework.beans.factory.config.PropertyPathFactoryBean"");
        // [databind#2680]
        s.add(""org.springframework.aop.config.MethodLocatingFactoryBean"");
        s.add(""org.springframework.beans.factory.config.BeanReferenceFactoryBean"");

// s.add(""com.mchange.v2.c3p0.JndiRefForwardingDataSource""); // deprecated by [databind#1931]
// s.add(""com.mchange.v2.c3p0.WrapperConnectionPoolDataSource""); // - """" -
        // [databind#1855]: more 3rd party
        s.add(""org.apache.tomcat.dbcp.dbcp2.BasicDataSource"");
        s.add(""com.sun.org.apache.bcel.internal.util.ClassLoader"");
        // [databind#1899]: more 3rd party
        s.add(""org.hibernate.jmx.StatisticsService"");
        s.add(""org.apache.ibatis.datasource.jndi.JndiDataSourceFactory"");
        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities
        s.add(""org.apache.ibatis.parsing.XPathParser"");

        // [databind#2052]: Jodd-db, with jndi/ldap lookup
        s.add(""jodd.db.connection.DataSourceConnectionProvider"");

        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup
        s.add(""oracle.jdbc.connector.OracleManagedConnectionFactory"");
        s.add(""oracle.jdbc.rowset.OracleJDBCRowSet"");

        // [databind#2097]: some 3rd party, one JDK-bundled
        s.add(""org.slf4j.ext.EventData"");
        s.add(""flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor"");
        s.add(""com.sun.deploy.security.ruleset.DRSHelper"");
        s.add(""org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl"");

        // [databind#2186], [databind#2670]: yet more 3rd party gadgets
        s.add(""org.jboss.util.propertyeditor.DocumentEditor"");
        s.add(""org.apache.openjpa.ee.RegistryManagedRuntime"");
        s.add(""org.apache.openjpa.ee.JNDIManagedRuntime"");
        s.add(""org.apache.openjpa.ee.WASRegistryManagedRuntime""); // [#2670] addition
        s.add(""org.apache.axis2.transport.jms.JMSOutTransportInfo"");

        // [databind#2326] (2.9.9)
        s.add(""com.mysql.cj.jdbc.admin.MiniAdmin"");

        // [databind#2334]: logback-core (2.9.9.1)
        s.add(""ch.qos.logback.core.db.DriverManagerConnectionSource"");

        // [databind#2341]: jdom/jdom2 (2.9.9.1)
        s.add(""org.jdom.transform.XSLTransformer"");
        s.add(""org.jdom2.transform.XSLTransformer"");

        // [databind#2387], [databind#2460]: EHCache
        s.add(""net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup"");
        s.add(""net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup"");

        // [databind#2389]: logback/jndi
        s.add(""ch.qos.logback.core.db.JNDIConnectionSource"");

        // [databind#2410]: HikariCP/metricRegistry config
        s.add(""com.zaxxer.hikari.HikariConfig"");
        // [databind#2449]: and sub-class thereof
        s.add(""com.zaxxer.hikari.HikariDataSource"");

        // [databind#2420]: CXF/JAX-RS provider/XSLT
        s.add(""org.apache.cxf.jaxrs.provider.XSLTJaxbProvider"");

        // [databind#2462]: commons-configuration / -2
        s.add(""org.apache.commons.configuration.JNDIConfiguration"");
        s.add(""org.apache.commons.configuration2.JNDIConfiguration"");

        // [databind#2469]: xalan2
        s.add(""org.apache.xalan.lib.sql.JNDIConnectionPool"");

        // [databind#2478]: comons-dbcp, p6spy
        s.add(""org.apache.commons.dbcp.datasources.PerUserPoolDataSource"");
        s.add(""org.apache.commons.dbcp.datasources.SharedPoolDataSource"");
        s.add(""com.p6spy.engine.spy.P6DataSource"");

        // [databind#2498]: log4j-extras (1.2)
        s.add(""org.apache.log4j.receivers.db.DriverManagerConnectionSource"");
        s.add(""org.apache.log4j.receivers.db.JNDIConnectionSource"");

        // [databind#2526]: some more ehcache
        s.add(""net.sf.ehcache.transaction.manager.selector.GenericJndiSelector"");
        s.add(""net.sf.ehcache.transaction.manager.selector.GlassfishSelector"");

        // [databind#2620]: xbean-reflect
        s.add(""org.apache.xbean.propertyeditor.JndiConverter"");

        // [databind#2631]: shaded hikari-config
        s.add(""org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig"");

        // [databind#2634]: ibatis-sqlmap, anteros-core
        s.add(""com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig"");
        s.add(""br.com.anteros.dbcp.AnterosDBCPConfig"");

        // [databind#2642]: javax.swing (jdk)
        s.add(""javax.swing.JEditorPane"");

        // [databind#2648], [databind#2653]: shire-core
        s.add(""org.apache.shiro.realm.jndi.JndiRealmFactory"");
        s.add(""org.apache.shiro.jndi.JndiObjectFactory"");

        // [databind#2658]: ignite-jta (, quartz-core)
        s.add(""org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup"");
        s.add(""org.apache.ignite.cache.jta.jndi.CacheJndiTmFactory"");
        s.add(""org.quartz.utils.JNDIConnectionProvider"");

        // [databind#2659]: aries.transaction.jms
        s.add(""org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory"");
        s.add(""org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory"");

        // [databind#2660]: caucho-quercus
        s.add(""com.caucho.config.types.ResourceRef"");

        // [databind#2662]: aoju/bus-proxy
        s.add(""org.aoju.bus.proxy.provider.RmiProvider"");
        s.add(""org.aoju.bus.proxy.provider.remoting.RmiProvider"");

        // [databind#2664]: activemq-core, activemq-pool, activemq-pool-jms

        s.add(""org.apache.activemq.ActiveMQConnectionFactory""); // core
        s.add(""org.apache.activemq.ActiveMQXAConnectionFactory"");
        s.add(""org.apache.activemq.spring.ActiveMQConnectionFactory"");
        s.add(""org.apache.activemq.spring.ActiveMQXAConnectionFactory"");
        s.add(""org.apache.activemq.pool.JcaPooledConnectionFactory""); // pool
        s.add(""org.apache.activemq.pool.PooledConnectionFactory"");
        s.add(""org.apache.activemq.pool.XaPooledConnectionFactory"");
        s.add(""org.apache.activemq.jms.pool.XaPooledConnectionFactory""); // pool-jms
        s.add(""org.apache.activemq.jms.pool.JcaPooledConnectionFactory"");
        
        // [databind#2666]: apache/commons-jms
        s.add(""org.apache.commons.proxy.provider.remoting.RmiProvider"");

        // [databind#2682]: commons-jelly
        s.add(""org.apache.commons.jelly.impl.Embedded"");

        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);
    }

    /**
     * Set of class names of types that are never to be deserialized.
     */
    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;

    private final static SubTypeValidator instance = new SubTypeValidator();

    protected SubTypeValidator() { }

    public static SubTypeValidator instance() { return instance; }

    public void validateSubType(DeserializationContext ctxt, JavaType type,
            BeanDescription beanDesc) throws JsonMappingException
    {
        // There are certain nasty classes that could cause problems, mostly
        // via default typing -- catch them here.
        final Class<?> raw = type.getRawClass();
        String full = raw.getName();

        main_check:
        do {
            if (_cfgIllegalClassNames.contains(full)) {
                break;
            }

            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling
            //    for some Spring framework types
            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces
            if (raw.isInterface()) {
                ;
            } else if (full.startsWith(PREFIX_SPRING)) {
                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){
                    String name = cls.getSimpleName();
                    // looking for ""AbstractBeanFactoryPointcutAdvisor"" but no point to allow any is there?
                    if (""AbstractPointcutAdvisor"".equals(name)
                            // ditto  for ""FileSystemXmlApplicationContext"": block all ApplicationContexts
                            || ""AbstractApplicationContext"".equals(name)) {
                        break main_check;
                    }
                }
            } else if (full.startsWith(PREFIX_C3P0)) {
                // [databind#1737]; more 3rd party
                // s.add(""com.mchange.v2.c3p0.JndiRefForwardingDataSource"");
                // s.add(""com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"");
                // [databind#1931]; more 3rd party
                // com.mchange.v2.c3p0.ComboPooledDataSource
                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource 
                if (full.endsWith(""DataSource"")) {
                    break main_check;
                }
            }
            return;
        } while (false);

        ctxt.reportBadTypeDefinition(beanDesc,
                ""Illegal type (%s) to deserialize: prevented for security reasons"", full);
    }
}
",0
CVE-2020-14060,src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java,"package com.fasterxml.jackson.databind.jsontype.impl;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import com.fasterxml.jackson.databind.BeanDescription;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonMappingException;

/**
 * Helper class used to encapsulate rules that determine subtypes that
 * are invalid to use, even with default typing, mostly due to security
 * concerns.
 * Used by <code>BeanDeserializerFacotry</code>
 *
 * @since 2.8.11
 */
public class SubTypeValidator
{
    protected final static String PREFIX_SPRING = ""org.springframework."";

    protected final static String PREFIX_C3P0 = ""com.mchange.v2.c3p0."";

    /**
     * Set of well-known ""nasty classes"", deserialization of which is considered dangerous
     * and should (and is) prevented by default.
     */
    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;
    static {
        Set<String> s = new HashSet<String>();
        // Courtesy of [https://github.com/kantega/notsoserial]:
        // (and wrt [databind#1599])
        s.add(""org.apache.commons.collections.functors.InvokerTransformer"");
        s.add(""org.apache.commons.collections.functors.InstantiateTransformer"");
        s.add(""org.apache.commons.collections4.functors.InvokerTransformer"");
        s.add(""org.apache.commons.collections4.functors.InstantiateTransformer"");
        s.add(""org.codehaus.groovy.runtime.ConvertedClosure"");
        s.add(""org.codehaus.groovy.runtime.MethodClosure"");
        s.add(""org.springframework.beans.factory.ObjectFactory"");
        s.add(""com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"");
        s.add(""org.apache.xalan.xsltc.trax.TemplatesImpl"");
        // [databind#1680]: may or may not be problem, take no chance
        s.add(""com.sun.rowset.JdbcRowSetImpl"");
        // [databind#1737]; JDK provided
        s.add(""java.util.logging.FileHandler"");
        s.add(""java.rmi.server.UnicastRemoteObject"");
        // [databind#1737]; 3rd party
//s.add(""org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor""); // deprecated by [databind#1855]
        s.add(""org.springframework.beans.factory.config.PropertyPathFactoryBean"");
        // [databind#2680]
        s.add(""org.springframework.aop.config.MethodLocatingFactoryBean"");
        s.add(""org.springframework.beans.factory.config.BeanReferenceFactoryBean"");

// s.add(""com.mchange.v2.c3p0.JndiRefForwardingDataSource""); // deprecated by [databind#1931]
// s.add(""com.mchange.v2.c3p0.WrapperConnectionPoolDataSource""); // - """" -
        // [databind#1855]: more 3rd party
        s.add(""org.apache.tomcat.dbcp.dbcp2.BasicDataSource"");
        s.add(""com.sun.org.apache.bcel.internal.util.ClassLoader"");
        // [databind#1899]: more 3rd party
        s.add(""org.hibernate.jmx.StatisticsService"");
        s.add(""org.apache.ibatis.datasource.jndi.JndiDataSourceFactory"");
        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities
        s.add(""org.apache.ibatis.parsing.XPathParser"");

        // [databind#2052]: Jodd-db, with jndi/ldap lookup
        s.add(""jodd.db.connection.DataSourceConnectionProvider"");

        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup
        s.add(""oracle.jdbc.connector.OracleManagedConnectionFactory"");
        s.add(""oracle.jdbc.rowset.OracleJDBCRowSet"");

        // [databind#2097]: some 3rd party, one JDK-bundled
        s.add(""org.slf4j.ext.EventData"");
        s.add(""flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor"");
        s.add(""com.sun.deploy.security.ruleset.DRSHelper"");
        s.add(""org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl"");

        // [databind#2186], [databind#2670]: yet more 3rd party gadgets
        s.add(""org.jboss.util.propertyeditor.DocumentEditor"");
        s.add(""org.apache.openjpa.ee.RegistryManagedRuntime"");
        s.add(""org.apache.openjpa.ee.JNDIManagedRuntime"");
        s.add(""org.apache.openjpa.ee.WASRegistryManagedRuntime""); // [#2670] addition
        s.add(""org.apache.axis2.transport.jms.JMSOutTransportInfo"");

        // [databind#2326] (2.9.9)
        s.add(""com.mysql.cj.jdbc.admin.MiniAdmin"");

        // [databind#2334]: logback-core (2.9.9.1)
        s.add(""ch.qos.logback.core.db.DriverManagerConnectionSource"");

        // [databind#2341]: jdom/jdom2 (2.9.9.1)
        s.add(""org.jdom.transform.XSLTransformer"");
        s.add(""org.jdom2.transform.XSLTransformer"");

        // [databind#2387], [databind#2460]: EHCache
        s.add(""net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup"");
        s.add(""net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup"");

        // [databind#2389]: logback/jndi
        s.add(""ch.qos.logback.core.db.JNDIConnectionSource"");

        // [databind#2410]: HikariCP/metricRegistry config
        s.add(""com.zaxxer.hikari.HikariConfig"");
        // [databind#2449]: and sub-class thereof
        s.add(""com.zaxxer.hikari.HikariDataSource"");

        // [databind#2420]: CXF/JAX-RS provider/XSLT
        s.add(""org.apache.cxf.jaxrs.provider.XSLTJaxbProvider"");

        // [databind#2462]: commons-configuration / -2
        s.add(""org.apache.commons.configuration.JNDIConfiguration"");
        s.add(""org.apache.commons.configuration2.JNDIConfiguration"");

        // [databind#2469]: xalan2
        s.add(""org.apache.xalan.lib.sql.JNDIConnectionPool"");

        // [databind#2478]: comons-dbcp, p6spy
        s.add(""org.apache.commons.dbcp.datasources.PerUserPoolDataSource"");
        s.add(""org.apache.commons.dbcp.datasources.SharedPoolDataSource"");
        s.add(""com.p6spy.engine.spy.P6DataSource"");

        // [databind#2498]: log4j-extras (1.2)
        s.add(""org.apache.log4j.receivers.db.DriverManagerConnectionSource"");
        s.add(""org.apache.log4j.receivers.db.JNDIConnectionSource"");

        // [databind#2526]: some more ehcache
        s.add(""net.sf.ehcache.transaction.manager.selector.GenericJndiSelector"");
        s.add(""net.sf.ehcache.transaction.manager.selector.GlassfishSelector"");

        // [databind#2620]: xbean-reflect
        s.add(""org.apache.xbean.propertyeditor.JndiConverter"");

        // [databind#2631]: shaded hikari-config
        s.add(""org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig"");

        // [databind#2634]: ibatis-sqlmap, anteros-core
        s.add(""com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig"");
        s.add(""br.com.anteros.dbcp.AnterosDBCPConfig"");

        // [databind#2642]: javax.swing (jdk)
        s.add(""javax.swing.JEditorPane"");

        // [databind#2648], [databind#2653]: shire-core
        s.add(""org.apache.shiro.realm.jndi.JndiRealmFactory"");
        s.add(""org.apache.shiro.jndi.JndiObjectFactory"");

        // [databind#2658]: ignite-jta (, quartz-core)
        s.add(""org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup"");
        s.add(""org.apache.ignite.cache.jta.jndi.CacheJndiTmFactory"");
        s.add(""org.quartz.utils.JNDIConnectionProvider"");

        // [databind#2659]: aries.transaction.jms
        s.add(""org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory"");
        s.add(""org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory"");

        // [databind#2660]: caucho-quercus
        s.add(""com.caucho.config.types.ResourceRef"");

        // [databind#2662]: aoju/bus-proxy
        s.add(""org.aoju.bus.proxy.provider.RmiProvider"");
        s.add(""org.aoju.bus.proxy.provider.remoting.RmiProvider"");

        // [databind#2664]: activemq-core, activemq-pool, activemq-pool-jms

        s.add(""org.apache.activemq.ActiveMQConnectionFactory""); // core
        s.add(""org.apache.activemq.ActiveMQXAConnectionFactory"");
        s.add(""org.apache.activemq.spring.ActiveMQConnectionFactory"");
        s.add(""org.apache.activemq.spring.ActiveMQXAConnectionFactory"");
        s.add(""org.apache.activemq.pool.JcaPooledConnectionFactory""); // pool
        s.add(""org.apache.activemq.pool.PooledConnectionFactory"");
        s.add(""org.apache.activemq.pool.XaPooledConnectionFactory"");
        s.add(""org.apache.activemq.jms.pool.XaPooledConnectionFactory""); // pool-jms
        s.add(""org.apache.activemq.jms.pool.JcaPooledConnectionFactory"");
        
        // [databind#2666]: apache/commons-jms
        s.add(""org.apache.commons.proxy.provider.remoting.RmiProvider"");

        // [databind#2682]: commons-jelly
        s.add(""org.apache.commons.jelly.impl.Embedded"");

        // [databind#2688]: apache/drill
        s.add(""oadd.org.apache.xalan.lib.sql.JNDIConnectionPool"");

        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);
    }

    /**
     * Set of class names of types that are never to be deserialized.
     */
    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;

    private final static SubTypeValidator instance = new SubTypeValidator();

    protected SubTypeValidator() { }

    public static SubTypeValidator instance() { return instance; }

    public void validateSubType(DeserializationContext ctxt, JavaType type,
            BeanDescription beanDesc) throws JsonMappingException
    {
        // There are certain nasty classes that could cause problems, mostly
        // via default typing -- catch them here.
        final Class<?> raw = type.getRawClass();
        String full = raw.getName();

        main_check:
        do {
            if (_cfgIllegalClassNames.contains(full)) {
                break;
            }

            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling
            //    for some Spring framework types
            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces
            if (raw.isInterface()) {
                ;
            } else if (full.startsWith(PREFIX_SPRING)) {
                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){
                    String name = cls.getSimpleName();
                    // looking for ""AbstractBeanFactoryPointcutAdvisor"" but no point to allow any is there?
                    if (""AbstractPointcutAdvisor"".equals(name)
                            // ditto  for ""FileSystemXmlApplicationContext"": block all ApplicationContexts
                            || ""AbstractApplicationContext"".equals(name)) {
                        break main_check;
                    }
                }
            } else if (full.startsWith(PREFIX_C3P0)) {
                // [databind#1737]; more 3rd party
                // s.add(""com.mchange.v2.c3p0.JndiRefForwardingDataSource"");
                // s.add(""com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"");
                // [databind#1931]; more 3rd party
                // com.mchange.v2.c3p0.ComboPooledDataSource
                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource 
                if (full.endsWith(""DataSource"")) {
                    break main_check;
                }
            }
            return;
        } while (false);

        ctxt.reportBadTypeDefinition(beanDesc,
                ""Illegal type (%s) to deserialize: prevented for security reasons"", full);
    }
}
",1
CVE-2015-5171,common/src/main/java/org/cloudfoundry/identity/uaa/authentication/AuthzAuthenticationFilter.java,"/*******************************************************************************
 *     Cloud Foundry
 *     Copyright (c) [2009-2014] Pivotal Software, Inc. All Rights Reserved.
 *
 *     This product is licensed to you under the Apache License, Version 2.0 (the ""License"").
 *     You may not use this product except in compliance with the License.
 *
 *     This product includes a number of subcomponents with
 *     separate copyright notices and license terms. Your use of these
 *     subcomponents is subject to the terms and conditions of the
 *     subcomponent's license, as noted in the LICENSE file.
 *******************************************************************************/
package org.cloudfoundry.identity.uaa.authentication;

import java.io.IOException;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;

import com.fasterxml.jackson.core.type.TypeReference;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.cloudfoundry.identity.uaa.util.JsonUtils;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.provider.error.OAuth2AuthenticationEntryPoint;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.util.Assert;

/**
 * Filter which processes authentication submitted through the
 * <code>/authorize</code> endpoint.
 *
 * Checks the submitted information for a parameter named ""credentials"" (or
 * specified via the {@link #setParameterNames(List) parameter name}), in JSON
 * format.
 * <p>
 * If the parameter is found, it will submit an authentication request to the
 * AuthenticationManager and attempt to authenticate the user. If authentication
 * fails, it will return an error message. Otherwise, it creates a security
 * context and allows the request to continue.
 * <p>
 * If the parameter is not present, the filter will have no effect.
 *
 * See <a
 * href=""https://github.com/cloudfoundry/uaa/blob/master/docs/UAA-APIs.md"">UUA
 * API Docs</a>
 */
public class AuthzAuthenticationFilter implements Filter {

    private final Log logger = LogFactory.getLog(getClass());

    private AuthenticationManager authenticationManager;

    private List<String> parameterNames = Collections.emptyList();

    private AuthenticationEntryPoint authenticationEntryPoint = new OAuth2AuthenticationEntryPoint();

    private Set<String> methods = Collections.singleton(HttpMethod.POST.toString());

    /**
     * The filter fails on requests that don't have one of these HTTP methods.
     *
     * @param methods the methods to set (defaults to POST)
     */
    public void setMethods(Set<String> methods) {
        this.methods = new HashSet<>();
        for (String method : methods) {
            this.methods.add(method.toUpperCase());
        }
    }

    /**
     * @param authenticationEntryPoint the authenticationEntryPoint to set
     */
    public void setAuthenticationEntryPoint(AuthenticationEntryPoint authenticationEntryPoint) {
        this.authenticationEntryPoint = authenticationEntryPoint;
    }

    /**
     * The name of the parameter to extract credentials from. Request parameters
     * with these names are extracted and
     * passed as credentials to the authentication manager. A request that
     * doesn't have any of the specified parameters
     * is ignored.
     *
     * @param parameterNames the parameter names to set (default empty)
     */
    public void setParameterNames(List<String> parameterNames) {
        this.parameterNames = parameterNames;
    }

    public AuthzAuthenticationFilter(AuthenticationManager authenticationManager) {
        Assert.notNull(authenticationManager);
        this.authenticationManager = authenticationManager;
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException,
        ServletException {

        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse res = (HttpServletResponse) response;

        Map<String, String> loginInfo = getCredentials(req);

        boolean buggyVmcAcceptHeader = false;

        try {
            if (loginInfo.isEmpty()) {
                throw new BadCredentialsException(""Request does not contain credentials."");
            }
            else {
                logger.debug(""Located credentials in request, with keys: "" + loginInfo.keySet());
                if (methods != null && !methods.contains(req.getMethod().toUpperCase())) {
                    throw new BadCredentialsException(""Credentials must be sent by (one of methods): "" + methods);
                }
                Authentication result = authenticationManager.authenticate(new AuthzAuthenticationRequest(loginInfo,
                    new UaaAuthenticationDetails(req)));
                SecurityContextHolder.getContext().setAuthentication(result);
            }
        } catch (AuthenticationException e) {
            logger.debug(""Authentication failed"");

            String acceptHeaderValue = req.getHeader(""accept"");
            String clientId = req.getParameter(""client_id"");
            if (""*/*; q=0.5, application/xml"".equals(acceptHeaderValue) && ""vmc"".equals(clientId)) {
                buggyVmcAcceptHeader = true;
            }

            if (buggyVmcAcceptHeader) {
                HttpServletRequest jsonAcceptingRequest = new HttpServletRequestWrapper(req) {

                    @SuppressWarnings(""unchecked"")
                    @Override
                    public Enumeration<String> getHeaders(String name) {
                        if (""accept"".equalsIgnoreCase(name)) {
                            return new JsonInjectedEnumeration(((HttpServletRequest) getRequest()).getHeaders(name));
                        } else {
                            return ((HttpServletRequest) getRequest()).getHeaders(name);
                        }
                    }

                    @Override
                    public String getHeader(String name) {
                        if (name.equalsIgnoreCase(""accept"")) {
                            return ""application/json"";
                        } else {
                            return ((HttpServletRequest) getRequest()).getHeader(name);
                        }
                    }
                };

                authenticationEntryPoint.commence(jsonAcceptingRequest, res, e);
            }
            else {
                authenticationEntryPoint.commence(req, res, e);
            }
            return;
        }

        chain.doFilter(request, response);
    }

    private Map<String, String> getCredentials(HttpServletRequest request) {
        Map<String, String> credentials = new HashMap<String, String>();

        for (String paramName : parameterNames) {
            String value = request.getParameter(paramName);
            if (value != null) {
                if (value.startsWith(""{"")) {
                    try {
                        Map<String, String> jsonCredentials = JsonUtils.readValue(value,
                            new TypeReference<Map<String, String>>() {
                            });
                        credentials.putAll(jsonCredentials);
                    } catch (JsonUtils.JsonUtilException e) {
                        logger.warn(""Unknown format of value for request param: "" + paramName + "". Ignoring."");
                    }
                }
                else {
                    credentials.put(paramName, value);
                }
            }
        }

        return credentials;
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void destroy() {
    }

    static class JsonInjectedEnumeration implements Enumeration<String> {
        private Enumeration<String> underlying;

        public JsonInjectedEnumeration(Enumeration<String> underlying) {
            this.underlying = underlying;
        }

        @Override
        public boolean hasMoreElements() {
            return underlying.hasMoreElements();
        }

        @Override
        public String nextElement() {
            underlying.nextElement();
            return ""application/json"";
        }

    }
}",1
CVE-2015-5171,common/src/main/java/org/cloudfoundry/identity/uaa/authentication/UaaAuthentication.java,"/*******************************************************************************
 *     Cloud Foundry
 *     Copyright (c) [2009-2014] Pivotal Software, Inc. All Rights Reserved.
 *
 *     This product is licensed to you under the Apache License, Version 2.0 (the ""License"").
 *     You may not use this product except in compliance with the License.
 *
 *     This product includes a number of subcomponents with
 *     separate copyright notices and license terms. Your use of these
 *     subcomponents is subject to the terms and conditions of the
 *     subcomponent's license, as noted in the LICENSE file.
 *******************************************************************************/
package org.cloudfoundry.identity.uaa.authentication;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

/**
 * Authentication token which represents a user.
 */
public class UaaAuthentication implements Authentication, Serializable {
    private List<? extends GrantedAuthority> authorities;
    private Object credentials;
    private UaaPrincipal principal;
    private UaaAuthenticationDetails details;
    private boolean authenticated;

    /**
     * Creates a token with the supplied array of authorities.
     *
     * @param authorities the collection of <tt>GrantedAuthority</tt>s for the
     *            principal represented by this authentication object.
     */
    public UaaAuthentication(UaaPrincipal principal,
                             List<? extends GrantedAuthority> authorities,
                             UaaAuthenticationDetails details) {
        this(principal, null, authorities, details, true);
    }

    @JsonCreator
    public UaaAuthentication(@JsonProperty(""principal"") UaaPrincipal principal,
                             @JsonProperty(""credentials"") Object credentials,
                             @JsonProperty(""authorities"") List<? extends GrantedAuthority> authorities,
                             @JsonProperty(""details"") UaaAuthenticationDetails details,
                             @JsonProperty(""authenticated"") boolean authenticated) {
        if (principal == null || authorities == null) {
            throw new IllegalArgumentException(""principal and authorities must not be null"");
        }
        this.principal = principal;
        this.authorities = authorities;
        this.details = details;
        this.credentials = credentials;
        this.authenticated = authenticated;
    }

    @Override
    public String getName() {
        // Should we return the ID for the principal name? (No, because the
        // UaaUserDatabase retrieves users by name.)
        return principal.getName();
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    @Override
    public Object getCredentials() {
        return credentials;
    }

    @Override
    public Object getDetails() {
        return details;
    }

    @Override
    public UaaPrincipal getPrincipal() {
        return principal;
    }

    @Override
    public boolean isAuthenticated() {
        return authenticated;
    }

    @Override
    public void setAuthenticated(boolean isAuthenticated) {
        authenticated = isAuthenticated;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        UaaAuthentication that = (UaaAuthentication) o;

        if (!authorities.equals(that.authorities)) {
            return false;
        }
        if (!principal.equals(that.principal)) {
            return false;
        }

        return true;
    }

    @Override
    public int hashCode() {
        int result = authorities.hashCode();
        result = 31 * result + principal.hashCode();
        return result;
    }
}
",0
CVE-2015-5171,common/src/main/java/org/cloudfoundry/identity/uaa/authentication/UaaAuthentication.java,"/*******************************************************************************
 *     Cloud Foundry
 *     Copyright (c) [2009-2014] Pivotal Software, Inc. All Rights Reserved.
 *
 *     This product is licensed to you under the Apache License, Version 2.0 (the ""License"").
 *     You may not use this product except in compliance with the License.
 *
 *     This product includes a number of subcomponents with
 *     separate copyright notices and license terms. Your use of these
 *     subcomponents is subject to the terms and conditions of the
 *     subcomponent's license, as noted in the LICENSE file.
 *******************************************************************************/
package org.cloudfoundry.identity.uaa.authentication;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

/**
 * Authentication token which represents a user.
 */
public class UaaAuthentication implements Authentication, Serializable {
    private List<? extends GrantedAuthority> authorities;
    private Object credentials;
    private UaaPrincipal principal;
    private UaaAuthenticationDetails details;
    private boolean authenticated;
    private long authenticatedTime = -1l;

    /**
     * Creates a token with the supplied array of authorities.
     *
     * @param authorities the collection of <tt>GrantedAuthority</tt>s for the
     *            principal represented by this authentication object.
     */
    public UaaAuthentication(UaaPrincipal principal,
                             List<? extends GrantedAuthority> authorities,
                             UaaAuthenticationDetails details) {
        this(principal, null, authorities, details, true, System.currentTimeMillis());
    }

    @JsonCreator
    public UaaAuthentication(@JsonProperty(""principal"") UaaPrincipal principal,
                             @JsonProperty(""credentials"") Object credentials,
                             @JsonProperty(""authorities"") List<? extends GrantedAuthority> authorities,
                             @JsonProperty(""details"") UaaAuthenticationDetails details,
                             @JsonProperty(""authenticated"") boolean authenticated,
                             @JsonProperty(value = ""authenticatedTime"", defaultValue = ""-1"") long authenticatedTime) {
        if (principal == null || authorities == null) {
            throw new IllegalArgumentException(""principal and authorities must not be null"");
        }
        this.principal = principal;
        this.authorities = authorities;
        this.details = details;
        this.credentials = credentials;
        this.authenticated = authenticated;
        this.authenticatedTime = authenticatedTime == 0 ? -1 : authenticatedTime;
    }

    public long getAuthenticatedTime() {
        return authenticatedTime;
    }

    @Override
    @JsonIgnore
    public String getName() {
        // Should we return the ID for the principal name? (No, because the
        // UaaUserDatabase retrieves users by name.)
        return principal.getName();
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    @Override
    public Object getCredentials() {
        return credentials;
    }

    @Override
    public Object getDetails() {
        return details;
    }

    @Override
    public UaaPrincipal getPrincipal() {
        return principal;
    }

    @Override
    public boolean isAuthenticated() {
        return authenticated;
    }

    @Override
    public void setAuthenticated(boolean isAuthenticated) {
        authenticated = isAuthenticated;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        UaaAuthentication that = (UaaAuthentication) o;

        if (!authorities.equals(that.authorities)) {
            return false;
        }
        if (!principal.equals(that.principal)) {
            return false;
        }

        return true;
    }

    @Override
    public int hashCode() {
        int result = authorities.hashCode();
        result = 31 * result + principal.hashCode();
        return result;
    }
}
",1
CVE-2015-5171,common/src/main/java/org/cloudfoundry/identity/uaa/authentication/manager/AuthzAuthenticationManager.java,"/*******************************************************************************
 *     Cloud Foundry 
 *     Copyright (c) [2009-2014] Pivotal Software, Inc. All Rights Reserved.
 *
 *     This product is licensed to you under the Apache License, Version 2.0 (the ""License"").
 *     You may not use this product except in compliance with the License.
 *
 *     This product includes a number of subcomponents with
 *     separate copyright notices and license terms. Your use of these
 *     subcomponents is subject to the terms and conditions of the
 *     subcomponent's license, as noted in the LICENSE file.
 *******************************************************************************/
package org.cloudfoundry.identity.uaa.authentication.manager;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.cloudfoundry.identity.uaa.authentication.AccountNotVerifiedException;
import org.cloudfoundry.identity.uaa.authentication.AuthenticationPolicyRejectionException;
import org.cloudfoundry.identity.uaa.authentication.Origin;
import org.cloudfoundry.identity.uaa.authentication.PasswordExpiredException;
import org.cloudfoundry.identity.uaa.authentication.UaaAuthentication;
import org.cloudfoundry.identity.uaa.authentication.UaaAuthenticationDetails;
import org.cloudfoundry.identity.uaa.authentication.UaaPrincipal;
import org.cloudfoundry.identity.uaa.authentication.event.UnverifiedUserAuthenticationEvent;
import org.cloudfoundry.identity.uaa.authentication.event.UserAuthenticationFailureEvent;
import org.cloudfoundry.identity.uaa.authentication.event.UserAuthenticationSuccessEvent;
import org.cloudfoundry.identity.uaa.authentication.event.UserNotFoundEvent;
import org.cloudfoundry.identity.uaa.user.UaaUser;
import org.cloudfoundry.identity.uaa.user.UaaUserDatabase;
import org.cloudfoundry.identity.uaa.zone.IdentityProvider;
import org.cloudfoundry.identity.uaa.zone.IdentityProviderProvisioning;
import org.cloudfoundry.identity.uaa.zone.IdentityZoneHolder;
import org.cloudfoundry.identity.uaa.zone.UaaIdentityProviderDefinition;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationEventPublisherAware;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.event.AuthenticationFailureBadCredentialsEvent;
import org.springframework.security.authentication.event.AuthenticationFailureLockedEvent;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.codec.Hex;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.security.SecureRandom;
import java.util.Calendar;
import java.util.List;
import java.util.Locale;
import java.util.UUID;

/**
 * @author Luke Taylor
 * @author Dave Syer
 * 
 */
public class AuthzAuthenticationManager implements AuthenticationManager, ApplicationEventPublisherAware {

    private final Log logger = LogFactory.getLog(getClass());
    private final PasswordEncoder encoder;
    private final UaaUserDatabase userDatabase;
    private ApplicationEventPublisher eventPublisher;
    private AccountLoginPolicy accountLoginPolicy = new PermitAllAccountLoginPolicy();
    private IdentityProviderProvisioning providerProvisioning;

    private String origin;
    private boolean allowUnverifiedUsers = true;

    /**
     * Dummy user allows the authentication process for non-existent and locked
     * out users to be as close to
     * that of normal users as possible to avoid differences in timing.
     */
    private final UaaUser dummyUser;

    public AuthzAuthenticationManager(UaaUserDatabase cfusers, IdentityProviderProvisioning providerProvisioning) {
        this(cfusers, new BCryptPasswordEncoder(), providerProvisioning);
    }

    public AuthzAuthenticationManager(UaaUserDatabase userDatabase, PasswordEncoder encoder, IdentityProviderProvisioning providerProvisioning) {
        this.userDatabase = userDatabase;
        this.encoder = encoder;
        this.dummyUser = createDummyUser();
        this.providerProvisioning = providerProvisioning;
    }

    @Override
    public Authentication authenticate(Authentication req) throws AuthenticationException {
        logger.debug(""Processing authentication request for "" + req.getName());

        if (req.getCredentials() == null) {
            BadCredentialsException e = new BadCredentialsException(""No password supplied"");
            publish(new AuthenticationFailureBadCredentialsEvent(req, e));
            throw e;
        }

        UaaUser user;
        boolean passwordMatches = false;
        user = getUaaUser(req);
        if (user!=null) {
            passwordMatches =
                ((CharSequence) req.getCredentials()).length() != 0 && encoder.matches((CharSequence) req.getCredentials(), user.getPassword());
        } else {
            user = dummyUser;
        }

        if (!accountLoginPolicy.isAllowed(user, req)) {
            logger.warn(""Login policy rejected authentication for "" + user.getUsername() + "", "" + user.getId()
                            + "". Ignoring login request."");
            AuthenticationPolicyRejectionException e = new AuthenticationPolicyRejectionException(""Login policy rejected authentication"");
            publish(new AuthenticationFailureLockedEvent(req, e));
            throw e;
        }

        if (passwordMatches) {
            logger.debug(""Password successfully matched for userId[""+user.getUsername()+""]:""+user.getId());

            if (!allowUnverifiedUsers && !user.isVerified()) {
                publish(new UnverifiedUserAuthenticationEvent(user, req));
                logger.debug(""Account not verified: "" + user.getId());
                throw new AccountNotVerifiedException(""Account not verified"");
            }

            int expiringPassword = getPasswordExpiresInMonths();
            if (expiringPassword>0) {
                Calendar cal = Calendar.getInstance();
                cal.setTimeInMillis(user.getPasswordLastModified().getTime());
                cal.add(Calendar.MONTH, expiringPassword);
                if (cal.getTimeInMillis() < System.currentTimeMillis()) {
                    throw new PasswordExpiredException(""Your current password has expired. Please reset your password."");
                }
            }

            Authentication success = new UaaAuthentication(new UaaPrincipal(user),
                            user.getAuthorities(), (UaaAuthenticationDetails) req.getDetails());
            publish(new UserAuthenticationSuccessEvent(user, success));

            return success;
        }

        if (user == dummyUser || user == null) {
            logger.debug(""No user named '"" + req.getName() + ""' was found for origin:""+ origin);
            publish(new UserNotFoundEvent(req));
        } else {
            logger.debug(""Password did not match for user "" + req.getName());
            publish(new UserAuthenticationFailureEvent(user, req));
        }
        BadCredentialsException e = new BadCredentialsException(""Bad credentials"");
        publish(new AuthenticationFailureBadCredentialsEvent(req, e));
        throw e;
    }

    protected int getPasswordExpiresInMonths() {
        int result = 0;
        IdentityProvider provider = providerProvisioning.retrieveByOrigin(Origin.UAA, IdentityZoneHolder.get().getId());
        if (provider!=null) {
            UaaIdentityProviderDefinition idpDefinition = provider.getConfigValue(UaaIdentityProviderDefinition.class);
            if (idpDefinition!=null) {
                if (null!=idpDefinition.getPasswordPolicy()) {
                    return idpDefinition.getPasswordPolicy().getExpirePasswordInMonths();
                }
            }
        }
        return result;
    }

    private UaaUser getUaaUser(Authentication req) {
        try {
            UaaUser user = userDatabase.retrieveUserByName(req.getName().toLowerCase(Locale.US), getOrigin());
            if (user!=null) {
                return user;
            }
        } catch (UsernameNotFoundException e) {
        }
        return null;
    }

    private void publish(ApplicationEvent event) {
        if (eventPublisher != null) {
            eventPublisher.publishEvent(event);
        }
    }

    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    public void setAccountLoginPolicy(AccountLoginPolicy accountLoginPolicy) {
        this.accountLoginPolicy = accountLoginPolicy;
    }

    public AccountLoginPolicy getAccountLoginPolicy() {
        return this.accountLoginPolicy;
    }

    private UaaUser createDummyUser() {
        // Create random unguessable password
        SecureRandom random = new SecureRandom();
        byte[] passBytes = new byte[16];
        random.nextBytes(passBytes);
        String password = encoder.encode(new String(Hex.encode(passBytes)));
        // Unique ID which isn't in the database
        final String id = UUID.randomUUID().toString();

        return new UaaUser(""dummy_user"", password, ""dummy_user"", ""dummy"", ""dummy"") {
            @Override
            public final String getId() {
                return id;
            }

            @Override
            public final List<? extends GrantedAuthority> getAuthorities() {
                throw new IllegalStateException();
            }
        };
    }

    public String getOrigin() {
        return origin;
    }

    public void setOrigin(String origin) {
        this.origin = origin;
    }

    public void setAllowUnverifiedUsers(boolean allowUnverifiedUsers) {
        this.allowUnverifiedUsers = allowUnverifiedUsers;
    }
}
",0
CVE-2015-5171,common/src/main/java/org/cloudfoundry/identity/uaa/authentication/manager/AuthzAuthenticationManager.java,"/*******************************************************************************
 *     Cloud Foundry 
 *     Copyright (c) [2009-2014] Pivotal Software, Inc. All Rights Reserved.
 *
 *     This product is licensed to you under the Apache License, Version 2.0 (the ""License"").
 *     You may not use this product except in compliance with the License.
 *
 *     This product includes a number of subcomponents with
 *     separate copyright notices and license terms. Your use of these
 *     subcomponents is subject to the terms and conditions of the
 *     subcomponent's license, as noted in the LICENSE file.
 *******************************************************************************/
package org.cloudfoundry.identity.uaa.authentication.manager;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.cloudfoundry.identity.uaa.authentication.AccountNotVerifiedException;
import org.cloudfoundry.identity.uaa.authentication.AuthenticationPolicyRejectionException;
import org.cloudfoundry.identity.uaa.authentication.Origin;
import org.cloudfoundry.identity.uaa.authentication.PasswordExpiredException;
import org.cloudfoundry.identity.uaa.authentication.UaaAuthentication;
import org.cloudfoundry.identity.uaa.authentication.UaaAuthenticationDetails;
import org.cloudfoundry.identity.uaa.authentication.UaaPrincipal;
import org.cloudfoundry.identity.uaa.authentication.event.UnverifiedUserAuthenticationEvent;
import org.cloudfoundry.identity.uaa.authentication.event.UserAuthenticationFailureEvent;
import org.cloudfoundry.identity.uaa.authentication.event.UserAuthenticationSuccessEvent;
import org.cloudfoundry.identity.uaa.authentication.event.UserNotFoundEvent;
import org.cloudfoundry.identity.uaa.user.UaaUser;
import org.cloudfoundry.identity.uaa.user.UaaUserDatabase;
import org.cloudfoundry.identity.uaa.zone.IdentityProvider;
import org.cloudfoundry.identity.uaa.zone.IdentityProviderProvisioning;
import org.cloudfoundry.identity.uaa.zone.IdentityZoneHolder;
import org.cloudfoundry.identity.uaa.zone.UaaIdentityProviderDefinition;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationEventPublisherAware;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.event.AuthenticationFailureBadCredentialsEvent;
import org.springframework.security.authentication.event.AuthenticationFailureLockedEvent;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.codec.Hex;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.security.SecureRandom;
import java.util.Calendar;
import java.util.List;
import java.util.Locale;
import java.util.UUID;

/**
 * @author Luke Taylor
 * @author Dave Syer
 * 
 */
public class AuthzAuthenticationManager implements AuthenticationManager, ApplicationEventPublisherAware {

    private final Log logger = LogFactory.getLog(getClass());
    private final PasswordEncoder encoder;
    private final UaaUserDatabase userDatabase;
    private ApplicationEventPublisher eventPublisher;
    private AccountLoginPolicy accountLoginPolicy = new PermitAllAccountLoginPolicy();
    private IdentityProviderProvisioning providerProvisioning;

    private String origin;
    private boolean allowUnverifiedUsers = true;

    /**
     * Dummy user allows the authentication process for non-existent and locked
     * out users to be as close to
     * that of normal users as possible to avoid differences in timing.
     */
    private final UaaUser dummyUser;

    public AuthzAuthenticationManager(UaaUserDatabase cfusers, IdentityProviderProvisioning providerProvisioning) {
        this(cfusers, new BCryptPasswordEncoder(), providerProvisioning);
    }

    public AuthzAuthenticationManager(UaaUserDatabase userDatabase, PasswordEncoder encoder, IdentityProviderProvisioning providerProvisioning) {
        this.userDatabase = userDatabase;
        this.encoder = encoder;
        this.dummyUser = createDummyUser();
        this.providerProvisioning = providerProvisioning;
    }

    @Override
    public Authentication authenticate(Authentication req) throws AuthenticationException {
        logger.debug(""Processing authentication request for "" + req.getName());

        if (req.getCredentials() == null) {
            BadCredentialsException e = new BadCredentialsException(""No password supplied"");
            publish(new AuthenticationFailureBadCredentialsEvent(req, e));
            throw e;
        }

        UaaUser user;
        boolean passwordMatches = false;
        user = getUaaUser(req);
        if (user!=null) {
            passwordMatches =
                ((CharSequence) req.getCredentials()).length() != 0 && encoder.matches((CharSequence) req.getCredentials(), user.getPassword());
        } else {
            user = dummyUser;
        }

        if (!accountLoginPolicy.isAllowed(user, req)) {
            logger.warn(""Login policy rejected authentication for "" + user.getUsername() + "", "" + user.getId()
                            + "". Ignoring login request."");
            AuthenticationPolicyRejectionException e = new AuthenticationPolicyRejectionException(""Login policy rejected authentication"");
            publish(new AuthenticationFailureLockedEvent(req, e));
            throw e;
        }

        if (passwordMatches) {
            logger.debug(""Password successfully matched for userId[""+user.getUsername()+""]:""+user.getId());

            if (!allowUnverifiedUsers && !user.isVerified()) {
                publish(new UnverifiedUserAuthenticationEvent(user, req));
                logger.debug(""Account not verified: "" + user.getId());
                throw new AccountNotVerifiedException(""Account not verified"");
            }

            int expiringPassword = getPasswordExpiresInMonths();
            if (expiringPassword>0) {
                Calendar cal = Calendar.getInstance();
                cal.setTimeInMillis(user.getPasswordLastModified().getTime());
                cal.add(Calendar.MONTH, expiringPassword);
                if (cal.getTimeInMillis() < System.currentTimeMillis()) {
                    throw new PasswordExpiredException(""Your current password has expired. Please reset your password."");
                }
            }

            Authentication success = new UaaAuthentication(
                new UaaPrincipal(user),
                user.getAuthorities(),
                (UaaAuthenticationDetails) req.getDetails());

            publish(new UserAuthenticationSuccessEvent(user, success));

            return success;
        }

        if (user == dummyUser || user == null) {
            logger.debug(""No user named '"" + req.getName() + ""' was found for origin:""+ origin);
            publish(new UserNotFoundEvent(req));
        } else {
            logger.debug(""Password did not match for user "" + req.getName());
            publish(new UserAuthenticationFailureEvent(user, req));
        }
        BadCredentialsException e = new BadCredentialsException(""Bad credentials"");
        publish(new AuthenticationFailureBadCredentialsEvent(req, e));
        throw e;
    }

    protected int getPasswordExpiresInMonths() {
        int result = 0;
        IdentityProvider provider = providerProvisioning.retrieveByOrigin(Origin.UAA, IdentityZoneHolder.get().getId());
        if (provider!=null) {
            UaaIdentityProviderDefinition idpDefinition = provider.getConfigValue(UaaIdentityProviderDefinition.class);
            if (idpDefinition!=null) {
                if (null!=idpDefinition.getPasswordPolicy()) {
                    return idpDefinition.getPasswordPolicy().getExpirePasswordInMonths();
                }
            }
        }
        return result;
    }

    private UaaUser getUaaUser(Authentication req) {
        try {
            UaaUser user = userDatabase.retrieveUserByName(req.getName().toLowerCase(Locale.US), getOrigin());
            if (user!=null) {
                return user;
            }
        } catch (UsernameNotFoundException e) {
        }
        return null;
    }

    private void publish(ApplicationEvent event) {
        if (eventPublisher != null) {
            eventPublisher.publishEvent(event);
        }
    }

    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    public void setAccountLoginPolicy(AccountLoginPolicy accountLoginPolicy) {
        this.accountLoginPolicy = accountLoginPolicy;
    }

    public AccountLoginPolicy getAccountLoginPolicy() {
        return this.accountLoginPolicy;
    }

    private UaaUser createDummyUser() {
        // Create random unguessable password
        SecureRandom random = new SecureRandom();
        byte[] passBytes = new byte[16];
        random.nextBytes(passBytes);
        String password = encoder.encode(new String(Hex.encode(passBytes)));
        // Unique ID which isn't in the database
        final String id = UUID.randomUUID().toString();

        return new UaaUser(""dummy_user"", password, ""dummy_user"", ""dummy"", ""dummy"") {
            @Override
            public final String getId() {
                return id;
            }

            @Override
            public final List<? extends GrantedAuthority> getAuthorities() {
                throw new IllegalStateException();
            }
        };
    }

    public String getOrigin() {
        return origin;
    }

    public void setOrigin(String origin) {
        this.origin = origin;
    }

    public void setAllowUnverifiedUsers(boolean allowUnverifiedUsers) {
        this.allowUnverifiedUsers = allowUnverifiedUsers;
    }
}
",1
CVE-2015-5171,common/src/main/java/org/cloudfoundry/identity/uaa/zone/IdentityZoneSwitchingFilter.java,"package org.cloudfoundry.identity.uaa.zone;

import org.cloudfoundry.identity.uaa.authentication.UaaAuthentication;
import org.cloudfoundry.identity.uaa.authentication.UaaAuthenticationDetails;
import org.cloudfoundry.identity.uaa.util.UaaStringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.OAuth2Request;
import org.springframework.security.oauth2.provider.expression.OAuth2ExpressionUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * If the X-Identity-Zone-Id header is set and the user has a scope
 * of zones.&lt;id&gt;.admin, this filter switches the IdentityZone in the IdentityZoneHolder
 * to the one in the header.
 *
 * @author wtran@pivotal.io
 *
 */
public class IdentityZoneSwitchingFilter extends OncePerRequestFilter {

    @Autowired
    public IdentityZoneSwitchingFilter(IdentityZoneProvisioning dao) {
        super();
        this.dao = dao;
    }

    private final IdentityZoneProvisioning dao;
    public static final String HEADER = ""X-Identity-Zone-Id"";

    public static final String ZONE_ID_MATCH = ""{zone_id}"";
    public static final String ZONES_ZONE_ID_PREFIX = ""zones."" ;
    public static final String ZONES_ZONE_ID_ADMIN = ZONES_ZONE_ID_PREFIX + ZONE_ID_MATCH + "".""+ ""admin"";
    public static final List<String> zoneSwitchScopes = Collections.unmodifiableList(
        Arrays.asList(
            ZONES_ZONE_ID_ADMIN,
            ZONES_ZONE_ID_PREFIX + ZONE_ID_MATCH + "".read"",
            ZONES_ZONE_ID_PREFIX + ZONE_ID_MATCH + "".clients.admin"",
            ZONES_ZONE_ID_PREFIX + ZONE_ID_MATCH + "".clients.read"",
            ZONES_ZONE_ID_PREFIX + ZONE_ID_MATCH + "".clients.write"",
            ZONES_ZONE_ID_PREFIX + ZONE_ID_MATCH + "".idps.read"")
    );
    public static final List<String> zoneScopestoNotStripPrefix = Collections.unmodifiableList(
         Arrays.asList(
            ""admin"",
            ""read"")
            );

    protected boolean isAuthorizedToSwitchToIdentityZone(String identityZoneId) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        boolean hasScope = OAuth2ExpressionUtils.hasAnyScope(authentication, getZoneSwitchingScopes(identityZoneId));
        boolean isUaa = IdentityZoneHolder.isUaa();
        boolean isTokenAuth = (authentication instanceof OAuth2Authentication);
        return isTokenAuth && isUaa && hasScope;
    }

    protected void stripScopesFromAuthentication(String identityZoneId, HttpServletRequest servletRequest) {
        OAuth2Authentication oa = (OAuth2Authentication)SecurityContextHolder.getContext().getAuthentication();

        Object oaDetails = oa.getDetails();

        //strip client scopes
        OAuth2Request request = oa.getOAuth2Request();
        Collection<String> requestAuthorities = UaaStringUtils.getStringsFromAuthorities(request.getAuthorities());
        Set<String> clientScopes = new HashSet<>();
        Set<String> clientAuthorities = new HashSet<>();
        for (String s : getZoneSwitchingScopes(identityZoneId)) {
            String scope = stripPrefix(s, identityZoneId);
            if (request.getScope().contains(s)) {
                clientScopes.add(scope);
            }
            if (requestAuthorities.contains(s)) {
                clientAuthorities.add(scope);
            }
        }
        request = new OAuth2Request(
            request.getRequestParameters(),
            request.getClientId(),
            UaaStringUtils.getAuthoritiesFromStrings(clientAuthorities),
            request.isApproved(),
            clientScopes,
            request.getResourceIds(),
            request.getRedirectUri(),
            request.getResponseTypes(),
            request.getExtensions()
            );


        UaaAuthentication userAuthentication = (UaaAuthentication)oa.getUserAuthentication();
        if (userAuthentication!=null) {
            userAuthentication = new UaaAuthentication(
                userAuthentication.getPrincipal(),
                null,
                UaaStringUtils.getAuthoritiesFromStrings(clientScopes),
                new UaaAuthenticationDetails(servletRequest),
                true);
        }
        oa = new OAuth2Authentication(request, userAuthentication);
        oa.setDetails(oaDetails);
        SecurityContextHolder.getContext().setAuthentication(oa);
    }

    protected String stripPrefix(String s, String identityZoneId) {
        if (!StringUtils.hasText(s)) {
            return s;
        }
        //dont touch the zones.{zone.id}.admin scope
        String replace = ZONES_ZONE_ID_PREFIX+identityZoneId+""."";
        for (String scope : zoneScopestoNotStripPrefix) {
            if (s.equals(replace + scope)) {
                return s;
            }
        }

        //replace zones.<id>.

        if (s.startsWith(replace)) {
            return s.substring(replace.length());
        }
        return s;
    }

    protected String[] getZoneSwitchingScopes(String identityZoneId) {
        String[] result = new String[zoneSwitchScopes.size()];
        for (int i=0; i<result.length; i++) {
            result[i] = zoneSwitchScopes.get(i).replace(ZONE_ID_MATCH, identityZoneId);
        }
        return result;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        String identityZoneId = request.getHeader(HEADER);
        if (StringUtils.hasText(identityZoneId)) {
            if (!isAuthorizedToSwitchToIdentityZone(identityZoneId)) {
                response.sendError(HttpServletResponse.SC_FORBIDDEN, ""User is not authorized to switch to IdentityZone with id ""+identityZoneId);
                return;
            }
            IdentityZone originalIdentityZone = IdentityZoneHolder.get();
            try {

                IdentityZone identityZone = null;
                try {
                    identityZone = dao.retrieve(identityZoneId);
                } catch (ZoneDoesNotExistsException ex) {
                } catch (EmptyResultDataAccessException ex) {
                } catch (Exception ex) {
                    throw ex;
                }
                if (identityZone == null) {
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, ""Identity zone with id ""+identityZoneId+"" does not exist"");
                    return;
                }
                stripScopesFromAuthentication(identityZoneId, request);
                IdentityZoneHolder.set(identityZone);
                filterChain.doFilter(request, response);
            } finally {
                IdentityZoneHolder.set(originalIdentityZone);
            }
        } else {
            filterChain.doFilter(request, response);
        }
    }
}
",0
CVE-2015-5171,common/src/main/java/org/cloudfoundry/identity/uaa/zone/IdentityZoneSwitchingFilter.java,"package org.cloudfoundry.identity.uaa.zone;

import org.cloudfoundry.identity.uaa.authentication.UaaAuthentication;
import org.cloudfoundry.identity.uaa.authentication.UaaAuthenticationDetails;
import org.cloudfoundry.identity.uaa.util.UaaStringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.OAuth2Request;
import org.springframework.security.oauth2.provider.expression.OAuth2ExpressionUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * If the X-Identity-Zone-Id header is set and the user has a scope
 * of zones.&lt;id&gt;.admin, this filter switches the IdentityZone in the IdentityZoneHolder
 * to the one in the header.
 *
 * @author wtran@pivotal.io
 *
 */
public class IdentityZoneSwitchingFilter extends OncePerRequestFilter {

    @Autowired
    public IdentityZoneSwitchingFilter(IdentityZoneProvisioning dao) {
        super();
        this.dao = dao;
    }

    private final IdentityZoneProvisioning dao;
    public static final String HEADER = ""X-Identity-Zone-Id"";

    public static final String ZONE_ID_MATCH = ""{zone_id}"";
    public static final String ZONES_ZONE_ID_PREFIX = ""zones."" ;
    public static final String ZONES_ZONE_ID_ADMIN = ZONES_ZONE_ID_PREFIX + ZONE_ID_MATCH + "".""+ ""admin"";
    public static final List<String> zoneSwitchScopes = Collections.unmodifiableList(
        Arrays.asList(
            ZONES_ZONE_ID_ADMIN,
            ZONES_ZONE_ID_PREFIX + ZONE_ID_MATCH + "".read"",
            ZONES_ZONE_ID_PREFIX + ZONE_ID_MATCH + "".clients.admin"",
            ZONES_ZONE_ID_PREFIX + ZONE_ID_MATCH + "".clients.read"",
            ZONES_ZONE_ID_PREFIX + ZONE_ID_MATCH + "".clients.write"",
            ZONES_ZONE_ID_PREFIX + ZONE_ID_MATCH + "".idps.read"")
    );
    public static final List<String> zoneScopestoNotStripPrefix = Collections.unmodifiableList(
         Arrays.asList(
            ""admin"",
            ""read"")
            );

    protected boolean isAuthorizedToSwitchToIdentityZone(String identityZoneId) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        boolean hasScope = OAuth2ExpressionUtils.hasAnyScope(authentication, getZoneSwitchingScopes(identityZoneId));
        boolean isUaa = IdentityZoneHolder.isUaa();
        boolean isTokenAuth = (authentication instanceof OAuth2Authentication);
        return isTokenAuth && isUaa && hasScope;
    }

    protected void stripScopesFromAuthentication(String identityZoneId, HttpServletRequest servletRequest) {
        OAuth2Authentication oa = (OAuth2Authentication)SecurityContextHolder.getContext().getAuthentication();

        Object oaDetails = oa.getDetails();

        //strip client scopes
        OAuth2Request request = oa.getOAuth2Request();
        Collection<String> requestAuthorities = UaaStringUtils.getStringsFromAuthorities(request.getAuthorities());
        Set<String> clientScopes = new HashSet<>();
        Set<String> clientAuthorities = new HashSet<>();
        for (String s : getZoneSwitchingScopes(identityZoneId)) {
            String scope = stripPrefix(s, identityZoneId);
            if (request.getScope().contains(s)) {
                clientScopes.add(scope);
            }
            if (requestAuthorities.contains(s)) {
                clientAuthorities.add(scope);
            }
        }
        request = new OAuth2Request(
            request.getRequestParameters(),
            request.getClientId(),
            UaaStringUtils.getAuthoritiesFromStrings(clientAuthorities),
            request.isApproved(),
            clientScopes,
            request.getResourceIds(),
            request.getRedirectUri(),
            request.getResponseTypes(),
            request.getExtensions()
            );


        UaaAuthentication userAuthentication = (UaaAuthentication)oa.getUserAuthentication();
        if (userAuthentication!=null) {
            userAuthentication = new UaaAuthentication(
                userAuthentication.getPrincipal(),
                null,
                UaaStringUtils.getAuthoritiesFromStrings(clientScopes),
                new UaaAuthenticationDetails(servletRequest),
                true, userAuthentication.getAuthenticatedTime());
        }
        oa = new OAuth2Authentication(request, userAuthentication);
        oa.setDetails(oaDetails);
        SecurityContextHolder.getContext().setAuthentication(oa);
    }

    protected String stripPrefix(String s, String identityZoneId) {
        if (!StringUtils.hasText(s)) {
            return s;
        }
        //dont touch the zones.{zone.id}.admin scope
        String replace = ZONES_ZONE_ID_PREFIX+identityZoneId+""."";
        for (String scope : zoneScopestoNotStripPrefix) {
            if (s.equals(replace + scope)) {
                return s;
            }
        }

        //replace zones.<id>.

        if (s.startsWith(replace)) {
            return s.substring(replace.length());
        }
        return s;
    }

    protected String[] getZoneSwitchingScopes(String identityZoneId) {
        String[] result = new String[zoneSwitchScopes.size()];
        for (int i=0; i<result.length; i++) {
            result[i] = zoneSwitchScopes.get(i).replace(ZONE_ID_MATCH, identityZoneId);
        }
        return result;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        String identityZoneId = request.getHeader(HEADER);
        if (StringUtils.hasText(identityZoneId)) {
            if (!isAuthorizedToSwitchToIdentityZone(identityZoneId)) {
                response.sendError(HttpServletResponse.SC_FORBIDDEN, ""User is not authorized to switch to IdentityZone with id ""+identityZoneId);
                return;
            }
            IdentityZone originalIdentityZone = IdentityZoneHolder.get();
            try {

                IdentityZone identityZone = null;
                try {
                    identityZone = dao.retrieve(identityZoneId);
                } catch (ZoneDoesNotExistsException ex) {
                } catch (EmptyResultDataAccessException ex) {
                } catch (Exception ex) {
                    throw ex;
                }
                if (identityZone == null) {
                    response.sendError(HttpServletResponse.SC_NOT_FOUND, ""Identity zone with id ""+identityZoneId+"" does not exist"");
                    return;
                }
                stripScopesFromAuthentication(identityZoneId, request);
                IdentityZoneHolder.set(identityZone);
                filterChain.doFilter(request, response);
            } finally {
                IdentityZoneHolder.set(originalIdentityZone);
            }
        } else {
            filterChain.doFilter(request, response);
        }
    }
}
",1
CVE-2015-5171,login/src/main/java/org/cloudfoundry/identity/uaa/login/ChangePasswordController.java,"/*******************************************************************************
 *     Cloud Foundry
 *     Copyright (c) [2009-2014] Pivotal Software, Inc. All Rights Reserved.
 *
 *     This product is licensed to you under the Apache License, Version 2.0 (the ""License"").
 *     You may not use this product except in compliance with the License.
 *
 *     This product includes a number of subcomponents with
 *     separate copyright notices and license terms. Your use of these
 *     subcomponents is subject to the terms and conditions of the
 *     subcomponent's license, as noted in the LICENSE file.
 *******************************************************************************/
package org.cloudfoundry.identity.uaa.login;

import org.cloudfoundry.identity.uaa.scim.exception.InvalidPasswordException;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import static org.springframework.web.bind.annotation.RequestMethod.GET;
import static org.springframework.web.bind.annotation.RequestMethod.POST;

@Controller
public class ChangePasswordController {

    private final ChangePasswordService changePasswordService;

    public ChangePasswordController(ChangePasswordService changePasswordService) {
        this.changePasswordService = changePasswordService;
    }

    @RequestMapping(value=""/change_password"", method = GET)
    public String changePasswordPage() {
        return ""change_password"";
    }

    @RequestMapping(value=""/change_password.do"", method = POST)
    public String changePassword(
            Model model,
            @RequestParam(""current_password"") String currentPassword,
            @RequestParam(""new_password"") String newPassword,
            @RequestParam(""confirm_password"") String confirmPassword,
            HttpServletResponse response,
            HttpServletRequest request) {

        PasswordConfirmationValidation validation = new PasswordConfirmationValidation(newPassword, confirmPassword);
        if (!validation.valid()) {
            model.addAttribute(""message_code"", validation.getMessageCode());
            response.setStatus(HttpStatus.UNPROCESSABLE_ENTITY.value());
            return ""change_password"";
        }

        SecurityContext securityContext = SecurityContextHolder.getContext();
        Authentication authentication = securityContext.getAuthentication();
        String username = authentication.getName();

        try {
            changePasswordService.changePassword(username, currentPassword, newPassword);
            request.getSession().invalidate();
            request.getSession(true);
            securityContext.setAuthentication(authentication);
            return ""redirect:profile"";
        } catch (BadCredentialsException e) {
            model.addAttribute(""message_code"", ""unauthorized"");
        } catch (InvalidPasswordException e) {
            model.addAttribute(""message"", e.getMessagesAsOneString());
        }
        response.setStatus(HttpStatus.UNPROCESSABLE_ENTITY.value());
        return ""change_password"";
    }
}
",0
CVE-2015-5171,login/src/main/java/org/cloudfoundry/identity/uaa/login/ChangePasswordController.java,"/*******************************************************************************
 *     Cloud Foundry
 *     Copyright (c) [2009-2014] Pivotal Software, Inc. All Rights Reserved.
 *
 *     This product is licensed to you under the Apache License, Version 2.0 (the ""License"").
 *     You may not use this product except in compliance with the License.
 *
 *     This product includes a number of subcomponents with
 *     separate copyright notices and license terms. Your use of these
 *     subcomponents is subject to the terms and conditions of the
 *     subcomponent's license, as noted in the LICENSE file.
 *******************************************************************************/
package org.cloudfoundry.identity.uaa.login;

import org.cloudfoundry.identity.uaa.authentication.UaaAuthentication;
import org.cloudfoundry.identity.uaa.authentication.UaaAuthenticationDetails;
import org.cloudfoundry.identity.uaa.scim.exception.InvalidPasswordException;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.util.Arrays;
import java.util.LinkedList;

import static org.springframework.web.bind.annotation.RequestMethod.GET;
import static org.springframework.web.bind.annotation.RequestMethod.POST;

@Controller
public class ChangePasswordController {

    private final ChangePasswordService changePasswordService;

    public ChangePasswordController(ChangePasswordService changePasswordService) {
        this.changePasswordService = changePasswordService;
    }

    @RequestMapping(value=""/change_password"", method = GET)
    public String changePasswordPage() {
        return ""change_password"";
    }

    @RequestMapping(value=""/change_password.do"", method = POST)
    public String changePassword(
            Model model,
            @RequestParam(""current_password"") String currentPassword,
            @RequestParam(""new_password"") String newPassword,
            @RequestParam(""confirm_password"") String confirmPassword,
            HttpServletResponse response,
            HttpServletRequest request) {

        PasswordConfirmationValidation validation = new PasswordConfirmationValidation(newPassword, confirmPassword);
        if (!validation.valid()) {
            model.addAttribute(""message_code"", validation.getMessageCode());
            response.setStatus(HttpStatus.UNPROCESSABLE_ENTITY.value());
            return ""change_password"";
        }

        SecurityContext securityContext = SecurityContextHolder.getContext();
        Authentication authentication = securityContext.getAuthentication();
        String username = authentication.getName();

        try {
            changePasswordService.changePassword(username, currentPassword, newPassword);
            request.getSession().invalidate();
            request.getSession(true);
            if (authentication instanceof UaaAuthentication) {
                UaaAuthentication uaaAuthentication = (UaaAuthentication)authentication;
                authentication = new UaaAuthentication(
                    uaaAuthentication.getPrincipal(),
                    new LinkedList<>(uaaAuthentication.getAuthorities()),
                    new UaaAuthenticationDetails(request)
                );
            }
            securityContext.setAuthentication(authentication);
            return ""redirect:profile"";
        } catch (BadCredentialsException e) {
            model.addAttribute(""message_code"", ""unauthorized"");
        } catch (InvalidPasswordException e) {
            model.addAttribute(""message"", e.getMessagesAsOneString());
        }
        response.setStatus(HttpStatus.UNPROCESSABLE_ENTITY.value());
        return ""change_password"";
    }
}
",1
CVE-2015-5171,scim/src/main/java/org/cloudfoundry/identity/uaa/scim/jdbc/JdbcScimUserProvisioning.java,"/*******************************************************************************
 *     Cloud Foundry
 *     Copyright (c) [2009-2014] Pivotal Software, Inc. All Rights Reserved.
 *
 *     This product is licensed to you under the Apache License, Version 2.0 (the ""License"").
 *     You may not use this product except in compliance with the License.
 *
 *     This product includes a number of subcomponents with
 *     separate copyright notices and license terms. Your use of these
 *     subcomponents is subject to the terms and conditions of the
 *     subcomponent's license, as noted in the LICENSE file.
 *******************************************************************************/
package org.cloudfoundry.identity.uaa.scim.jdbc;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.cloudfoundry.identity.uaa.authentication.Origin;
import org.cloudfoundry.identity.uaa.rest.ResourceMonitor;
import org.cloudfoundry.identity.uaa.rest.jdbc.AbstractQueryable;
import org.cloudfoundry.identity.uaa.rest.jdbc.JdbcPagingListFactory;
import org.cloudfoundry.identity.uaa.scim.ScimMeta;
import org.cloudfoundry.identity.uaa.scim.ScimUser;
import org.cloudfoundry.identity.uaa.scim.ScimUser.Name;
import org.cloudfoundry.identity.uaa.scim.ScimUserProvisioning;
import org.cloudfoundry.identity.uaa.scim.exception.InvalidPasswordException;
import org.cloudfoundry.identity.uaa.scim.exception.InvalidScimResourceException;
import org.cloudfoundry.identity.uaa.scim.exception.ScimResourceAlreadyExistsException;
import org.cloudfoundry.identity.uaa.scim.exception.ScimResourceConstraintFailedException;
import org.cloudfoundry.identity.uaa.scim.exception.ScimResourceNotFoundException;
import org.cloudfoundry.identity.uaa.zone.IdentityZoneHolder;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.dao.IncorrectResultSizeDataAccessException;
import org.springframework.dao.OptimisticLockingFailureException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementSetter;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.regex.Pattern;

/**
 * @author Luke Taylor
 * @author Dave Syer
 */
public class JdbcScimUserProvisioning extends AbstractQueryable<ScimUser> implements ScimUserProvisioning, ResourceMonitor<ScimUser> {

    private final Log logger = LogFactory.getLog(getClass());

    public static final String USER_FIELDS = ""id,version,created,lastModified,username,email,givenName,familyName,active,phoneNumber,verified,origin,external_id,identity_zone_id,salt,passwd_lastmodified "";

    public static final String CREATE_USER_SQL = ""insert into users ("" + USER_FIELDS
                    + "",password) values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)"";

    public static final String UPDATE_USER_SQL = ""update users set version=?, lastModified=?, userName=?, email=?, givenName=?, familyName=?, active=?, phoneNumber=?, verified=?, origin=?, external_id=?, salt=?, passwd_lastmodified=? where id=? and version=?"";

    public static final String DEACTIVATE_USER_SQL = ""update users set active=? where id=?"";

    public static final String VERIFY_USER_SQL = ""update users set verified=? where id=?"";

    public static final String DELETE_USER_SQL = ""delete from users where id=?"";

    public static final String CHANGE_PASSWORD_SQL = ""update users set lastModified=?, password=?, passwd_lastmodified=? where id=?"";

    public static final String READ_PASSWORD_SQL = ""select password from users where id=?"";

    public static final String USER_BY_ID_QUERY = ""select "" + USER_FIELDS + "" from users "" + ""where id=?"";

    public static final String ALL_USERS = ""select "" + USER_FIELDS + "" from users"";

    protected final JdbcTemplate jdbcTemplate;

    private PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    private boolean deactivateOnDelete = true;

    private final RowMapper<ScimUser> mapper = new ScimUserRowMapper();

    private Pattern usernamePattern = Pattern.compile(""[a-zA-Z0-9+\\-_.@'!]+"");

    public JdbcScimUserProvisioning(JdbcTemplate jdbcTemplate, JdbcPagingListFactory pagingListFactory) {
        super(jdbcTemplate, pagingListFactory, new ScimUserRowMapper());
        Assert.notNull(jdbcTemplate);
        this.jdbcTemplate = jdbcTemplate;
        setQueryConverter(new ScimSearchQueryConverter());
    }

    @Override
    public ScimUser retrieve(String id) {
        try {
            ScimUser u = jdbcTemplate.queryForObject(USER_BY_ID_QUERY, mapper, id);
            return u;
        } catch (EmptyResultDataAccessException e) {
            throw new ScimResourceNotFoundException(""User "" + id + "" does not exist"");
        }
    }

    @Override
    protected String getBaseSqlQuery() {
        return ALL_USERS;
    }

    @Override
    protected String getTableName() {
        return ""users"";
    }

    @Override
    public List<ScimUser> retrieveAll() {
        return query(""id pr"", ""created"", true);
    }

    @Override
    public List<ScimUser> query(String filter, String sortBy, boolean ascending) {
        if (StringUtils.hasText(filter)) {
            filter += "" and"";
        }
        filter += "" identity_zone_id eq \""""+IdentityZoneHolder.get().getId()+""\"""";
        return super.query(filter, sortBy, ascending);
    }

    @Override
    public ScimUser create(final ScimUser user) {
        validate(user);
        logger.debug(""Creating new user: "" + user.getUserName());

        final String id = UUID.randomUUID().toString();
        final String identityZoneId = IdentityZoneHolder.get().getId();
        final String origin = StringUtils.hasText(user.getOrigin()) ? user.getOrigin() : Origin.UAA;

        try {
            jdbcTemplate.update(CREATE_USER_SQL, new PreparedStatementSetter() {
                @Override
                public void setValues(PreparedStatement ps) throws SQLException {
                    Timestamp t = new Timestamp(new Date().getTime());
                    ps.setString(1, id);
                    ps.setInt(2, user.getVersion());
                    ps.setTimestamp(3, t);
                    ps.setTimestamp(4, t);
                    ps.setString(5, user.getUserName());
                    ps.setString(6, user.getPrimaryEmail());
                    if (user.getName() == null) {
                        ps.setString(7, null);
                        ps.setString(8, null);
                    }
                    else {
                        ps.setString(7, user.getName().getGivenName());
                        ps.setString(8, user.getName().getFamilyName());
                    }
                    ps.setBoolean(9, user.isActive());
                    String phoneNumber = extractPhoneNumber(user);
                    ps.setString(10, phoneNumber);
                    ps.setBoolean(11, user.isVerified());
                    ps.setString(12, origin);
                    ps.setString(13, StringUtils.hasText(user.getExternalId())?user.getExternalId():null);
                    ps.setString(14, identityZoneId);
                    ps.setString(15, user.getSalt());
                    ps.setTimestamp(16, t);
                    ps.setString(17, user.getPassword());
                }

            });
        } catch (DuplicateKeyException e) {
            ScimUser existingUser = query(""userName eq \"""" + user.getUserName() + ""\"" and origin eq \"""" + (StringUtils.hasText(user.getOrigin())? user.getOrigin() : Origin.UAA) + ""\"""").get(0);
            Map<String,Object> userDetails = new HashMap<>();
            userDetails.put(""active"", existingUser.isActive());
            userDetails.put(""verified"", existingUser.isVerified());
            userDetails.put(""user_id"", existingUser.getId());
            throw new ScimResourceAlreadyExistsException(""Username already in use: "" + existingUser.getUserName(), userDetails);
        }
        return retrieve(id);
    }

    @Override
    public ScimUser createUser(ScimUser user, final String password) throws InvalidPasswordException,
                    InvalidScimResourceException {
        user.setPassword(passwordEncoder.encode(password));
        return create(user);
    }

    private void validate(final ScimUser user) throws InvalidScimResourceException {
        if (!usernamePattern.matcher(user.getUserName()).matches()) {
            throw new InvalidScimResourceException(""Username must match pattern: "" + usernamePattern.pattern());
        }
        if (user.getEmails() == null || user.getEmails().isEmpty()) {
            throw new InvalidScimResourceException(""An email must be provided."");
        }
    }

    private String extractPhoneNumber(final ScimUser user) {
        String phoneNumber = null;
        if (user.getPhoneNumbers() != null && !user.getPhoneNumbers().isEmpty()) {
            phoneNumber = user.getPhoneNumbers().get(0).getValue();
        }
        return phoneNumber;
    }

    @Override
    public ScimUser update(final String id, final ScimUser user) throws InvalidScimResourceException {
        validate(user);
        logger.debug(""Updating user "" + user.getUserName());
        final String origin = StringUtils.hasText(user.getOrigin()) ? user.getOrigin() : Origin.UAA;

        int updated = jdbcTemplate.update(UPDATE_USER_SQL, new PreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps) throws SQLException {
                int pos = 1;
                Timestamp t = new Timestamp(new Date().getTime());
                ps.setInt(pos++, user.getVersion() + 1);
                ps.setTimestamp(pos++, t);
                ps.setString(pos++, user.getUserName());
                ps.setString(pos++, user.getPrimaryEmail());
                ps.setString(pos++, user.getName().getGivenName());
                ps.setString(pos++, user.getName().getFamilyName());
                ps.setBoolean(pos++, user.isActive());
                ps.setString(pos++, extractPhoneNumber(user));
                ps.setBoolean(pos++, user.isVerified());
                ps.setString(pos++, origin);
                ps.setString(pos++, StringUtils.hasText(user.getExternalId())?user.getExternalId():null);
                ps.setString(pos++, user.getSalt());
                ps.setTimestamp(pos++, t);
                ps.setString(pos++, id);
                ps.setInt(pos++, user.getVersion());
            }
        });
        ScimUser result = retrieve(id);
        if (updated == 0) {
            throw new OptimisticLockingFailureException(String.format(
                            ""Attempt to update a user (%s) with wrong version: expected=%d but found=%d"", id,
                            result.getVersion(), user.getVersion()));
        }
        if (updated > 1) {
            throw new IncorrectResultSizeDataAccessException(1);
        }
        return result;
    }

    @Override
    public void changePassword(final String id, String oldPassword, final String newPassword)
                    throws ScimResourceNotFoundException {
        if (oldPassword != null && !checkPasswordMatches(id, oldPassword)) {
            throw new BadCredentialsException(""Old password is incorrect"");
        }
        if (checkPasswordMatches(id, newPassword)) {
            return; //we don't want to update the same password
        }
        final String encNewPassword = passwordEncoder.encode(newPassword);
        int updated = jdbcTemplate.update(CHANGE_PASSWORD_SQL, new PreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps) throws SQLException {
                Timestamp t = new Timestamp(new Date().getTime());
                ps.setTimestamp(1, t);
                ps.setString(2, encNewPassword);
                ps.setTimestamp(3, t);
                ps.setString(4, id);
            }
        });
        if (updated == 0) {
            throw new ScimResourceNotFoundException(""User "" + id + "" does not exist"");
        }
        if (updated != 1) {
            throw new ScimResourceConstraintFailedException(""User "" + id + "" duplicated"");
        }
    }

    // Checks the existing password for a user
    public boolean checkPasswordMatches(String id, String password) {
        String currentPassword;
        try {
            currentPassword = jdbcTemplate.queryForObject(READ_PASSWORD_SQL, new Object[] { id },
                            new int[] { Types.VARCHAR }, String.class);
        } catch (IncorrectResultSizeDataAccessException e) {
            throw new ScimResourceNotFoundException(""User "" + id + "" does not exist"");
        }

        return passwordEncoder.matches(password, currentPassword);
    }

    @Override
    public ScimUser delete(String id, int version) {
        ScimUser user = retrieve(id);
        return deactivateOnDelete ? deactivateUser(user, version) : deleteUser(user, version);
    }

    private ScimUser deactivateUser(ScimUser user, int version) {
        logger.debug(""Deactivating user: "" + user.getId());
        int updated;
        if (version < 0) {
            // Ignore
            updated = jdbcTemplate.update(DEACTIVATE_USER_SQL, false, user.getId());
        }
        else {
            updated = jdbcTemplate.update(DEACTIVATE_USER_SQL + "" and version=?"", false, user.getId(), version);
        }
        if (updated == 0) {
            throw new OptimisticLockingFailureException(String.format(
                            ""Attempt to update a user (%s) with wrong version: expected=%d but found=%d"", user.getId(),
                            user.getVersion(), version));
        }
        if (updated > 1) {
            throw new IncorrectResultSizeDataAccessException(1);
        }
        user.setActive(false);
        return user;
    }

    @Override
    public ScimUser verifyUser(String id, int version) throws ScimResourceNotFoundException,
                    InvalidScimResourceException {
        logger.debug(""Verifying user: "" + id);
        int updated;
        if (version < 0) {
            // Ignore
            updated = jdbcTemplate.update(VERIFY_USER_SQL, true, id);
        }
        else {
            updated = jdbcTemplate.update(VERIFY_USER_SQL + "" and version=?"", true, id, version);
        }
        ScimUser user = retrieve(id);
        if (updated == 0) {
            throw new OptimisticLockingFailureException(String.format(
                            ""Attempt to update a user (%s) with wrong version: expected=%d but found=%d"", user.getId(),
                            user.getVersion(), version));
        }
        if (updated > 1) {
            throw new IncorrectResultSizeDataAccessException(1);
        }
        return user;
    }

    private ScimUser deleteUser(ScimUser user, int version) {
        logger.debug(""Deleting user: "" + user.getId());
        int updated;

        if (version < 0) {
            updated = jdbcTemplate.update(DELETE_USER_SQL, user.getId());
        }
        else {
            updated = jdbcTemplate.update(DELETE_USER_SQL + "" and version=?"", user.getId(), version);
        }
        if (updated == 0) {
            throw new OptimisticLockingFailureException(String.format(
                            ""Attempt to update a user (%s) with wrong version: expected=%d but found=%d"", user.getId(),
                            user.getVersion(), version));
        }
        return user;
    }

    public void setDeactivateOnDelete(boolean deactivateOnDelete) {
        this.deactivateOnDelete = deactivateOnDelete;
    }

    /**
     * The encoder used to hash passwords before storing them in the database.
     *
     * Defaults to a {@link BCryptPasswordEncoder}.
     */
    public void setPasswordEncoder(PasswordEncoder passwordEncoder) {
        Assert.notNull(passwordEncoder, ""passwordEncoder cannot be null"");
        this.passwordEncoder = passwordEncoder;
    }

    /**
     * Sets the regular expression which will be used to validate the username.
     */
    public void setUsernamePattern(String usernamePattern) {
        Assert.hasText(usernamePattern, ""Username pattern must not be empty"");
        this.usernamePattern = Pattern.compile(usernamePattern);
    }

    private static final class ScimUserRowMapper implements RowMapper<ScimUser> {
        @Override
        public ScimUser mapRow(ResultSet rs, int rowNum) throws SQLException {
            String id = rs.getString(1);
            int version = rs.getInt(2);
            Date created = rs.getTimestamp(3);
            Date lastModified = rs.getTimestamp(4);
            String userName = rs.getString(5);
            String email = rs.getString(6);
            String givenName = rs.getString(7);
            String familyName = rs.getString(8);
            boolean active = rs.getBoolean(9);
            String phoneNumber = rs.getString(10);
            boolean verified = rs.getBoolean(11);
            String origin = rs.getString(12);
            String externalId = rs.getString(13);
            String zoneId = rs.getString(14);
            String salt = rs.getString(15);
            Date passwordLastModified = rs.getTimestamp(16);
            ScimUser user = new ScimUser();
            user.setId(id);
            ScimMeta meta = new ScimMeta();
            meta.setVersion(version);
            meta.setCreated(created);
            meta.setLastModified(lastModified);
            user.setMeta(meta);
            user.setUserName(userName);
            user.addEmail(email);
            if (phoneNumber != null) {
                user.addPhoneNumber(phoneNumber);
            }
            Name name = new Name();
            name.setGivenName(givenName);
            name.setFamilyName(familyName);
            user.setName(name);
            user.setActive(active);
            user.setVerified(verified);
            user.setOrigin(origin);
            user.setExternalId(externalId);
            user.setZoneId(zoneId);
            user.setSalt(salt);
            user.setPasswordLastModified(passwordLastModified);
            return user;
        }
    }

    @Override
    public int getTotalCount() {
    	Integer count = jdbcTemplate.queryForObject(""select count(*) from users"",Integer.class);
    	if (count == null) {
    		return 0;
    	}
    	return count;
    }

}
",0
CVE-2015-5171,scim/src/main/java/org/cloudfoundry/identity/uaa/scim/jdbc/JdbcScimUserProvisioning.java,"/*******************************************************************************
 *     Cloud Foundry
 *     Copyright (c) [2009-2014] Pivotal Software, Inc. All Rights Reserved.
 *
 *     This product is licensed to you under the Apache License, Version 2.0 (the ""License"").
 *     You may not use this product except in compliance with the License.
 *
 *     This product includes a number of subcomponents with
 *     separate copyright notices and license terms. Your use of these
 *     subcomponents is subject to the terms and conditions of the
 *     subcomponent's license, as noted in the LICENSE file.
 *******************************************************************************/
package org.cloudfoundry.identity.uaa.scim.jdbc;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.cloudfoundry.identity.uaa.authentication.Origin;
import org.cloudfoundry.identity.uaa.rest.ResourceMonitor;
import org.cloudfoundry.identity.uaa.rest.jdbc.AbstractQueryable;
import org.cloudfoundry.identity.uaa.rest.jdbc.JdbcPagingListFactory;
import org.cloudfoundry.identity.uaa.scim.ScimMeta;
import org.cloudfoundry.identity.uaa.scim.ScimUser;
import org.cloudfoundry.identity.uaa.scim.ScimUser.Name;
import org.cloudfoundry.identity.uaa.scim.ScimUserProvisioning;
import org.cloudfoundry.identity.uaa.scim.exception.InvalidPasswordException;
import org.cloudfoundry.identity.uaa.scim.exception.InvalidScimResourceException;
import org.cloudfoundry.identity.uaa.scim.exception.ScimResourceAlreadyExistsException;
import org.cloudfoundry.identity.uaa.scim.exception.ScimResourceConstraintFailedException;
import org.cloudfoundry.identity.uaa.scim.exception.ScimResourceNotFoundException;
import org.cloudfoundry.identity.uaa.zone.IdentityZoneHolder;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.dao.IncorrectResultSizeDataAccessException;
import org.springframework.dao.OptimisticLockingFailureException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementSetter;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.regex.Pattern;

/**
 * @author Luke Taylor
 * @author Dave Syer
 */
public class JdbcScimUserProvisioning extends AbstractQueryable<ScimUser> implements ScimUserProvisioning, ResourceMonitor<ScimUser> {

    private final Log logger = LogFactory.getLog(getClass());

    public static final String USER_FIELDS = ""id,version,created,lastModified,username,email,givenName,familyName,active,phoneNumber,verified,origin,external_id,identity_zone_id,salt,passwd_lastmodified "";

    public static final String CREATE_USER_SQL = ""insert into users ("" + USER_FIELDS
                    + "",password) values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)"";

    public static final String UPDATE_USER_SQL = ""update users set version=?, lastModified=?, userName=?, email=?, givenName=?, familyName=?, active=?, phoneNumber=?, verified=?, origin=?, external_id=?, salt=? where id=? and version=?"";

    public static final String DEACTIVATE_USER_SQL = ""update users set active=? where id=?"";

    public static final String VERIFY_USER_SQL = ""update users set verified=? where id=?"";

    public static final String DELETE_USER_SQL = ""delete from users where id=?"";

    public static final String CHANGE_PASSWORD_SQL = ""update users set lastModified=?, password=?, passwd_lastmodified=? where id=?"";

    public static final String READ_PASSWORD_SQL = ""select password from users where id=?"";

    public static final String USER_BY_ID_QUERY = ""select "" + USER_FIELDS + "" from users "" + ""where id=?"";

    public static final String ALL_USERS = ""select "" + USER_FIELDS + "" from users"";

    protected final JdbcTemplate jdbcTemplate;

    private PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    private boolean deactivateOnDelete = true;

    private final RowMapper<ScimUser> mapper = new ScimUserRowMapper();

    private Pattern usernamePattern = Pattern.compile(""[a-zA-Z0-9+\\-_.@'!]+"");

    public JdbcScimUserProvisioning(JdbcTemplate jdbcTemplate, JdbcPagingListFactory pagingListFactory) {
        super(jdbcTemplate, pagingListFactory, new ScimUserRowMapper());
        Assert.notNull(jdbcTemplate);
        this.jdbcTemplate = jdbcTemplate;
        setQueryConverter(new ScimSearchQueryConverter());
    }

    @Override
    public ScimUser retrieve(String id) {
        try {
            ScimUser u = jdbcTemplate.queryForObject(USER_BY_ID_QUERY, mapper, id);
            return u;
        } catch (EmptyResultDataAccessException e) {
            throw new ScimResourceNotFoundException(""User "" + id + "" does not exist"");
        }
    }

    @Override
    protected String getBaseSqlQuery() {
        return ALL_USERS;
    }

    @Override
    protected String getTableName() {
        return ""users"";
    }

    @Override
    public List<ScimUser> retrieveAll() {
        return query(""id pr"", ""created"", true);
    }

    @Override
    public List<ScimUser> query(String filter, String sortBy, boolean ascending) {
        if (StringUtils.hasText(filter)) {
            filter += "" and"";
        }
        filter += "" identity_zone_id eq \""""+IdentityZoneHolder.get().getId()+""\"""";
        return super.query(filter, sortBy, ascending);
    }

    @Override
    public ScimUser create(final ScimUser user) {
        validate(user);
        logger.debug(""Creating new user: "" + user.getUserName());

        final String id = UUID.randomUUID().toString();
        final String identityZoneId = IdentityZoneHolder.get().getId();
        final String origin = StringUtils.hasText(user.getOrigin()) ? user.getOrigin() : Origin.UAA;

        try {
            jdbcTemplate.update(CREATE_USER_SQL, new PreparedStatementSetter() {
                @Override
                public void setValues(PreparedStatement ps) throws SQLException {
                    Timestamp t = new Timestamp(new Date().getTime());
                    ps.setString(1, id);
                    ps.setInt(2, user.getVersion());
                    ps.setTimestamp(3, t);
                    ps.setTimestamp(4, t);
                    ps.setString(5, user.getUserName());
                    ps.setString(6, user.getPrimaryEmail());
                    if (user.getName() == null) {
                        ps.setString(7, null);
                        ps.setString(8, null);
                    }
                    else {
                        ps.setString(7, user.getName().getGivenName());
                        ps.setString(8, user.getName().getFamilyName());
                    }
                    ps.setBoolean(9, user.isActive());
                    String phoneNumber = extractPhoneNumber(user);
                    ps.setString(10, phoneNumber);
                    ps.setBoolean(11, user.isVerified());
                    ps.setString(12, origin);
                    ps.setString(13, StringUtils.hasText(user.getExternalId())?user.getExternalId():null);
                    ps.setString(14, identityZoneId);
                    ps.setString(15, user.getSalt());
                    ps.setTimestamp(16, getPasswordLastModifiedTimestamp(t));
                    ps.setString(17, user.getPassword());
                }

            });
        } catch (DuplicateKeyException e) {
            ScimUser existingUser = query(""userName eq \"""" + user.getUserName() + ""\"" and origin eq \"""" + (StringUtils.hasText(user.getOrigin())? user.getOrigin() : Origin.UAA) + ""\"""").get(0);
            Map<String,Object> userDetails = new HashMap<>();
            userDetails.put(""active"", existingUser.isActive());
            userDetails.put(""verified"", existingUser.isVerified());
            userDetails.put(""user_id"", existingUser.getId());
            throw new ScimResourceAlreadyExistsException(""Username already in use: "" + existingUser.getUserName(), userDetails);
        }
        return retrieve(id);
    }

    protected Timestamp getPasswordLastModifiedTimestamp(Timestamp t) {
        Calendar cal = new GregorianCalendar();
        cal.set(Calendar.MILLISECOND, 0);
        return new Timestamp(cal.getTimeInMillis());
    }

    @Override
    public ScimUser createUser(ScimUser user, final String password) throws InvalidPasswordException,
                    InvalidScimResourceException {
        user.setPassword(passwordEncoder.encode(password));
        return create(user);
    }

    private void validate(final ScimUser user) throws InvalidScimResourceException {
        if (!usernamePattern.matcher(user.getUserName()).matches()) {
            throw new InvalidScimResourceException(""Username must match pattern: "" + usernamePattern.pattern());
        }
        if (user.getEmails() == null || user.getEmails().isEmpty()) {
            throw new InvalidScimResourceException(""An email must be provided."");
        }
    }

    private String extractPhoneNumber(final ScimUser user) {
        String phoneNumber = null;
        if (user.getPhoneNumbers() != null && !user.getPhoneNumbers().isEmpty()) {
            phoneNumber = user.getPhoneNumbers().get(0).getValue();
        }
        return phoneNumber;
    }

    @Override
    public ScimUser update(final String id, final ScimUser user) throws InvalidScimResourceException {
        validate(user);
        logger.debug(""Updating user "" + user.getUserName());
        final String origin = StringUtils.hasText(user.getOrigin()) ? user.getOrigin() : Origin.UAA;

        int updated = jdbcTemplate.update(UPDATE_USER_SQL, new PreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps) throws SQLException {
                int pos = 1;
                Timestamp t = new Timestamp(new Date().getTime());
                ps.setInt(pos++, user.getVersion() + 1);
                ps.setTimestamp(pos++, t);
                ps.setString(pos++, user.getUserName());
                ps.setString(pos++, user.getPrimaryEmail());
                ps.setString(pos++, user.getName().getGivenName());
                ps.setString(pos++, user.getName().getFamilyName());
                ps.setBoolean(pos++, user.isActive());
                ps.setString(pos++, extractPhoneNumber(user));
                ps.setBoolean(pos++, user.isVerified());
                ps.setString(pos++, origin);
                ps.setString(pos++, StringUtils.hasText(user.getExternalId())?user.getExternalId():null);
                ps.setString(pos++, user.getSalt());
                ps.setString(pos++, id);
                ps.setInt(pos++, user.getVersion());
            }
        });
        ScimUser result = retrieve(id);
        if (updated == 0) {
            throw new OptimisticLockingFailureException(String.format(
                            ""Attempt to update a user (%s) with wrong version: expected=%d but found=%d"", id,
                            result.getVersion(), user.getVersion()));
        }
        if (updated > 1) {
            throw new IncorrectResultSizeDataAccessException(1);
        }
        return result;
    }

    @Override
    public void changePassword(final String id, String oldPassword, final String newPassword)
                    throws ScimResourceNotFoundException {
        if (oldPassword != null && !checkPasswordMatches(id, oldPassword)) {
            throw new BadCredentialsException(""Old password is incorrect"");
        }
        if (checkPasswordMatches(id, newPassword)) {
            return; //we don't want to update the same password
        }
        final String encNewPassword = passwordEncoder.encode(newPassword);
        int updated = jdbcTemplate.update(CHANGE_PASSWORD_SQL, new PreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps) throws SQLException {
                Timestamp t = new Timestamp(new Date().getTime());
                ps.setTimestamp(1, t);
                ps.setString(2, encNewPassword);
                ps.setTimestamp(3, getPasswordLastModifiedTimestamp(t));
                ps.setString(4, id);
            }
        });
        if (updated == 0) {
            throw new ScimResourceNotFoundException(""User "" + id + "" does not exist"");
        }
        if (updated != 1) {
            throw new ScimResourceConstraintFailedException(""User "" + id + "" duplicated"");
        }
    }

    // Checks the existing password for a user
    public boolean checkPasswordMatches(String id, String password) {
        String currentPassword;
        try {
            currentPassword = jdbcTemplate.queryForObject(READ_PASSWORD_SQL, new Object[] { id },
                            new int[] { Types.VARCHAR }, String.class);
        } catch (IncorrectResultSizeDataAccessException e) {
            throw new ScimResourceNotFoundException(""User "" + id + "" does not exist"");
        }

        return passwordEncoder.matches(password, currentPassword);
    }

    @Override
    public ScimUser delete(String id, int version) {
        ScimUser user = retrieve(id);
        return deactivateOnDelete ? deactivateUser(user, version) : deleteUser(user, version);
    }

    private ScimUser deactivateUser(ScimUser user, int version) {
        logger.debug(""Deactivating user: "" + user.getId());
        int updated;
        if (version < 0) {
            // Ignore
            updated = jdbcTemplate.update(DEACTIVATE_USER_SQL, false, user.getId());
        }
        else {
            updated = jdbcTemplate.update(DEACTIVATE_USER_SQL + "" and version=?"", false, user.getId(), version);
        }
        if (updated == 0) {
            throw new OptimisticLockingFailureException(String.format(
                            ""Attempt to update a user (%s) with wrong version: expected=%d but found=%d"", user.getId(),
                            user.getVersion(), version));
        }
        if (updated > 1) {
            throw new IncorrectResultSizeDataAccessException(1);
        }
        user.setActive(false);
        return user;
    }

    @Override
    public ScimUser verifyUser(String id, int version) throws ScimResourceNotFoundException,
                    InvalidScimResourceException {
        logger.debug(""Verifying user: "" + id);
        int updated;
        if (version < 0) {
            // Ignore
            updated = jdbcTemplate.update(VERIFY_USER_SQL, true, id);
        }
        else {
            updated = jdbcTemplate.update(VERIFY_USER_SQL + "" and version=?"", true, id, version);
        }
        ScimUser user = retrieve(id);
        if (updated == 0) {
            throw new OptimisticLockingFailureException(String.format(
                            ""Attempt to update a user (%s) with wrong version: expected=%d but found=%d"", user.getId(),
                            user.getVersion(), version));
        }
        if (updated > 1) {
            throw new IncorrectResultSizeDataAccessException(1);
        }
        return user;
    }

    private ScimUser deleteUser(ScimUser user, int version) {
        logger.debug(""Deleting user: "" + user.getId());
        int updated;

        if (version < 0) {
            updated = jdbcTemplate.update(DELETE_USER_SQL, user.getId());
        }
        else {
            updated = jdbcTemplate.update(DELETE_USER_SQL + "" and version=?"", user.getId(), version);
        }
        if (updated == 0) {
            throw new OptimisticLockingFailureException(String.format(
                            ""Attempt to update a user (%s) with wrong version: expected=%d but found=%d"", user.getId(),
                            user.getVersion(), version));
        }
        return user;
    }

    public void setDeactivateOnDelete(boolean deactivateOnDelete) {
        this.deactivateOnDelete = deactivateOnDelete;
    }

    /**
     * The encoder used to hash passwords before storing them in the database.
     *
     * Defaults to a {@link BCryptPasswordEncoder}.
     */
    public void setPasswordEncoder(PasswordEncoder passwordEncoder) {
        Assert.notNull(passwordEncoder, ""passwordEncoder cannot be null"");
        this.passwordEncoder = passwordEncoder;
    }

    /**
     * Sets the regular expression which will be used to validate the username.
     */
    public void setUsernamePattern(String usernamePattern) {
        Assert.hasText(usernamePattern, ""Username pattern must not be empty"");
        this.usernamePattern = Pattern.compile(usernamePattern);
    }

    private static final class ScimUserRowMapper implements RowMapper<ScimUser> {
        @Override
        public ScimUser mapRow(ResultSet rs, int rowNum) throws SQLException {
            String id = rs.getString(1);
            int version = rs.getInt(2);
            Date created = rs.getTimestamp(3);
            Date lastModified = rs.getTimestamp(4);
            String userName = rs.getString(5);
            String email = rs.getString(6);
            String givenName = rs.getString(7);
            String familyName = rs.getString(8);
            boolean active = rs.getBoolean(9);
            String phoneNumber = rs.getString(10);
            boolean verified = rs.getBoolean(11);
            String origin = rs.getString(12);
            String externalId = rs.getString(13);
            String zoneId = rs.getString(14);
            String salt = rs.getString(15);
            Date passwordLastModified = rs.getTimestamp(16);
            ScimUser user = new ScimUser();
            user.setId(id);
            ScimMeta meta = new ScimMeta();
            meta.setVersion(version);
            meta.setCreated(created);
            meta.setLastModified(lastModified);
            user.setMeta(meta);
            user.setUserName(userName);
            user.addEmail(email);
            if (phoneNumber != null) {
                user.addPhoneNumber(phoneNumber);
            }
            Name name = new Name();
            name.setGivenName(givenName);
            name.setFamilyName(familyName);
            user.setName(name);
            user.setActive(active);
            user.setVerified(verified);
            user.setOrigin(origin);
            user.setExternalId(externalId);
            user.setZoneId(zoneId);
            user.setSalt(salt);
            user.setPasswordLastModified(passwordLastModified);
            return user;
        }
    }

    @Override
    public int getTotalCount() {
    	Integer count = jdbcTemplate.queryForObject(""select count(*) from users"",Integer.class);
    	if (count == null) {
    		return 0;
    	}
    	return count;
    }

}
",1
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/mom/JmsAppenderTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */

package org.apache.logging.log4j.core.appender.mom;

import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.isA;
import static org.mockito.BDDMockito.given;
import static org.mockito.BDDMockito.then;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;

import java.io.Serializable;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.Destination;
import javax.jms.MapMessage;
import javax.jms.MessageProducer;
import javax.jms.ObjectMessage;
import javax.jms.Session;
import javax.jms.TextMessage;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.categories.Appenders;
import org.apache.logging.log4j.core.LogEvent;
import org.apache.logging.log4j.core.impl.Log4jLogEvent;
import org.apache.logging.log4j.junit.JndiRule;
import org.apache.logging.log4j.junit.LoggerContextRule;
import org.apache.logging.log4j.message.Message;
import org.apache.logging.log4j.message.SimpleMessage;
import org.apache.logging.log4j.message.StringMapMessage;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.experimental.categories.Category;
import org.junit.rules.RuleChain;

@Category(Appenders.Jms.class)
public class JmsAppenderTest {

    private static final String CONNECTION_FACTORY_NAME = ""jms/connectionFactory"";
    private static final String QUEUE_FACTORY_NAME = ""jms/queues"";
    private static final String TOPIC_FACTORY_NAME = ""jms/topics"";
    private static final String DESTINATION_NAME = ""jms/destination"";
    private static final String DESTINATION_NAME_ML = ""jms/destination-ml"";
    private static final String QUEUE_NAME = ""jms/queue"";
    private static final String TOPIC_NAME = ""jms/topic"";
    private static final String LOG_MESSAGE = ""Hello, world!"";

    private final ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    private final Connection connection = mock(Connection.class);
    private final Session session = mock(Session.class);
    private final Destination destination = mock(Destination.class);
    private final Destination destinationMl = mock(Destination.class);
    private final MessageProducer messageProducer = mock(MessageProducer.class);
    private final MessageProducer messageProducerMl = mock(MessageProducer.class);
    private final TextMessage textMessage = mock(TextMessage.class);
    private final ObjectMessage objectMessage = mock(ObjectMessage.class);
    private final MapMessage mapMessage = mock(MapMessage.class);

    private final JndiRule jndiRule = new JndiRule(createBindings());
    private final LoggerContextRule ctx = new LoggerContextRule(""JmsAppenderTest.xml"");

    @Rule
    public RuleChain rules = RuleChain.outerRule(jndiRule).around(ctx);

    @AfterClass
    public static void afterClass() throws Exception {
        System.clearProperty(""log4j2.enableJndiJms"");
    }

    @BeforeClass
    public static void beforeClass() throws Exception {
        System.setProperty(""log4j2.enableJndiJms"", ""true"");
    }

    public JmsAppenderTest() throws Exception {
        // this needs to set up before LoggerContextRule
        given(connectionFactory.createConnection()).willReturn(connection);
        given(connectionFactory.createConnection(anyString(), anyString())).willThrow(IllegalArgumentException.class);
        given(connection.createSession(eq(false), eq(Session.AUTO_ACKNOWLEDGE))).willReturn(session);
        given(session.createProducer(eq(destination))).willReturn(messageProducer);
        given(session.createProducer(eq(destinationMl))).willReturn(messageProducerMl);
        given(session.createTextMessage(anyString())).willReturn(textMessage);
        given(session.createObjectMessage(isA(Serializable.class))).willReturn(objectMessage);
        given(session.createMapMessage()).willReturn(mapMessage);
    }

    private Map<String, Object> createBindings() {
        final ConcurrentHashMap<String, Object> map = new ConcurrentHashMap<>();
        map.put(CONNECTION_FACTORY_NAME, connectionFactory);
        map.put(DESTINATION_NAME, destination);
        map.put(DESTINATION_NAME_ML, destinationMl);
        map.put(QUEUE_FACTORY_NAME, connectionFactory);
        map.put(QUEUE_NAME, destination);
        map.put(TOPIC_FACTORY_NAME, connectionFactory);
        map.put(TOPIC_NAME, destination);
        return map;
    }

    private  Log4jLogEvent createLogEvent() {
        return createLogEvent(new SimpleMessage(LOG_MESSAGE));
    }

    private Log4jLogEvent createLogEvent(final Message message) {
        // @formatter:off
        return Log4jLogEvent.newBuilder()
            .setLoggerName(JmsAppenderTest.class.getName())
            .setLoggerFqcn(JmsAppenderTest.class.getName())
            .setLevel(Level.INFO)
            .setMessage(message)
            .build();
        // @formatter:on
    }

    private Log4jLogEvent createMapMessageLogEvent() {
        final StringMapMessage mapMessage = new StringMapMessage();
        return createLogEvent(mapMessage.with(""testMesage"", LOG_MESSAGE));
    }

    @Before
    public void setUp() throws Exception {
        // we have 4 appenders all connecting to the same ConnectionFactory
        then(connection).should(times(4)).start();
    }

    @Test
    public void testAppendToQueue() throws Exception {
        final JmsAppender appender = (JmsAppender) ctx.getRequiredAppender(""JmsAppender"");
        final LogEvent event = createLogEvent();
        appender.append(event);
        then(session).should().createTextMessage(eq(LOG_MESSAGE));
        then(textMessage).should().setJMSTimestamp(anyLong());
        then(messageProducer).should().send(textMessage);
        appender.stop();
        then(session).should().close();
        then(connection).should().close();
    }

    @Test
    public void testAppendToQueueWithMessageLayout() throws Exception {
        final JmsAppender appender = (JmsAppender) ctx.getRequiredAppender(""JmsAppender-MessageLayout"");
        final LogEvent event = createMapMessageLogEvent();
        appender.append(event);
        then(session).should().createMapMessage();
        then(mapMessage).should().setJMSTimestamp(anyLong());
        then(messageProducerMl).should().send(mapMessage);
        appender.stop();
        then(session).should().close();
        then(connection).should().close();
    }

    @Test
    public void testJmsQueueAppenderCompatibility() throws Exception {
        final JmsAppender appender = (JmsAppender) ctx.getRequiredAppender(""JmsQueueAppender"");
        final LogEvent expected = createLogEvent();
        appender.append(expected);
        then(session).should().createObjectMessage(eq(expected));
        then(objectMessage).should().setJMSTimestamp(anyLong());
        then(messageProducer).should().send(objectMessage);
        appender.stop();
        then(session).should().close();
        then(connection).should().close();
    }

    @Test
    public void testJmsTopicAppenderCompatibility() throws Exception {
        final JmsAppender appender = (JmsAppender) ctx.getRequiredAppender(""JmsTopicAppender"");
        final LogEvent expected = createLogEvent();
        appender.append(expected);
        then(session).should().createObjectMessage(eq(expected));
        then(objectMessage).should().setJMSTimestamp(anyLong());
        then(messageProducer).should().send(objectMessage);
        appender.stop();
        then(session).should().close();
        then(connection).should().close();
    }

}",1
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/net/JndiManagerTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */

package org.apache.logging.log4j.core.net;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;

import java.util.Properties;

import org.junit.jupiter.api.Test;

/**
 * Tests {@link JndiManager}.
 */
public class JndiManagerTest {

    @Test
    public void testIsJndiEnabled() {
        assertFalse(JndiManager.isJndiEnabled());
    }

    @Test
    public void testIsJndiContextSelectorEnabled() {
        assertFalse(JndiManager.isJndiContextSelectorEnabled());
    }

    @Test
    public void testIsJndiJmsEnabled() {
        assertFalse(JndiManager.isJndiJmsEnabled());
    }

    @Test
    public void testIsJndiLookupEnabled() {
        assertFalse(JndiManager.isJndiLookupEnabled());
    }
    
    @Test
    public void testNoInstanceByDefault() {
        assertThrows(IllegalStateException.class, () -> JndiManager.getDefaultManager());
        assertThrows(IllegalStateException.class, () -> JndiManager.getDefaultManager(null));
        assertThrows(IllegalStateException.class, () -> JndiManager.getDefaultManager(""A""));
        assertThrows(IllegalStateException.class, () -> JndiManager.getJndiManager(null));
        assertThrows(IllegalStateException.class, () -> JndiManager.getJndiManager(new Properties()));
        assertThrows(IllegalStateException.class, () -> JndiManager.getJndiManager(null, null, null, null, null, null));
        assertThrows(IllegalStateException.class, () -> JndiManager.getJndiManager(""A"", ""A"", ""A"", ""A"", ""A"", new Properties()));
    }
    
    
}
",0
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/net/JndiManagerTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */

package org.apache.logging.log4j.core.net;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;

import java.util.Properties;

import org.junit.jupiter.api.Test;

/**
 * Tests {@link JndiManager}.
 */
public class JndiManagerTest {

    @Test
    public void testIsJndiContextSelectorEnabled() {
        assertFalse(JndiManager.isJndiContextSelectorEnabled());
    }

    @Test
    public void testIsJndiEnabled() {
        assertFalse(JndiManager.isJndiEnabled());
    }

    @Test
    public void testIsJndiJdbcEnabled() {
        assertFalse(JndiManager.isJndiJdbcEnabled());
    }

    @Test
    public void testIsJndiJmsEnabled() {
        assertFalse(JndiManager.isJndiJmsEnabled());
    }

    @Test
    public void testIsJndiLookupEnabled() {
        assertFalse(JndiManager.isJndiLookupEnabled());
    }
    
    @Test
    public void testNoInstanceByDefault() {
        assertThrows(IllegalStateException.class, () -> JndiManager.getDefaultManager());
        assertThrows(IllegalStateException.class, () -> JndiManager.getDefaultManager(null));
        assertThrows(IllegalStateException.class, () -> JndiManager.getDefaultManager(""A""));
        assertThrows(IllegalStateException.class, () -> JndiManager.getJndiManager(null));
        assertThrows(IllegalStateException.class, () -> JndiManager.getJndiManager(new Properties()));
        assertThrows(IllegalStateException.class, () -> JndiManager.getJndiManager(null, null, null, null, null, null));
        assertThrows(IllegalStateException.class, () -> JndiManager.getJndiManager(""A"", ""A"", ""A"", ""A"", ""A"", new Properties()));
    }
    
    
}
",1
CVE-2021-44832,log4j-core/src/main/java/org/apache/logging/log4j/core/appender/db/jdbc/DataSourceConnectionSource.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import java.sql.Connection;
import java.sql.SQLException;

import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.Core;
import org.apache.logging.log4j.core.config.plugins.Plugin;
import org.apache.logging.log4j.core.config.plugins.PluginAttribute;
import org.apache.logging.log4j.core.config.plugins.PluginFactory;
import org.apache.logging.log4j.status.StatusLogger;
import org.apache.logging.log4j.util.Strings;

/**
 * A {@link JdbcAppender} connection source that uses a {@link DataSource} to connect to the database.
 */
@Plugin(name = ""DataSource"", category = Core.CATEGORY_NAME, elementType = ""connectionSource"", printObject = true)
public final class DataSourceConnectionSource extends AbstractConnectionSource {
    private static final Logger LOGGER = StatusLogger.getLogger();

    private final DataSource dataSource;
    private final String description;

    private DataSourceConnectionSource(final String dataSourceName, final DataSource dataSource) {
        this.dataSource = dataSource;
        this.description = ""dataSource{ name="" + dataSourceName + "", value="" + dataSource + "" }"";
    }

    @Override
    public Connection getConnection() throws SQLException {
        return this.dataSource.getConnection();
    }

    @Override
    public String toString() {
        return this.description;
    }

    /**
     * Factory method for creating a connection source within the plugin manager.
     *
     * @param jndiName The full JNDI path where the data source is bound. Should start with java:/comp/env or
     *                 environment-equivalent.
     * @return the created connection source.
     */
    @PluginFactory
    public static DataSourceConnectionSource createConnectionSource(@PluginAttribute(""jndiName"") final String jndiName) {
        if (Strings.isEmpty(jndiName)) {
            LOGGER.error(""No JNDI name provided."");
            return null;
        }

        try {
            final InitialContext context = new InitialContext();
            final DataSource dataSource = (DataSource) context.lookup(jndiName);
            if (dataSource == null) {
                LOGGER.error(""No data source found with JNDI name ["" + jndiName + ""]."");
                return null;
            }

            return new DataSourceConnectionSource(jndiName, dataSource);
        } catch (final NamingException e) {
            LOGGER.error(e.getMessage(), e);
            return null;
        }
    }
}
",0
CVE-2021-44832,log4j-core/src/main/java/org/apache/logging/log4j/core/appender/db/jdbc/DataSourceConnectionSource.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.Objects;

import javax.naming.NamingException;
import javax.sql.DataSource;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.Core;
import org.apache.logging.log4j.core.config.plugins.Plugin;
import org.apache.logging.log4j.core.config.plugins.PluginAttribute;
import org.apache.logging.log4j.core.config.plugins.PluginFactory;
import org.apache.logging.log4j.core.net.JndiManager;
import org.apache.logging.log4j.status.StatusLogger;
import org.apache.logging.log4j.util.Strings;

/**
 * A {@link JdbcAppender} connection source that uses a {@link DataSource} to connect to the database.
 */
@Plugin(name = ""DataSource"", category = Core.CATEGORY_NAME, elementType = ""connectionSource"", printObject = true)
public final class DataSourceConnectionSource extends AbstractConnectionSource {
    private static final Logger LOGGER = StatusLogger.getLogger();

    private final DataSource dataSource;
    private final String description;

    private DataSourceConnectionSource(final String dataSourceName, final DataSource dataSource) {
        this.dataSource = Objects.requireNonNull(dataSource, ""dataSource"");
        this.description = ""dataSource{ name="" + dataSourceName + "", value="" + dataSource + "" }"";
    }

    @Override
    public Connection getConnection() throws SQLException {
        return this.dataSource.getConnection();
    }

    @Override
    public String toString() {
        return this.description;
    }

    /**
     * Factory method for creating a connection source within the plugin manager.
     *
     * @param jndiName The full JNDI path where the data source is bound. Must start with java:/comp/env or environment-equivalent.
     * @return the created connection source.
     */
    @PluginFactory
    public static DataSourceConnectionSource createConnectionSource(@PluginAttribute(""jndiName"") final String jndiName) {
        if (!JndiManager.isJndiJdbcEnabled()) {
            LOGGER.error(""JNDI must be enabled by setting log4j2.enableJndiJdbc=true"");
            return null;
        }
        if (Strings.isEmpty(jndiName)) {
            LOGGER.error(""No JNDI name provided."");
            return null;
        }
        try {
            @SuppressWarnings(""resource"")
            final DataSource dataSource = JndiManager.getDefaultManager(DataSourceConnectionSource.class.getCanonicalName()).lookup(jndiName);
            if (dataSource == null) {
                LOGGER.error(""No DataSource found with JNDI name ["" + jndiName + ""]."");
                return null;
            }
            return new DataSourceConnectionSource(jndiName, dataSource);
        } catch (final NamingException e) {
            LOGGER.error(e.getMessage(), e);
            return null;
        }
    }
}
",1
CVE-2021-44832,log4j-core/src/main/java/org/apache/logging/log4j/core/net/JndiManager.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */

package org.apache.logging.log4j.core.net;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Properties;
import java.util.concurrent.TimeUnit;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import org.apache.logging.log4j.core.appender.AbstractManager;
import org.apache.logging.log4j.core.appender.ManagerFactory;
import org.apache.logging.log4j.core.util.JndiCloser;
import org.apache.logging.log4j.util.PropertiesUtil;

/**
 * Manages a JNDI {@link javax.naming.Context}.
 *
 * @since 2.1
 */
public class JndiManager extends AbstractManager {

    private static final JndiManagerFactory FACTORY = new JndiManagerFactory();
    private static final String PREFIX = ""log4j2.enableJndi"";
    private static final String JAVA_SCHEME = ""java"";

    private final Context context;

    private static boolean isJndiEnabled(final String subKey) {
        return PropertiesUtil.getProperties().getBooleanProperty(PREFIX + subKey, false);
    }

    public static boolean isJndiEnabled() {
        return isJndiContextSelectorEnabled() || isJndiJmsEnabled() || isJndiLookupEnabled();
    }

    public static boolean isJndiContextSelectorEnabled() {
        return isJndiEnabled(""ContextSelector"");
    }

    public static boolean isJndiJmsEnabled() {
        return isJndiEnabled(""Jms"");
    }

    public static boolean isJndiLookupEnabled() {
        return isJndiEnabled(""Lookup"");
    }

    private JndiManager(final String name, final Context context) {
        super(null, name);
        this.context = context;
    }

    /**
     * Gets the default JndiManager using the default {@link javax.naming.InitialContext}.
     *
     * @return the default JndiManager
     */
    public static JndiManager getDefaultManager() {
        return getManager(JndiManager.class.getName(), FACTORY, null);
    }

    /**
     * Gets a named JndiManager using the default {@link javax.naming.InitialContext}.
     *
     * @param name the name of the JndiManager instance to create or use if available
     * @return a default JndiManager
     */
    public static JndiManager getDefaultManager(final String name) {
        return getManager(name, FACTORY, null);
    }

    /**
     * Gets a JndiManager with the provided configuration information.
     *
     * @param initialContextFactoryName Fully qualified class name of an implementation of
     *                                  {@link javax.naming.spi.InitialContextFactory}.
     * @param providerURL               The provider URL to use for the JNDI connection (specific to the above factory).
     * @param urlPkgPrefixes            A colon-separated list of package prefixes for the class name of the factory
     *                                  class that will create a URL context factory
     * @param securityPrincipal         The name of the identity of the Principal.
     * @param securityCredentials       The security credentials of the Principal.
     * @param additionalProperties      Any additional JNDI environment properties to set or {@code null} for none.
     * @return the JndiManager for the provided parameters.
     */
    public static JndiManager getJndiManager(final String initialContextFactoryName,
            final String providerURL,
            final String urlPkgPrefixes,
            final String securityPrincipal,
            final String securityCredentials,
            final Properties additionalProperties) {
        final Properties properties = createProperties(initialContextFactoryName, providerURL, urlPkgPrefixes,
                securityPrincipal, securityCredentials, additionalProperties);
        return getManager(createManagerName(), FACTORY, properties);
    }

    /**
     * Gets a JndiManager with the provided configuration information.
     *
     * @param properties JNDI properties, usually created by calling {@link #createProperties(String, String, String, String, String, Properties)}.
     * @return the JndiManager for the provided parameters.
     * @see #createProperties(String, String, String, String, String, Properties)
     * @since 2.9
     */
    public static JndiManager getJndiManager(final Properties properties) {
        return getManager(createManagerName(), FACTORY, properties);
    }

    private static String createManagerName() {
        return JndiManager.class.getName() + '@' + JndiManager.class.hashCode();
    }

    /**
     * Creates JNDI Properties with the provided configuration information.
     *
     * @param initialContextFactoryName
     *            Fully qualified class name of an implementation of {@link javax.naming.spi.InitialContextFactory}.
     * @param providerURL
     *            The provider URL to use for the JNDI connection (specific to the above factory).
     * @param urlPkgPrefixes
     *            A colon-separated list of package prefixes for the class name of the factory class that will create a
     *            URL context factory
     * @param securityPrincipal
     *            The name of the identity of the Principal.
     * @param securityCredentials
     *            The security credentials of the Principal.
     * @param additionalProperties
     *            Any additional JNDI environment properties to set or {@code null} for none.
     * @return the Properties for the provided parameters.
     * @since 2.9
     */
    public static Properties createProperties(final String initialContextFactoryName, final String providerURL,
            final String urlPkgPrefixes, final String securityPrincipal, final String securityCredentials,
            final Properties additionalProperties) {
        if (initialContextFactoryName == null) {
            return null;
        }
        final Properties properties = new Properties();
        properties.setProperty(Context.INITIAL_CONTEXT_FACTORY, initialContextFactoryName);
        if (providerURL != null) {
            properties.setProperty(Context.PROVIDER_URL, providerURL);
        } else {
            LOGGER.warn(""The JNDI InitialContextFactory class name [{}] was provided, but there was no associated ""
                    + ""provider URL. This is likely to cause problems."", initialContextFactoryName);
        }
        if (urlPkgPrefixes != null) {
            properties.setProperty(Context.URL_PKG_PREFIXES, urlPkgPrefixes);
        }
        if (securityPrincipal != null) {
            properties.setProperty(Context.SECURITY_PRINCIPAL, securityPrincipal);
            if (securityCredentials != null) {
                properties.setProperty(Context.SECURITY_CREDENTIALS, securityCredentials);
            } else {
                LOGGER.warn(""A security principal [{}] was provided, but with no corresponding security credentials."",
                        securityPrincipal);
            }
        }
        if (additionalProperties != null) {
            properties.putAll(additionalProperties);
        }
        return properties;
    }

    @Override
    protected boolean releaseSub(final long timeout, final TimeUnit timeUnit) {
        return JndiCloser.closeSilently(this.context);
    }

    /**
     * Looks up a named object through this JNDI context.
     *
     * @param name name of the object to look up.
     * @param <T>  the type of the object.
     * @return the named object if it could be located.
     * @throws  NamingException if a naming exception is encountered
     */
    @SuppressWarnings(""unchecked"")
    public <T> T lookup(final String name) throws NamingException {
        if (context == null) {
            return null;
        }
        try {
            URI uri = new URI(name);
            if (uri.getScheme() == null || uri.getScheme().equals(JAVA_SCHEME)) {
                return (T) this.context.lookup(name);
            }
            LOGGER.warn(""Unsupported JNDI URI - {}"", name);
        } catch (URISyntaxException ex) {
            LOGGER.warn(""Invalid  JNDI URI - {}"", name);
        }
        return null;
    }

    private static class JndiManagerFactory implements ManagerFactory<JndiManager, Properties> {

        @Override
        public JndiManager createManager(final String name, final Properties data) {
            if (!isJndiEnabled()) {
                throw new IllegalStateException(String.format(""JNDI must be enabled by setting one of the %s* properties to true"", PREFIX));
            }
            try {
                return new JndiManager(name, new InitialContext(data));
            } catch (final NamingException e) {
                LOGGER.error(""Error creating JNDI InitialContext for '{}'."", name, e);
                return null;
            }
        }

    }

    @Override
    public String toString() {
        return ""JndiManager [context="" + context + "", count="" + count + ""]"";
    }

}
",0
CVE-2021-44832,log4j-core/src/main/java/org/apache/logging/log4j/core/net/JndiManager.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */

package org.apache.logging.log4j.core.net;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Properties;
import java.util.concurrent.TimeUnit;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import org.apache.logging.log4j.core.appender.AbstractManager;
import org.apache.logging.log4j.core.appender.ManagerFactory;
import org.apache.logging.log4j.core.util.JndiCloser;
import org.apache.logging.log4j.util.PropertiesUtil;

/**
 * Manages a JNDI {@link javax.naming.Context}.
 *
 * @since 2.1
 */
public class JndiManager extends AbstractManager {

    private static final JndiManagerFactory FACTORY = new JndiManagerFactory();
    private static final String PREFIX = ""log4j2.enableJndi"";
    private static final String JAVA_SCHEME = ""java"";

    private static final boolean JNDI_CONTEXT_SELECTOR_ENABLED = isJndiEnabled(""ContextSelector"");
    private static final boolean JNDI_JDBC_ENABLED = isJndiEnabled(""Jdbc"");
    private static final boolean JNDI_JMS_ENABLED = isJndiEnabled(""Jms"");
    private static final boolean JNDI_LOOKUP_ENABLED = isJndiEnabled(""Lookup"");

    private final InitialContext context;

    private static boolean isJndiEnabled(final String subKey) {
        return PropertiesUtil.getProperties().getBooleanProperty(PREFIX + subKey, false);
    }

    public static boolean isJndiEnabled() {
        return isJndiContextSelectorEnabled() || isJndiJdbcEnabled() || isJndiJmsEnabled() || isJndiLookupEnabled();
    }

    public static boolean isJndiContextSelectorEnabled() {
        return JNDI_CONTEXT_SELECTOR_ENABLED;
    }

    public static boolean isJndiJdbcEnabled() {
        return JNDI_JDBC_ENABLED;
    }

    public static boolean isJndiJmsEnabled() {
        return JNDI_JMS_ENABLED;
    }

    public static boolean isJndiLookupEnabled() {
        return JNDI_LOOKUP_ENABLED;
    }

    private JndiManager(final String name, final InitialContext context) {
        super(null, name);
        this.context = context;
    }

    /**
     * Gets the default JndiManager using the default {@link javax.naming.InitialContext}.
     *
     * @return the default JndiManager
     */
    public static JndiManager getDefaultManager() {
        return getManager(JndiManager.class.getName(), FACTORY, null);
    }

    /**
     * Gets a named JndiManager using the default {@link javax.naming.InitialContext}.
     *
     * @param name the name of the JndiManager instance to create or use if available
     * @return a default JndiManager
     */
    public static JndiManager getDefaultManager(final String name) {
        return getManager(name, FACTORY, null);
    }

    /**
     * Gets a JndiManager with the provided configuration information.
     *
     * @param initialContextFactoryName Fully qualified class name of an implementation of
     *                                  {@link javax.naming.spi.InitialContextFactory}.
     * @param providerURL               The provider URL to use for the JNDI connection (specific to the above factory).
     * @param urlPkgPrefixes            A colon-separated list of package prefixes for the class name of the factory
     *                                  class that will create a URL context factory
     * @param securityPrincipal         The name of the identity of the Principal.
     * @param securityCredentials       The security credentials of the Principal.
     * @param additionalProperties      Any additional JNDI environment properties to set or {@code null} for none.
     * @return the JndiManager for the provided parameters.
     */
    public static JndiManager getJndiManager(final String initialContextFactoryName,
            final String providerURL,
            final String urlPkgPrefixes,
            final String securityPrincipal,
            final String securityCredentials,
            final Properties additionalProperties) {
        final Properties properties = createProperties(initialContextFactoryName, providerURL, urlPkgPrefixes,
                securityPrincipal, securityCredentials, additionalProperties);
        return getManager(createManagerName(), FACTORY, properties);
    }

    /**
     * Gets a JndiManager with the provided configuration information.
     *
     * @param properties JNDI properties, usually created by calling {@link #createProperties(String, String, String, String, String, Properties)}.
     * @return the JndiManager for the provided parameters.
     * @see #createProperties(String, String, String, String, String, Properties)
     * @since 2.9
     */
    public static JndiManager getJndiManager(final Properties properties) {
        return getManager(createManagerName(), FACTORY, properties);
    }

    private static String createManagerName() {
        return JndiManager.class.getName() + '@' + JndiManager.class.hashCode();
    }

    /**
     * Creates JNDI Properties with the provided configuration information.
     *
     * @param initialContextFactoryName
     *            Fully qualified class name of an implementation of {@link javax.naming.spi.InitialContextFactory}.
     * @param providerURL
     *            The provider URL to use for the JNDI connection (specific to the above factory).
     * @param urlPkgPrefixes
     *            A colon-separated list of package prefixes for the class name of the factory class that will create a
     *            URL context factory
     * @param securityPrincipal
     *            The name of the identity of the Principal.
     * @param securityCredentials
     *            The security credentials of the Principal.
     * @param additionalProperties
     *            Any additional JNDI environment properties to set or {@code null} for none.
     * @return the Properties for the provided parameters.
     * @since 2.9
     */
    public static Properties createProperties(final String initialContextFactoryName, final String providerURL,
            final String urlPkgPrefixes, final String securityPrincipal, final String securityCredentials,
            final Properties additionalProperties) {
        if (initialContextFactoryName == null) {
            return null;
        }
        final Properties properties = new Properties();
        properties.setProperty(Context.INITIAL_CONTEXT_FACTORY, initialContextFactoryName);
        if (providerURL != null) {
            properties.setProperty(Context.PROVIDER_URL, providerURL);
        } else {
            LOGGER.warn(""The JNDI InitialContextFactory class name [{}] was provided, but there was no associated ""
                    + ""provider URL. This is likely to cause problems."", initialContextFactoryName);
        }
        if (urlPkgPrefixes != null) {
            properties.setProperty(Context.URL_PKG_PREFIXES, urlPkgPrefixes);
        }
        if (securityPrincipal != null) {
            properties.setProperty(Context.SECURITY_PRINCIPAL, securityPrincipal);
            if (securityCredentials != null) {
                properties.setProperty(Context.SECURITY_CREDENTIALS, securityCredentials);
            } else {
                LOGGER.warn(""A security principal [{}] was provided, but with no corresponding security credentials."",
                        securityPrincipal);
            }
        }
        if (additionalProperties != null) {
            properties.putAll(additionalProperties);
        }
        return properties;
    }

    @Override
    protected boolean releaseSub(final long timeout, final TimeUnit timeUnit) {
        return JndiCloser.closeSilently(this.context);
    }

    /**
     * Looks up a named object through this JNDI context.
     *
     * @param name name of the object to look up.
     * @param <T>  the type of the object.
     * @return the named object if it could be located.
     * @throws  NamingException if a naming exception is encountered
     */
    @SuppressWarnings(""unchecked"")
    public <T> T lookup(final String name) throws NamingException {
        if (context == null) {
            return null;
        }
        try {
            URI uri = new URI(name);
            if (uri.getScheme() == null || uri.getScheme().equals(JAVA_SCHEME)) {
                return (T) this.context.lookup(name);
            }
            LOGGER.warn(""Unsupported JNDI URI - {}"", name);
        } catch (URISyntaxException ex) {
            LOGGER.warn(""Invalid JNDI URI - {}"", name);
        }
        return null;
    }

    private static class JndiManagerFactory implements ManagerFactory<JndiManager, Properties> {

        @Override
        public JndiManager createManager(final String name, final Properties data) {
            if (!isJndiEnabled()) {
                throw new IllegalStateException(String.format(""JNDI must be enabled by setting one of the %s* properties to true"", PREFIX));
            }
            try {
                return new JndiManager(name, new InitialContext(data));
            } catch (final NamingException e) {
                LOGGER.error(""Error creating JNDI InitialContext for '{}'."", name, e);
                return null;
            }
        }

    }

    @Override
    public String toString() {
        return ""JndiManager [context="" + context + "", count="" + count + ""]"";
    }

}
",1
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/db/jdbc/AbstractJdbcAppenderDataSourceTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import java.io.ByteArrayOutputStream;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import javax.sql.DataSource;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.util.Throwables;
import org.apache.logging.log4j.junit.JdbcRule;
import org.apache.logging.log4j.junit.JndiRule;
import org.apache.logging.log4j.junit.LoggerContextRule;
import org.h2.util.IOUtils;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.RuleChain;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

import static org.junit.Assert.*;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.mock;

/**
 * Abstract unit test for JdbcAppender using a {@link DataSource} configuration.
 */
public abstract class AbstractJdbcAppenderDataSourceTest {

    @Rule
    public final RuleChain rules;
    private final JdbcRule jdbcRule;

    protected AbstractJdbcAppenderDataSourceTest(final JdbcRule jdbcRule) {
        this.rules = RuleChain.emptyRuleChain()
            .around(new JndiRule(""java:/comp/env/jdbc/TestDataSourceAppender"", createMockDataSource()))
            .around(jdbcRule)
            .around(new LoggerContextRule(
                ""org/apache/logging/log4j/core/appender/db/jdbc/log4j2-data-source.xml""));
        this.jdbcRule = jdbcRule;
    }

    private DataSource createMockDataSource() {
        try {
            final DataSource dataSource = mock(DataSource.class);
            given(dataSource.getConnection()).willAnswer(new Answer<Connection>() {
                @Override
                public Connection answer(final InvocationOnMock invocation) throws Throwable {
                    return jdbcRule.getConnectionSource().getConnection();
                }
            });
            return dataSource;
        } catch (final SQLException e) {
            Throwables.rethrow(e);
            throw new InternalError(""unreachable"");
        }
    }

    @Test
    public void testDataSourceConfig() throws Exception {
        try (final Connection connection = jdbcRule.getConnectionSource().getConnection()) {
            final Error exception = new Error(""Final error massage is fatal!"");
            final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            try (final PrintWriter writer = new PrintWriter(outputStream)) {
                exception.printStackTrace(writer);
            }
            final String stackTrace = outputStream.toString();

            final long millis = System.currentTimeMillis();

            final Logger logger = LogManager.getLogger(this.getClass().getName() + "".testDataSourceConfig"");
            logger.trace(""Data source logged message 01."");
            logger.fatal(""Error from data source 02."", exception);

            try (final Statement statement = connection.createStatement();
                    final ResultSet resultSet = statement.executeQuery(""SELECT * FROM dsLogEntry ORDER BY id"")) {

                assertTrue(""There should be at least one row."", resultSet.next());

                final long date = resultSet.getTimestamp(""eventDate"").getTime();
                assertTrue(""The date should be later than pre-logging (1)."", date >= millis);
                assertTrue(""The date should be earlier than now (1)."", date <= System.currentTimeMillis());
                assertEquals(""The literal column is not correct (1)."", ""Literal Value of Data Source"",
                        resultSet.getString(""literalColumn""));
                assertEquals(""The level column is not correct (1)."", ""FATAL"", resultSet.getNString(""level""));
                assertEquals(""The logger column is not correct (1)."", logger.getName(), resultSet.getNString(""logger""));
                assertEquals(""The message column is not correct (1)."", ""Error from data source 02."",
                        resultSet.getString(""message""));
                assertEquals(""The exception column is not correct (1)."", stackTrace,
                        IOUtils.readStringAndClose(resultSet.getNClob(""exception"").getCharacterStream(), -1));

                assertFalse(""There should not be two rows."", resultSet.next());
            }
        }
    }
}
",0
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/db/jdbc/AbstractJdbcAppenderDataSourceTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.mock;

import java.io.ByteArrayOutputStream;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import javax.sql.DataSource;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.util.Throwables;
import org.apache.logging.log4j.junit.JdbcRule;
import org.apache.logging.log4j.junit.JndiRule;
import org.apache.logging.log4j.junit.LoggerContextRule;
import org.h2.util.IOUtils;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.RuleChain;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

/**
 * Abstract unit test for JdbcAppender using a {@link DataSource} configuration.
 */
public abstract class AbstractJdbcAppenderDataSourceTest extends AbstractJdbcDataSourceTest {

    @Rule
    public final RuleChain rules;
    private final JdbcRule jdbcRule;

    protected AbstractJdbcAppenderDataSourceTest(final JdbcRule jdbcRule) {
        this.rules = RuleChain.emptyRuleChain()
            .around(new JndiRule(""java:/comp/env/jdbc/TestDataSourceAppender"", createMockDataSource()))
            .around(jdbcRule)
            .around(new LoggerContextRule(
                ""org/apache/logging/log4j/core/appender/db/jdbc/log4j2-data-source.xml""));
        this.jdbcRule = jdbcRule;
    }

    private DataSource createMockDataSource() {
        try {
            final DataSource dataSource = mock(DataSource.class);
            given(dataSource.getConnection()).willAnswer(new Answer<Connection>() {
                @Override
                public Connection answer(final InvocationOnMock invocation) throws Throwable {
                    return jdbcRule.getConnectionSource().getConnection();
                }
            });
            return dataSource;
        } catch (final SQLException e) {
            Throwables.rethrow(e);
            throw new InternalError(""unreachable"");
        }
    }

    @Test
    public void testDataSourceConfig() throws Exception {
        try (final Connection connection = jdbcRule.getConnectionSource().getConnection()) {
            final Error exception = new Error(""Final error massage is fatal!"");
            final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            try (final PrintWriter writer = new PrintWriter(outputStream)) {
                exception.printStackTrace(writer);
            }
            final String stackTrace = outputStream.toString();

            final long millis = System.currentTimeMillis();

            final Logger logger = LogManager.getLogger(this.getClass().getName() + "".testDataSourceConfig"");
            logger.trace(""Data source logged message 01."");
            logger.fatal(""Error from data source 02."", exception);

            try (final Statement statement = connection.createStatement();
                    final ResultSet resultSet = statement.executeQuery(""SELECT * FROM dsLogEntry ORDER BY id"")) {

                assertTrue(""There should be at least one row."", resultSet.next());

                final long date = resultSet.getTimestamp(""eventDate"").getTime();
                assertTrue(""The date should be later than pre-logging (1)."", date >= millis);
                assertTrue(""The date should be earlier than now (1)."", date <= System.currentTimeMillis());
                assertEquals(""The literal column is not correct (1)."", ""Literal Value of Data Source"",
                        resultSet.getString(""literalColumn""));
                assertEquals(""The level column is not correct (1)."", ""FATAL"", resultSet.getNString(""level""));
                assertEquals(""The logger column is not correct (1)."", logger.getName(), resultSet.getNString(""logger""));
                assertEquals(""The message column is not correct (1)."", ""Error from data source 02."",
                        resultSet.getString(""message""));
                assertEquals(""The exception column is not correct (1)."", stackTrace,
                        IOUtils.readStringAndClose(resultSet.getNClob(""exception"").getCharacterStream(), -1));

                assertFalse(""There should not be two rows."", resultSet.next());
            }
        }
    }
}
",1
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/db/jdbc/DataSourceConnectionSourceTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.mock;

import java.sql.Connection;
import java.sql.SQLException;

import javax.sql.DataSource;

import org.apache.logging.log4j.junit.JndiRule;
import org.apache.logging.log4j.junit.LoggerContextRule;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.RuleChain;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

@RunWith(Parameterized.class)
public class DataSourceConnectionSourceTest {

    @Parameterized.Parameters(name = ""{0}"")
    public static Object[][] data() {
        return new Object[][]{
            {""java:/comp/env/jdbc/Logging01""},
            {""java:/comp/env/jdbc/Logging02""}
        };
    }

    private static final String CONFIG = ""log4j-fatalOnly.xml"";

    @Rule
    public final RuleChain rules;
    private final DataSource dataSource = mock(DataSource.class);
    private final String jndiURL;

    public DataSourceConnectionSourceTest(final String jndiURL) {
        this.rules = RuleChain.outerRule(new JndiRule(jndiURL, dataSource))
            .around(new LoggerContextRule(CONFIG));
        this.jndiURL = jndiURL;
    }

    @Test
    public void testNullJndiName() {
        final DataSourceConnectionSource source = DataSourceConnectionSource.createConnectionSource(null);

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testEmptyJndiName() {
        final DataSourceConnectionSource source = DataSourceConnectionSource.createConnectionSource("""");

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testNoDataSource() {
        final DataSourceConnectionSource source = DataSourceConnectionSource.createConnectionSource(jndiURL + ""123"");

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testDataSource() throws SQLException {
        try (final Connection connection1 = mock(Connection.class);
                final Connection connection2 = mock(Connection.class)) {

            given(dataSource.getConnection()).willReturn(connection1, connection2);

            DataSourceConnectionSource source = DataSourceConnectionSource.createConnectionSource(jndiURL);

            assertNotNull(""The connection source should not be null."", source);
            assertEquals(""The toString value is not correct."",
                    ""dataSource{ name="" + jndiURL + "", value="" + dataSource + "" }"", source.toString());
            assertSame(""The connection is not correct (1)."", connection1, source.getConnection());
            assertSame(""The connection is not correct (2)."", connection2, source.getConnection());

            source = DataSourceConnectionSource.createConnectionSource(jndiURL.substring(0, jndiURL.length() - 1));

            assertNull(""The connection source should be null now."", source);
        }
    }

}
",0
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/db/jdbc/DataSourceConnectionSourceTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.mock;

import java.sql.Connection;
import java.sql.SQLException;

import javax.sql.DataSource;

import org.apache.logging.log4j.junit.JndiRule;
import org.apache.logging.log4j.junit.LoggerContextRule;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.RuleChain;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

@RunWith(Parameterized.class)
public class DataSourceConnectionSourceTest extends AbstractJdbcDataSourceTest {

    @Parameterized.Parameters(name = ""{0}"")
    public static Object[][] data() {
        return new Object[][]{
            {""java:/comp/env/jdbc/Logging01""},
            {""java:/comp/env/jdbc/Logging02""}
        };
    }

    private static final String CONFIG = ""log4j-fatalOnly.xml"";

    @Rule
    public final RuleChain rules;
    private final DataSource dataSource = mock(DataSource.class);
    private final String jndiURL;

    public DataSourceConnectionSourceTest(final String jndiURL) {
        this.rules = RuleChain.outerRule(new JndiRule(jndiURL, dataSource))
            .around(new LoggerContextRule(CONFIG));
        this.jndiURL = jndiURL;
    }

    @Test
    public void testNullJndiName() {
        final DataSourceConnectionSource source = DataSourceConnectionSource.createConnectionSource(null);

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testEmptyJndiName() {
        final DataSourceConnectionSource source = DataSourceConnectionSource.createConnectionSource("""");

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testNoDataSource() {
        final DataSourceConnectionSource source = DataSourceConnectionSource.createConnectionSource(jndiURL + ""123"");

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testDataSource() throws SQLException {
        try (final Connection connection1 = mock(Connection.class);
                final Connection connection2 = mock(Connection.class)) {

            given(dataSource.getConnection()).willReturn(connection1, connection2);

            DataSourceConnectionSource source = DataSourceConnectionSource.createConnectionSource(jndiURL);

            assertNotNull(""The connection source should not be null."", source);
            assertEquals(""The toString value is not correct."",
                    ""dataSource{ name="" + jndiURL + "", value="" + dataSource + "" }"", source.toString());
            assertSame(""The connection is not correct (1)."", connection1, source.getConnection());
            assertSame(""The connection is not correct (2)."", connection2, source.getConnection());

            source = DataSourceConnectionSource.createConnectionSource(jndiURL.substring(0, jndiURL.length() - 1));

            assertNull(""The connection source should be null now."", source);
        }
    }

}
",1
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/db/jdbc/JdbcAppenderMapMessageDataSourceTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.mock;

import java.io.ByteArrayOutputStream;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import javax.sql.DataSource;

import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.util.Throwables;
import org.apache.logging.log4j.junit.JdbcRule;
import org.apache.logging.log4j.junit.JndiRule;
import org.apache.logging.log4j.junit.LoggerContextRule;
import org.apache.logging.log4j.message.MapMessage;
import org.junit.Assert;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.RuleChain;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

/**
 * Unit tests {@link MapMessage}s for JdbcAppender using a {@link DataSource} configuration.
 */
public class JdbcAppenderMapMessageDataSourceTest {

    @Rule
    public final RuleChain rules;
    private final JdbcRule jdbcRule;

    public JdbcAppenderMapMessageDataSourceTest() {
        this(new JdbcRule(JdbcH2TestHelper.TEST_CONFIGURATION_SOURCE_MEM,
        // @formatter:off
                ""CREATE TABLE dsLogEntry (Id INTEGER IDENTITY, ColumnA VARCHAR(255), ColumnB VARCHAR(255))"",
                ""DROP TABLE dsLogEntry""));
        // @formatter:on
    }

    protected JdbcAppenderMapMessageDataSourceTest(final JdbcRule jdbcRule) {
        // @formatter:off
        this.rules = RuleChain.emptyRuleChain()
                .around(new JndiRule(""java:/comp/env/jdbc/TestDataSourceAppender"", createMockDataSource()))
                .around(jdbcRule)
                .around(new LoggerContextRule(""org/apache/logging/log4j/core/appender/db/jdbc/log4j2-data-source-map-message.xml""));
        // @formatter:on
        this.jdbcRule = jdbcRule;
    }

    private DataSource createMockDataSource() {
        try {
            final DataSource dataSource = mock(DataSource.class);
            given(dataSource.getConnection()).willAnswer(new Answer<Connection>() {
                @Override
                public Connection answer(final InvocationOnMock invocation) throws Throwable {
                    return jdbcRule.getConnectionSource().getConnection();
                }
            });
            return dataSource;
        } catch (final SQLException e) {
            Throwables.rethrow(e);
            throw new InternalError(""unreachable"");
        }
    }

    @Test
    public void testDataSourceConfig() throws Exception {
        try (final Connection connection = jdbcRule.getConnectionSource().getConnection()) {
            final Error exception = new Error(""Final error massage is fatal!"");
            final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            final PrintWriter writer = new PrintWriter(outputStream);
            exception.printStackTrace(writer);
            writer.close();

            final Logger logger = LogManager.getLogger(this.getClass().getName() + "".testDataSourceConfig"");
            final MapMessage mapMessage = new MapMessage();
            mapMessage.with(""Id"", 1);
            mapMessage.with(""ColumnA"", ""ValueA"");
            mapMessage.with(""ColumnB"", ""ValueB"");
            logger.info(mapMessage);

            try (final Statement statement = connection.createStatement();
                    final ResultSet resultSet = statement
                            .executeQuery(""SELECT Id, ColumnA, ColumnB FROM dsLogEntry ORDER BY Id"")) {

                assertTrue(""There should be at least one row."", resultSet.next());

                Assert.assertEquals(1, resultSet.getInt(""Id""));

                assertFalse(""There should not be two rows."", resultSet.next());
            }
        }
    }

    @Test
    public void testTruncate() throws SQLException {
        try (final Connection connection = jdbcRule.getConnectionSource().getConnection()) {
            final Logger logger = LogManager.getLogger(this.getClass().getName() + "".testFactoryMethodConfig"");
            // Some drivers and database will not allow more data than the column defines.
            // We really need a MySQL databases with a default configuration to test this.
            final MapMessage mapMessage = new MapMessage();
            mapMessage.with(""Id"", 1);
            mapMessage.with(""ColumnA"", StringUtils.repeat('A', 1000));
            mapMessage.with(""ColumnB"", StringUtils.repeat('B', 1000));
            logger.info(mapMessage);
            try (final Statement statement = connection.createStatement();
                    final ResultSet resultSet = statement
                            .executeQuery(""SELECT Id, ColumnA, ColumnB FROM dsLogEntry ORDER BY Id"")) {

                assertTrue(""There should be at least one row."", resultSet.next());

                Assert.assertEquals(1, resultSet.getInt(""Id""));

                assertFalse(""There should not be two rows."", resultSet.next());
            }
        }
    }
}
",0
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/db/jdbc/JdbcAppenderMapMessageDataSourceTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.mock;

import java.io.ByteArrayOutputStream;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import javax.sql.DataSource;

import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.util.Throwables;
import org.apache.logging.log4j.junit.JdbcRule;
import org.apache.logging.log4j.junit.JndiRule;
import org.apache.logging.log4j.junit.LoggerContextRule;
import org.apache.logging.log4j.message.MapMessage;
import org.junit.Assert;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.RuleChain;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

/**
 * Unit tests {@link MapMessage}s for JdbcAppender using a {@link DataSource} configuration.
 */
public class JdbcAppenderMapMessageDataSourceTest extends AbstractJdbcDataSourceTest {

    @Rule
    public final RuleChain rules;
    private final JdbcRule jdbcRule;

    public JdbcAppenderMapMessageDataSourceTest() {
        this(new JdbcRule(JdbcH2TestHelper.TEST_CONFIGURATION_SOURCE_MEM,
        // @formatter:off
                ""CREATE TABLE dsLogEntry (Id INTEGER IDENTITY, ColumnA VARCHAR(255), ColumnB VARCHAR(255))"",
                ""DROP TABLE dsLogEntry""));
        // @formatter:on
    }

    protected JdbcAppenderMapMessageDataSourceTest(final JdbcRule jdbcRule) {
        // @formatter:off
        this.rules = RuleChain.emptyRuleChain()
                .around(new JndiRule(""java:/comp/env/jdbc/TestDataSourceAppender"", createMockDataSource()))
                .around(jdbcRule)
                .around(new LoggerContextRule(""org/apache/logging/log4j/core/appender/db/jdbc/log4j2-data-source-map-message.xml""));
        // @formatter:on
        this.jdbcRule = jdbcRule;
    }

    private DataSource createMockDataSource() {
        try {
            final DataSource dataSource = mock(DataSource.class);
            given(dataSource.getConnection()).willAnswer(new Answer<Connection>() {
                @Override
                public Connection answer(final InvocationOnMock invocation) throws Throwable {
                    return jdbcRule.getConnectionSource().getConnection();
                }
            });
            return dataSource;
        } catch (final SQLException e) {
            Throwables.rethrow(e);
            throw new InternalError(""unreachable"");
        }
    }

    @Test
    public void testDataSourceConfig() throws Exception {
        try (final Connection connection = jdbcRule.getConnectionSource().getConnection()) {
            final Error exception = new Error(""Final error massage is fatal!"");
            final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            final PrintWriter writer = new PrintWriter(outputStream);
            exception.printStackTrace(writer);
            writer.close();

            final Logger logger = LogManager.getLogger(this.getClass().getName() + "".testDataSourceConfig"");
            final MapMessage mapMessage = new MapMessage();
            mapMessage.with(""Id"", 1);
            mapMessage.with(""ColumnA"", ""ValueA"");
            mapMessage.with(""ColumnB"", ""ValueB"");
            logger.info(mapMessage);

            try (final Statement statement = connection.createStatement();
                    final ResultSet resultSet = statement
                            .executeQuery(""SELECT Id, ColumnA, ColumnB FROM dsLogEntry ORDER BY Id"")) {

                assertTrue(""There should be at least one row."", resultSet.next());

                Assert.assertEquals(1, resultSet.getInt(""Id""));

                assertFalse(""There should not be two rows."", resultSet.next());
            }
        }
    }

    @Test
    public void testTruncate() throws SQLException {
        try (final Connection connection = jdbcRule.getConnectionSource().getConnection()) {
            final Logger logger = LogManager.getLogger(this.getClass().getName() + "".testFactoryMethodConfig"");
            // Some drivers and database will not allow more data than the column defines.
            // We really need a MySQL databases with a default configuration to test this.
            final MapMessage mapMessage = new MapMessage();
            mapMessage.with(""Id"", 1);
            mapMessage.with(""ColumnA"", StringUtils.repeat('A', 1000));
            mapMessage.with(""ColumnB"", StringUtils.repeat('B', 1000));
            logger.info(mapMessage);
            try (final Statement statement = connection.createStatement();
                    final ResultSet resultSet = statement
                            .executeQuery(""SELECT Id, ColumnA, ColumnB FROM dsLogEntry ORDER BY Id"")) {

                assertTrue(""There should be at least one row."", resultSet.next());

                Assert.assertEquals(1, resultSet.getInt(""Id""));

                assertFalse(""There should not be two rows."", resultSet.next());
            }
        }
    }
}
",1
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/mom/JmsAppenderTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */

package org.apache.logging.log4j.core.appender.mom;

import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.isA;
import static org.mockito.BDDMockito.given;
import static org.mockito.BDDMockito.then;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;

import java.io.Serializable;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.Destination;
import javax.jms.MapMessage;
import javax.jms.MessageProducer;
import javax.jms.ObjectMessage;
import javax.jms.Session;
import javax.jms.TextMessage;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.categories.Appenders;
import org.apache.logging.log4j.core.LogEvent;
import org.apache.logging.log4j.core.impl.Log4jLogEvent;
import org.apache.logging.log4j.junit.JndiRule;
import org.apache.logging.log4j.junit.LoggerContextRule;
import org.apache.logging.log4j.message.Message;
import org.apache.logging.log4j.message.SimpleMessage;
import org.apache.logging.log4j.message.StringMapMessage;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.experimental.categories.Category;
import org.junit.rules.RuleChain;

@Category(Appenders.Jms.class)
public class JmsAppenderTest {

    private static final String CONNECTION_FACTORY_NAME = ""jms/connectionFactory"";
    private static final String QUEUE_FACTORY_NAME = ""jms/queues"";
    private static final String TOPIC_FACTORY_NAME = ""jms/topics"";
    private static final String DESTINATION_NAME = ""jms/destination"";
    private static final String DESTINATION_NAME_ML = ""jms/destination-ml"";
    private static final String QUEUE_NAME = ""jms/queue"";
    private static final String TOPIC_NAME = ""jms/topic"";
    private static final String LOG_MESSAGE = ""Hello, world!"";

    private final ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    private final Connection connection = mock(Connection.class);
    private final Session session = mock(Session.class);
    private final Destination destination = mock(Destination.class);
    private final Destination destinationMl = mock(Destination.class);
    private final MessageProducer messageProducer = mock(MessageProducer.class);
    private final MessageProducer messageProducerMl = mock(MessageProducer.class);
    private final TextMessage textMessage = mock(TextMessage.class);
    private final ObjectMessage objectMessage = mock(ObjectMessage.class);
    private final MapMessage mapMessage = mock(MapMessage.class);

    private final JndiRule jndiRule = new JndiRule(createBindings());
    private final LoggerContextRule ctx = new LoggerContextRule(""JmsAppenderTest.xml"");

    @Rule
    public RuleChain rules = RuleChain.outerRule(jndiRule).around(ctx);

    @BeforeClass
    public static void afterClass() throws Exception {
        System.clearProperty(""log4j2.enableJndiJms"");
    }

    @BeforeClass
    public static void beforeClass() throws Exception {
        System.setProperty(""log4j2.enableJndiJms"", ""true"");
    }

    public JmsAppenderTest() throws Exception {
        // this needs to set up before LoggerContextRule
        given(connectionFactory.createConnection()).willReturn(connection);
        given(connectionFactory.createConnection(anyString(), anyString())).willThrow(IllegalArgumentException.class);
        given(connection.createSession(eq(false), eq(Session.AUTO_ACKNOWLEDGE))).willReturn(session);
        given(session.createProducer(eq(destination))).willReturn(messageProducer);
        given(session.createProducer(eq(destinationMl))).willReturn(messageProducerMl);
        given(session.createTextMessage(anyString())).willReturn(textMessage);
        given(session.createObjectMessage(isA(Serializable.class))).willReturn(objectMessage);
        given(session.createMapMessage()).willReturn(mapMessage);
    }

    private Map<String, Object> createBindings() {
        final ConcurrentHashMap<String, Object> map = new ConcurrentHashMap<>();
        map.put(CONNECTION_FACTORY_NAME, connectionFactory);
        map.put(DESTINATION_NAME, destination);
        map.put(DESTINATION_NAME_ML, destinationMl);
        map.put(QUEUE_FACTORY_NAME, connectionFactory);
        map.put(QUEUE_NAME, destination);
        map.put(TOPIC_FACTORY_NAME, connectionFactory);
        map.put(TOPIC_NAME, destination);
        return map;
    }

    private  Log4jLogEvent createLogEvent() {
        return createLogEvent(new SimpleMessage(LOG_MESSAGE));
    }

    private Log4jLogEvent createLogEvent(final Message message) {
        // @formatter:off
        return Log4jLogEvent.newBuilder()
            .setLoggerName(JmsAppenderTest.class.getName())
            .setLoggerFqcn(JmsAppenderTest.class.getName())
            .setLevel(Level.INFO)
            .setMessage(message)
            .build();
        // @formatter:on
    }

    private Log4jLogEvent createMapMessageLogEvent() {
        final StringMapMessage mapMessage = new StringMapMessage();
        return createLogEvent(mapMessage.with(""testMesage"", LOG_MESSAGE));
    }

    @Before
    public void setUp() throws Exception {
        // we have 4 appenders all connecting to the same ConnectionFactory
        then(connection).should(times(4)).start();
    }

    @Test
    public void testAppendToQueue() throws Exception {
        final JmsAppender appender = (JmsAppender) ctx.getRequiredAppender(""JmsAppender"");
        final LogEvent event = createLogEvent();
        appender.append(event);
        then(session).should().createTextMessage(eq(LOG_MESSAGE));
        then(textMessage).should().setJMSTimestamp(anyLong());
        then(messageProducer).should().send(textMessage);
        appender.stop();
        then(session).should().close();
        then(connection).should().close();
    }

    @Test
    public void testAppendToQueueWithMessageLayout() throws Exception {
        final JmsAppender appender = (JmsAppender) ctx.getRequiredAppender(""JmsAppender-MessageLayout"");
        final LogEvent event = createMapMessageLogEvent();
        appender.append(event);
        then(session).should().createMapMessage();
        then(mapMessage).should().setJMSTimestamp(anyLong());
        then(messageProducerMl).should().send(mapMessage);
        appender.stop();
        then(session).should().close();
        then(connection).should().close();
    }

    @Test
    public void testJmsQueueAppenderCompatibility() throws Exception {
        final JmsAppender appender = (JmsAppender) ctx.getRequiredAppender(""JmsQueueAppender"");
        final LogEvent expected = createLogEvent();
        appender.append(expected);
        then(session).should().createObjectMessage(eq(expected));
        then(objectMessage).should().setJMSTimestamp(anyLong());
        then(messageProducer).should().send(objectMessage);
        appender.stop();
        then(session).should().close();
        then(connection).should().close();
    }

    @Test
    public void testJmsTopicAppenderCompatibility() throws Exception {
        final JmsAppender appender = (JmsAppender) ctx.getRequiredAppender(""JmsTopicAppender"");
        final LogEvent expected = createLogEvent();
        appender.append(expected);
        then(session).should().createObjectMessage(eq(expected));
        then(objectMessage).should().setJMSTimestamp(anyLong());
        then(messageProducer).should().send(objectMessage);
        appender.stop();
        then(session).should().close();
        then(connection).should().close();
    }

}",0
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/mom/JmsAppenderTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */

package org.apache.logging.log4j.core.appender.mom;

import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.isA;
import static org.mockito.BDDMockito.given;
import static org.mockito.BDDMockito.then;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;

import java.io.Serializable;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.Destination;
import javax.jms.MapMessage;
import javax.jms.MessageProducer;
import javax.jms.ObjectMessage;
import javax.jms.Session;
import javax.jms.TextMessage;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.categories.Appenders;
import org.apache.logging.log4j.core.LogEvent;
import org.apache.logging.log4j.core.impl.Log4jLogEvent;
import org.apache.logging.log4j.junit.JndiRule;
import org.apache.logging.log4j.junit.LoggerContextRule;
import org.apache.logging.log4j.message.Message;
import org.apache.logging.log4j.message.SimpleMessage;
import org.apache.logging.log4j.message.StringMapMessage;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.experimental.categories.Category;
import org.junit.rules.RuleChain;

@Category(Appenders.Jms.class)
public class JmsAppenderTest {

    private static final String CONNECTION_FACTORY_NAME = ""jms/connectionFactory"";
    private static final String QUEUE_FACTORY_NAME = ""jms/queues"";
    private static final String TOPIC_FACTORY_NAME = ""jms/topics"";
    private static final String DESTINATION_NAME = ""jms/destination"";
    private static final String DESTINATION_NAME_ML = ""jms/destination-ml"";
    private static final String QUEUE_NAME = ""jms/queue"";
    private static final String TOPIC_NAME = ""jms/topic"";
    private static final String LOG_MESSAGE = ""Hello, world!"";

    private final ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    private final Connection connection = mock(Connection.class);
    private final Session session = mock(Session.class);
    private final Destination destination = mock(Destination.class);
    private final Destination destinationMl = mock(Destination.class);
    private final MessageProducer messageProducer = mock(MessageProducer.class);
    private final MessageProducer messageProducerMl = mock(MessageProducer.class);
    private final TextMessage textMessage = mock(TextMessage.class);
    private final ObjectMessage objectMessage = mock(ObjectMessage.class);
    private final MapMessage mapMessage = mock(MapMessage.class);

    private final JndiRule jndiRule = new JndiRule(createBindings());
    private final LoggerContextRule ctx = new LoggerContextRule(""JmsAppenderTest.xml"");

    @Rule
    public RuleChain rules = RuleChain.outerRule(jndiRule).around(ctx);

    @AfterClass
    public static void afterClass() throws Exception {
        System.clearProperty(""log4j2.enableJndiJms"");
    }

    @BeforeClass
    public static void beforeClass() throws Exception {
        System.setProperty(""log4j2.enableJndiJms"", ""true"");
    }

    public JmsAppenderTest() throws Exception {
        // this needs to set up before LoggerContextRule
        given(connectionFactory.createConnection()).willReturn(connection);
        given(connectionFactory.createConnection(anyString(), anyString())).willThrow(IllegalArgumentException.class);
        given(connection.createSession(eq(false), eq(Session.AUTO_ACKNOWLEDGE))).willReturn(session);
        given(session.createProducer(eq(destination))).willReturn(messageProducer);
        given(session.createProducer(eq(destinationMl))).willReturn(messageProducerMl);
        given(session.createTextMessage(anyString())).willReturn(textMessage);
        given(session.createObjectMessage(isA(Serializable.class))).willReturn(objectMessage);
        given(session.createMapMessage()).willReturn(mapMessage);
    }

    private Map<String, Object> createBindings() {
        final ConcurrentHashMap<String, Object> map = new ConcurrentHashMap<>();
        map.put(CONNECTION_FACTORY_NAME, connectionFactory);
        map.put(DESTINATION_NAME, destination);
        map.put(DESTINATION_NAME_ML, destinationMl);
        map.put(QUEUE_FACTORY_NAME, connectionFactory);
        map.put(QUEUE_NAME, destination);
        map.put(TOPIC_FACTORY_NAME, connectionFactory);
        map.put(TOPIC_NAME, destination);
        return map;
    }

    private  Log4jLogEvent createLogEvent() {
        return createLogEvent(new SimpleMessage(LOG_MESSAGE));
    }

    private Log4jLogEvent createLogEvent(final Message message) {
        // @formatter:off
        return Log4jLogEvent.newBuilder()
            .setLoggerName(JmsAppenderTest.class.getName())
            .setLoggerFqcn(JmsAppenderTest.class.getName())
            .setLevel(Level.INFO)
            .setMessage(message)
            .build();
        // @formatter:on
    }

    private Log4jLogEvent createMapMessageLogEvent() {
        final StringMapMessage mapMessage = new StringMapMessage();
        return createLogEvent(mapMessage.with(""testMesage"", LOG_MESSAGE));
    }

    @Before
    public void setUp() throws Exception {
        // we have 4 appenders all connecting to the same ConnectionFactory
        then(connection).should(times(4)).start();
    }

    @Test
    public void testAppendToQueue() throws Exception {
        final JmsAppender appender = (JmsAppender) ctx.getRequiredAppender(""JmsAppender"");
        final LogEvent event = createLogEvent();
        appender.append(event);
        then(session).should().createTextMessage(eq(LOG_MESSAGE));
        then(textMessage).should().setJMSTimestamp(anyLong());
        then(messageProducer).should().send(textMessage);
        appender.stop();
        then(session).should().close();
        then(connection).should().close();
    }

    @Test
    public void testAppendToQueueWithMessageLayout() throws Exception {
        final JmsAppender appender = (JmsAppender) ctx.getRequiredAppender(""JmsAppender-MessageLayout"");
        final LogEvent event = createMapMessageLogEvent();
        appender.append(event);
        then(session).should().createMapMessage();
        then(mapMessage).should().setJMSTimestamp(anyLong());
        then(messageProducerMl).should().send(mapMessage);
        appender.stop();
        then(session).should().close();
        then(connection).should().close();
    }

    @Test
    public void testJmsQueueAppenderCompatibility() throws Exception {
        final JmsAppender appender = (JmsAppender) ctx.getRequiredAppender(""JmsQueueAppender"");
        final LogEvent expected = createLogEvent();
        appender.append(expected);
        then(session).should().createObjectMessage(eq(expected));
        then(objectMessage).should().setJMSTimestamp(anyLong());
        then(messageProducer).should().send(objectMessage);
        appender.stop();
        then(session).should().close();
        then(connection).should().close();
    }

    @Test
    public void testJmsTopicAppenderCompatibility() throws Exception {
        final JmsAppender appender = (JmsAppender) ctx.getRequiredAppender(""JmsTopicAppender"");
        final LogEvent expected = createLogEvent();
        appender.append(expected);
        then(session).should().createObjectMessage(eq(expected));
        then(objectMessage).should().setJMSTimestamp(anyLong());
        then(messageProducer).should().send(objectMessage);
        appender.stop();
        then(session).should().close();
        then(connection).should().close();
    }

}",1
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/net/JndiManagerTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */

package org.apache.logging.log4j.core.net;

import static org.junit.Assert.assertFalse;

import java.util.Properties;

import org.apache.logging.log4j.test.JUnit5Bridge;
import org.junit.Test;

/**
 * Tests {@link JndiManager}.
 */
public class JndiManagerTest {

    @Test
    public void testIsJndiEnabled() {
        assertFalse(JndiManager.isJndiEnabled());
    }

    @Test
    public void testIsJndiContextSelectorEnabled() {
        assertFalse(JndiManager.isJndiContextSelectorEnabled());
    }

    @Test
    public void testIsJndiJmsEnabled() {
        assertFalse(JndiManager.isJndiJmsEnabled());
    }

    @Test
    public void testIsJndiLookupEnabled() {
        assertFalse(JndiManager.isJndiLookupEnabled());
    }

    @Test
    public void testNoInstanceByDefault() {
        JUnit5Bridge.assertThrows(IllegalStateException.class, new Runnable() {
            @Override
            public void run() {
                JndiManager.getDefaultManager();
            }
        });
        JUnit5Bridge.assertThrows(IllegalStateException.class, new Runnable() {
            @Override
            public void run() {
                JndiManager.getDefaultManager(null);
            }
        });
        JUnit5Bridge.assertThrows(IllegalStateException.class, new Runnable() {
            @Override
            public void run() {
                JndiManager.getDefaultManager(""A"");
            }
        });
        JUnit5Bridge.assertThrows(IllegalStateException.class, new Runnable() {
            @Override
            public void run() {
                JndiManager.getJndiManager(null);
            }
        });
        JUnit5Bridge.assertThrows(IllegalStateException.class, new Runnable() {
            @Override
            public void run() {
                JndiManager.getJndiManager(new Properties());
            }
        });
        JUnit5Bridge.assertThrows(IllegalStateException.class, new Runnable() {
            @Override
            public void run() {
                JndiManager.getJndiManager(null, null, null, null, null, null);
            }
        });
        JUnit5Bridge.assertThrows(IllegalStateException.class, new Runnable() {
            @Override
            public void run() {
                JndiManager.getJndiManager(""A"", ""A"", ""A"", ""A"", ""A"", new Properties());
            }
        });
    }

}
",0
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/net/JndiManagerTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */

package org.apache.logging.log4j.core.net;

import static org.junit.Assert.assertFalse;

import java.util.Properties;

import org.apache.logging.log4j.test.JUnit5Bridge;
import org.junit.Test;

/**
 * Tests {@link JndiManager}.
 */
public class JndiManagerTest {

    @Test
    public void testIsJndiContextSelectorEnabled() {
        assertFalse(JndiManager.isJndiContextSelectorEnabled());
    }

    @Test
    public void testIsJndiEnabled() {
        assertFalse(JndiManager.isJndiEnabled());
    }

    @Test
    public void testIsJndiJdbcEnabled() {
        assertFalse(JndiManager.isJndiJdbcEnabled());
    }

    @Test
    public void testIsJndiJmsEnabled() {
        assertFalse(JndiManager.isJndiJmsEnabled());
    }

    @Test
    public void testIsJndiLookupEnabled() {
        assertFalse(JndiManager.isJndiLookupEnabled());
    }

    @Test
    public void testNoInstanceByDefault() {
        JUnit5Bridge.assertThrows(IllegalStateException.class, new Runnable() {
            @Override
            public void run() {
                JndiManager.getDefaultManager();
            }
        });
        JUnit5Bridge.assertThrows(IllegalStateException.class, new Runnable() {
            @Override
            public void run() {
                JndiManager.getDefaultManager(null);
            }
        });
        JUnit5Bridge.assertThrows(IllegalStateException.class, new Runnable() {
            @Override
            public void run() {
                JndiManager.getDefaultManager(""A"");
            }
        });
        JUnit5Bridge.assertThrows(IllegalStateException.class, new Runnable() {
            @Override
            public void run() {
                JndiManager.getJndiManager(null);
            }
        });
        JUnit5Bridge.assertThrows(IllegalStateException.class, new Runnable() {
            @Override
            public void run() {
                JndiManager.getJndiManager(new Properties());
            }
        });
        JUnit5Bridge.assertThrows(IllegalStateException.class, new Runnable() {
            @Override
            public void run() {
                JndiManager.getJndiManager(null, null, null, null, null, null);
            }
        });
        JUnit5Bridge.assertThrows(IllegalStateException.class, new Runnable() {
            @Override
            public void run() {
                JndiManager.getJndiManager(""A"", ""A"", ""A"", ""A"", ""A"", new Properties());
            }
        });
    }

}
",1
CVE-2021-44832,log4j-core/src/main/java/org/apache/logging/log4j/core/AbstractLifeCycle.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core;

import java.io.Serializable;

import org.apache.logging.log4j.status.StatusLogger;

/**
 * A life cycle to be extended.
 * <p>
 * Wraps a {@link LifeCycle.State}.
 * </p>
 */
public class AbstractLifeCycle implements LifeCycle, Serializable {

    /**
     * Allow subclasses access to the status logger without creating another instance.
     */
    protected static final org.apache.logging.log4j.Logger LOGGER = StatusLogger.getLogger();

    private static final long serialVersionUID = 1L;

    private volatile LifeCycle.State state = LifeCycle.State.INITIALIZED;

    protected boolean equalsImpl(final Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final LifeCycle other = (LifeCycle) obj;
        if (state != other.getState()) {
            return false;
        }
        return true;
    }

    @Override
    public LifeCycle.State getState() {
        return this.state;
    }

    protected int hashCodeImpl() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((state == null) ? 0 : state.hashCode());
        return result;
    }

    public boolean isInitialized() {
        return this.state == LifeCycle.State.INITIALIZED;
    }

    @Override
    public boolean isStarted() {
        return this.state == LifeCycle.State.STARTED;
    }

    public boolean isStarting() {
        return this.state == LifeCycle.State.STARTING;
    }

    @Override
    public boolean isStopped() {
        return this.state == LifeCycle.State.STOPPED;
    }

    public boolean isStopping() {
        return this.state == LifeCycle.State.STOPPING;
    }

    protected void setStarted() {
        this.setState(LifeCycle.State.STARTED);
    }

    protected void setStarting() {
        this.setState(LifeCycle.State.STARTING);
    }

    protected void setState(final LifeCycle.State newState) {
        this.state = newState;
        // Need a better string than this.toString() for the message
        // LOGGER.debug(""{} {}"", this.state, this);
    }

    protected void setStopped() {
        this.setState(LifeCycle.State.STOPPED);
    }

    protected void setStopping() {
        this.setState(LifeCycle.State.STOPPING);
    }

    @Override
    public void start() {
        this.setStarted();
    }

    @Override
    public void stop() {
        this.state = LifeCycle.State.STOPPED;
    }

}
",0
CVE-2021-44832,log4j-core/src/main/java/org/apache/logging/log4j/core/AbstractLifeCycle.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core;

import java.io.Serializable;
import java.util.concurrent.TimeUnit;

import org.apache.logging.log4j.status.StatusLogger;

/**
 * A life cycle to be extended.
 * <p>
 * Wraps a {@link LifeCycle.State}.
 * </p>
 */
public class AbstractLifeCycle implements LifeCycle, Serializable {

    /** @since 2.3.2 */
    public static final int DEFAULT_STOP_TIMEOUT = 0;
    
    /** @since 2.3.2 */
    public static final TimeUnit DEFAULT_STOP_TIMEUNIT = TimeUnit.MILLISECONDS;

    /**
     * Allow subclasses access to the status logger without creating another instance.
     */
    protected static final org.apache.logging.log4j.Logger LOGGER = StatusLogger.getLogger();

    private static final long serialVersionUID = 1L;

    private volatile LifeCycle.State state = LifeCycle.State.INITIALIZED;

    protected boolean equalsImpl(final Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final LifeCycle other = (LifeCycle) obj;
        if (state != other.getState()) {
            return false;
        }
        return true;
    }

    @Override
    public LifeCycle.State getState() {
        return this.state;
    }

    protected int hashCodeImpl() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((state == null) ? 0 : state.hashCode());
        return result;
    }

    public boolean isInitialized() {
        return this.state == LifeCycle.State.INITIALIZED;
    }

    @Override
    public boolean isStarted() {
        return this.state == LifeCycle.State.STARTED;
    }

    public boolean isStarting() {
        return this.state == LifeCycle.State.STARTING;
    }

    @Override
    public boolean isStopped() {
        return this.state == LifeCycle.State.STOPPED;
    }

    public boolean isStopping() {
        return this.state == LifeCycle.State.STOPPING;
    }

    protected void setStarted() {
        this.setState(LifeCycle.State.STARTED);
    }

    protected void setStarting() {
        this.setState(LifeCycle.State.STARTING);
    }

    protected void setState(final LifeCycle.State newState) {
        this.state = newState;
        // Need a better string than this.toString() for the message
        // LOGGER.debug(""{} {}"", this.state, this);
    }

    protected void setStopped() {
        this.setState(LifeCycle.State.STOPPED);
    }

    protected void setStopping() {
        this.setState(LifeCycle.State.STOPPING);
    }

    @Override
    public void start() {
        this.setStarted();
    }

    @Override
    public void stop() {
        this.state = LifeCycle.State.STOPPED;
    }

}
",1
CVE-2021-44832,log4j-core/src/main/java/org/apache/logging/log4j/core/appender/db/jdbc/DataSourceConnectionSource.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import java.sql.Connection;
import java.sql.SQLException;

import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.config.plugins.Plugin;
import org.apache.logging.log4j.core.config.plugins.PluginAttribute;
import org.apache.logging.log4j.core.config.plugins.PluginFactory;
import org.apache.logging.log4j.status.StatusLogger;
import org.apache.logging.log4j.util.Strings;

/**
 * A {@link JdbcAppender} connection source that uses a {@link DataSource} to connect to the database.
 */
@Plugin(name = ""DataSource"", category = ""Core"", elementType = ""connectionSource"", printObject = true)
public final class DataSourceConnectionSource implements ConnectionSource {
    private static final Logger LOGGER = StatusLogger.getLogger();

    private final DataSource dataSource;
    private final String description;

    private DataSourceConnectionSource(final String dataSourceName, final DataSource dataSource) {
        this.dataSource = dataSource;
        this.description = ""dataSource{ name="" + dataSourceName + "", value="" + dataSource + "" }"";
    }

    @Override
    public Connection getConnection() throws SQLException {
        return this.dataSource.getConnection();
    }

    @Override
    public String toString() {
        return this.description;
    }

    /**
     * Factory method for creating a connection source within the plugin manager.
     *
     * @param jndiName The full JNDI path where the data source is bound. Should start with java:/comp/env or
     *                 environment-equivalent.
     * @return the created connection source.
     */
    @PluginFactory
    public static DataSourceConnectionSource createConnectionSource(@PluginAttribute(""jndiName"") final String jndiName) {
        if (Strings.isEmpty(jndiName)) {
            LOGGER.error(""No JNDI name provided."");
            return null;
        }

        try {
            final InitialContext context = new InitialContext();
            final DataSource dataSource = (DataSource) context.lookup(jndiName);
            if (dataSource == null) {
                LOGGER.error(""No data source found with JNDI name ["" + jndiName + ""]."");
                return null;
            }

            return new DataSourceConnectionSource(jndiName, dataSource);
        } catch (final NamingException e) {
            LOGGER.error(e.getMessage(), e);
            return null;
        }
    }
}
",0
CVE-2021-44832,log4j-core/src/main/java/org/apache/logging/log4j/core/appender/db/jdbc/DataSourceConnectionSource.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.Objects;

import javax.naming.NamingException;
import javax.sql.DataSource;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.config.plugins.Plugin;
import org.apache.logging.log4j.core.config.plugins.PluginAttribute;
import org.apache.logging.log4j.core.config.plugins.PluginFactory;
import org.apache.logging.log4j.core.net.JndiManager;
import org.apache.logging.log4j.status.StatusLogger;
import org.apache.logging.log4j.util.Strings;

/**
 * A {@link JdbcAppender} connection source that uses a {@link DataSource} to connect to the database.
 */
@Plugin(name = ""DataSource"", category = ""Core"", elementType = ""connectionSource"", printObject = true)
public final class DataSourceConnectionSource implements ConnectionSource {
    private static final Logger LOGGER = StatusLogger.getLogger();

    private final DataSource dataSource;
    private final String description;

    private DataSourceConnectionSource(final String dataSourceName, final DataSource dataSource) {
        this.dataSource = Objects.requireNonNull(dataSource, ""dataSource"");
        this.description = ""dataSource{ name="" + dataSourceName + "", value="" + dataSource + "" }"";
    }

    @Override
    public Connection getConnection() throws SQLException {
        return this.dataSource.getConnection();
    }

    @Override
    public String toString() {
        return this.description;
    }

    /**
     * Factory method for creating a connection source within the plugin manager.
     *
     * @param jndiName The full JNDI path where the data source is bound. Must start with java:/comp/env or environment-equivalent.
     * @return the created connection source.
     */
    @PluginFactory
    public static DataSourceConnectionSource createConnectionSource(@PluginAttribute(""jndiName"") final String jndiName) {
        if (!JndiManager.isJndiJdbcEnabled()) {
            LOGGER.error(""JNDI must be enabled by setting log4j2.enableJndiJdbc=true"");
            return null;
        }
        if (Strings.isEmpty(jndiName)) {
            LOGGER.error(""No JNDI name provided."");
            return null;
        }
        try {
            @SuppressWarnings(""resource"")
            final DataSource dataSource = JndiManager.getDefaultManager(DataSourceConnectionSource.class.getCanonicalName()).lookup(jndiName);
            if (dataSource == null) {
                LOGGER.error(""No DataSource found with JNDI name ["" + jndiName + ""]."");
                return null;
            }
            return new DataSourceConnectionSource(jndiName, dataSource);
        } catch (final NamingException e) {
            LOGGER.error(e.getMessage(), e);
            return null;
        }
    }
}
",1
CVE-2021-44832,log4j-core/src/main/java/org/apache/logging/log4j/core/appender/db/jdbc/JdbcAppender.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import org.apache.logging.log4j.core.Filter;
import org.apache.logging.log4j.core.appender.AbstractAppender;
import org.apache.logging.log4j.core.appender.db.AbstractDatabaseAppender;
import org.apache.logging.log4j.core.config.plugins.Plugin;
import org.apache.logging.log4j.core.config.plugins.PluginAttribute;
import org.apache.logging.log4j.core.config.plugins.PluginElement;
import org.apache.logging.log4j.core.config.plugins.PluginFactory;
import org.apache.logging.log4j.core.util.Booleans;

/**
 * This Appender writes logging events to a relational database using standard JDBC mechanisms. It takes a list of
 * {@link ColumnConfig}s with which it determines how to save the event data into the appropriate columns in the table.
 * A {@link ConnectionSource} plugin instance instructs the appender (and {@link JdbcDatabaseManager}) how to connect to
 * the database. This appender can be reconfigured at run time.
 *
 * @see ColumnConfig
 * @see ConnectionSource
 */
@Plugin(name = ""JDBC"", category = ""Core"", elementType = ""appender"", printObject = true)
public final class JdbcAppender extends AbstractDatabaseAppender<JdbcDatabaseManager> {
    private static final long serialVersionUID = 1L;

    private final String description;

    private JdbcAppender(final String name, final Filter filter, final boolean ignoreExceptions,
                         final JdbcDatabaseManager manager) {
        super(name, filter, ignoreExceptions, manager);
        this.description = this.getName() + ""{ manager="" + this.getManager() + "" }"";
    }

    @Override
    public String toString() {
        return this.description;
    }

    /**
     * Factory method for creating a JDBC appender within the plugin manager.
     *
     * @param name The name of the appender.
     * @param ignore If {@code ""true""} (default) exceptions encountered when appending events are logged; otherwise
     *               they are propagated to the caller.
     * @param filter The filter, if any, to use.
     * @param connectionSource The connections source from which database connections should be retrieved.
     * @param bufferSize If an integer greater than 0, this causes the appender to buffer log events and flush whenever
     *                   the buffer reaches this size.
     * @param tableName The name of the database table to insert log events into.
     * @param columnConfigs Information about the columns that log event data should be inserted into and how to insert
     *                      that data.
     * @return a new JDBC appender.
     */
    @PluginFactory
    public static JdbcAppender createAppender(
            @PluginAttribute(""name"") final String name,
            @PluginAttribute(""ignoreExceptions"") final String ignore,
            @PluginElement(""Filter"") final Filter filter,
            @PluginElement(""ConnectionSource"") final ConnectionSource connectionSource,
            @PluginAttribute(""bufferSize"") final String bufferSize,
            @PluginAttribute(""tableName"") final String tableName,
            @PluginElement(""ColumnConfigs"") final ColumnConfig[] columnConfigs) {

        final int bufferSizeInt = AbstractAppender.parseInt(bufferSize, 0);
        final boolean ignoreExceptions = Booleans.parseBoolean(ignore, true);

        final StringBuilder managerName = new StringBuilder(""jdbcManager{ description="").append(name)
                .append("", bufferSize="").append(bufferSizeInt).append("", connectionSource="")
                .append(connectionSource.toString()).append("", tableName="").append(tableName).append("", columns=[ "");

        int i = 0;
        for (final ColumnConfig column : columnConfigs) {
            if (i++ > 0) {
                managerName.append("", "");
            }
            managerName.append(column.toString());
        }

        managerName.append("" ] }"");

        final JdbcDatabaseManager manager = JdbcDatabaseManager.getJDBCDatabaseManager(
                managerName.toString(), bufferSizeInt, connectionSource, tableName, columnConfigs
        );
        if (manager == null) {
            return null;
        }

        return new JdbcAppender(name, filter, ignoreExceptions, manager);
    }
}
",0
CVE-2021-44832,log4j-core/src/main/java/org/apache/logging/log4j/core/appender/db/jdbc/JdbcAppender.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import java.util.Objects;

import org.apache.logging.log4j.core.Filter;
import org.apache.logging.log4j.core.appender.AbstractAppender;
import org.apache.logging.log4j.core.appender.db.AbstractDatabaseAppender;
import org.apache.logging.log4j.core.config.plugins.Plugin;
import org.apache.logging.log4j.core.config.plugins.PluginAttribute;
import org.apache.logging.log4j.core.config.plugins.PluginElement;
import org.apache.logging.log4j.core.config.plugins.PluginFactory;
import org.apache.logging.log4j.core.util.Booleans;

/**
 * This Appender writes logging events to a relational database using standard JDBC mechanisms. It takes a list of
 * {@link ColumnConfig}s with which it determines how to save the event data into the appropriate columns in the table.
 * A {@link ConnectionSource} plugin instance instructs the appender (and {@link JdbcDatabaseManager}) how to connect to
 * the database. This appender can be reconfigured at run time.
 *
 * @see ColumnConfig
 * @see ConnectionSource
 */
@Plugin(name = ""JDBC"", category = ""Core"", elementType = ""appender"", printObject = true)
public final class JdbcAppender extends AbstractDatabaseAppender<JdbcDatabaseManager> {
    private static final long serialVersionUID = 1L;

    private final String description;

    private JdbcAppender(final String name, final Filter filter, final boolean ignoreExceptions,
                         final JdbcDatabaseManager manager) {
        super(name, filter, ignoreExceptions, manager);
        this.description = this.getName() + ""{ manager="" + this.getManager() + "" }"";
    }

    @Override
    public String toString() {
        return this.description;
    }

    /**
     * Factory method for creating a JDBC appender within the plugin manager.
     *
     * @param name The name of the appender.
     * @param ignore If {@code ""true""} (default) exceptions encountered when appending events are logged; otherwise
     *               they are propagated to the caller.
     * @param filter The filter, if any, to use.
     * @param connectionSource The connections source from which database connections should be retrieved.
     * @param bufferSize If an integer greater than 0, this causes the appender to buffer log events and flush whenever
     *                   the buffer reaches this size.
     * @param tableName The name of the database table to insert log events into.
     * @param columnConfigs Information about the columns that log event data should be inserted into and how to insert
     *                      that data.
     * @return a new JDBC appender.
     */
    @PluginFactory
    public static JdbcAppender createAppender(
            @PluginAttribute(""name"") final String name,
            @PluginAttribute(""ignoreExceptions"") final String ignore,
            @PluginElement(""Filter"") final Filter filter,
            @PluginElement(""ConnectionSource"") final ConnectionSource connectionSource,
            @PluginAttribute(""bufferSize"") final String bufferSize,
            @PluginAttribute(""tableName"") final String tableName,
            @PluginElement(""ColumnConfigs"") final ColumnConfig[] columnConfigs) {
        if (connectionSource == null) {
            throw new NullPointerException(""connectionSource"");
        }
        final int bufferSizeInt = AbstractAppender.parseInt(bufferSize, 0);
        final boolean ignoreExceptions = Booleans.parseBoolean(ignore, true);

        final StringBuilder managerName = new StringBuilder(""jdbcManager{ description="").append(name)
                .append("", bufferSize="").append(bufferSizeInt).append("", connectionSource="")
                .append(connectionSource.toString()).append("", tableName="").append(tableName).append("", columns=[ "");

        int i = 0;
        for (final ColumnConfig column : columnConfigs) {
            if (i++ > 0) {
                managerName.append("", "");
            }
            managerName.append(column.toString());
        }

        managerName.append("" ] }"");

        final JdbcDatabaseManager manager = JdbcDatabaseManager.getJDBCDatabaseManager(
                managerName.toString(), bufferSizeInt, connectionSource, tableName, columnConfigs
        );
        if (manager == null) {
            return null;
        }

        return new JdbcAppender(name, filter, ignoreExceptions, manager);
    }
}
",1
CVE-2021-44832,log4j-core/src/main/java/org/apache/logging/log4j/core/net/JndiManager.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */

package org.apache.logging.log4j.core.net;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Properties;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import org.apache.logging.log4j.core.appender.AbstractManager;
import org.apache.logging.log4j.core.appender.ManagerFactory;
import org.apache.logging.log4j.core.util.JndiCloser;
import org.apache.logging.log4j.util.PropertiesUtil;

/**
 * JNDI {@link javax.naming.Context} manager.
 *
 * @since 2.1
 */
public class JndiManager extends AbstractManager {

    private static final JndiManagerFactory FACTORY = new JndiManagerFactory();
    private static final String PREFIX = ""log4j2.enableJndi"";
    private static final String JAVA_SCHEME = ""java"";

    private final Context context;

    private static boolean isJndiEnabled(final String subKey) {
        return PropertiesUtil.getProperties().getBooleanProperty(PREFIX + subKey, false);
    }

    public static boolean isJndiEnabled() {
        return isJndiContextSelectorEnabled() || isJndiJmsEnabled() || isJndiLookupEnabled();
    }

    public static boolean isJndiContextSelectorEnabled() {
        return isJndiEnabled(""ContextSelector"");
    }

    public static boolean isJndiJmsEnabled() {
        return isJndiEnabled(""Jms"");
    }

    public static boolean isJndiLookupEnabled() {
        return isJndiEnabled(""Lookup"");
    }

    private JndiManager(final String name, final Context context) {
        super(name);
        this.context = context;
    }

    /**
     * Gets the default JndiManager using the default {@link javax.naming.InitialContext}.
     *
     * @return the default JndiManager
     */
    public static JndiManager getDefaultManager() {
        return getManager(JndiManager.class.getName(), FACTORY, null);
    }

    /**
     * Gets a named JndiManager using the default {@link javax.naming.InitialContext}.
     * @param name the name of the JndiManager instance to create or use if available
     * @return a default JndiManager
     */
    public static JndiManager getDefaultManager(final String name) {
        return getManager(name, FACTORY, null);
    }

    /**
     * Gets a JndiManager with the provided configuration information.
     *
     * @param initialContextFactoryName Fully qualified class name of an implementation of
     *                                  {@link javax.naming.spi.InitialContextFactory}.
     * @param providerURL               The provider URL to use for the JNDI connection (specific to the above factory).
     * @param urlPkgPrefixes            A colon-separated list of package prefixes for the class name of the factory
     *                                  class that will create a URL context factory
     * @param securityPrincipal         The name of the identity of the Principal.
     * @param securityCredentials       The security credentials of the Principal.
     * @param additionalProperties      Any additional JNDI environment properties to set or {@code null} for none.
     * @return the JndiManager for the provided parameters.
     */
    public static JndiManager getJndiManager(final String initialContextFactoryName,
                                             final String providerURL,
                                             final String urlPkgPrefixes,
                                             final String securityPrincipal,
                                             final String securityCredentials,
                                             final Properties additionalProperties) {
        final String name = JndiManager.class.getName() + '@' + JndiManager.class.hashCode();
        if (initialContextFactoryName == null) {
            return getManager(name, FACTORY, null);
        }
        final Properties properties = new Properties();
        properties.setProperty(Context.INITIAL_CONTEXT_FACTORY, initialContextFactoryName);
        if (providerURL != null) {
            properties.setProperty(Context.PROVIDER_URL, providerURL);
        } else {
            LOGGER.warn(""The JNDI InitialContextFactory class name [{}] was provided, but there was no associated "" +
                ""provider URL. This is likely to cause problems."", initialContextFactoryName);
        }
        if (urlPkgPrefixes != null) {
            properties.setProperty(Context.URL_PKG_PREFIXES, urlPkgPrefixes);
        }
        if (securityPrincipal != null) {
            properties.setProperty(Context.SECURITY_PRINCIPAL, securityPrincipal);
            if (securityCredentials != null) {
                properties.setProperty(Context.SECURITY_CREDENTIALS, securityCredentials);
            } else {
                LOGGER.warn(""A security principal [{}] was provided, but with no corresponding security credentials."",
                    securityPrincipal);
            }
        }
        if (additionalProperties != null) {
            properties.putAll(additionalProperties);
        }
        return getManager(name, FACTORY, properties);
    }

    @Override
    protected void releaseSub() {
        JndiCloser.closeSilently(this.context);
    }

    /**
     * Looks up a named object through this JNDI context.
     *
     * @param name name of the object to look up.
     * @param <T>  the type of the object.
     * @return the named object if it could be located.
     * @throws NamingException
     */
    @SuppressWarnings(""unchecked"")
    public <T> T lookup(final String name) throws NamingException {
        if (context == null) {
            return null;
        }
        try {
            URI uri = new URI(name);
            if (uri.getScheme() == null || uri.getScheme().equals(JAVA_SCHEME)) {
                return (T) this.context.lookup(name);
            }
            LOGGER.warn(""Unsupported JNDI URI - {}"", name);
        } catch (URISyntaxException ex) {
            LOGGER.warn(""Invalid  JNDI URI - {}"", name);
        }
        return null;
    }

    private static class JndiManagerFactory implements ManagerFactory<JndiManager, Properties> {

        @Override
        public JndiManager createManager(final String name, final Properties data) {
            if (!isJndiEnabled()) {
                throw new IllegalStateException(String.format(""JNDI must be enabled by setting one of the %s* properties to true"", PREFIX));
            }
            try {
                return new JndiManager(name, new InitialContext(data));
            } catch (final NamingException e) {
                LOGGER.error(""Error creating JNDI InitialContext."", e);
                return null;
            }
        }
    }
}
",0
CVE-2021-44832,log4j-core/src/main/java/org/apache/logging/log4j/core/net/JndiManager.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */

package org.apache.logging.log4j.core.net;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Properties;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

import org.apache.logging.log4j.core.appender.AbstractManager;
import org.apache.logging.log4j.core.appender.ManagerFactory;
import org.apache.logging.log4j.core.util.JndiCloser;
import org.apache.logging.log4j.util.PropertiesUtil;

/**
 * JNDI {@link javax.naming.Context} manager.
 *
 * @since 2.1
 */
public class JndiManager extends AbstractManager {

    private static final JndiManagerFactory FACTORY = new JndiManagerFactory();
    private static final String PREFIX = ""log4j2.enableJndi"";
    private static final String JAVA_SCHEME = ""java"";

    private static final boolean JNDI_CONTEXT_SELECTOR_ENABLED = isJndiEnabled(""ContextSelector"");
    private static final boolean JNDI_JDBC_ENABLED = isJndiEnabled(""Jdbc"");
    private static final boolean JNDI_JMS_ENABLED = isJndiEnabled(""Jms"");
    private static final boolean JNDI_LOOKUP_ENABLED = isJndiEnabled(""Lookup"");

    private final InitialContext context;

    private static String createManagerName() {
        return JndiManager.class.getName() + '@' + JndiManager.class.hashCode();
    }

    private static boolean isJndiEnabled(final String subKey) {
        return PropertiesUtil.getProperties().getBooleanProperty(PREFIX + subKey, false);
    }

    public static boolean isJndiEnabled() {
        return isJndiContextSelectorEnabled() || isJndiJdbcEnabled() || isJndiJmsEnabled() || isJndiLookupEnabled();
    }

    public static boolean isJndiContextSelectorEnabled() {
        return JNDI_CONTEXT_SELECTOR_ENABLED;
    }

    public static boolean isJndiJdbcEnabled() {
        return JNDI_JDBC_ENABLED;
    }

    public static boolean isJndiJmsEnabled() {
        return JNDI_JMS_ENABLED;
    }

    public static boolean isJndiLookupEnabled() {
        return JNDI_LOOKUP_ENABLED;
    }

    private JndiManager(final String name, final InitialContext context) {
        super(name);
        this.context = context;
    }

    /**
     * Gets the default JndiManager using the default {@link javax.naming.InitialContext}.
     *
     * @return the default JndiManager
     */
    public static JndiManager getDefaultManager() {
        return getManager(JndiManager.class.getName(), FACTORY, null);
    }

    /**
     * Gets a named JndiManager using the default {@link javax.naming.InitialContext}.
     * @param name the name of the JndiManager instance to create or use if available
     * @return a default JndiManager
     */
    public static JndiManager getDefaultManager(final String name) {
        return getManager(name, FACTORY, null);
    }

    /**
     * Gets a JndiManager with the provided configuration information.
     *
     * @param properties JNDI properties, usually created by calling {@link #createProperties(String, String, String, String, String, Properties)}.
     * @return the JndiManager for the provided parameters.
     * @see #createProperties(String, String, String, String, String, Properties)
     * @since 2.9
     */
    public static JndiManager getJndiManager(final Properties properties) {
        return getManager(createManagerName(), FACTORY, properties);
    }

    /**
     * Gets a JndiManager with the provided configuration information.
     *
     * @param initialContextFactoryName Fully qualified class name of an implementation of
     *                                  {@link javax.naming.spi.InitialContextFactory}.
     * @param providerURL               The provider URL to use for the JNDI connection (specific to the above factory).
     * @param urlPkgPrefixes            A colon-separated list of package prefixes for the class name of the factory
     *                                  class that will create a URL context factory
     * @param securityPrincipal         The name of the identity of the Principal.
     * @param securityCredentials       The security credentials of the Principal.
     * @param additionalProperties      Any additional JNDI environment properties to set or {@code null} for none.
     * @return the JndiManager for the provided parameters.
     */
    public static JndiManager getJndiManager(final String initialContextFactoryName,
                                             final String providerURL,
                                             final String urlPkgPrefixes,
                                             final String securityPrincipal,
                                             final String securityCredentials,
                                             final Properties additionalProperties) {
        final String name = JndiManager.class.getName() + '@' + JndiManager.class.hashCode();
        if (initialContextFactoryName == null) {
            return getManager(name, FACTORY, null);
        }
        final Properties properties = new Properties();
        properties.setProperty(Context.INITIAL_CONTEXT_FACTORY, initialContextFactoryName);
        if (providerURL != null) {
            properties.setProperty(Context.PROVIDER_URL, providerURL);
        } else {
            LOGGER.warn(""The JNDI InitialContextFactory class name [{}] was provided, but there was no associated "" +
                ""provider URL. This is likely to cause problems."", initialContextFactoryName);
        }
        if (urlPkgPrefixes != null) {
            properties.setProperty(Context.URL_PKG_PREFIXES, urlPkgPrefixes);
        }
        if (securityPrincipal != null) {
            properties.setProperty(Context.SECURITY_PRINCIPAL, securityPrincipal);
            if (securityCredentials != null) {
                properties.setProperty(Context.SECURITY_CREDENTIALS, securityCredentials);
            } else {
                LOGGER.warn(""A security principal [{}] was provided, but with no corresponding security credentials."",
                    securityPrincipal);
            }
        }
        if (additionalProperties != null) {
            properties.putAll(additionalProperties);
        }
        return getManager(name, FACTORY, properties);
    }

    @Override
    protected void releaseSub() {
        JndiCloser.closeSilently(this.context);
    }

    /**
     * Looks up a named object through this JNDI context.
     *
     * @param name name of the object to look up.
     * @param <T>  the type of the object.
     * @return the named object if it could be located.
     * @throws NamingException
     */
    @SuppressWarnings(""unchecked"")
    public <T> T lookup(final String name) throws NamingException {
        if (context == null) {
            return null;
        }
        try {
            URI uri = new URI(name);
            if (uri.getScheme() == null || uri.getScheme().equals(JAVA_SCHEME)) {
                return (T) this.context.lookup(name);
            }
            LOGGER.warn(""Unsupported JNDI URI - {}"", name);
        } catch (URISyntaxException ex) {
            LOGGER.warn(""Invalid JNDI URI - {}"", name);
        }
        return null;
    }

    private static class JndiManagerFactory implements ManagerFactory<JndiManager, Properties> {

        @Override
        public JndiManager createManager(final String name, final Properties data) {
            if (!isJndiEnabled()) {
                throw new IllegalStateException(String.format(""JNDI must be enabled by setting one of the %s* properties to true"", PREFIX));
            }
            try {
                return new JndiManager(name, new InitialContext(data));
            } catch (final NamingException e) {
                LOGGER.error(""Error creating JNDI InitialContext."", e);
                return null;
            }
        }
    }
}
",1
CVE-2021-44832,log4j-core/src/main/java/org/apache/logging/log4j/core/util/Closer.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */

package org.apache.logging.log4j.core.util;

import java.io.Closeable;
import java.io.IOException;
import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * Helper class for closing resources.
 */
public final class Closer {

    private Closer() {
    }

    /**
     * Closes the specified {@code Closeable} (stream or reader/writer),
     * ignoring any exceptions thrown by the close operation.
     *
     * @param closeable the resource to close, may be {@code null}
     */
    public static void closeSilently(final Closeable closeable) {
        try {
            close(closeable);
        } catch (final Exception ignored) {
            // ignored
        }
    }

    /**
     * Closes the specified {@code Closeable} (stream or reader/writer).
     *
     * @param closeable the resource to close, may be {@code null}
     * @throws IOException if a problem occurred closing the specified resource
     */
    public static void close(final Closeable closeable) throws IOException {
        if (closeable != null) {
            closeable.close();
        }
    }

    /**
     * Closes the specified resource, ignoring any exceptions thrown by the close operation.
     *
     * @param serverSocket the resource to close, may be {@code null}
     */
    public static void closeSilently(final ServerSocket serverSocket) {
        try {
            close(serverSocket);
        } catch (final Exception ignored) {
            // ignored
        }
    }

    /**
     * Closes the specified resource.
     *
     * @param serverSocket the resource to close, may be {@code null}
     * @throws IOException if a problem occurred closing the specified resource
     */
    public static void close(final ServerSocket serverSocket) throws IOException {
        if (serverSocket != null) {
            serverSocket.close();
        }
    }

    /**
     * Closes the specified resource, ignoring any exceptions thrown by the close operation.
     *
     * @param datagramSocket the resource to close, may be {@code null}
     */
    public static void closeSilently(final DatagramSocket datagramSocket) {
        try {
            close(datagramSocket);
        } catch (final Exception ignored) {
            // ignored
        }
    }

    /**
     * Closes the specified resource.
     *
     * @param datagramSocket the resource to close, may be {@code null}
     * @throws IOException if a problem occurred closing the specified resource
     */
    public static void close(final DatagramSocket datagramSocket) throws IOException {
        if (datagramSocket != null) {
            datagramSocket.close();
        }
    }

    /**
     * Closes the specified {@code Statement}, ignoring any exceptions thrown by
     * the close operation.
     *
     * @param statement the resource to close, may be {@code null}
     */
    public static void closeSilently(final Statement statement) {
        try {
            close(statement);
        } catch (final Exception ignored) {
            // ignored
        }
    }

    /**
     * Closes the specified {@code Statement}.
     *
     * @param statement the resource to close, may be {@code null}
     * @throws SQLException if a problem occurred closing the specified resource
     */
    public static void close(final Statement statement) throws SQLException {
        if (statement != null) {
            statement.close();
        }
    }

    /**
     * Closes the specified {@code Connection}, ignoring any exceptions thrown
     * by the close operation.
     *
     * @param connection the resource to close, may be {@code null}
     */
    public static void closeSilently(final Connection connection) {
        try {
            close(connection);
        } catch (final Exception ignored) {
            // ignored
        }
    }

    /**
     * Closes the specified {@code Connection}.
     *
     * @param connection the resource to close, may be {@code null}
     * @throws SQLException if a problem occurred closing the specified resource
     */
    public static void close(final Connection connection) throws SQLException {
        if (connection != null) {
            connection.close();
        }
    }

}
",0
CVE-2021-44832,log4j-core/src/main/java/org/apache/logging/log4j/core/util/Closer.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */

package org.apache.logging.log4j.core.util;

import java.io.Closeable;
import java.io.IOException;
import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * Helper class for closing resources.
 */
public final class Closer {

    private Closer() {
    }

    /**
     * Closes the specified {@code Closeable} (stream or reader/writer),
     * ignoring any exceptions thrown by the close operation.
     *
     * @param closeable the resource to close, may be {@code null}
     */
    public static void closeSilently(final Closeable closeable) {
        try {
            close(closeable);
        } catch (final Exception ignored) {
            // ignored
        }
    }

    /**
     * Closes the specified {@code Closeable} (stream or reader/writer).
     *
     * @param closeable the resource to close, may be {@code null}
     * @throws IOException if a problem occurred closing the specified resource
     */
    public static void close(final Closeable closeable) throws IOException {
        if (closeable != null) {
            closeable.close();
        }
    }

    /**
     * Closes the specified resource, ignoring any exceptions thrown by the close operation.
     *
     * @param serverSocket the resource to close, may be {@code null}
     */
    public static void closeSilently(final ServerSocket serverSocket) {
        try {
            close(serverSocket);
        } catch (final Exception ignored) {
            // ignored
        }
    }

    /**
     * Closes the specified resource.
     *
     * @param serverSocket the resource to close, may be {@code null}
     * @throws IOException if a problem occurred closing the specified resource
     */
    public static void close(final ServerSocket serverSocket) throws IOException {
        if (serverSocket != null) {
            serverSocket.close();
        }
    }

    /**
     * Closes the specified resource, ignoring any exceptions thrown by the close operation.
     *
     * @param datagramSocket the resource to close, may be {@code null}
     */
    public static void closeSilently(final DatagramSocket datagramSocket) {
        try {
            close(datagramSocket);
        } catch (final Exception ignored) {
            // ignored
        }
    }

    /**
     * Closes the specified resource.
     *
     * @param datagramSocket the resource to close, may be {@code null}
     * @throws IOException if a problem occurred closing the specified resource
     */
    public static void close(final DatagramSocket datagramSocket) throws IOException {
        if (datagramSocket != null) {
            datagramSocket.close();
        }
    }

    /**
     * Closes the specified {@code Statement}, ignoring any exceptions thrown by
     * the close operation.
     *
     * @param statement the resource to close, may be {@code null}
     */
    public static void closeSilently(final Statement statement) {
        try {
            close(statement);
        } catch (final Exception ignored) {
            // ignored
        }
    }

    /**
     * Closes the specified {@code ResultSet}.
     *
     * @param resultSet the resource to close, may be {@code null}
     * @throws SQLException if a problem occurred closing the specified resource
     */
    public static void close(final ResultSet resultSet) throws SQLException {
        if (resultSet != null) {
            resultSet.close();
        }
    }

    /**
     * Closes the specified {@code Statement}.
     *
     * @param statement the resource to close, may be {@code null}
     * @throws SQLException if a problem occurred closing the specified resource
     */
    public static void close(final Statement statement) throws SQLException {
        if (statement != null) {
            statement.close();
        }
    }

    /**
     * Closes the specified {@code Connection}, ignoring any exceptions thrown
     * by the close operation.
     *
     * @param connection the resource to close, may be {@code null}
     */
    public static void closeSilently(final Connection connection) {
        try {
            close(connection);
        } catch (final Exception ignored) {
            // ignored
        }
    }

    /**
     * Closes the specified {@code Connection}.
     *
     * @param connection the resource to close, may be {@code null}
     * @throws SQLException if a problem occurred closing the specified resource
     */
    public static void close(final Connection connection) throws SQLException {
        if (connection != null) {
            connection.close();
        }
    }

}
",1
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/db/jdbc/AbstractJdbcAppenderTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import java.io.ByteArrayOutputStream;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import javax.naming.InitialContext;
import javax.sql.DataSource;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.Appender;
import org.apache.logging.log4j.core.LoggerContext;
import org.apache.logging.log4j.core.config.ConfigurationFactory;
import org.apache.logging.log4j.core.config.DefaultConfiguration;
import org.apache.logging.log4j.status.StatusLogger;
import org.apache.logging.log4j.util.Strings;
import org.easymock.IAnswer;
import org.h2.util.IOUtils;
import org.junit.After;
import org.junit.Test;
import org.mockejb.jndi.MockContextFactory;

import static org.easymock.EasyMock.*;

import static org.junit.Assert.*;

public abstract class AbstractJdbcAppenderTest {
    private final String databaseType;
    private Connection connection;

    public AbstractJdbcAppenderTest(final String databaseType) {
        this.databaseType = databaseType;
    }

    protected abstract Connection newConnection() throws SQLException;

    protected abstract String toCreateTableSqlString(final String tableName);

    protected void setUp(final String tableName, final String configFileName) throws SQLException {
        this.connection = this.newConnection();
        final Statement statement = this.connection.createStatement();
        try {
            statement.executeUpdate(this.toCreateTableSqlString(tableName));
        } finally {
            statement.close();
        }
        System.setProperty(ConfigurationFactory.CONFIGURATION_FILE_PROPERTY,
                ""org/apache/logging/log4j/core/appender/db/jdbc/"" + configFileName);
        final LoggerContext context = (LoggerContext) LogManager.getContext(false);
        if (context.getConfiguration() instanceof DefaultConfiguration) {
            context.reconfigure();
        }
        StatusLogger.getLogger().reset();
    }

    @After
    public void tearDown() throws SQLException {
        final LoggerContext context = (LoggerContext) LogManager.getContext(false);
        try {
            final Appender appender = context.getConfiguration().getAppender(""databaseAppender"");
            assertNotNull(""The appender should not be null."", appender);
            assertTrue(""The appender should be a JdbcAppender."", appender instanceof JdbcAppender);
            ((JdbcAppender) appender).getManager().release();
        } finally {
            System.clearProperty(ConfigurationFactory.CONFIGURATION_FILE_PROPERTY);
            context.reconfigure();
            StatusLogger.getLogger().reset();

            Statement statement = null;
            try {
                statement = this.connection.createStatement();
                statement.execute(""SHUTDOWN"");
            } finally {
                try {
                    if (statement != null) {
                        statement.close();
                    }
                } catch (final SQLException ignore) {
                    /* */
                }
            }

            this.connection.close();
        }
    }

    @Test
    public void testDataSourceConfig() throws Exception {
        final DataSource dataSource = createStrictMock(DataSource.class);

        expect(dataSource.getConnection()).andAnswer(new IAnswer<Connection>() {
            @Override
            public Connection answer() throws Throwable {
                return newConnection();
            }
        }).atLeastOnce();
        replay(dataSource);

        MockContextFactory.setAsInitial();

        final InitialContext context = new InitialContext();
        context.createSubcontext(""java:"");
        context.createSubcontext(""java:/comp"");
        context.createSubcontext(""java:/comp/env"");
        context.createSubcontext(""java:/comp/env/jdbc"");

        context.bind(""java:/comp/env/jdbc/TestDataSourceAppender"", dataSource);

        try {
            this.setUp(""dsLogEntry"", ""log4j2-data-source.xml"");

            final Error exception = new Error(""Final error massage is fatal!"");
            final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            final PrintWriter writer = new PrintWriter(outputStream);
            exception.printStackTrace(writer);
            writer.close();
            final String stackTrace = outputStream.toString();

            final long millis = System.currentTimeMillis();

            final Logger logger = LogManager.getLogger(this.getClass().getName() + "".testDataSourceConfig"");
            logger.trace(""Data source logged message 01."");
            logger.fatal(""Error from data source 02."", exception);

            final Statement statement = this.connection.createStatement();
            final ResultSet resultSet = statement.executeQuery(""SELECT * FROM dsLogEntry ORDER BY id"");

            assertTrue(""There should be at least one row."", resultSet.next());

            final long date = resultSet.getTimestamp(""eventDate"").getTime();
            assertTrue(""The date should be later than pre-logging (1)."", date >= millis);
            assertTrue(""The date should be earlier than now (1)."", date <= System.currentTimeMillis());
            assertEquals(""The literal column is not correct (1)."", ""Literal Value of Data Source"",
                    resultSet.getString(""literalColumn""));
            assertEquals(""The level column is not correct (1)."", ""FATAL"", resultSet.getNString(""level""));
            assertEquals(""The logger column is not correct (1)."", logger.getName(), resultSet.getNString(""logger""));
            assertEquals(""The message column is not correct (1)."", ""Error from data source 02."",
                    resultSet.getString(""message""));
            assertEquals(""The exception column is not correct (1)."", stackTrace,
                    IOUtils.readStringAndClose(resultSet.getNClob(""exception"").getCharacterStream(), -1));

            assertFalse(""There should not be two rows."", resultSet.next());

            verify(dataSource);
        } finally {
            MockContextFactory.revertSetAsInitial();
        }
    }

    @Test
    public void testFactoryMethodConfig() throws Exception {
        this.setUp(""fmLogEntry"", ""log4j2-"" + this.databaseType + ""-factory-method.xml"");

        final SQLException exception = new SQLException(""Some other error message!"");
        final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        final PrintWriter writer = new PrintWriter(outputStream);
        exception.printStackTrace(writer);
        writer.close();
        final String stackTrace = outputStream.toString();

        final long millis = System.currentTimeMillis();

        final Logger logger = LogManager.getLogger(this.getClass().getName() + "".testFactoryMethodConfig"");
        logger.debug(""Factory logged message 01."");
        logger.error(""Error from factory 02."", exception);

        final Statement statement = this.connection.createStatement();
        final ResultSet resultSet = statement.executeQuery(""SELECT * FROM fmLogEntry ORDER BY id"");

        assertTrue(""There should be at least one row."", resultSet.next());

        long date = resultSet.getTimestamp(""eventDate"").getTime();
        assertTrue(""The date should be later than pre-logging (1)."", date >= millis);
        assertTrue(""The date should be earlier than now (1)."", date <= System.currentTimeMillis());
        assertEquals(""The literal column is not correct (1)."", ""Some Other Literal Value"",
                resultSet.getString(""literalColumn""));
        assertEquals(""The level column is not correct (1)."", ""DEBUG"", resultSet.getNString(""level""));
        assertEquals(""The logger column is not correct (1)."", logger.getName(), resultSet.getNString(""logger""));
        assertEquals(""The message column is not correct (1)."", ""Factory logged message 01."",
                resultSet.getString(""message""));
        assertEquals(""The exception column is not correct (1)."", Strings.EMPTY,
                IOUtils.readStringAndClose(resultSet.getNClob(""exception"").getCharacterStream(), -1));

        assertTrue(""There should be two rows."", resultSet.next());

        date = resultSet.getTimestamp(""eventDate"").getTime();
        assertTrue(""The date should be later than pre-logging (2)."", date >= millis);
        assertTrue(""The date should be earlier than now (2)."", date <= System.currentTimeMillis());
        assertEquals(""The literal column is not correct (2)."", ""Some Other Literal Value"",
                resultSet.getString(""literalColumn""));
        assertEquals(""The level column is not correct (2)."", ""ERROR"", resultSet.getNString(""level""));
        assertEquals(""The logger column is not correct (2)."", logger.getName(), resultSet.getNString(""logger""));
        assertEquals(""The message column is not correct (2)."", ""Error from factory 02."",
                resultSet.getString(""message""));
        assertEquals(""The exception column is not correct (2)."", stackTrace,
                IOUtils.readStringAndClose(resultSet.getNClob(""exception"").getCharacterStream(), -1));

        assertFalse(""There should not be three rows."", resultSet.next());
    }
}
",0
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/db/jdbc/AbstractJdbcAppenderTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import java.io.ByteArrayOutputStream;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import javax.naming.InitialContext;
import javax.sql.DataSource;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.Appender;
import org.apache.logging.log4j.core.LoggerContext;
import org.apache.logging.log4j.core.config.ConfigurationFactory;
import org.apache.logging.log4j.core.config.DefaultConfiguration;
import org.apache.logging.log4j.status.StatusLogger;
import org.apache.logging.log4j.util.Strings;
import org.easymock.IAnswer;
import org.h2.util.IOUtils;
import org.junit.After;
import org.junit.Test;
import org.mockejb.jndi.MockContextFactory;

import static org.easymock.EasyMock.*;

import static org.junit.Assert.*;

public abstract class AbstractJdbcAppenderTest extends AbstractJdbcDataSourceTest {
    private final String databaseType;
    private Connection connection;

    public AbstractJdbcAppenderTest(final String databaseType) {
        this.databaseType = databaseType;
    }

    protected abstract Connection newConnection() throws SQLException;

    protected abstract String toCreateTableSqlString(final String tableName);

    protected void setUp(final String tableName, final String configFileName) throws SQLException {
        this.connection = this.newConnection();
        final Statement statement = this.connection.createStatement();
        try {
            statement.executeUpdate(this.toCreateTableSqlString(tableName));
        } finally {
            statement.close();
        }
        System.setProperty(ConfigurationFactory.CONFIGURATION_FILE_PROPERTY,
                ""org/apache/logging/log4j/core/appender/db/jdbc/"" + configFileName);
        final LoggerContext context = (LoggerContext) LogManager.getContext(false);
        if (context.getConfiguration() instanceof DefaultConfiguration) {
            context.reconfigure();
        }
        StatusLogger.getLogger().reset();
    }

    @After
    public void tearDown() throws SQLException {
        final LoggerContext context = (LoggerContext) LogManager.getContext(false);
        try {
            final Appender appender = context.getConfiguration().getAppender(""databaseAppender"");
            assertNotNull(""The appender should not be null."", appender);
            assertTrue(""The appender should be a JdbcAppender."", appender instanceof JdbcAppender);
            ((JdbcAppender) appender).getManager().release();
        } finally {
            System.clearProperty(ConfigurationFactory.CONFIGURATION_FILE_PROPERTY);
            context.reconfigure();
            StatusLogger.getLogger().reset();

            Statement statement = null;
            try {
                statement = this.connection.createStatement();
                statement.execute(""SHUTDOWN"");
            } finally {
                try {
                    if (statement != null) {
                        statement.close();
                    }
                } catch (final SQLException ignore) {
                    /* */
                }
            }

            this.connection.close();
        }
    }

    @Test
    public void testDataSourceConfig() throws Exception {
        final DataSource dataSource = createStrictMock(DataSource.class);

        expect(dataSource.getConnection()).andAnswer(new IAnswer<Connection>() {
            @Override
            public Connection answer() throws Throwable {
                return newConnection();
            }
        }).atLeastOnce();
        replay(dataSource);

        MockContextFactory.setAsInitial();

        final InitialContext context = new InitialContext();
        context.createSubcontext(""java:"");
        context.createSubcontext(""java:/comp"");
        context.createSubcontext(""java:/comp/env"");
        context.createSubcontext(""java:/comp/env/jdbc"");

        context.bind(""java:/comp/env/jdbc/TestDataSourceAppender"", dataSource);

        try {
            this.setUp(""dsLogEntry"", ""log4j2-data-source.xml"");

            final Error exception = new Error(""Final error massage is fatal!"");
            final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            final PrintWriter writer = new PrintWriter(outputStream);
            exception.printStackTrace(writer);
            writer.close();
            final String stackTrace = outputStream.toString();

            final long millis = System.currentTimeMillis();

            final Logger logger = LogManager.getLogger(this.getClass().getName() + "".testDataSourceConfig"");
            logger.trace(""Data source logged message 01."");
            logger.fatal(""Error from data source 02."", exception);

            final Statement statement = this.connection.createStatement();
            final ResultSet resultSet = statement.executeQuery(""SELECT * FROM dsLogEntry ORDER BY id"");

            assertTrue(""There should be at least one row."", resultSet.next());

            final long date = resultSet.getTimestamp(""eventDate"").getTime();
            assertTrue(""The date should be later than pre-logging (1)."", date >= millis);
            assertTrue(""The date should be earlier than now (1)."", date <= System.currentTimeMillis());
            assertEquals(""The literal column is not correct (1)."", ""Literal Value of Data Source"",
                    resultSet.getString(""literalColumn""));
            assertEquals(""The level column is not correct (1)."", ""FATAL"", resultSet.getNString(""level""));
            assertEquals(""The logger column is not correct (1)."", logger.getName(), resultSet.getNString(""logger""));
            assertEquals(""The message column is not correct (1)."", ""Error from data source 02."",
                    resultSet.getString(""message""));
            assertEquals(""The exception column is not correct (1)."", stackTrace,
                    IOUtils.readStringAndClose(resultSet.getNClob(""exception"").getCharacterStream(), -1));

            assertFalse(""There should not be two rows."", resultSet.next());

            verify(dataSource);
        } finally {
            MockContextFactory.revertSetAsInitial();
        }
    }

    @Test
    public void testFactoryMethodConfig() throws Exception {
        this.setUp(""fmLogEntry"", ""log4j2-"" + this.databaseType + ""-factory-method.xml"");

        final SQLException exception = new SQLException(""Some other error message!"");
        final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        final PrintWriter writer = new PrintWriter(outputStream);
        exception.printStackTrace(writer);
        writer.close();
        final String stackTrace = outputStream.toString();

        final long millis = System.currentTimeMillis();

        final Logger logger = LogManager.getLogger(this.getClass().getName() + "".testFactoryMethodConfig"");
        logger.debug(""Factory logged message 01."");
        logger.error(""Error from factory 02."", exception);

        final Statement statement = this.connection.createStatement();
        final ResultSet resultSet = statement.executeQuery(""SELECT * FROM fmLogEntry ORDER BY id"");

        assertTrue(""There should be at least one row."", resultSet.next());

        long date = resultSet.getTimestamp(""eventDate"").getTime();
        assertTrue(""The date should be later than pre-logging (1)."", date >= millis);
        assertTrue(""The date should be earlier than now (1)."", date <= System.currentTimeMillis());
        assertEquals(""The literal column is not correct (1)."", ""Some Other Literal Value"",
                resultSet.getString(""literalColumn""));
        assertEquals(""The level column is not correct (1)."", ""DEBUG"", resultSet.getNString(""level""));
        assertEquals(""The logger column is not correct (1)."", logger.getName(), resultSet.getNString(""logger""));
        assertEquals(""The message column is not correct (1)."", ""Factory logged message 01."",
                resultSet.getString(""message""));
        assertEquals(""The exception column is not correct (1)."", Strings.EMPTY,
                IOUtils.readStringAndClose(resultSet.getNClob(""exception"").getCharacterStream(), -1));

        assertTrue(""There should be two rows."", resultSet.next());

        date = resultSet.getTimestamp(""eventDate"").getTime();
        assertTrue(""The date should be later than pre-logging (2)."", date >= millis);
        assertTrue(""The date should be earlier than now (2)."", date <= System.currentTimeMillis());
        assertEquals(""The literal column is not correct (2)."", ""Some Other Literal Value"",
                resultSet.getString(""literalColumn""));
        assertEquals(""The level column is not correct (2)."", ""ERROR"", resultSet.getNString(""level""));
        assertEquals(""The logger column is not correct (2)."", logger.getName(), resultSet.getNString(""logger""));
        assertEquals(""The message column is not correct (2)."", ""Error from factory 02."",
                resultSet.getString(""message""));
        assertEquals(""The exception column is not correct (2)."", stackTrace,
                IOUtils.readStringAndClose(resultSet.getNClob(""exception"").getCharacterStream(), -1));

        assertFalse(""There should not be three rows."", resultSet.next());
    }
}
",1
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/db/jdbc/DataSourceConnectionSourceTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.Collection;

import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.core.LoggerContext;
import org.apache.logging.log4j.core.config.ConfigurationFactory;
import org.apache.logging.log4j.status.StatusLogger;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.mockejb.jndi.MockContextFactory;

import static org.easymock.EasyMock.*;

import static org.junit.Assert.*;

@RunWith(Parameterized.class)
public class DataSourceConnectionSourceTest {

    @Parameterized.Parameters(name = ""{0}"")
    public static Collection<Object[]> data() {
        return Arrays.asList(
                new Object[][]{
                        {""java:/comp/env/jdbc/Logging01""},
                        {""java:/comp/env/jdbc/Logging02""}
                }
        );
    }

    private final String jndiURL;
    private InitialContext context;

    public DataSourceConnectionSourceTest(final String jndiURL) {
        this.jndiURL = jndiURL;
    }

    private static final String CONFIG = ""log4j-fatalOnly.xml"";

    @BeforeClass
    public static void beforeClass() {
        System.setProperty(ConfigurationFactory.CONFIGURATION_FILE_PROPERTY, CONFIG);
        final LoggerContext ctx = (LoggerContext) LogManager.getContext();
        ctx.reconfigure();
        final StatusLogger logger = StatusLogger.getLogger();
        logger.setLevel(Level.FATAL);
    }

    @Before
    public void setUp() throws NamingException {
        MockContextFactory.setAsInitial();

        this.context = new InitialContext();
        this.context.createSubcontext(""java:"");
        this.context.createSubcontext(""java:/comp"");
        this.context.createSubcontext(""java:/comp/env"");
        this.context.createSubcontext(""java:/comp/env/jdbc"");
    }

    @After
    public void tearDown() {
        MockContextFactory.revertSetAsInitial();
    }

    @Test
    public void testNullJndiName() {
        final DataSourceConnectionSource source = DataSourceConnectionSource.createConnectionSource(null);

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testEmptyJndiName() {
        final DataSourceConnectionSource source = DataSourceConnectionSource.createConnectionSource("""");

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testNoDataSource() {
        final DataSourceConnectionSource source = DataSourceConnectionSource
                .createConnectionSource(this.jndiURL);

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testDataSource() throws NamingException, SQLException {
        final DataSource dataSource = createStrictMock(DataSource.class);
        final Connection connection1 = createStrictMock(Connection.class);
        final Connection connection2 = createStrictMock(Connection.class);

        expect(dataSource.getConnection()).andReturn(connection1);
        expect(dataSource.getConnection()).andReturn(connection2);
        replay(dataSource, connection1, connection2);

        this.context.bind(this.jndiURL, dataSource);

        DataSourceConnectionSource source = DataSourceConnectionSource
                .createConnectionSource(this.jndiURL);

        assertNotNull(""The connection source should not be null."", source);
        assertEquals(""The toString value is not correct."", ""dataSource{ name="" + jndiURL + "", value=""
                + dataSource + "" }"", source.toString());
        assertSame(""The connection is not correct (1)."", connection1, source.getConnection());
        assertSame(""The connection is not correct (2)."", connection2, source.getConnection());

        source = DataSourceConnectionSource.createConnectionSource(jndiURL.substring(0, jndiURL.length() - 1));

        assertNull(""The connection source should be null now."", source);

        verify(dataSource, connection1, connection2);
    }

}
",0
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/db/jdbc/DataSourceConnectionSourceTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.Collection;

import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.core.LoggerContext;
import org.apache.logging.log4j.core.config.ConfigurationFactory;
import org.apache.logging.log4j.status.StatusLogger;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.mockejb.jndi.MockContextFactory;

import static org.easymock.EasyMock.*;

import static org.junit.Assert.*;

@RunWith(Parameterized.class)
public class DataSourceConnectionSourceTest extends AbstractJdbcDataSourceTest {

    @Parameterized.Parameters(name = ""{0}"")
    public static Collection<Object[]> data() {
        return Arrays.asList(
                new Object[][]{
                        {""java:/comp/env/jdbc/Logging01""},
                        {""java:/comp/env/jdbc/Logging02""}
                }
        );
    }

    private final String jndiURL;
    private InitialContext context;

    public DataSourceConnectionSourceTest(final String jndiURL) {
        this.jndiURL = jndiURL;
    }

    private static final String CONFIG = ""log4j-fatalOnly.xml"";

    @BeforeClass
    public static void beforeClass() {
        System.setProperty(ConfigurationFactory.CONFIGURATION_FILE_PROPERTY, CONFIG);
        final LoggerContext ctx = (LoggerContext) LogManager.getContext();
        ctx.reconfigure();
        final StatusLogger logger = StatusLogger.getLogger();
        logger.setLevel(Level.FATAL);
    }

    @Before
    public void setUp() throws NamingException {
        MockContextFactory.setAsInitial();

        this.context = new InitialContext();
        this.context.createSubcontext(""java:"");
        this.context.createSubcontext(""java:/comp"");
        this.context.createSubcontext(""java:/comp/env"");
        this.context.createSubcontext(""java:/comp/env/jdbc"");
    }

    @After
    public void tearDown() {
        MockContextFactory.revertSetAsInitial();
    }

    @Test
    public void testNullJndiName() {
        final DataSourceConnectionSource source = DataSourceConnectionSource.createConnectionSource(null);

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testEmptyJndiName() {
        final DataSourceConnectionSource source = DataSourceConnectionSource.createConnectionSource("""");

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testNoDataSource() {
        final DataSourceConnectionSource source = DataSourceConnectionSource
                .createConnectionSource(this.jndiURL);

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testDataSource() throws NamingException, SQLException {
        final DataSource dataSource = createStrictMock(DataSource.class);
        final Connection connection1 = createStrictMock(Connection.class);
        final Connection connection2 = createStrictMock(Connection.class);

        expect(dataSource.getConnection()).andReturn(connection1);
        expect(dataSource.getConnection()).andReturn(connection2);
        replay(dataSource, connection1, connection2);

        this.context.bind(this.jndiURL, dataSource);

        DataSourceConnectionSource source = DataSourceConnectionSource.createConnectionSource(this.jndiURL);

        assertNotNull(""The connection source should not be null for "" + this.jndiURL, source);
        assertEquals(""The toString value is not correct."", ""dataSource{ name="" + jndiURL + "", value="" + dataSource + "" }"", source.toString());
        assertSame(""The connection is not correct (1)."", connection1, source.getConnection());
        assertSame(""The connection is not correct (2)."", connection2, source.getConnection());

        source = DataSourceConnectionSource.createConnectionSource(jndiURL.substring(0, jndiURL.length() - 1));

        assertNull(""The connection source should be null now."", source);

        verify(dataSource, connection1, connection2);
    }

}
",1
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/db/jdbc/FactoryMethodConnectionSourceTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import java.sql.Connection;
import java.sql.SQLException;

import javax.sql.DataSource;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.core.LoggerContext;
import org.apache.logging.log4j.core.config.ConfigurationFactory;
import org.apache.logging.log4j.status.StatusLogger;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import static org.easymock.EasyMock.*;

import static org.junit.Assert.*;

public class FactoryMethodConnectionSourceTest {
    private static ThreadLocal<Object> holder = new ThreadLocal<Object>();
    private static final String CONFIG = ""log4j-fatalOnly.xml"";

    @BeforeClass
    public static void beforeClass() {
        System.setProperty(ConfigurationFactory.CONFIGURATION_FILE_PROPERTY, CONFIG);
        final LoggerContext ctx = (LoggerContext) LogManager.getContext();
        ctx.reconfigure();
        final StatusLogger logger = StatusLogger.getLogger();
        logger.setLevel(Level.FATAL);
    }

    @AfterClass
    public static void tearDownClass() {
        holder.remove();
        holder = null;
    }

    @Before
    public void setUp() {

    }

    @After
    public void tearDown() {
        holder.remove();
    }

    @Test
    public void testNoClassName() {
        final FactoryMethodConnectionSource source =
                FactoryMethodConnectionSource.createConnectionSource(null, ""method"");

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testNoMethodName() {
        final FactoryMethodConnectionSource source =
                FactoryMethodConnectionSource.createConnectionSource(""someClass"", null);

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testBadClassName() {
        final FactoryMethodConnectionSource source =
                FactoryMethodConnectionSource.createConnectionSource(""org.apache.BadClass"", ""factoryMethod"");

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testBadMethodName() {
        final FactoryMethodConnectionSource source =
                FactoryMethodConnectionSource.createConnectionSource(this.getClass().getName(), ""factoryMethod"");

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testBadReturnType() {
        final FactoryMethodConnectionSource source = FactoryMethodConnectionSource.createConnectionSource(
                BadReturnTypeFactory.class.getName(), ""factoryMethod01""
        );

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testDataSourceReturnType() throws SQLException {
        final DataSource dataSource = createStrictMock(DataSource.class);
        final Connection connection1 = createStrictMock(Connection.class);
        final Connection connection2 = createStrictMock(Connection.class);

        expect(dataSource.getConnection()).andReturn(connection1);
        expect(dataSource.getConnection()).andReturn(connection2);
        replay(dataSource, connection1, connection2);

        holder.set(dataSource);

        final FactoryMethodConnectionSource source = FactoryMethodConnectionSource.createConnectionSource(
                DataSourceFactory.class.getName(), ""factoryMethod02""
        );

        assertNotNull(""The connection source should not be null."", source);
        assertEquals(""The toString value is not correct."", ""factory{ public static javax.sql.DataSource["" + dataSource
                + ""] "" + DataSourceFactory.class.getName() + "".factoryMethod02() }"", source.toString());
        assertSame(""The connection is not correct (1)."", connection1, source.getConnection());
        assertSame(""The connection is not correct (2)."", connection2, source.getConnection());

        verify(connection1, connection2);
    }

    @Test
    public void testConnectionReturnType() throws SQLException {
        final Connection connection = createStrictMock(Connection.class);

        replay(connection);

        holder.set(connection);

        final FactoryMethodConnectionSource source = FactoryMethodConnectionSource.createConnectionSource(
                ConnectionFactory.class.getName(), ""anotherMethod03""
        );

        assertNotNull(""The connection source should not be null."", source);
        assertEquals(""The toString value is not correct."", ""factory{ public static java.sql.Connection ""
                + ConnectionFactory.class.getName() + "".anotherMethod03() }"", source.toString());
        assertSame(""The connection is not correct (1)."", connection, source.getConnection());
        assertSame(""The connection is not correct (2)."", connection, source.getConnection());

        verify(connection);
    }

    @SuppressWarnings(""unused"")
    protected static final class BadReturnTypeFactory {
        public static String factoryMethod01() {
            return ""hello"";
        }
    }

    @SuppressWarnings(""unused"")
    protected static final class DataSourceFactory {
        public static DataSource factoryMethod02() {
            return (DataSource) holder.get();
        }
    }

    @SuppressWarnings(""unused"")
    protected static final class ConnectionFactory {
        public static Connection anotherMethod03() {
            return (Connection) holder.get();
        }
    }
}
",0
CVE-2021-44832,log4j-core/src/test/java/org/apache/logging/log4j/core/appender/db/jdbc/FactoryMethodConnectionSourceTest.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.core.appender.db.jdbc;

import java.sql.Connection;
import java.sql.SQLException;

import javax.sql.DataSource;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.core.LoggerContext;
import org.apache.logging.log4j.core.config.ConfigurationFactory;
import org.apache.logging.log4j.status.StatusLogger;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import static org.easymock.EasyMock.*;

import static org.junit.Assert.*;

public class FactoryMethodConnectionSourceTest {
    private static ThreadLocal<Object> holder = new ThreadLocal<Object>();
    private static final String CONFIG = ""log4j-fatalOnly.xml"";

    @BeforeClass
    public static void beforeClass() {
        System.setProperty(ConfigurationFactory.CONFIGURATION_FILE_PROPERTY, CONFIG);
        final LoggerContext ctx = (LoggerContext) LogManager.getContext();
        ctx.reconfigure();
        final StatusLogger logger = StatusLogger.getLogger();
        logger.setLevel(Level.FATAL);
    }

    @AfterClass
    public static void tearDownClass() {
        holder.remove();
        holder = null;
    }

    @After
    public void tearDown() {
        holder.remove();
    }

    @Test
    public void testNoClassName() {
        final FactoryMethodConnectionSource source =
                FactoryMethodConnectionSource.createConnectionSource(null, ""method"");

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testNoMethodName() {
        final FactoryMethodConnectionSource source =
                FactoryMethodConnectionSource.createConnectionSource(""someClass"", null);

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testBadClassName() {
        final FactoryMethodConnectionSource source =
                FactoryMethodConnectionSource.createConnectionSource(""org.apache.BadClass"", ""factoryMethod"");

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testBadMethodName() {
        final FactoryMethodConnectionSource source =
                FactoryMethodConnectionSource.createConnectionSource(this.getClass().getName(), ""factoryMethod"");

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testBadReturnType() {
        final FactoryMethodConnectionSource source = FactoryMethodConnectionSource.createConnectionSource(
                BadReturnTypeFactory.class.getName(), ""factoryMethod01""
        );

        assertNull(""The connection source should be null."", source);
    }

    @Test
    public void testDataSourceReturnType() throws SQLException {
        final DataSource dataSource = createStrictMock(DataSource.class);
        final Connection connection1 = createStrictMock(Connection.class);
        final Connection connection2 = createStrictMock(Connection.class);

        expect(dataSource.getConnection()).andReturn(connection1);
        expect(dataSource.getConnection()).andReturn(connection2);
        replay(dataSource, connection1, connection2);

        holder.set(dataSource);

        final FactoryMethodConnectionSource source = FactoryMethodConnectionSource.createConnectionSource(
                DataSourceFactory.class.getName(), ""factoryMethod02""
        );

        assertNotNull(""The connection source should not be null."", source);
        assertEquals(""The toString value is not correct."", ""factory{ public static javax.sql.DataSource["" + dataSource
                + ""] "" + DataSourceFactory.class.getName() + "".factoryMethod02() }"", source.toString());
        assertSame(""The connection is not correct (1)."", connection1, source.getConnection());
        assertSame(""The connection is not correct (2)."", connection2, source.getConnection());

        verify(connection1, connection2);
    }

    @Test
    public void testConnectionReturnType() throws SQLException {
        final Connection connection = createStrictMock(Connection.class);

        replay(connection);

        holder.set(connection);

        final FactoryMethodConnectionSource source = FactoryMethodConnectionSource.createConnectionSource(
                ConnectionFactory.class.getName(), ""anotherMethod03""
        );

        assertNotNull(""The connection source should not be null."", source);
        assertEquals(""The toString value is not correct."", ""factory{ public static java.sql.Connection ""
                + ConnectionFactory.class.getName() + "".anotherMethod03() }"", source.toString());
        assertSame(""The connection is not correct (1)."", connection, source.getConnection());
        assertSame(""The connection is not correct (2)."", connection, source.getConnection());

        verify(connection);
    }

    @SuppressWarnings(""unused"")
    protected static final class BadReturnTypeFactory {
        public static String factoryMethod01() {
            return ""hello"";
        }
    }

    @SuppressWarnings(""unused"")
    protected static final class DataSourceFactory {
        public static DataSource factoryMethod02() {
            return (DataSource) holder.get();
        }
    }

    @SuppressWarnings(""unused"")
    protected static final class ConnectionFactory {
        public static Connection anotherMethod03() {
            return (Connection) holder.get();
        }
    }
}
",1
CVE-2021-21234,lib/src/main/java/eu/hinsch/spring/boot/actuator/logview/LogViewEndpoint.java,"package eu.hinsch.spring.boot.actuator.logview;

import freemarker.template.Configuration;
import freemarker.template.TemplateException;
import org.apache.commons.io.IOUtils;
import org.springframework.boot.actuate.endpoint.Endpoint;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;
import org.springframework.http.MediaType;
import org.springframework.ui.Model;
import org.springframework.ui.freemarker.FreeMarkerTemplateUtils;
import org.springframework.util.Assert;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URLEncoder;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import static java.util.Arrays.asList;
import static java.util.stream.Collectors.toList;

/**
 * Created by lh on 23/02/15.
 */
public class LogViewEndpoint implements MvcEndpoint{

    private final List<FileProvider> fileProviders;
    private final Configuration freemarkerConfig;
    private final String loggingPath;
    private final List<String> stylesheets;

    public LogViewEndpoint(String loggingPath, List<String> stylesheets) {
        this.loggingPath = loggingPath;
        this.stylesheets = stylesheets;
        fileProviders = asList(new FileSystemFileProvider(),
                new ZipArchiveFileProvider(),
                new TarGzArchiveFileProvider());
        freemarkerConfig = new Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);
        freemarkerConfig.setClassForTemplateLoading(this.getClass(), ""/templates"");
    }

    @RequestMapping
    public void redirect(HttpServletResponse response) throws IOException {
        response.sendRedirect(""log/"");
    }

    @RequestMapping(""/"")
    @ResponseBody
    public String list(Model model, // TODO model should no longer be injected
                       @RequestParam(required = false, defaultValue = ""FILENAME"") SortBy sortBy,
                       @RequestParam(required = false, defaultValue = ""false"") boolean desc,
                       @RequestParam(required = false) String base) throws IOException, TemplateException {
        securityCheck(base);

        Path currentFolder = loggingPath(base);

        List<FileEntry> files = getFileProvider(currentFolder).getFileEntries(currentFolder);
        List<FileEntry> sortedFiles = sortFiles(files, sortBy, desc);

        model.addAttribute(""sortBy"", sortBy);
        model.addAttribute(""desc"", desc);
        model.addAttribute(""files"", sortedFiles);
        model.addAttribute(""currentFolder"", currentFolder.toAbsolutePath().toString());
        model.addAttribute(""base"", base != null ? URLEncoder.encode(base, ""UTF-8"") : """");
        model.addAttribute(""parent"", getParent(currentFolder));
        model.addAttribute(""stylesheets"", stylesheets);

        return FreeMarkerTemplateUtils.processTemplateIntoString(freemarkerConfig.getTemplate(""logview.ftl""), model);
    }

    private FileProvider getFileProvider(Path folder) {
        return fileProviders.stream()
                .filter(provider -> provider.canHandle(folder))
                .findFirst()
                .orElseThrow(() -> new RuntimeException(""no file provider found for "" + folder.toString()));
    }

    private String getParent(Path loggingPath) {
        Path basePath = loggingPath(null);
        String parent = """";
        if (!basePath.toString().equals(loggingPath.toString())) {
            parent = loggingPath.getParent().toString();
            if (parent.startsWith(basePath.toString())) {
                parent = parent.substring(basePath.toString().length());
            }
        }
        return parent;
    }

    private Path loggingPath(String base) {
        return base != null ? Paths.get(loggingPath, base) : Paths.get(loggingPath);
    }

    private List<FileEntry> sortFiles(List<FileEntry> files, SortBy sortBy, boolean desc) {
        Comparator<FileEntry> comparator = null;
        switch (sortBy) {
            case FILENAME:
                comparator = (a, b) -> a.getFilename().compareTo(b.getFilename());
                break;
            case SIZE:
                comparator = (a, b) -> Long.compare(a.getSize(), b.getSize());
                break;
            case MODIFIED:
                comparator = (a, b) -> Long.compare(a.getModified().toMillis(), b.getModified().toMillis());
                break;
        }
        List<FileEntry> sortedFiles = files.stream().sorted(comparator).collect(toList());

        if (desc) {
            Collections.reverse(sortedFiles);
        }
        return sortedFiles;
    }

    @RequestMapping(""/view"")
    public void view(@RequestParam String filename,
                     @RequestParam(required = false) String base,
                     @RequestParam(required = false) Integer tailLines,
                     HttpServletResponse response) throws IOException {
        securityCheck(filename);
        response.setContentType(MediaType.TEXT_PLAIN_VALUE);

        Path path = loggingPath(base);
        FileProvider fileProvider = getFileProvider(path);
        if (tailLines != null) {
            fileProvider.tailContent(path, filename, response.getOutputStream(), tailLines);
        }
        else {
            fileProvider.streamContent(path, filename, response.getOutputStream());
        }
    }

    @RequestMapping(""/search"")
    public void search(@RequestParam String term, HttpServletResponse response) throws IOException {
        Path folder = loggingPath(null);
        List<FileEntry> files = getFileProvider(folder).getFileEntries(folder);
        List<FileEntry> sortedFiles = sortFiles(files, SortBy.MODIFIED, false);

        response.setContentType(MediaType.TEXT_PLAIN_VALUE);
        ServletOutputStream outputStream = response.getOutputStream();

        sortedFiles.stream()
                .filter(file -> file.getFileType().equals(FileType.FILE))
                .forEach(file -> searchAndStreamFile(file, term, outputStream));
    }

    private void searchAndStreamFile(FileEntry fileEntry, String term, OutputStream outputStream) {
        Path folder = loggingPath(null);
        try {
            List<String> lines = IOUtils.readLines(new FileInputStream(new File(folder.toFile().toString(), fileEntry.getFilename())))
                    .stream()
                    .filter(line -> line.contains(term))
                    .map(line -> ""["" + fileEntry.getFilename() + ""] "" + line)
                    .collect(toList());
            for (String line : lines) {
                outputStream.write(line.getBytes());
                outputStream.write(System.lineSeparator().getBytes());
            }
        } catch (IOException e) {
            throw new RuntimeException(""error reading file"", e);
        }
    }

    private void securityCheck(String filename) {
        Assert.doesNotContain(filename, "".."");
    }

    @Override
    public String getPath() {
        return ""/log"";
    }

    @Override
    public boolean isSensitive() {
        return true;
    }


    @Override
    public Class<? extends Endpoint> getEndpointType() {
        return null;
    }

}
",0
CVE-2021-21234,lib/src/main/java/eu/hinsch/spring/boot/actuator/logview/LogViewEndpoint.java,"package eu.hinsch.spring.boot.actuator.logview;

import freemarker.template.Configuration;
import freemarker.template.TemplateException;
import org.apache.commons.io.IOUtils;
import org.springframework.boot.actuate.endpoint.Endpoint;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;
import org.springframework.http.MediaType;
import org.springframework.ui.Model;
import org.springframework.ui.freemarker.FreeMarkerTemplateUtils;
import org.springframework.util.Assert;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URLEncoder;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import static java.util.Arrays.asList;
import static java.util.stream.Collectors.toList;

/**
 * Created by lh on 23/02/15.
 */
public class LogViewEndpoint implements MvcEndpoint{

    private final List<FileProvider> fileProviders;
    private final Configuration freemarkerConfig;
    private final String loggingPath;
    private final List<String> stylesheets;

    public LogViewEndpoint(String loggingPath, List<String> stylesheets) {
        this.loggingPath = loggingPath;
        this.stylesheets = stylesheets;
        fileProviders = asList(new FileSystemFileProvider(),
                new ZipArchiveFileProvider(),
                new TarGzArchiveFileProvider());
        freemarkerConfig = new Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);
        freemarkerConfig.setClassForTemplateLoading(this.getClass(), ""/templates"");
    }

    @RequestMapping
    public void redirect(HttpServletResponse response) throws IOException {
        response.sendRedirect(""log/"");
    }

    @RequestMapping(""/"")
    @ResponseBody
    public String list(Model model, // TODO model should no longer be injected
                       @RequestParam(required = false, defaultValue = ""FILENAME"") SortBy sortBy,
                       @RequestParam(required = false, defaultValue = ""false"") boolean desc,
                       @RequestParam(required = false) String base) throws IOException, TemplateException {
        Path currentFolder = loggingPath(base);
        securityCheck(currentFolder, null);


        List<FileEntry> files = getFileProvider(currentFolder).getFileEntries(currentFolder);
        List<FileEntry> sortedFiles = sortFiles(files, sortBy, desc);

        model.addAttribute(""sortBy"", sortBy);
        model.addAttribute(""desc"", desc);
        model.addAttribute(""files"", sortedFiles);
        model.addAttribute(""currentFolder"", currentFolder.toAbsolutePath().toString());
        model.addAttribute(""base"", base != null ? URLEncoder.encode(base, ""UTF-8"") : """");
        model.addAttribute(""parent"", getParent(currentFolder));
        model.addAttribute(""stylesheets"", stylesheets);

        return FreeMarkerTemplateUtils.processTemplateIntoString(freemarkerConfig.getTemplate(""logview.ftl""), model);
    }

    private FileProvider getFileProvider(Path folder) {
        return fileProviders.stream()
                .filter(provider -> provider.canHandle(folder))
                .findFirst()
                .orElseThrow(() -> new RuntimeException(""no file provider found for "" + folder.toString()));
    }

    private String getParent(Path loggingPath) {
        Path basePath = loggingPath(null);
        String parent = """";
        if (!basePath.toString().equals(loggingPath.toString())) {
            parent = loggingPath.getParent().toString();
            if (parent.startsWith(basePath.toString())) {
                parent = parent.substring(basePath.toString().length());
            }
        }
        return parent;
    }

    private Path loggingPath(String base) {
        return base != null ? Paths.get(loggingPath, base) : Paths.get(loggingPath);
    }

    private List<FileEntry> sortFiles(List<FileEntry> files, SortBy sortBy, boolean desc) {
        Comparator<FileEntry> comparator = null;
        switch (sortBy) {
            case FILENAME:
                comparator = (a, b) -> a.getFilename().compareTo(b.getFilename());
                break;
            case SIZE:
                comparator = (a, b) -> Long.compare(a.getSize(), b.getSize());
                break;
            case MODIFIED:
                comparator = (a, b) -> Long.compare(a.getModified().toMillis(), b.getModified().toMillis());
                break;
        }
        List<FileEntry> sortedFiles = files.stream().sorted(comparator).collect(toList());

        if (desc) {
            Collections.reverse(sortedFiles);
        }
        return sortedFiles;
    }

    @RequestMapping(""/view"")
    public void view(@RequestParam String filename,
                     @RequestParam(required = false) String base,
                     @RequestParam(required = false) Integer tailLines,
                     HttpServletResponse response) throws IOException {

        Path path = loggingPath(base);
        securityCheck(path, filename);
        response.setContentType(MediaType.TEXT_PLAIN_VALUE);
        FileProvider fileProvider = getFileProvider(path);
        if (tailLines != null) {
            fileProvider.tailContent(path, filename, response.getOutputStream(), tailLines);
        }
        else {
            fileProvider.streamContent(path, filename, response.getOutputStream());
        }
    }

    @RequestMapping(""/search"")
    public void search(@RequestParam String term, HttpServletResponse response) throws IOException {
        Path folder = loggingPath(null);
        List<FileEntry> files = getFileProvider(folder).getFileEntries(folder);
        List<FileEntry> sortedFiles = sortFiles(files, SortBy.MODIFIED, false);

        response.setContentType(MediaType.TEXT_PLAIN_VALUE);
        ServletOutputStream outputStream = response.getOutputStream();

        sortedFiles.stream()
                .filter(file -> file.getFileType().equals(FileType.FILE))
                .forEach(file -> searchAndStreamFile(file, term, outputStream));
    }

    private void searchAndStreamFile(FileEntry fileEntry, String term, OutputStream outputStream) {
        Path folder = loggingPath(null);
        try {
            List<String> lines = IOUtils.readLines(new FileInputStream(new File(folder.toFile().toString(), fileEntry.getFilename())))
                    .stream()
                    .filter(line -> line.contains(term))
                    .map(line -> ""["" + fileEntry.getFilename() + ""] "" + line)
                    .collect(toList());
            for (String line : lines) {
                outputStream.write(line.getBytes());
                outputStream.write(System.lineSeparator().getBytes());
            }
        } catch (IOException e) {
            throw new RuntimeException(""error reading file"", e);
        }
    }

    private void securityCheck(Path base, String filename) {
        try {
            String canonicalLoggingPath = (filename != null ? new File(base.toFile().toString(), filename) : new File(base.toFile().toString())).getCanonicalPath();
            String baseCanonicalPath = new File(loggingPath).getCanonicalPath();
            String errorMessage = ""File "" + base.toString() + ""/"" + filename + "" may not be located outside base path "" + loggingPath;
            Assert.isTrue(canonicalLoggingPath.startsWith(baseCanonicalPath), errorMessage);
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }

    @Override
    public String getPath() {
        return ""/log"";
    }

    @Override
    public boolean isSensitive() {
        return true;
    }


    @Override
    public Class<? extends Endpoint> getEndpointType() {
        return null;
    }

}
",1
CVE-2021-21234,lib/src/test/java/eu/hinsch/spring/boot/actuator/logview/LogViewEndpointTest.java,"package eu.hinsch.spring.boot.actuator.logview;

import org.apache.catalina.ssi.ByteArrayServletOutputStream;
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.rules.TemporaryFolder;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.ui.ExtendedModelMap;
import org.springframework.ui.Model;

import javax.servlet.http.HttpServletResponse;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Date;
import java.util.List;
import java.util.zip.GZIPOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static java.util.stream.Collectors.toList;
import static org.hamcrest.Matchers.*;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@SuppressWarnings(""unchecked"")
public class LogViewEndpointTest {

    @Rule
    public TemporaryFolder temporaryFolder = new TemporaryFolder();

    @Rule
    public ExpectedException expectedException = ExpectedException.none();

    @Mock
    private HttpServletResponse response;

    private LogViewEndpoint logViewEndpoint;

    private Model model;
    private long now;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        logViewEndpoint = new LogViewEndpoint(temporaryFolder.getRoot().getAbsolutePath(),
                new LogViewEndpointAutoconfig.EndpointConfiguration().getStylesheets());
        model = new ExtendedModelMap();
        now = new Date().getTime();
    }

    @Test
    public void shouldReturnEmptyFileListForEmptyDirectory() throws Exception {
        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, null);

        // then
        assertThat(model.containsAttribute(""files""), is(true));
        assertThat(getFileEntries(), hasSize(0));
    }

    @Test
    public void shouldListSortedByFilename() throws Exception {
        // given
        createFile(""B.log"", ""x"", now);
        createFile(""A.log"", ""x"", now);
        createFile(""C.log"", ""x"", now);

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, null);

        // then
        assertThat(getFileNames(), contains(""A.log"", ""B.log"", ""C.log""));
    }

    @Test
    public void shouldListReverseSortedByFilename() throws Exception {
        // given
        createFile(""B.log"", ""x"", now);
        createFile(""A.log"", ""x"", now);
        createFile(""C.log"", ""x"", now);

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, true, null);

        // then
        assertThat(getFileNames(), contains(""C.log"", ""B.log"", ""A.log""));
    }

    @Test
    public void shouldListSortedBySize() throws Exception {
        // given
        createFile(""A.log"", ""xx"", now);
        createFile(""B.log"", ""x"", now);
        createFile(""C.log"", ""xxx"", now);

        // when
        logViewEndpoint.list(model, SortBy.SIZE, false, null);

        // then
        assertThat(getFileNames(), contains(""B.log"", ""A.log"", ""C.log""));
        assertThat(getFileSizes(), contains(1L, 2L, 3L));
    }

    @Test
    public void shouldListSortedByDate() throws Exception {
        // given
        // TODO java 8 date api
        createFile(""A.log"", ""x"", now);
        createFile(""B.log"", ""x"", now - 10 * 60 * 1000);
        createFile(""C.log"", ""x"", now - 5 * 60 * 1000);

        // when
        logViewEndpoint.list(model, SortBy.MODIFIED, false, null);

        // then
        assertThat(getFileNames(), contains(""B.log"", ""C.log"", ""A.log""));
        assertThat(getFilePrettyTimes(), contains(""10 minutes ago"", ""5 minutes ago"", ""moments ago""));
    }

    @Test
    public void shouldSetFileTypeForFile() throws Exception {
        // given
        createFile(""A.log"", ""x"", now);

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, null);

        // then
        assertThat(getFileEntries().get(0).getFileType(), is(FileType.FILE));
    }

    @Test
    public void shouldSetFileTypeForArchive() throws Exception {
        // given
        createFile(""A.log.tar.gz"", ""x"", now);

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, null);

        // then
        assertThat(getFileEntries().get(0).getFileType(), is(FileType.ARCHIVE));
    }

    @Test
    public void shouldContainEmptyParentLinkInBaseFolder() throws Exception {
        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, null);

        // then
        assertThat(model.asMap().get(""parent""), is(""""));
    }

    @Test
    public void shouldContainEmptyParentLinkInSubfolder() throws Exception {
        // given
        temporaryFolder.newFolder(""subfolder"");

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, ""subfolder"");

        // then
        assertThat(model.asMap().get(""parent""), is(""""));
    }

    @Test
    public void shouldContainEmptyParentLinkInNestedSubfolder() throws Exception {
        // given
        temporaryFolder.newFolder(""subfolder"");
        temporaryFolder.newFolder(""subfolder"", ""nested"");

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, ""subfolder/nested"");

        // then
        assertThat(model.asMap().get(""parent""), is(""/subfolder""));
    }

    @Test
    public void shouldIncludeSubfolderEntry() throws Exception {
        // given
        temporaryFolder.newFolder(""subfolder"");

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, null);

        // then
        List<FileEntry> fileEntries = getFileEntries();
        assertThat(fileEntries, hasSize(1));
        FileEntry fileEntry = fileEntries.get(0);
        assertThat(fileEntry.getFileType(), is(FileType.DIRECTORY));
        assertThat(fileEntry.getFilename(), is(""subfolder""));
    }

    @Test
    public void shouldListZipContent() throws Exception {
        // given
        createZipArchive(""file.zip"", ""A.log"", ""content"");

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, ""file.zip"");

        // then
        List<FileEntry> fileEntries = getFileEntries();
        assertThat(fileEntries, hasSize(1));
        FileEntry fileEntry = fileEntries.get(0);
        assertThat(fileEntry.getFilename(), is(""A.log""));
    }

    @Test
    public void shouldViewZipFileContent() throws Exception {
        // given
        createZipArchive(""file.zip"", ""A.log"", ""content"");
        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();

        // when
        logViewEndpoint.view(""A.log"", ""file.zip"", null, response);

        // then
        assertThat(new String(outputStream.toByteArray()), is(""content""));
    }

    private void createZipArchive(String archiveFileName, String contentFileName, String content) throws Exception {
        try(ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(temporaryFolder.getRoot(), archiveFileName)))) {
            ZipEntry zipEntry = new ZipEntry(contentFileName);
            zos.putNextEntry(zipEntry);
            IOUtils.write(content, zos);
        }
    }

    @Test(expected = UnsupportedOperationException.class)
    public void shouldThrowExceptionWhenCallingTailForZip() throws Exception {
        // given
        createZipArchive(""file.zip"", ""A.log"", ""content"");

        // when
        logViewEndpoint.view(""A.log"", ""file.zip"", 1, response);

        // then -> exception
    }

    @Test
    public void shouldListTarGzContent() throws Exception {
        // given
        createTarGzArchive(""file.tar.gz"", ""A.log"", ""content"");

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, ""file.tar.gz"");

        // then
        List<FileEntry> fileEntries = getFileEntries();
        assertThat(fileEntries, hasSize(1));
        FileEntry fileEntry = fileEntries.get(0);
        assertThat(fileEntry.getFilename(), is(""A.log""));
    }

    @Test
    public void shouldViewTarGzFileContent() throws Exception {
        // given
        createTarGzArchive(""file.tar.gz"", ""A.log"", ""content"");
        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();

        // when
        logViewEndpoint.view(""A.log"", ""file.tar.gz"", null, response);

        // then
        assertThat(new String(outputStream.toByteArray()), is(""content""));
    }

    @Test(expected = UnsupportedOperationException.class)
    public void shouldThrowExceptionWhenCallingTailForTarGz() throws Exception {
        // given
        createTarGzArchive(""file.tar.gz"", ""A.log"", ""content"");

        // when
        logViewEndpoint.view(""A.log"", ""file.tar.gz"", 1, response);

        // then -> exception
    }

    private void createTarGzArchive(String archiveFileName, String contentFileName, String content) throws Exception {

        try(TarArchiveOutputStream tos = new TarArchiveOutputStream(new GZIPOutputStream(
                new BufferedOutputStream(new FileOutputStream(
                        new File(temporaryFolder.getRoot(), archiveFileName)))))) {
            tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_STAR);
            tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);
            TarArchiveEntry archiveEntry = new TarArchiveEntry(contentFileName);
            archiveEntry.setSize(content.length());
            tos.putArchiveEntry(archiveEntry);
            IOUtils.write(content, tos);
            tos.closeArchiveEntry();
        }
    }

    @Test
    public void shouldRedirectWithoutTrainingSlash() throws IOException {
        // when
        logViewEndpoint.redirect(response);

        // then
        verify(response).sendRedirect(""log/"");
    }

    @Test
    public void shouldEndpointBeSensitive() {
        assertThat(logViewEndpoint.isSensitive(), is(true));
    }

    @Test
    public void shouldReturnContextPath() {
        assertThat(logViewEndpoint.getPath(), is(""/log""));
    }

    @Test
    public void shouldReturnNullEndpointType() {
        assertThat(logViewEndpoint.getEndpointType(), is(nullValue()));
    }

    @Test
    public void shouldNotAllowToListFileOutsideRoot() throws Exception {
        // given
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(containsString(""this String argument must not contain the substring [..]""));

        // when
        logViewEndpoint.view(""../somefile"", null, null, null);
    }

    @Test
    public void shouldViewFile() throws Exception {
        // given
        createFile(""file.log"", ""abc"", now);
        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();

        // when
        logViewEndpoint.view(""file.log"", null, null, response);

        // then
        assertThat(new String(outputStream.toByteArray()), is(""abc""));
    }

    @Test
    public void shouldTailViewOnlyLastLine() throws Exception {
        // given
        createFile(""file.log"", ""line1"" + System.lineSeparator() + ""line2"" + System.lineSeparator(), now);
        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();

        // when
        logViewEndpoint.view(""file.log"", null, 1, response);

        // then
        assertThat(new String(outputStream.toByteArray()), not(containsString(""line1"")));
        assertThat(new String(outputStream.toByteArray()), containsString(""line2""));
    }

    @Test
    public void shouldSearchInFiles() throws Exception {
        // given
        String sep = System.lineSeparator();
        createFile(""A.log"", ""A-line1"" + sep + ""A-line2"" + sep + ""A-line3"", now - 1);
        createFile(""B.log"", ""B-line1"" + sep + ""B-line2"" + sep + ""B-line3"", now);
        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();

        // when
        logViewEndpoint.search(""line2"", response);

        // then
        String output = new String(outputStream.toByteArray());
        assertThat(output, containsString(""[A.log] A-line2""));
        assertThat(output, containsString(""[B.log] B-line2""));
        assertThat(output, not(containsString(""line1"")));
        assertThat(output, not(containsString(""line3"")));
    }

    private ByteArrayServletOutputStream mockResponseOutputStream() throws Exception {
        ByteArrayServletOutputStream outputStream = new ByteArrayServletOutputStream();
        when(response.getOutputStream()).thenReturn(outputStream);
        return outputStream;
    }

    private List<String> getFileNames() {
        return getFileEntries()
                .stream()
                .map(FileEntry::getFilename)
                .collect(toList());
    }

    private List<Long> getFileSizes() {
        return getFileEntries()
                .stream()
                .map(FileEntry::getSize)
                .collect(toList());
    }

    private List<String> getFilePrettyTimes() {
        return getFileEntries()
                .stream()
                .map(FileEntry::getModifiedPretty)
                .collect(toList());
    }

    private List<FileEntry> getFileEntries() {
        return (List<FileEntry>) model.asMap().get(""files"");
    }

    private void createFile(String filename, String content, long modified) throws Exception {
        File file = new File(temporaryFolder.getRoot(), filename);
        FileUtils.write(file, content);
        assertThat(file.setLastModified(modified), is(true));
    }

}",0
CVE-2021-21234,lib/src/test/java/eu/hinsch/spring/boot/actuator/logview/LogViewEndpointTest.java,"package eu.hinsch.spring.boot.actuator.logview;

import org.apache.catalina.ssi.ByteArrayServletOutputStream;
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.rules.TemporaryFolder;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.ui.ExtendedModelMap;
import org.springframework.ui.Model;

import javax.servlet.http.HttpServletResponse;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Date;
import java.util.List;
import java.util.zip.GZIPOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static java.util.stream.Collectors.toList;
import static org.hamcrest.Matchers.*;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@SuppressWarnings(""unchecked"")
public class LogViewEndpointTest {

    @Rule
    public TemporaryFolder temporaryFolder = new TemporaryFolder();

    @Rule
    public ExpectedException expectedException = ExpectedException.none();

    @Mock
    private HttpServletResponse response;

    private LogViewEndpoint logViewEndpoint;

    private Model model;
    private long now;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        logViewEndpoint = new LogViewEndpoint(temporaryFolder.getRoot().getAbsolutePath(),
                new LogViewEndpointAutoconfig.EndpointConfiguration().getStylesheets());
        model = new ExtendedModelMap();
        now = new Date().getTime();
    }

    @Test
    public void shouldReturnEmptyFileListForEmptyDirectory() throws Exception {
        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, null);

        // then
        assertThat(model.containsAttribute(""files""), is(true));
        assertThat(getFileEntries(), hasSize(0));
    }

    @Test
    public void shouldListSortedByFilename() throws Exception {
        // given
        createFile(""B.log"", ""x"", now);
        createFile(""A.log"", ""x"", now);
        createFile(""C.log"", ""x"", now);

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, null);

        // then
        assertThat(getFileNames(), contains(""A.log"", ""B.log"", ""C.log""));
    }

    @Test
    public void shouldListReverseSortedByFilename() throws Exception {
        // given
        createFile(""B.log"", ""x"", now);
        createFile(""A.log"", ""x"", now);
        createFile(""C.log"", ""x"", now);

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, true, null);

        // then
        assertThat(getFileNames(), contains(""C.log"", ""B.log"", ""A.log""));
    }

    @Test
    public void shouldListSortedBySize() throws Exception {
        // given
        createFile(""A.log"", ""xx"", now);
        createFile(""B.log"", ""x"", now);
        createFile(""C.log"", ""xxx"", now);

        // when
        logViewEndpoint.list(model, SortBy.SIZE, false, null);

        // then
        assertThat(getFileNames(), contains(""B.log"", ""A.log"", ""C.log""));
        assertThat(getFileSizes(), contains(1L, 2L, 3L));
    }

    @Test
    public void shouldListSortedByDate() throws Exception {
        // given
        // TODO java 8 date api
        createFile(""A.log"", ""x"", now);
        createFile(""B.log"", ""x"", now - 10 * 60 * 1000);
        createFile(""C.log"", ""x"", now - 5 * 60 * 1000);

        // when
        logViewEndpoint.list(model, SortBy.MODIFIED, false, null);

        // then
        assertThat(getFileNames(), contains(""B.log"", ""C.log"", ""A.log""));
        assertThat(getFilePrettyTimes(), contains(""10 minutes ago"", ""5 minutes ago"", ""moments ago""));
    }

    @Test
    public void shouldSetFileTypeForFile() throws Exception {
        // given
        createFile(""A.log"", ""x"", now);

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, null);

        // then
        assertThat(getFileEntries().get(0).getFileType(), is(FileType.FILE));
    }

    @Test
    public void shouldSetFileTypeForArchive() throws Exception {
        // given
        createFile(""A.log.tar.gz"", ""x"", now);

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, null);

        // then
        assertThat(getFileEntries().get(0).getFileType(), is(FileType.ARCHIVE));
    }

    @Test
    public void shouldContainEmptyParentLinkInBaseFolder() throws Exception {
        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, null);

        // then
        assertThat(model.asMap().get(""parent""), is(""""));
    }

    @Test
    public void shouldContainEmptyParentLinkInSubfolder() throws Exception {
        // given
        temporaryFolder.newFolder(""subfolder"");

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, ""subfolder"");

        // then
        assertThat(model.asMap().get(""parent""), is(""""));
    }

    @Test
    public void shouldContainEmptyParentLinkInNestedSubfolder() throws Exception {
        // given
        temporaryFolder.newFolder(""subfolder"");
        temporaryFolder.newFolder(""subfolder"", ""nested"");

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, ""subfolder/nested"");

        // then
        assertThat(model.asMap().get(""parent""), is(""/subfolder""));
    }

    @Test
    public void shouldIncludeSubfolderEntry() throws Exception {
        // given
        temporaryFolder.newFolder(""subfolder"");

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, null);

        // then
        List<FileEntry> fileEntries = getFileEntries();
        assertThat(fileEntries, hasSize(1));
        FileEntry fileEntry = fileEntries.get(0);
        assertThat(fileEntry.getFileType(), is(FileType.DIRECTORY));
        assertThat(fileEntry.getFilename(), is(""subfolder""));
    }

    @Test
    public void shouldListZipContent() throws Exception {
        // given
        createZipArchive(""file.zip"", ""A.log"", ""content"");

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, ""file.zip"");

        // then
        List<FileEntry> fileEntries = getFileEntries();
        assertThat(fileEntries, hasSize(1));
        FileEntry fileEntry = fileEntries.get(0);
        assertThat(fileEntry.getFilename(), is(""A.log""));
    }

    @Test
    public void shouldViewZipFileContent() throws Exception {
        // given
        createZipArchive(""file.zip"", ""A.log"", ""content"");
        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();

        // when
        logViewEndpoint.view(""A.log"", ""file.zip"", null, response);

        // then
        assertThat(new String(outputStream.toByteArray()), is(""content""));
    }

    private void createZipArchive(String archiveFileName, String contentFileName, String content) throws Exception {
        try(ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(temporaryFolder.getRoot(), archiveFileName)))) {
            ZipEntry zipEntry = new ZipEntry(contentFileName);
            zos.putNextEntry(zipEntry);
            IOUtils.write(content, zos);
        }
    }

    @Test(expected = UnsupportedOperationException.class)
    public void shouldThrowExceptionWhenCallingTailForZip() throws Exception {
        // given
        createZipArchive(""file.zip"", ""A.log"", ""content"");

        // when
        logViewEndpoint.view(""A.log"", ""file.zip"", 1, response);

        // then -> exception
    }

    @Test
    public void shouldListTarGzContent() throws Exception {
        // given
        createTarGzArchive(""file.tar.gz"", ""A.log"", ""content"");

        // when
        logViewEndpoint.list(model, SortBy.FILENAME, false, ""file.tar.gz"");

        // then
        List<FileEntry> fileEntries = getFileEntries();
        assertThat(fileEntries, hasSize(1));
        FileEntry fileEntry = fileEntries.get(0);
        assertThat(fileEntry.getFilename(), is(""A.log""));
    }

    @Test
    public void shouldViewTarGzFileContent() throws Exception {
        // given
        createTarGzArchive(""file.tar.gz"", ""A.log"", ""content"");
        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();

        // when
        logViewEndpoint.view(""A.log"", ""file.tar.gz"", null, response);

        // then
        assertThat(new String(outputStream.toByteArray()), is(""content""));
    }

    @Test(expected = UnsupportedOperationException.class)
    public void shouldThrowExceptionWhenCallingTailForTarGz() throws Exception {
        // given
        createTarGzArchive(""file.tar.gz"", ""A.log"", ""content"");

        // when
        logViewEndpoint.view(""A.log"", ""file.tar.gz"", 1, response);

        // then -> exception
    }

    private void createTarGzArchive(String archiveFileName, String contentFileName, String content) throws Exception {

        try(TarArchiveOutputStream tos = new TarArchiveOutputStream(new GZIPOutputStream(
                new BufferedOutputStream(new FileOutputStream(
                        new File(temporaryFolder.getRoot(), archiveFileName)))))) {
            tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_STAR);
            tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);
            TarArchiveEntry archiveEntry = new TarArchiveEntry(contentFileName);
            archiveEntry.setSize(content.length());
            tos.putArchiveEntry(archiveEntry);
            IOUtils.write(content, tos);
            tos.closeArchiveEntry();
        }
    }

    @Test
    public void shouldRedirectWithoutTrainingSlash() throws IOException {
        // when
        logViewEndpoint.redirect(response);

        // then
        verify(response).sendRedirect(""log/"");
    }

    @Test
    public void shouldEndpointBeSensitive() {
        assertThat(logViewEndpoint.isSensitive(), is(true));
    }

    @Test
    public void shouldReturnContextPath() {
        assertThat(logViewEndpoint.getPath(), is(""/log""));
    }

    @Test
    public void shouldReturnNullEndpointType() {
        assertThat(logViewEndpoint.getEndpointType(), is(nullValue()));
    }

    @Test
    public void shouldNotAllowToListFileOutsideRoot() throws Exception {
        // given
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(containsString(""may not be located outside base path""));

        // when
        logViewEndpoint.view(""../somefile"", null, null, null);
    }

    @Test
    public void shouldNotAllowToListWithBaseOutsideRoot() throws Exception {
        // given
        expectedException.expect(IllegalArgumentException.class);
        expectedException.expectMessage(containsString(""may not be located outside base path""));

        // when
        logViewEndpoint.view(""somefile"", ""../otherdir"", null, null);
    }

    @Test
    public void shouldViewFile() throws Exception {
        // given
        createFile(""file.log"", ""abc"", now);
        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();

        // when
        logViewEndpoint.view(""file.log"", null, null, response);

        // then
        assertThat(new String(outputStream.toByteArray()), is(""abc""));
    }

    @Test
    public void shouldTailViewOnlyLastLine() throws Exception {
        // given
        createFile(""file.log"", ""line1"" + System.lineSeparator() + ""line2"" + System.lineSeparator(), now);
        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();

        // when
        logViewEndpoint.view(""file.log"", null, 1, response);

        // then
        assertThat(new String(outputStream.toByteArray()), not(containsString(""line1"")));
        assertThat(new String(outputStream.toByteArray()), containsString(""line2""));
    }

    @Test
    public void shouldSearchInFiles() throws Exception {
        // given
        String sep = System.lineSeparator();
        createFile(""A.log"", ""A-line1"" + sep + ""A-line2"" + sep + ""A-line3"", now - 1);
        createFile(""B.log"", ""B-line1"" + sep + ""B-line2"" + sep + ""B-line3"", now);
        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();

        // when
        logViewEndpoint.search(""line2"", response);

        // then
        String output = new String(outputStream.toByteArray());
        assertThat(output, containsString(""[A.log] A-line2""));
        assertThat(output, containsString(""[B.log] B-line2""));
        assertThat(output, not(containsString(""line1"")));
        assertThat(output, not(containsString(""line3"")));
    }

    private ByteArrayServletOutputStream mockResponseOutputStream() throws Exception {
        ByteArrayServletOutputStream outputStream = new ByteArrayServletOutputStream();
        when(response.getOutputStream()).thenReturn(outputStream);
        return outputStream;
    }

    private List<String> getFileNames() {
        return getFileEntries()
                .stream()
                .map(FileEntry::getFilename)
                .collect(toList());
    }

    private List<Long> getFileSizes() {
        return getFileEntries()
                .stream()
                .map(FileEntry::getSize)
                .collect(toList());
    }

    private List<String> getFilePrettyTimes() {
        return getFileEntries()
                .stream()
                .map(FileEntry::getModifiedPretty)
                .collect(toList());
    }

    private List<FileEntry> getFileEntries() {
        return (List<FileEntry>) model.asMap().get(""files"");
    }

    private void createFile(String filename, String content, long modified) throws Exception {
        File file = new File(temporaryFolder.getRoot(), filename);
        FileUtils.write(file, content);
        assertThat(file.setLastModified(modified), is(true));
    }

}",1
CVE-2019-10135,osbs/build/config_map_response.py,"""""""
Copyright (c) 2017 Red Hat, Inc
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the LICENSE file for details.
""""""
from __future__ import print_function, absolute_import, unicode_literals

import logging
import json
import yaml

from osbs.utils import graceful_chain_get


logger = logging.getLogger(__name__)


class ConfigMapResponse(object):
    """"""
    Wrapper for JSON describing a ConfigMap
    """"""

    def __init__(self, config_map):
        """"""
        :param config_map: dict, data to be stored in the ConfigMap
        """"""
        self._json = config_map

    @property
    def json(self):
        return self._json

    def is_yaml(self, name):
        if name.rsplit('.', 1)[-1] in ('yaml', 'yml'):
            return True
        return False

    def get_data(self):
        """"""
        Find the data stored in the config_map

        :return: dict, the json of the data data that was passed into the ConfigMap on creation
        """"""
        data = graceful_chain_get(self.json, ""data"")
        if data is None:
            return {}

        data_dict = {}
        for key in data:
            if self.is_yaml(key):
                data_dict[key] = yaml.load(data[key])
            else:
                data_dict[key] = json.loads(data[key])

        return data_dict

    def get_data_by_key(self, name):
        """"""
        Find the object stored by a JSON string at key 'name'

        :return: str or dict, the json of the str or dict stored in the ConfigMap at that location
        """"""
        data = graceful_chain_get(self.json, ""data"")

        if data is None or name not in data:
            return {}

        if self.is_yaml(name):
            return yaml.load(data[name]) or {}
        return json.loads(data[name])
",0
CVE-2019-10135,osbs/build/config_map_response.py,"""""""
Copyright (c) 2017 Red Hat, Inc
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the LICENSE file for details.
""""""
from __future__ import print_function, absolute_import, unicode_literals

import logging
import json
import yaml

from osbs.utils import graceful_chain_get


logger = logging.getLogger(__name__)


class ConfigMapResponse(object):
    """"""
    Wrapper for JSON describing a ConfigMap
    """"""

    def __init__(self, config_map):
        """"""
        :param config_map: dict, data to be stored in the ConfigMap
        """"""
        self._json = config_map

    @property
    def json(self):
        return self._json

    def is_yaml(self, name):
        if name.rsplit('.', 1)[-1] in ('yaml', 'yml'):
            return True
        return False

    def get_data(self):
        """"""
        Find the data stored in the config_map

        :return: dict, the json of the data data that was passed into the ConfigMap on creation
        """"""
        data = graceful_chain_get(self.json, ""data"")
        if data is None:
            return {}

        data_dict = {}
        for key in data:
            if self.is_yaml(key):
                data_dict[key] = yaml.safe_load(data[key])
            else:
                data_dict[key] = json.loads(data[key])

        return data_dict

    def get_data_by_key(self, name):
        """"""
        Find the object stored by a JSON string at key 'name'

        :return: str or dict, the json of the str or dict stored in the ConfigMap at that location
        """"""
        data = graceful_chain_get(self.json, ""data"")

        if data is None or name not in data:
            return {}

        if self.is_yaml(name):
            return yaml.safe_load(data[name]) or {}
        return json.loads(data[name])
",1
CVE-2019-10135,osbs/repo_utils.py,"""""""
Copyright (c) 2017 Red Hat, Inc
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the LICENSE file for details.
""""""


from __future__ import absolute_import

from osbs.exceptions import OsbsException
from osbs.constants import REPO_CONFIG_FILE, ADDITIONAL_TAGS_FILE, REPO_CONTAINER_CONFIG
from six import StringIO
from six.moves.configparser import ConfigParser
from textwrap import dedent

import logging
import os
import re
import yaml


logger = logging.getLogger(__name__)


class RepoInfo(object):
    """"""
    Aggregator for different aspects of the repository.
    """"""

    def __init__(self, dockerfile_parser=None, configuration=None, additional_tags=None):
        self.dockerfile_parser = dockerfile_parser
        self.configuration = configuration or RepoConfiguration()
        self.additional_tags = additional_tags or AdditionalTagsConfig(
            tags=self.configuration.container.get('tags', set()))


class RepoConfiguration(object):
    """"""
    Read configuration from repository.
    """"""

    DEFAULT_CONFIG = dedent(""""""\
        [autorebuild]
        enabled = false
        """""")

    def __init__(self, dir_path='', file_name=REPO_CONFIG_FILE, depth=None):

        self._config_parser = ConfigParser()
        self.container = {}
        self.depth = depth or 0

        # Set default options
        self._config_parser.readfp(StringIO(self.DEFAULT_CONFIG))   # pylint: disable=W1505; py2

        config_path = os.path.join(dir_path, file_name)
        if os.path.exists(config_path):
            self._config_parser.read(config_path)

        file_path = os.path.join(dir_path, REPO_CONTAINER_CONFIG)
        if os.path.exists(file_path):
            with open(file_path) as f:
                try:
                    self.container = yaml.load(f) or {}
                except yaml.scanner.ScannerError as e:
                    msg = ('Failed to parse YAML file ""{file}"": {reason}'
                           .format(file=REPO_CONTAINER_CONFIG, reason=e))
                    raise OsbsException(msg)

        # container values may be set to None
        container_compose = self.container.get('compose') or {}
        modules = container_compose.get('modules') or []

        self.container_module_specs = []
        value_errors = []
        for module in modules:
            try:
                self.container_module_specs.append(ModuleSpec.from_str(module))
            except ValueError as e:
                value_errors.append(e)
        if value_errors:
            raise ValueError(value_errors)

    def is_autorebuild_enabled(self):
        return self._config_parser.getboolean('autorebuild', 'enabled')


class ModuleSpec(object):
    """"""
    Specification for a to-be-requested module.

    This module representation is simplified from the possible
    NAME:STREAM:VERSION:CONTEXT:ARCH/PROFILE by not supporting ARCH, which
    should be determined by the architecture of the build, and by not
    supporting partal specifications such as NAME:::CONTEXT.
    """"""

    def __init__(self, name, stream, version=None, context=None, profile=None):
        self.name = name
        self.stream = stream
        self.version = version
        self.context = context
        self.profile = profile

    def to_str(self, include_profile=True):
        result = self.name + ':' + self.stream
        if self.version:
            result += ':' + self.version
        if self.context:
            result += ':' + self.context
        if include_profile and self.profile:
            result += '/' + self.profile

        return result

    def __repr__(self):
        return ""ModuleSpec({})"".format(self.to_str())

    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    __hash__ = None     # py2 compatibility

    @classmethod
    def from_str(cls, text):
        profile = None
        if '/' in text:
            module, profile = text.rsplit('/', 1)
        else:
            module = text

        pieces = module.split(':')
        if not 1 < len(pieces) < 5:
            raise ValueError('Module specification {} should be in '
                             'NAME:STREAM[:VERSION[:CONTEXT]][/PROFILE] format'.format(module))
        if not all(pieces) or profile == '':
            raise ValueError('Module specification {} contains empty fields'.format(module))
        return cls(*pieces, profile=profile)


class AdditionalTagsConfig(object):
    """"""
    Container for additional image tags.
    Tags are passed to constructor or are read from repository.
    """"""

    VALID_TAG_REGEX = re.compile(r'^[\w.]{0,127}$')

    def __init__(self, dir_path='', file_name=ADDITIONAL_TAGS_FILE, tags=None):
        tags = tags or set()
        self._tags = set([x for x in tags if self._is_tag_valid(x)])
        self._from_container_yaml = True if tags else False
        self._file_path = os.path.join(dir_path, file_name)

        self._populate_tags()

    def _populate_tags(self):
        if self._from_container_yaml:
            logger.warning('Tags were read from container.yaml file. Additional tags'
                           ' are being ignored!')
            return

        if not os.path.exists(self._file_path):
            return

        with open(self._file_path) as f:
            for tag in f:
                tag = tag.strip()
                if not self._is_tag_valid(tag):
                    continue
                self._tags.add(tag)

    def _is_tag_valid(self, tag):
        if not tag:
            return False

        if not self.VALID_TAG_REGEX.match(tag):
            logger.warning('Invalid additional tag ""%s"", must match pattern %s',
                           tag, self.VALID_TAG_REGEX.pattern)
            return False

        return True

    @property
    def tags(self):
        return list(self._tags)

    @property
    def from_container_yaml(self):
        return self._from_container_yaml
",0
CVE-2019-10135,osbs/repo_utils.py,"""""""
Copyright (c) 2017 Red Hat, Inc
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the LICENSE file for details.
""""""


from __future__ import absolute_import

from osbs.exceptions import OsbsException
from osbs.constants import REPO_CONFIG_FILE, ADDITIONAL_TAGS_FILE, REPO_CONTAINER_CONFIG
from six import StringIO
from six.moves.configparser import ConfigParser
from textwrap import dedent

import logging
import os
import re
import yaml


logger = logging.getLogger(__name__)


class RepoInfo(object):
    """"""
    Aggregator for different aspects of the repository.
    """"""

    def __init__(self, dockerfile_parser=None, configuration=None, additional_tags=None):
        self.dockerfile_parser = dockerfile_parser
        self.configuration = configuration or RepoConfiguration()
        self.additional_tags = additional_tags or AdditionalTagsConfig(
            tags=self.configuration.container.get('tags', set()))


class RepoConfiguration(object):
    """"""
    Read configuration from repository.
    """"""

    DEFAULT_CONFIG = dedent(""""""\
        [autorebuild]
        enabled = false
        """""")

    def __init__(self, dir_path='', file_name=REPO_CONFIG_FILE, depth=None):

        self._config_parser = ConfigParser()
        self.container = {}
        self.depth = depth or 0

        # Set default options
        self._config_parser.readfp(StringIO(self.DEFAULT_CONFIG))   # pylint: disable=W1505; py2

        config_path = os.path.join(dir_path, file_name)
        if os.path.exists(config_path):
            self._config_parser.read(config_path)

        file_path = os.path.join(dir_path, REPO_CONTAINER_CONFIG)
        if os.path.exists(file_path):
            with open(file_path) as f:
                try:
                    self.container = yaml.safe_load(f) or {}
                except yaml.scanner.ScannerError as e:
                    msg = ('Failed to parse YAML file ""{file}"": {reason}'
                           .format(file=REPO_CONTAINER_CONFIG, reason=e))
                    raise OsbsException(msg)

        # container values may be set to None
        container_compose = self.container.get('compose') or {}
        modules = container_compose.get('modules') or []

        self.container_module_specs = []
        value_errors = []
        for module in modules:
            try:
                self.container_module_specs.append(ModuleSpec.from_str(module))
            except ValueError as e:
                value_errors.append(e)
        if value_errors:
            raise ValueError(value_errors)

    def is_autorebuild_enabled(self):
        return self._config_parser.getboolean('autorebuild', 'enabled')


class ModuleSpec(object):
    """"""
    Specification for a to-be-requested module.

    This module representation is simplified from the possible
    NAME:STREAM:VERSION:CONTEXT:ARCH/PROFILE by not supporting ARCH, which
    should be determined by the architecture of the build, and by not
    supporting partal specifications such as NAME:::CONTEXT.
    """"""

    def __init__(self, name, stream, version=None, context=None, profile=None):
        self.name = name
        self.stream = stream
        self.version = version
        self.context = context
        self.profile = profile

    def to_str(self, include_profile=True):
        result = self.name + ':' + self.stream
        if self.version:
            result += ':' + self.version
        if self.context:
            result += ':' + self.context
        if include_profile and self.profile:
            result += '/' + self.profile

        return result

    def __repr__(self):
        return ""ModuleSpec({})"".format(self.to_str())

    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    __hash__ = None     # py2 compatibility

    @classmethod
    def from_str(cls, text):
        profile = None
        if '/' in text:
            module, profile = text.rsplit('/', 1)
        else:
            module = text

        pieces = module.split(':')
        if not 1 < len(pieces) < 5:
            raise ValueError('Module specification {} should be in '
                             'NAME:STREAM[:VERSION[:CONTEXT]][/PROFILE] format'.format(module))
        if not all(pieces) or profile == '':
            raise ValueError('Module specification {} contains empty fields'.format(module))
        return cls(*pieces, profile=profile)


class AdditionalTagsConfig(object):
    """"""
    Container for additional image tags.
    Tags are passed to constructor or are read from repository.
    """"""

    VALID_TAG_REGEX = re.compile(r'^[\w.]{0,127}$')

    def __init__(self, dir_path='', file_name=ADDITIONAL_TAGS_FILE, tags=None):
        tags = tags or set()
        self._tags = set([x for x in tags if self._is_tag_valid(x)])
        self._from_container_yaml = True if tags else False
        self._file_path = os.path.join(dir_path, file_name)

        self._populate_tags()

    def _populate_tags(self):
        if self._from_container_yaml:
            logger.warning('Tags were read from container.yaml file. Additional tags'
                           ' are being ignored!')
            return

        if not os.path.exists(self._file_path):
            return

        with open(self._file_path) as f:
            for tag in f:
                tag = tag.strip()
                if not self._is_tag_valid(tag):
                    continue
                self._tags.add(tag)

    def _is_tag_valid(self, tag):
        if not tag:
            return False

        if not self.VALID_TAG_REGEX.match(tag):
            logger.warning('Invalid additional tag ""%s"", must match pattern %s',
                           tag, self.VALID_TAG_REGEX.pattern)
            return False

        return True

    @property
    def tags(self):
        return list(self._tags)

    @property
    def from_container_yaml(self):
        return self._from_container_yaml
",1
CVE-2016-1000338,core/src/main/java/org/bouncycastle/asn1/ASN1Enumerated.java,"package org.bouncycastle.asn1;

import java.io.IOException;
import java.math.BigInteger;

import org.bouncycastle.util.Arrays;

/**
 * Class representing the ASN.1 ENUMERATED type.
 */
public class ASN1Enumerated
    extends ASN1Primitive
{
    private final byte[] bytes;

    /**
     * return an enumerated from the passed in object
     *
     * @param obj an ASN1Enumerated or an object that can be converted into one.
     * @exception IllegalArgumentException if the object cannot be converted.
     * @return an ASN1Enumerated instance, or null.
     */
    public static ASN1Enumerated getInstance(
        Object  obj)
    {
        if (obj == null || obj instanceof ASN1Enumerated)
        {
            return (ASN1Enumerated)obj;
        }

        if (obj instanceof byte[])
        {
            try
            {
                return (ASN1Enumerated)fromByteArray((byte[])obj);
            }
            catch (Exception e)
            {
                throw new IllegalArgumentException(""encoding error in getInstance: "" + e.toString());
            }
        }

        throw new IllegalArgumentException(""illegal object in getInstance: "" + obj.getClass().getName());
    }

    /**
     * return an Enumerated from a tagged object.
     *
     * @param obj the tagged object holding the object we want
     * @param explicit true if the object is meant to be explicitly
     *              tagged false otherwise.
     * @exception IllegalArgumentException if the tagged object cannot
     *               be converted.
     * @return an ASN1Enumerated instance, or null.
     */
    public static ASN1Enumerated getInstance(
        ASN1TaggedObject obj,
        boolean          explicit)
    {
        ASN1Primitive o = obj.getObject();

        if (explicit || o instanceof ASN1Enumerated)
        {
            return getInstance(o);
        }
        else
        {
            return fromOctetString(((ASN1OctetString)o).getOctets());
        }
    }

    /**
     * Constructor from int.
     *
     * @param value the value of this enumerated.
     */
    public ASN1Enumerated(
        int         value)
    {
        bytes = BigInteger.valueOf(value).toByteArray();
    }

    /**
     * Constructor from BigInteger
     *
     * @param value the value of this enumerated.
     */
    public ASN1Enumerated(
        BigInteger   value)
    {
        bytes = value.toByteArray();
    }

    /**
     * Constructor from encoded BigInteger.
     *
     * @param bytes the value of this enumerated as an encoded BigInteger (signed).
     */
    public ASN1Enumerated(
        byte[]   bytes)
    {
        this.bytes = Arrays.clone(bytes);
    }

    public BigInteger getValue()
    {
        return new BigInteger(bytes);
    }

    boolean isConstructed()
    {
        return false;
    }

    int encodedLength()
    {
        return 1 + StreamUtil.calculateBodyLength(bytes.length) + bytes.length;
    }

    void encode(
        ASN1OutputStream out)
        throws IOException
    {
        out.writeEncoded(BERTags.ENUMERATED, bytes);
    }
    
    boolean asn1Equals(
        ASN1Primitive  o)
    {
        if (!(o instanceof ASN1Enumerated))
        {
            return false;
        }

        ASN1Enumerated other = (ASN1Enumerated)o;

        return Arrays.areEqual(this.bytes, other.bytes);
    }

    public int hashCode()
    {
        return Arrays.hashCode(bytes);
    }

    private static ASN1Enumerated[] cache = new ASN1Enumerated[12];

    static ASN1Enumerated fromOctetString(byte[] enc)
    {
        if (enc.length > 1)
        {
            return new ASN1Enumerated(enc);
        }

        if (enc.length == 0)
        {
            throw new IllegalArgumentException(""ENUMERATED has zero length"");
        }
        int value = enc[0] & 0xff;

        if (value >= cache.length)
        {
            return new ASN1Enumerated(Arrays.clone(enc));
        }

        ASN1Enumerated possibleMatch = cache[value];

        if (possibleMatch == null)
        {
            possibleMatch = cache[value] = new ASN1Enumerated(Arrays.clone(enc));
        }

        return possibleMatch;
    }
}
",0
CVE-2016-1000338,core/src/main/java/org/bouncycastle/asn1/ASN1Enumerated.java,"package org.bouncycastle.asn1;

import java.io.IOException;
import java.math.BigInteger;

import org.bouncycastle.util.Arrays;

/**
 * Class representing the ASN.1 ENUMERATED type.
 */
public class ASN1Enumerated
    extends ASN1Primitive
{
    private final byte[] bytes;

    /**
     * return an enumerated from the passed in object
     *
     * @param obj an ASN1Enumerated or an object that can be converted into one.
     * @exception IllegalArgumentException if the object cannot be converted.
     * @return an ASN1Enumerated instance, or null.
     */
    public static ASN1Enumerated getInstance(
        Object  obj)
    {
        if (obj == null || obj instanceof ASN1Enumerated)
        {
            return (ASN1Enumerated)obj;
        }

        if (obj instanceof byte[])
        {
            try
            {
                return (ASN1Enumerated)fromByteArray((byte[])obj);
            }
            catch (Exception e)
            {
                throw new IllegalArgumentException(""encoding error in getInstance: "" + e.toString());
            }
        }

        throw new IllegalArgumentException(""illegal object in getInstance: "" + obj.getClass().getName());
    }

    /**
     * return an Enumerated from a tagged object.
     *
     * @param obj the tagged object holding the object we want
     * @param explicit true if the object is meant to be explicitly
     *              tagged false otherwise.
     * @exception IllegalArgumentException if the tagged object cannot
     *               be converted.
     * @return an ASN1Enumerated instance, or null.
     */
    public static ASN1Enumerated getInstance(
        ASN1TaggedObject obj,
        boolean          explicit)
    {
        ASN1Primitive o = obj.getObject();

        if (explicit || o instanceof ASN1Enumerated)
        {
            return getInstance(o);
        }
        else
        {
            return fromOctetString(((ASN1OctetString)o).getOctets());
        }
    }

    /**
     * Constructor from int.
     *
     * @param value the value of this enumerated.
     */
    public ASN1Enumerated(
        int         value)
    {
        bytes = BigInteger.valueOf(value).toByteArray();
    }

    /**
     * Constructor from BigInteger
     *
     * @param value the value of this enumerated.
     */
    public ASN1Enumerated(
        BigInteger   value)
    {
        bytes = value.toByteArray();
    }

    /**
     * Constructor from encoded BigInteger.
     *
     * @param bytes the value of this enumerated as an encoded BigInteger (signed).
     */
    public ASN1Enumerated(
        byte[]   bytes)
    {
        if (bytes.length > 1)
        {
            if (bytes[0] == 0 && (bytes[1] & 0x80) == 0)
            {
                throw new IllegalArgumentException(""malformed enumerated"");
            }
            if (bytes[0] == (byte)0xff && (bytes[1] & 0x80) != 0)
            {
                throw new IllegalArgumentException(""malformed enumerated"");
            }
        }
        this.bytes = Arrays.clone(bytes);
    }

    public BigInteger getValue()
    {
        return new BigInteger(bytes);
    }

    boolean isConstructed()
    {
        return false;
    }

    int encodedLength()
    {
        return 1 + StreamUtil.calculateBodyLength(bytes.length) + bytes.length;
    }

    void encode(
        ASN1OutputStream out)
        throws IOException
    {
        out.writeEncoded(BERTags.ENUMERATED, bytes);
    }
    
    boolean asn1Equals(
        ASN1Primitive  o)
    {
        if (!(o instanceof ASN1Enumerated))
        {
            return false;
        }

        ASN1Enumerated other = (ASN1Enumerated)o;

        return Arrays.areEqual(this.bytes, other.bytes);
    }

    public int hashCode()
    {
        return Arrays.hashCode(bytes);
    }

    private static ASN1Enumerated[] cache = new ASN1Enumerated[12];

    static ASN1Enumerated fromOctetString(byte[] enc)
    {
        if (enc.length > 1)
        {
            return new ASN1Enumerated(enc);
        }

        if (enc.length == 0)
        {
            throw new IllegalArgumentException(""ENUMERATED has zero length"");
        }
        int value = enc[0] & 0xff;

        if (value >= cache.length)
        {
            return new ASN1Enumerated(Arrays.clone(enc));
        }

        ASN1Enumerated possibleMatch = cache[value];

        if (possibleMatch == null)
        {
            possibleMatch = cache[value] = new ASN1Enumerated(Arrays.clone(enc));
        }

        return possibleMatch;
    }
}
",1
CVE-2016-1000338,core/src/main/java/org/bouncycastle/asn1/ASN1Integer.java,"package org.bouncycastle.asn1;

import java.io.IOException;
import java.math.BigInteger;

import org.bouncycastle.util.Arrays;

/**
 * Class representing the ASN.1 INTEGER type.
 */
public class ASN1Integer
    extends ASN1Primitive
{
    private final byte[] bytes;

    /**
     * return an integer from the passed in object
     *
     * @param obj an ASN1Integer or an object that can be converted into one.
     * @throws IllegalArgumentException if the object cannot be converted.
     * @return an ASN1Integer instance.
     */
    public static ASN1Integer getInstance(
        Object obj)
    {
        if (obj == null || obj instanceof ASN1Integer)
        {
            return (ASN1Integer)obj;
        }

        if (obj instanceof byte[])
        {
            try
            {
                return (ASN1Integer)fromByteArray((byte[])obj);
            }
            catch (Exception e)
            {
                throw new IllegalArgumentException(""encoding error in getInstance: "" + e.toString());
            }
        }

        throw new IllegalArgumentException(""illegal object in getInstance: "" + obj.getClass().getName());
    }

    /**
     * return an Integer from a tagged object.
     *
     * @param obj      the tagged object holding the object we want
     * @param explicit true if the object is meant to be explicitly
     *                 tagged false otherwise.
     * @throws IllegalArgumentException if the tagged object cannot
     * be converted.
     * @return an ASN1Integer instance.
     */
    public static ASN1Integer getInstance(
        ASN1TaggedObject obj,
        boolean explicit)
    {
        ASN1Primitive o = obj.getObject();

        if (explicit || o instanceof ASN1Integer)
        {
            return getInstance(o);
        }
        else
        {
            return new ASN1Integer(ASN1OctetString.getInstance(obj.getObject()).getOctets());
        }
    }

    public ASN1Integer(
        long value)
    {
        bytes = BigInteger.valueOf(value).toByteArray();
    }

    public ASN1Integer(
        BigInteger value)
    {
        bytes = value.toByteArray();
    }

    public ASN1Integer(
        byte[] bytes)
    {
        this(bytes, true);
    }

    ASN1Integer(byte[] bytes, boolean clone)
    {
        this.bytes = (clone) ? Arrays.clone(bytes) : bytes;
    }

    public BigInteger getValue()
    {
        return new BigInteger(bytes);
    }

    /**
     * in some cases positive values get crammed into a space,
     * that's not quite big enough...
     * @return the BigInteger that results from treating this ASN.1 INTEGER as unsigned.
     */
    public BigInteger getPositiveValue()
    {
        return new BigInteger(1, bytes);
    }

    boolean isConstructed()
    {
        return false;
    }

    int encodedLength()
    {
        return 1 + StreamUtil.calculateBodyLength(bytes.length) + bytes.length;
    }

    void encode(
        ASN1OutputStream out)
        throws IOException
    {
        out.writeEncoded(BERTags.INTEGER, bytes);
    }

    public int hashCode()
    {
        int value = 0;

        for (int i = 0; i != bytes.length; i++)
        {
            value ^= (bytes[i] & 0xff) << (i % 4);
        }

        return value;
    }

    boolean asn1Equals(
        ASN1Primitive o)
    {
        if (!(o instanceof ASN1Integer))
        {
            return false;
        }

        ASN1Integer other = (ASN1Integer)o;

        return Arrays.areEqual(bytes, other.bytes);
    }

    public String toString()
    {
        return getValue().toString();
    }

}
",0
CVE-2016-1000338,core/src/main/java/org/bouncycastle/asn1/ASN1Integer.java,"package org.bouncycastle.asn1;

import java.io.IOException;
import java.math.BigInteger;

import org.bouncycastle.util.Arrays;

/**
 * Class representing the ASN.1 INTEGER type.
 */
public class ASN1Integer
    extends ASN1Primitive
{
    private final byte[] bytes;

    /**
     * return an integer from the passed in object
     *
     * @param obj an ASN1Integer or an object that can be converted into one.
     * @throws IllegalArgumentException if the object cannot be converted.
     * @return an ASN1Integer instance.
     */
    public static ASN1Integer getInstance(
        Object obj)
    {
        if (obj == null || obj instanceof ASN1Integer)
        {
            return (ASN1Integer)obj;
        }

        if (obj instanceof byte[])
        {
            try
            {
                return (ASN1Integer)fromByteArray((byte[])obj);
            }
            catch (Exception e)
            {
                throw new IllegalArgumentException(""encoding error in getInstance: "" + e.toString());
            }
        }

        throw new IllegalArgumentException(""illegal object in getInstance: "" + obj.getClass().getName());
    }

    /**
     * return an Integer from a tagged object.
     *
     * @param obj      the tagged object holding the object we want
     * @param explicit true if the object is meant to be explicitly
     *                 tagged false otherwise.
     * @throws IllegalArgumentException if the tagged object cannot
     * be converted.
     * @return an ASN1Integer instance.
     */
    public static ASN1Integer getInstance(
        ASN1TaggedObject obj,
        boolean explicit)
    {
        ASN1Primitive o = obj.getObject();

        if (explicit || o instanceof ASN1Integer)
        {
            return getInstance(o);
        }
        else
        {
            return new ASN1Integer(ASN1OctetString.getInstance(obj.getObject()).getOctets());
        }
    }

    public ASN1Integer(
        long value)
    {
        bytes = BigInteger.valueOf(value).toByteArray();
    }

    public ASN1Integer(
        BigInteger value)
    {
        bytes = value.toByteArray();
    }

    public ASN1Integer(
        byte[] bytes)
    {
        this(bytes, true);
    }

    ASN1Integer(byte[] bytes, boolean clone)
    {
        if (bytes.length > 1)
        {
            if (bytes[0] == 0 && (bytes[1] & 0x80) == 0)
            {
                throw new IllegalArgumentException(""malformed integer"");
            }
            if (bytes[0] == (byte)0xff && (bytes[1] & 0x80) != 0)
            {
                throw new IllegalArgumentException(""malformed integer"");
            }
        }
        this.bytes = (clone) ? Arrays.clone(bytes) : bytes;
    }

    public BigInteger getValue()
    {
        return new BigInteger(bytes);
    }

    /**
     * in some cases positive values get crammed into a space,
     * that's not quite big enough...
     * @return the BigInteger that results from treating this ASN.1 INTEGER as unsigned.
     */
    public BigInteger getPositiveValue()
    {
        return new BigInteger(1, bytes);
    }

    boolean isConstructed()
    {
        return false;
    }

    int encodedLength()
    {
        return 1 + StreamUtil.calculateBodyLength(bytes.length) + bytes.length;
    }

    void encode(
        ASN1OutputStream out)
        throws IOException
    {
        out.writeEncoded(BERTags.INTEGER, bytes);
    }

    public int hashCode()
    {
        int value = 0;

        for (int i = 0; i != bytes.length; i++)
        {
            value ^= (bytes[i] & 0xff) << (i % 4);
        }

        return value;
    }

    boolean asn1Equals(
        ASN1Primitive o)
    {
        if (!(o instanceof ASN1Integer))
        {
            return false;
        }

        ASN1Integer other = (ASN1Integer)o;

        return Arrays.areEqual(bytes, other.bytes);
    }

    public String toString()
    {
        return getValue().toString();
    }

}
",1
CVE-2016-1000338,core/src/test/java/org/bouncycastle/asn1/test/MiscTest.java,"package org.bouncycastle.asn1.test;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1OutputStream;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.BERSequence;
import org.bouncycastle.asn1.DERBitString;
import org.bouncycastle.asn1.DERIA5String;
import org.bouncycastle.asn1.misc.CAST5CBCParameters;
import org.bouncycastle.asn1.misc.IDEACBCPar;
import org.bouncycastle.asn1.misc.NetscapeCertType;
import org.bouncycastle.asn1.misc.NetscapeRevocationURL;
import org.bouncycastle.asn1.misc.VerisignCzagExtension;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.encoders.Base64;
import org.bouncycastle.util.test.SimpleTest;

public class MiscTest
    extends SimpleTest
{
    private boolean isSameAs(
        byte[]  a,
        byte[]  b)
    {
        if (a.length != b.length)
        {
            return false;
        }
        
        for (int i = 0; i != a.length; i++)
        {
            if (a[i] != b[i])
            {
                return false;
            }
        }
        
        return true;
    }

    public void shouldFailOnExtraData()
        throws Exception
    {
        // basic construction
        DERBitString s1 = new DERBitString(new byte[0], 0);

        ASN1Primitive.fromByteArray(s1.getEncoded());

        ASN1Primitive.fromByteArray(new BERSequence(s1).getEncoded());

        try
        {
            ASN1Primitive obj = ASN1Primitive.fromByteArray(Arrays.concatenate(s1.getEncoded(), new byte[1]));
            fail(""no exception"");
        }
        catch (IOException e)
        {
            if (!""Extra data detected in stream"".equals(e.getMessage()))
            {
                fail(""wrong exception"");
            }
        }
    }

    public void performTest()
        throws Exception
    {
        byte[]  testIv = { 1, 2, 3, 4, 5, 6, 7, 8 };
        
        ASN1Encodable[]     values = {
            new CAST5CBCParameters(testIv, 128), 
            new NetscapeCertType(NetscapeCertType.smime),    
            new VerisignCzagExtension(new DERIA5String(""hello"")),
            new IDEACBCPar(testIv),        
            new NetscapeRevocationURL(new DERIA5String(""http://test""))
        };
        
        byte[] data = Base64.decode(""MA4ECAECAwQFBgcIAgIAgAMCBSAWBWhlbGxvMAoECAECAwQFBgcIFgtodHRwOi8vdGVzdA=="");

        ByteArrayOutputStream bOut = new ByteArrayOutputStream();
        ASN1OutputStream aOut = new ASN1OutputStream(bOut);

        for (int i = 0; i != values.length; i++)
        {
            aOut.writeObject(values[i]);
        }

        ASN1Primitive[] readValues = new ASN1Primitive[values.length];

        if (!isSameAs(bOut.toByteArray(), data))
        {
            fail(""Failed data check"");
        }

        ByteArrayInputStream bIn = new ByteArrayInputStream(bOut.toByteArray());
        ASN1InputStream aIn = new ASN1InputStream(bIn);

        for (int i = 0; i != values.length; i++)
        {
            ASN1Primitive o = aIn.readObject();
            if (!values[i].equals(o))
            {
                fail(""Failed equality test for "" + o);
            }

            if (o.hashCode() != values[i].hashCode())
            {
                fail(""Failed hashCode test for "" + o);
            }
        }

        shouldFailOnExtraData();
    }

    public String getName()
    {
        return ""Misc"";
    }

    public static void main(
        String[] args)
    {
        runTest(new MiscTest());
    }
}
",0
CVE-2016-1000338,core/src/test/java/org/bouncycastle/asn1/test/MiscTest.java,"package org.bouncycastle.asn1.test;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Enumerated;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1OutputStream;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.BERSequence;
import org.bouncycastle.asn1.DERBitString;
import org.bouncycastle.asn1.DERIA5String;
import org.bouncycastle.asn1.misc.CAST5CBCParameters;
import org.bouncycastle.asn1.misc.IDEACBCPar;
import org.bouncycastle.asn1.misc.NetscapeCertType;
import org.bouncycastle.asn1.misc.NetscapeRevocationURL;
import org.bouncycastle.asn1.misc.VerisignCzagExtension;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.encoders.Base64;
import org.bouncycastle.util.test.SimpleTest;

public class MiscTest
    extends SimpleTest
{
    private boolean isSameAs(
        byte[]  a,
        byte[]  b)
    {
        if (a.length != b.length)
        {
            return false;
        }
        
        for (int i = 0; i != a.length; i++)
        {
            if (a[i] != b[i])
            {
                return false;
            }
        }
        
        return true;
    }

    public void shouldFailOnExtraData()
        throws Exception
    {
        // basic construction
        DERBitString s1 = new DERBitString(new byte[0], 0);

        ASN1Primitive.fromByteArray(s1.getEncoded());

        ASN1Primitive.fromByteArray(new BERSequence(s1).getEncoded());

        try
        {
            ASN1Primitive obj = ASN1Primitive.fromByteArray(Arrays.concatenate(s1.getEncoded(), new byte[1]));
            fail(""no exception"");
        }
        catch (IOException e)
        {
            if (!""Extra data detected in stream"".equals(e.getMessage()))
            {
                fail(""wrong exception"");
            }
        }
    }

    public void derIntegerTest()
        throws Exception
    {
        try
        {
            new ASN1Integer(new byte[] { 0, 0, 0, 1});
        }
        catch (IllegalArgumentException e)
        {
            isTrue(""wrong exc"", ""malformed integer"".equals(e.getMessage()));
        }

        try
        {
            new ASN1Integer(new byte[] {(byte)0xff, (byte)0x80, 0, 1});
        }
        catch (IllegalArgumentException e)
        {
            isTrue(""wrong exc"", ""malformed integer"".equals(e.getMessage()));
        }

        try
        {
            new ASN1Enumerated(new byte[] { 0, 0, 0, 1});
        }
        catch (IllegalArgumentException e)
        {
            isTrue(""wrong exc"", ""malformed enumerated"".equals(e.getMessage()));
        }

        try
        {
            new ASN1Enumerated(new byte[] {(byte)0xff, (byte)0x80, 0, 1});
        }
        catch (IllegalArgumentException e)
        {
            isTrue(""wrong exc"", ""malformed enumerated"".equals(e.getMessage()));
        }
    }

    public void performTest()
        throws Exception
    {
        byte[]  testIv = { 1, 2, 3, 4, 5, 6, 7, 8 };
        
        ASN1Encodable[]     values = {
            new CAST5CBCParameters(testIv, 128), 
            new NetscapeCertType(NetscapeCertType.smime),    
            new VerisignCzagExtension(new DERIA5String(""hello"")),
            new IDEACBCPar(testIv),        
            new NetscapeRevocationURL(new DERIA5String(""http://test""))
        };
        
        byte[] data = Base64.decode(""MA4ECAECAwQFBgcIAgIAgAMCBSAWBWhlbGxvMAoECAECAwQFBgcIFgtodHRwOi8vdGVzdA=="");

        ByteArrayOutputStream bOut = new ByteArrayOutputStream();
        ASN1OutputStream aOut = new ASN1OutputStream(bOut);

        for (int i = 0; i != values.length; i++)
        {
            aOut.writeObject(values[i]);
        }

        ASN1Primitive[] readValues = new ASN1Primitive[values.length];

        if (!isSameAs(bOut.toByteArray(), data))
        {
            fail(""Failed data check"");
        }

        ByteArrayInputStream bIn = new ByteArrayInputStream(bOut.toByteArray());
        ASN1InputStream aIn = new ASN1InputStream(bIn);

        for (int i = 0; i != values.length; i++)
        {
            ASN1Primitive o = aIn.readObject();
            if (!values[i].equals(o))
            {
                fail(""Failed equality test for "" + o);
            }

            if (o.hashCode() != values[i].hashCode())
            {
                fail(""Failed hashCode test for "" + o);
            }
        }

        shouldFailOnExtraData();
        derIntegerTest();
    }

    public String getName()
    {
        return ""Misc"";
    }

    public static void main(
        String[] args)
    {
        runTest(new MiscTest());
    }
}
",1
CVE-2016-1000338,prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/dsa/DSASigner.java,"package org.bouncycastle.jcajce.provider.asymmetric.dsa;

import java.io.IOException;
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.SignatureException;
import java.security.SignatureSpi;
import java.security.spec.AlgorithmParameterSpec;

import org.bouncycastle.asn1.ASN1Encoding;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
import org.bouncycastle.asn1.x509.X509ObjectIdentifiers;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DSA;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.digests.NullDigest;
import org.bouncycastle.crypto.digests.SHA1Digest;
import org.bouncycastle.crypto.digests.SHA224Digest;
import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.crypto.digests.SHA384Digest;
import org.bouncycastle.crypto.digests.SHA3Digest;
import org.bouncycastle.crypto.digests.SHA512Digest;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.crypto.signers.HMacDSAKCalculator;

public class DSASigner
    extends SignatureSpi
    implements PKCSObjectIdentifiers, X509ObjectIdentifiers
{
    private Digest                  digest;
    private DSA                     signer;
    private SecureRandom            random;

    protected DSASigner(
        Digest digest,
        DSA signer)
    {
        this.digest = digest;
        this.signer = signer;
    }

    protected void engineInitVerify(
        PublicKey   publicKey)
        throws InvalidKeyException
    {
        CipherParameters    param = DSAUtil.generatePublicKeyParameter(publicKey);

        digest.reset();
        signer.init(false, param);
    }

    protected void engineInitSign(
        PrivateKey      privateKey,
        SecureRandom    random)
        throws InvalidKeyException
    {
        this.random = random;
        engineInitSign(privateKey);
    }

    protected void engineInitSign(
        PrivateKey  privateKey)
        throws InvalidKeyException
    {
        CipherParameters    param = DSAUtil.generatePrivateKeyParameter(privateKey);

        if (random != null)
        {
            param = new ParametersWithRandom(param, random);
        }

        digest.reset();
        signer.init(true, param);
    }

    protected void engineUpdate(
        byte    b)
        throws SignatureException
    {
        digest.update(b);
    }

    protected void engineUpdate(
        byte[]  b,
        int     off,
        int     len) 
        throws SignatureException
    {
        digest.update(b, off, len);
    }

    protected byte[] engineSign()
        throws SignatureException
    {
        byte[]  hash = new byte[digest.getDigestSize()];

        digest.doFinal(hash, 0);

        try
        {
            BigInteger[]    sig = signer.generateSignature(hash);

            return derEncode(sig[0], sig[1]);
        }
        catch (Exception e)
        {
            throw new SignatureException(e.toString());
        }
    }

    protected boolean engineVerify(
        byte[]  sigBytes) 
        throws SignatureException
    {
        byte[]  hash = new byte[digest.getDigestSize()];

        digest.doFinal(hash, 0);

        BigInteger[]    sig;

        try
        {
            sig = derDecode(sigBytes);
        }
        catch (Exception e)
        {
            throw new SignatureException(""error decoding signature bytes."");
        }

        return signer.verifySignature(hash, sig[0], sig[1]);
    }

    protected void engineSetParameter(
        AlgorithmParameterSpec params)
    {
        throw new UnsupportedOperationException(""engineSetParameter unsupported"");
    }

    /**
     * @deprecated replaced with <a href = ""#engineSetParameter(java.security.spec.AlgorithmParameterSpec)"">
     */
    protected void engineSetParameter(
        String  param,
        Object  value)
    {
        throw new UnsupportedOperationException(""engineSetParameter unsupported"");
    }

    /**
     * @deprecated
     */
    protected Object engineGetParameter(
        String      param)
    {
        throw new UnsupportedOperationException(""engineSetParameter unsupported"");
    }

    private byte[] derEncode(
        BigInteger  r,
        BigInteger  s)
        throws IOException
    {
        ASN1Integer[] rs = new ASN1Integer[]{ new ASN1Integer(r), new ASN1Integer(s) };
        return new DERSequence(rs).getEncoded(ASN1Encoding.DER);
    }

    private BigInteger[] derDecode(
        byte[]  encoding)
        throws IOException
    {
        ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);
        if (s.size() != 2)
        {
            throw new IOException(""malformed signature"");
        }

        return new BigInteger[]{
            ((ASN1Integer)s.getObjectAt(0)).getValue(),
            ((ASN1Integer)s.getObjectAt(1)).getValue()
        };
    }

    static public class stdDSA
        extends DSASigner
    {
        public stdDSA()
        {
            super(new SHA1Digest(), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSA
        extends DSASigner
    {
        public detDSA()
        {
            super(new SHA1Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA1Digest())));
        }
    }

    static public class dsa224
        extends DSASigner
    {
        public dsa224()
        {
            super(new SHA224Digest(), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSA224
        extends DSASigner
    {
        public detDSA224()
        {
            super(new SHA224Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA224Digest())));
        }
    }

    static public class dsa256
        extends DSASigner
    {
        public dsa256()
        {
            super(new SHA256Digest(), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSA256
        extends DSASigner
    {
        public detDSA256()
        {
            super(new SHA256Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA256Digest())));
        }
    }

    static public class dsa384
        extends DSASigner
    {
        public dsa384()
        {
            super(new SHA384Digest(), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSA384
        extends DSASigner
    {
        public detDSA384()
        {
            super(new SHA384Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA384Digest())));
        }
    }

    static public class dsa512
        extends DSASigner
    {
        public dsa512()
        {
            super(new SHA512Digest(), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSA512
        extends DSASigner
    {
        public detDSA512()
        {
            super(new SHA512Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA512Digest())));
        }
    }

    static public class dsaSha3_224
        extends DSASigner
    {
        public dsaSha3_224()
        {
            super(new SHA3Digest(224), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSASha3_224
        extends DSASigner
    {
        public detDSASha3_224()
        {
            super(new SHA3Digest(224), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(224))));
        }
    }

    static public class dsaSha3_256
        extends DSASigner
    {
        public dsaSha3_256()
        {
            super(new SHA3Digest(256), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSASha3_256
        extends DSASigner
    {
        public detDSASha3_256()
        {
            super(new SHA3Digest(256), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(256))));
        }
    }

    static public class dsaSha3_384
        extends DSASigner
    {
        public dsaSha3_384()
        {
            super(new SHA3Digest(384), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSASha3_384
        extends DSASigner
    {
        public detDSASha3_384()
        {
            super(new SHA3Digest(384), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(384))));
        }
    }

    static public class dsaSha3_512
        extends DSASigner
    {
        public dsaSha3_512()
        {
            super(new SHA3Digest(512), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSASha3_512
        extends DSASigner
    {
        public detDSASha3_512()
        {
            super(new SHA3Digest(512), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(512))));
        }
    }

    static public class noneDSA
        extends DSASigner
    {
        public noneDSA()
        {
            super(new NullDigest(), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }
}
",0
CVE-2016-1000338,prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/dsa/DSASigner.java,"package org.bouncycastle.jcajce.provider.asymmetric.dsa;

import java.io.IOException;
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.SignatureException;
import java.security.SignatureSpi;
import java.security.spec.AlgorithmParameterSpec;

import org.bouncycastle.asn1.ASN1Encoding;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
import org.bouncycastle.asn1.x509.X509ObjectIdentifiers;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DSA;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.digests.NullDigest;
import org.bouncycastle.crypto.digests.SHA1Digest;
import org.bouncycastle.crypto.digests.SHA224Digest;
import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.crypto.digests.SHA384Digest;
import org.bouncycastle.crypto.digests.SHA3Digest;
import org.bouncycastle.crypto.digests.SHA512Digest;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.crypto.signers.HMacDSAKCalculator;
import org.bouncycastle.util.Arrays;

public class DSASigner
    extends SignatureSpi
    implements PKCSObjectIdentifiers, X509ObjectIdentifiers
{
    private Digest                  digest;
    private DSA                     signer;
    private SecureRandom            random;

    protected DSASigner(
        Digest digest,
        DSA signer)
    {
        this.digest = digest;
        this.signer = signer;
    }

    protected void engineInitVerify(
        PublicKey   publicKey)
        throws InvalidKeyException
    {
        CipherParameters    param = DSAUtil.generatePublicKeyParameter(publicKey);

        digest.reset();
        signer.init(false, param);
    }

    protected void engineInitSign(
        PrivateKey      privateKey,
        SecureRandom    random)
        throws InvalidKeyException
    {
        this.random = random;
        engineInitSign(privateKey);
    }

    protected void engineInitSign(
        PrivateKey  privateKey)
        throws InvalidKeyException
    {
        CipherParameters    param = DSAUtil.generatePrivateKeyParameter(privateKey);

        if (random != null)
        {
            param = new ParametersWithRandom(param, random);
        }

        digest.reset();
        signer.init(true, param);
    }

    protected void engineUpdate(
        byte    b)
        throws SignatureException
    {
        digest.update(b);
    }

    protected void engineUpdate(
        byte[]  b,
        int     off,
        int     len) 
        throws SignatureException
    {
        digest.update(b, off, len);
    }

    protected byte[] engineSign()
        throws SignatureException
    {
        byte[]  hash = new byte[digest.getDigestSize()];

        digest.doFinal(hash, 0);

        try
        {
            BigInteger[]    sig = signer.generateSignature(hash);

            return derEncode(sig[0], sig[1]);
        }
        catch (Exception e)
        {
            throw new SignatureException(e.toString());
        }
    }

    protected boolean engineVerify(
        byte[]  sigBytes) 
        throws SignatureException
    {
        byte[]  hash = new byte[digest.getDigestSize()];

        digest.doFinal(hash, 0);

        BigInteger[]    sig;

        try
        {
            sig = derDecode(sigBytes);
        }
        catch (Exception e)
        {
            throw new SignatureException(""error decoding signature bytes."");
        }

        return signer.verifySignature(hash, sig[0], sig[1]);
    }

    protected void engineSetParameter(
        AlgorithmParameterSpec params)
    {
        throw new UnsupportedOperationException(""engineSetParameter unsupported"");
    }

    /**
     * @deprecated replaced with <a href = ""#engineSetParameter(java.security.spec.AlgorithmParameterSpec)"">
     */
    protected void engineSetParameter(
        String  param,
        Object  value)
    {
        throw new UnsupportedOperationException(""engineSetParameter unsupported"");
    }

    /**
     * @deprecated
     */
    protected Object engineGetParameter(
        String      param)
    {
        throw new UnsupportedOperationException(""engineSetParameter unsupported"");
    }

    private byte[] derEncode(
        BigInteger  r,
        BigInteger  s)
        throws IOException
    {
        ASN1Integer[] rs = new ASN1Integer[]{ new ASN1Integer(r), new ASN1Integer(s) };
        return new DERSequence(rs).getEncoded(ASN1Encoding.DER);
    }

    private BigInteger[] derDecode(
        byte[]  encoding)
        throws IOException
    {
        ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);
        if (s.size() != 2)
        {
            throw new IOException(""malformed signature"");
        }
        if (!Arrays.areEqual(encoding, s.getEncoded(ASN1Encoding.DER)))
        {
            throw new IOException(""malformed signature"");
        }

        return new BigInteger[]{
            ((ASN1Integer)s.getObjectAt(0)).getValue(),
            ((ASN1Integer)s.getObjectAt(1)).getValue()
        };
    }

    static public class stdDSA
        extends DSASigner
    {
        public stdDSA()
        {
            super(new SHA1Digest(), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSA
        extends DSASigner
    {
        public detDSA()
        {
            super(new SHA1Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA1Digest())));
        }
    }

    static public class dsa224
        extends DSASigner
    {
        public dsa224()
        {
            super(new SHA224Digest(), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSA224
        extends DSASigner
    {
        public detDSA224()
        {
            super(new SHA224Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA224Digest())));
        }
    }

    static public class dsa256
        extends DSASigner
    {
        public dsa256()
        {
            super(new SHA256Digest(), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSA256
        extends DSASigner
    {
        public detDSA256()
        {
            super(new SHA256Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA256Digest())));
        }
    }

    static public class dsa384
        extends DSASigner
    {
        public dsa384()
        {
            super(new SHA384Digest(), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSA384
        extends DSASigner
    {
        public detDSA384()
        {
            super(new SHA384Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA384Digest())));
        }
    }

    static public class dsa512
        extends DSASigner
    {
        public dsa512()
        {
            super(new SHA512Digest(), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSA512
        extends DSASigner
    {
        public detDSA512()
        {
            super(new SHA512Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA512Digest())));
        }
    }

    static public class dsaSha3_224
        extends DSASigner
    {
        public dsaSha3_224()
        {
            super(new SHA3Digest(224), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSASha3_224
        extends DSASigner
    {
        public detDSASha3_224()
        {
            super(new SHA3Digest(224), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(224))));
        }
    }

    static public class dsaSha3_256
        extends DSASigner
    {
        public dsaSha3_256()
        {
            super(new SHA3Digest(256), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSASha3_256
        extends DSASigner
    {
        public detDSASha3_256()
        {
            super(new SHA3Digest(256), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(256))));
        }
    }

    static public class dsaSha3_384
        extends DSASigner
    {
        public dsaSha3_384()
        {
            super(new SHA3Digest(384), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSASha3_384
        extends DSASigner
    {
        public detDSASha3_384()
        {
            super(new SHA3Digest(384), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(384))));
        }
    }

    static public class dsaSha3_512
        extends DSASigner
    {
        public dsaSha3_512()
        {
            super(new SHA3Digest(512), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }

    static public class detDSASha3_512
        extends DSASigner
    {
        public detDSASha3_512()
        {
            super(new SHA3Digest(512), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(512))));
        }
    }

    static public class noneDSA
        extends DSASigner
    {
        public noneDSA()
        {
            super(new NullDigest(), new org.bouncycastle.crypto.signers.DSASigner());
        }
    }
}
",1
CVE-2016-1000338,prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/ec/SignatureSpi.java,"package org.bouncycastle.jcajce.provider.asymmetric.ec;

import java.io.IOException;
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.PrivateKey;
import java.security.PublicKey;

import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.ASN1Encoding;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DSA;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.digests.NullDigest;
import org.bouncycastle.crypto.digests.RIPEMD160Digest;
import org.bouncycastle.crypto.digests.SHA1Digest;
import org.bouncycastle.crypto.digests.SHA224Digest;
import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.crypto.digests.SHA384Digest;
import org.bouncycastle.crypto.digests.SHA3Digest;
import org.bouncycastle.crypto.digests.SHA512Digest;
import org.bouncycastle.crypto.params.ECPublicKeyParameters;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.crypto.signers.ECDSASigner;
import org.bouncycastle.crypto.signers.ECNRSigner;
import org.bouncycastle.crypto.signers.HMacDSAKCalculator;
import org.bouncycastle.jcajce.provider.asymmetric.util.DSABase;
import org.bouncycastle.jcajce.provider.asymmetric.util.DSAEncoder;
import org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;

public class SignatureSpi
    extends DSABase
{
    SignatureSpi(Digest digest, DSA signer, DSAEncoder encoder)
    {
        super(digest, signer, encoder);
    }

    protected void engineInitVerify(PublicKey publicKey)
        throws InvalidKeyException
    {
        CipherParameters param = ECUtils.generatePublicKeyParameter(publicKey);

        digest.reset();
        signer.init(false, param);
    }

    protected void engineInitSign(
        PrivateKey privateKey)
        throws InvalidKeyException
    {
        CipherParameters param = ECUtil.generatePrivateKeyParameter(privateKey);

        digest.reset();

        if (appRandom != null)
        {
            signer.init(true, new ParametersWithRandom(param, appRandom));
        }
        else
        {
            signer.init(true, param);
        }
    }

    static public class ecDSA
        extends SignatureSpi
    {
        public ecDSA()
        {
            super(new SHA1Digest(), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSA
        extends SignatureSpi
    {
        public ecDetDSA()
        {
            super(new SHA1Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA1Digest())), new StdDSAEncoder());
        }
    }

    static public class ecDSAnone
        extends SignatureSpi
    {
        public ecDSAnone()
        {
            super(new NullDigest(), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDSA224
        extends SignatureSpi
    {
        public ecDSA224()
        {
            super(new SHA224Digest(), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSA224
        extends SignatureSpi
    {
        public ecDetDSA224()
        {
            super(new SHA224Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA224Digest())), new StdDSAEncoder());
        }
    }

    static public class ecDSA256
        extends SignatureSpi
    {
        public ecDSA256()
        {
            super(new SHA256Digest(), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSA256
        extends SignatureSpi
    {
        public ecDetDSA256()
        {
            super(new SHA256Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest())), new StdDSAEncoder());
        }
    }

    static public class ecDSA384
        extends SignatureSpi
    {
        public ecDSA384()
        {
            super(new SHA384Digest(), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSA384
        extends SignatureSpi
    {
        public ecDetDSA384()
        {
            super(new SHA384Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA384Digest())), new StdDSAEncoder());
        }
    }

    static public class ecDSA512
        extends SignatureSpi
    {
        public ecDSA512()
        {
            super(new SHA512Digest(), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSA512
        extends SignatureSpi
    {
        public ecDetDSA512()
        {
            super(new SHA512Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA512Digest())), new StdDSAEncoder());
        }
    }

    static public class ecDSASha3_224
        extends SignatureSpi
    {
        public ecDSASha3_224()
        {
            super(new SHA3Digest(224), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSASha3_224
        extends SignatureSpi
    {
        public ecDetDSASha3_224()
        {
            super(new SHA3Digest(224), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(224))), new StdDSAEncoder());
        }
    }

    static public class ecDSASha3_256
        extends SignatureSpi
    {
        public ecDSASha3_256()
        {
            super(new SHA3Digest(256), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSASha3_256
        extends SignatureSpi
    {
        public ecDetDSASha3_256()
        {
            super(new SHA3Digest(256), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(256))), new StdDSAEncoder());
        }
    }

    static public class ecDSASha3_384
        extends SignatureSpi
    {
        public ecDSASha3_384()
        {
            super(new SHA3Digest(384), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSASha3_384
        extends SignatureSpi
    {
        public ecDetDSASha3_384()
        {
            super(new SHA3Digest(384), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(384))), new StdDSAEncoder());
        }
    }

    static public class ecDSASha3_512
        extends SignatureSpi
    {
        public ecDSASha3_512()
        {
            super(new SHA3Digest(512), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSASha3_512
        extends SignatureSpi
    {
        public ecDetDSASha3_512()
        {
            super(new SHA3Digest(512), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(512))), new StdDSAEncoder());
        }
    }

    static public class ecDSARipeMD160
        extends SignatureSpi
    {
        public ecDSARipeMD160()
        {
            super(new RIPEMD160Digest(), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecNR
        extends SignatureSpi
    {
        public ecNR()
        {
            super(new SHA1Digest(), new ECNRSigner(), new StdDSAEncoder());
        }
    }

    static public class ecNR224
        extends SignatureSpi
    {
        public ecNR224()
        {
            super(new SHA224Digest(), new ECNRSigner(), new StdDSAEncoder());
        }
    }

    static public class ecNR256
        extends SignatureSpi
    {
        public ecNR256()
        {
            super(new SHA256Digest(), new ECNRSigner(), new StdDSAEncoder());
        }
    }

    static public class ecNR384
        extends SignatureSpi
    {
        public ecNR384()
        {
            super(new SHA384Digest(), new ECNRSigner(), new StdDSAEncoder());
        }
    }

    static public class ecNR512
        extends SignatureSpi
    {
        public ecNR512()
        {
            super(new SHA512Digest(), new ECNRSigner(), new StdDSAEncoder());
        }
    }

    static public class ecCVCDSA
        extends SignatureSpi
    {
        public ecCVCDSA()
        {
            super(new SHA1Digest(), new ECDSASigner(), new PlainDSAEncoder());
        }
    }

    static public class ecCVCDSA224
        extends SignatureSpi
    {
        public ecCVCDSA224()
        {
            super(new SHA224Digest(), new ECDSASigner(), new PlainDSAEncoder());
        }
    }

    static public class ecCVCDSA256
        extends SignatureSpi
    {
        public ecCVCDSA256()
        {
            super(new SHA256Digest(), new ECDSASigner(), new PlainDSAEncoder());
        }
    }

    static public class ecCVCDSA384
        extends SignatureSpi
    {
        public ecCVCDSA384()
        {
            super(new SHA384Digest(), new ECDSASigner(), new PlainDSAEncoder());
        }
    }

    static public class ecCVCDSA512
        extends SignatureSpi
    {
        public ecCVCDSA512()
        {
            super(new SHA512Digest(), new ECDSASigner(), new PlainDSAEncoder());
        }
    }

    static public class ecPlainDSARP160
        extends SignatureSpi
    {
        public ecPlainDSARP160()
        {
            super(new RIPEMD160Digest(), new ECDSASigner(), new PlainDSAEncoder());
        }
    }

    private static class StdDSAEncoder
        implements DSAEncoder
    {
        public byte[] encode(
            BigInteger r,
            BigInteger s)
            throws IOException
        {
            ASN1EncodableVector v = new ASN1EncodableVector();

            v.add(new ASN1Integer(r));
            v.add(new ASN1Integer(s));

            return new DERSequence(v).getEncoded(ASN1Encoding.DER);
        }

        public BigInteger[] decode(
            byte[] encoding)
            throws IOException
        {
            ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);
            BigInteger[] sig = new BigInteger[2];

            sig[0] = ASN1Integer.getInstance(s.getObjectAt(0)).getValue();
            sig[1] = ASN1Integer.getInstance(s.getObjectAt(1)).getValue();

            return sig;
        }
    }

    private static class PlainDSAEncoder
        implements DSAEncoder
    {
        public byte[] encode(
            BigInteger r,
            BigInteger s)
            throws IOException
        {
            byte[] first = makeUnsigned(r);
            byte[] second = makeUnsigned(s);
            byte[] res;

            if (first.length > second.length)
            {
                res = new byte[first.length * 2];
            }
            else
            {
                res = new byte[second.length * 2];
            }

            System.arraycopy(first, 0, res, res.length / 2 - first.length, first.length);
            System.arraycopy(second, 0, res, res.length - second.length, second.length);

            return res;
        }


        private byte[] makeUnsigned(BigInteger val)
        {
            byte[] res = val.toByteArray();

            if (res[0] == 0)
            {
                byte[] tmp = new byte[res.length - 1];

                System.arraycopy(res, 1, tmp, 0, tmp.length);

                return tmp;
            }

            return res;
        }

        public BigInteger[] decode(
            byte[] encoding)
            throws IOException
        {
            BigInteger[] sig = new BigInteger[2];

            byte[] first = new byte[encoding.length / 2];
            byte[] second = new byte[encoding.length / 2];

            System.arraycopy(encoding, 0, first, 0, first.length);
            System.arraycopy(encoding, first.length, second, 0, second.length);

            sig[0] = new BigInteger(1, first);
            sig[1] = new BigInteger(1, second);

            return sig;
        }
    }
}",0
CVE-2016-1000338,prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/ec/SignatureSpi.java,"package org.bouncycastle.jcajce.provider.asymmetric.ec;

import java.io.IOException;
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.PrivateKey;
import java.security.PublicKey;

import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.ASN1Encoding;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DSA;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.digests.NullDigest;
import org.bouncycastle.crypto.digests.RIPEMD160Digest;
import org.bouncycastle.crypto.digests.SHA1Digest;
import org.bouncycastle.crypto.digests.SHA224Digest;
import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.crypto.digests.SHA384Digest;
import org.bouncycastle.crypto.digests.SHA3Digest;
import org.bouncycastle.crypto.digests.SHA512Digest;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.crypto.signers.ECDSASigner;
import org.bouncycastle.crypto.signers.ECNRSigner;
import org.bouncycastle.crypto.signers.HMacDSAKCalculator;
import org.bouncycastle.jcajce.provider.asymmetric.util.DSABase;
import org.bouncycastle.jcajce.provider.asymmetric.util.DSAEncoder;
import org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;
import org.bouncycastle.util.Arrays;

public class SignatureSpi
    extends DSABase
{
    SignatureSpi(Digest digest, DSA signer, DSAEncoder encoder)
    {
        super(digest, signer, encoder);
    }

    protected void engineInitVerify(PublicKey publicKey)
        throws InvalidKeyException
    {
        CipherParameters param = ECUtils.generatePublicKeyParameter(publicKey);

        digest.reset();
        signer.init(false, param);
    }

    protected void engineInitSign(
        PrivateKey privateKey)
        throws InvalidKeyException
    {
        CipherParameters param = ECUtil.generatePrivateKeyParameter(privateKey);

        digest.reset();

        if (appRandom != null)
        {
            signer.init(true, new ParametersWithRandom(param, appRandom));
        }
        else
        {
            signer.init(true, param);
        }
    }

    static public class ecDSA
        extends SignatureSpi
    {
        public ecDSA()
        {
            super(new SHA1Digest(), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSA
        extends SignatureSpi
    {
        public ecDetDSA()
        {
            super(new SHA1Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA1Digest())), new StdDSAEncoder());
        }
    }

    static public class ecDSAnone
        extends SignatureSpi
    {
        public ecDSAnone()
        {
            super(new NullDigest(), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDSA224
        extends SignatureSpi
    {
        public ecDSA224()
        {
            super(new SHA224Digest(), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSA224
        extends SignatureSpi
    {
        public ecDetDSA224()
        {
            super(new SHA224Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA224Digest())), new StdDSAEncoder());
        }
    }

    static public class ecDSA256
        extends SignatureSpi
    {
        public ecDSA256()
        {
            super(new SHA256Digest(), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSA256
        extends SignatureSpi
    {
        public ecDetDSA256()
        {
            super(new SHA256Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest())), new StdDSAEncoder());
        }
    }

    static public class ecDSA384
        extends SignatureSpi
    {
        public ecDSA384()
        {
            super(new SHA384Digest(), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSA384
        extends SignatureSpi
    {
        public ecDetDSA384()
        {
            super(new SHA384Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA384Digest())), new StdDSAEncoder());
        }
    }

    static public class ecDSA512
        extends SignatureSpi
    {
        public ecDSA512()
        {
            super(new SHA512Digest(), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSA512
        extends SignatureSpi
    {
        public ecDetDSA512()
        {
            super(new SHA512Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA512Digest())), new StdDSAEncoder());
        }
    }

    static public class ecDSASha3_224
        extends SignatureSpi
    {
        public ecDSASha3_224()
        {
            super(new SHA3Digest(224), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSASha3_224
        extends SignatureSpi
    {
        public ecDetDSASha3_224()
        {
            super(new SHA3Digest(224), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(224))), new StdDSAEncoder());
        }
    }

    static public class ecDSASha3_256
        extends SignatureSpi
    {
        public ecDSASha3_256()
        {
            super(new SHA3Digest(256), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSASha3_256
        extends SignatureSpi
    {
        public ecDetDSASha3_256()
        {
            super(new SHA3Digest(256), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(256))), new StdDSAEncoder());
        }
    }

    static public class ecDSASha3_384
        extends SignatureSpi
    {
        public ecDSASha3_384()
        {
            super(new SHA3Digest(384), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSASha3_384
        extends SignatureSpi
    {
        public ecDetDSASha3_384()
        {
            super(new SHA3Digest(384), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(384))), new StdDSAEncoder());
        }
    }

    static public class ecDSASha3_512
        extends SignatureSpi
    {
        public ecDSASha3_512()
        {
            super(new SHA3Digest(512), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecDetDSASha3_512
        extends SignatureSpi
    {
        public ecDetDSASha3_512()
        {
            super(new SHA3Digest(512), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(512))), new StdDSAEncoder());
        }
    }

    static public class ecDSARipeMD160
        extends SignatureSpi
    {
        public ecDSARipeMD160()
        {
            super(new RIPEMD160Digest(), new ECDSASigner(), new StdDSAEncoder());
        }
    }

    static public class ecNR
        extends SignatureSpi
    {
        public ecNR()
        {
            super(new SHA1Digest(), new ECNRSigner(), new StdDSAEncoder());
        }
    }

    static public class ecNR224
        extends SignatureSpi
    {
        public ecNR224()
        {
            super(new SHA224Digest(), new ECNRSigner(), new StdDSAEncoder());
        }
    }

    static public class ecNR256
        extends SignatureSpi
    {
        public ecNR256()
        {
            super(new SHA256Digest(), new ECNRSigner(), new StdDSAEncoder());
        }
    }

    static public class ecNR384
        extends SignatureSpi
    {
        public ecNR384()
        {
            super(new SHA384Digest(), new ECNRSigner(), new StdDSAEncoder());
        }
    }

    static public class ecNR512
        extends SignatureSpi
    {
        public ecNR512()
        {
            super(new SHA512Digest(), new ECNRSigner(), new StdDSAEncoder());
        }
    }

    static public class ecCVCDSA
        extends SignatureSpi
    {
        public ecCVCDSA()
        {
            super(new SHA1Digest(), new ECDSASigner(), new PlainDSAEncoder());
        }
    }

    static public class ecCVCDSA224
        extends SignatureSpi
    {
        public ecCVCDSA224()
        {
            super(new SHA224Digest(), new ECDSASigner(), new PlainDSAEncoder());
        }
    }

    static public class ecCVCDSA256
        extends SignatureSpi
    {
        public ecCVCDSA256()
        {
            super(new SHA256Digest(), new ECDSASigner(), new PlainDSAEncoder());
        }
    }

    static public class ecCVCDSA384
        extends SignatureSpi
    {
        public ecCVCDSA384()
        {
            super(new SHA384Digest(), new ECDSASigner(), new PlainDSAEncoder());
        }
    }

    static public class ecCVCDSA512
        extends SignatureSpi
    {
        public ecCVCDSA512()
        {
            super(new SHA512Digest(), new ECDSASigner(), new PlainDSAEncoder());
        }
    }

    static public class ecPlainDSARP160
        extends SignatureSpi
    {
        public ecPlainDSARP160()
        {
            super(new RIPEMD160Digest(), new ECDSASigner(), new PlainDSAEncoder());
        }
    }

    private static class StdDSAEncoder
        implements DSAEncoder
    {
        public byte[] encode(
            BigInteger r,
            BigInteger s)
            throws IOException
        {
            ASN1EncodableVector v = new ASN1EncodableVector();

            v.add(new ASN1Integer(r));
            v.add(new ASN1Integer(s));

            return new DERSequence(v).getEncoded(ASN1Encoding.DER);
        }

        public BigInteger[] decode(
            byte[] encoding)
            throws IOException
        {
            ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);
            if (s.size() != 2)
            {
                throw new IOException(""malformed signature"");
            }
            if (!Arrays.areEqual(encoding, s.getEncoded(ASN1Encoding.DER)))
            {
                throw new IOException(""malformed signature"");
            }

            BigInteger[] sig = new BigInteger[2];

            sig[0] = ASN1Integer.getInstance(s.getObjectAt(0)).getValue();
            sig[1] = ASN1Integer.getInstance(s.getObjectAt(1)).getValue();

            return sig;
        }
    }

    private static class PlainDSAEncoder
        implements DSAEncoder
    {
        public byte[] encode(
            BigInteger r,
            BigInteger s)
            throws IOException
        {
            byte[] first = makeUnsigned(r);
            byte[] second = makeUnsigned(s);
            byte[] res;

            if (first.length > second.length)
            {
                res = new byte[first.length * 2];
            }
            else
            {
                res = new byte[second.length * 2];
            }

            System.arraycopy(first, 0, res, res.length / 2 - first.length, first.length);
            System.arraycopy(second, 0, res, res.length - second.length, second.length);

            return res;
        }


        private byte[] makeUnsigned(BigInteger val)
        {
            byte[] res = val.toByteArray();

            if (res[0] == 0)
            {
                byte[] tmp = new byte[res.length - 1];

                System.arraycopy(res, 1, tmp, 0, tmp.length);

                return tmp;
            }

            return res;
        }

        public BigInteger[] decode(
            byte[] encoding)
            throws IOException
        {
            BigInteger[] sig = new BigInteger[2];

            byte[] first = new byte[encoding.length / 2];
            byte[] second = new byte[encoding.length / 2];

            System.arraycopy(encoding, 0, first, 0, first.length);
            System.arraycopy(encoding, first.length, second, 0, second.length);

            sig[0] = new BigInteger(1, first);
            sig[1] = new BigInteger(1, second);

            return sig;
        }
    }
}",1
CVE-2019-10087,jspwiki-main/src/main/java/org/apache/wiki/plugin/ReferredPagesPlugin.java,"/*
    Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    ""License""); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.
*/
package org.apache.wiki.plugin;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;

import org.apache.log4j.Logger;
import org.apache.oro.text.regex.MalformedPatternException;
import org.apache.oro.text.regex.Pattern;
import org.apache.oro.text.regex.PatternCompiler;
import org.apache.oro.text.regex.PatternMatcher;
import org.apache.oro.text.regex.Perl5Compiler;
import org.apache.oro.text.regex.Perl5Matcher;
import org.apache.wiki.ReferenceManager;
import org.apache.wiki.WikiContext;
import org.apache.wiki.WikiEngine;
import org.apache.wiki.WikiPage;
import org.apache.wiki.api.exceptions.PluginException;
import org.apache.wiki.api.plugin.WikiPlugin;
import org.apache.wiki.util.TextUtil;


/**
 *  Displays the pages referring to the current page.
 *
 *  <p>Parameters</p>
 *  <ul>
 *    <li><b>name</b> - Name of the root page. Default name of calling page
 *    <li><b>type</b> - local|externalattachment
 *    <li><b>depth</b> - How many levels of pages to be parsed.
 *    <li><b>include</b> - Include only these pages. (eg. include='UC.*|BP.*' )
 *    <li><b>exclude</b> - Exclude with this pattern. (eg. exclude='LeftMenu' )
 *    <li><b>format</b> -  full|compact, FULL now expands all levels correctly
 *  </ul>
 *
 */
public class ReferredPagesPlugin implements WikiPlugin {

    private static Logger log = Logger.getLogger( ReferredPagesPlugin.class );
    private WikiEngine     m_engine;
    private int            m_depth;
    private HashSet<String> m_exists  = new HashSet<>();
    private StringBuffer   m_result  = new StringBuffer(1024);
    private PatternMatcher m_matcher = new Perl5Matcher();
    private Pattern        m_includePattern;
    private Pattern        m_excludePattern;
    private boolean m_formatCompact  = true;
    private boolean m_formatSort     = false;

    /** The parameter name for the root page to start from.  Value is <tt>{@value}</tt>. */
    public static final String PARAM_ROOT    = ""page"";

    /** The parameter name for the depth.  Value is <tt>{@value}</tt>. */
    public static final String PARAM_DEPTH   = ""depth"";

    /** The parameter name for the type of the references.  Value is <tt>{@value}</tt>. */
    public static final String PARAM_TYPE    = ""type"";

    /** The parameter name for the included pages.  Value is <tt>{@value}</tt>. */
    public static final String PARAM_INCLUDE = ""include"";

    /** The parameter name for the excluded pages.  Value is <tt>{@value}</tt>. */
    public static final String PARAM_EXCLUDE = ""exclude"";

    /** The parameter name for the format.  Value is <tt>{@value}</tt>. */
    public static final String PARAM_FORMAT  = ""format"";

    /** The minimum depth. Value is <tt>{@value}</tt>. */
    public static final int    MIN_DEPTH = 1;

    /** The maximum depth. Value is <tt>{@value}</tt>. */
    public static final int    MAX_DEPTH = 8;

    /**
     *  {@inheritDoc}
     */
    public String execute( WikiContext context, Map<String, String> params ) throws PluginException {
        m_engine = context.getEngine();

        WikiPage         page   = context.getPage();
        if( page == null ) return """";

        // parse parameters
        String rootname = params.get( PARAM_ROOT );
        if( rootname == null ) rootname = page.getName() ;

        String format = params.get( PARAM_FORMAT );
        if( format == null) format = """";
        if( format.indexOf( ""full"" ) >=0 ) m_formatCompact = false ;
        if( format.indexOf( ""sort"" ) >=0 ) m_formatSort    = true  ;

        m_depth = TextUtil.parseIntParameter( params.get( PARAM_DEPTH ), MIN_DEPTH );
        if( m_depth > MAX_DEPTH )  m_depth = MAX_DEPTH;

        String includePattern = params.get(PARAM_INCLUDE);
        if( includePattern == null ) includePattern = "".*"";

        String excludePattern = params.get(PARAM_EXCLUDE);
        if( excludePattern == null ) excludePattern = ""^$"";

        log.debug( ""Fetching referred pages for ""+ rootname +
                   "" with a depth of ""+ m_depth +
                   "" with include pattern of ""+ includePattern +
                   "" with exclude pattern of ""+ excludePattern );

        //
        // do the actual work
        //
        String href  = context.getViewURL(rootname);
        String title = ""ReferredPagesPlugin: depth[""+m_depth+
                       ""] include[""+includePattern+""] exclude[""+excludePattern+
                       ""] format[""+(m_formatCompact ? ""compact"" : ""full"") +
                       (m_formatSort ? "" sort"" : """") + ""]"";

        m_result.append(""<div class=\""ReferredPagesPlugin\"">\n"");
        m_result.append(""<a class=\""wikipage\"" href=\""""+ href +
                        ""\"" title=\"""" + TextUtil.replaceEntities(title) +
                        ""\"">"" + TextUtil.replaceEntities(rootname) + ""</a>\n"");
        m_exists.add(rootname);

        // pre compile all needed patterns
        // glob compiler :  * is 0..n instance of any char  -- more convenient as input
        // perl5 compiler : .* is 0..n instances of any char -- more powerful
        //PatternCompiler g_compiler = new GlobCompiler();
        PatternCompiler compiler = new Perl5Compiler();

        try
        {
            m_includePattern = compiler.compile(includePattern);

            m_excludePattern = compiler.compile(excludePattern);
        }
        catch( MalformedPatternException e )
        {
            if (m_includePattern == null )
            {
                throw new PluginException(""Illegal include pattern detected."");
            }
            else if (m_excludePattern == null )
            {
                throw new PluginException(""Illegal exclude pattern detected."");
            }
            else
            {
                throw new PluginException(""Illegal internal pattern detected."");
            }
        }

        // go get all referred links
        getReferredPages(context,rootname, 0);

        // close and finish
        m_result.append (""</div>\n"" ) ;

        return m_result.toString() ;
    }


    /**
     * Retrieves a list of all referred pages. Is called recursively depending on the depth parameter.
     */
    private void getReferredPages( WikiContext context, String pagename, int depth ) {
        if( depth >= m_depth ) return;  // end of recursion
        if( pagename == null ) return;
        if( !m_engine.pageExists(pagename) ) return;

        ReferenceManager mgr = m_engine.getReferenceManager();

        Collection<String> allPages = mgr.findRefersTo( pagename );

        handleLinks( context, allPages, ++depth, pagename );
    }

    private void handleLinks(WikiContext context,Collection<String> links, int depth, String pagename) {
        boolean isUL = false;
        HashSet<String> localLinkSet = new HashSet<>();  // needed to skip multiple
        // links to the same page
        localLinkSet.add(pagename);

        ArrayList<String> allLinks = new ArrayList<>();

        if( links != null )
            allLinks.addAll( links );

        if( m_formatSort ) context.getEngine().getPageManager().getPageSorter().sort( allLinks );

        for( Iterator<String> i = allLinks.iterator(); i.hasNext(); ) {
            String link = i.next() ;

            if( localLinkSet.contains( link ) ) continue; // skip multiple links to the same page
            localLinkSet.add( link );

            if( !m_engine.pageExists( link ) ) continue; // hide links to non existing pages

            if(  m_matcher.matches( link , m_excludePattern ) ) continue;
            if( !m_matcher.matches( link , m_includePattern ) ) continue;

            if( m_exists.contains( link ) ) {
                if( !m_formatCompact ) {
                    if( !isUL ) {
                        isUL = true;
                        m_result.append(""<ul>\n"");
                    }

                    //See https://www.w3.org/wiki/HTML_lists  for proper nesting of UL and LI
                    m_result.append(""<li> "" + link + ""\n"");

                    getReferredPages( context, link, depth );  // added recursive call - on general request

                    m_result.append(""\n</li>\n"");

                }
            } else {
                if( !isUL ) {
                    isUL = true;
                    m_result.append(""<ul>\n"");
                }

                String href = context.getURL(WikiContext.VIEW,link);
                m_result.append(""<li><a class=\""wikipage\"" href=\""""+ href +""\"">""+link+""</a>\n"" );

                m_exists.add( link );

                getReferredPages( context, link, depth );

                m_result.append(""\n</li>\n"");

            }
        }

        if( isUL ) {
            m_result.append(""</ul>\n"");
        }
    }

}",1
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwk/JsonWebKeys.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jwk;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.jaxrs.json.basic.JsonMapObject;

public class JsonWebKeys extends JsonMapObject {
    public static final String KEYS_PROPERTY = ""keys"";
    private static final long serialVersionUID = -8002543601655429723L;

    public JsonWebKeys() {

    }
    public JsonWebKeys(JsonWebKey key) {
        setInitKey(key);
    }
    private void setInitKey(JsonWebKey key) {
        setKey(key);
    }
    public List<JsonWebKey> getKeys() {
        List<?> list = (List<?>)super.getProperty(KEYS_PROPERTY);
        if (list != null && !list.isEmpty()) {
            Object first = list.get(0);
            if (first instanceof JsonWebKey) {
                return CastUtils.cast(list);
            }
            List<JsonWebKey> keys = new LinkedList<>();
            List<Map<String, Object>> listOfMaps =
                CastUtils.cast((List<?>)super.getProperty(KEYS_PROPERTY));
            for (Map<String, Object> map : listOfMaps) {
                keys.add(new JsonWebKey(map));
            }
            return keys;
        }
        return null;
    }
    public final void setKey(JsonWebKey key) {
        setKeys(Collections.singletonList(key));
    }
    public final void setKeys(List<JsonWebKey> keys) {
        super.setProperty(KEYS_PROPERTY, keys);
    }

    public Map<String, JsonWebKey> getKeyIdMap() {
        List<JsonWebKey> keys = getKeys();
        if (keys == null) {
            return Collections.emptyMap();
        }
        Map<String, JsonWebKey> map = new LinkedHashMap<>();
        for (JsonWebKey key : keys) {
            String kid = key.getKeyId();
            if (kid != null) {
                map.put(kid, key);
            }
        }
        return map;
    }
    public JsonWebKey getKey(String kid) {
        return getKeyIdMap().get(kid);
    }
    public Map<KeyType, List<JsonWebKey>> getKeyTypeMap() {
        List<JsonWebKey> keys = getKeys();
        if (keys == null) {
            return Collections.emptyMap();
        }
        Map<KeyType, List<JsonWebKey>> map = new LinkedHashMap<>();
        for (JsonWebKey key : keys) {
            KeyType type = key.getKeyType();
            if (type != null) {
                List<JsonWebKey> list = map.get(type);
                if (list == null) {
                    list = new LinkedList<>();
                    map.put(type, list);
                }
                list.add(key);
            }
        }
        return map;
    }

    public Map<KeyOperation, List<JsonWebKey>> getKeyOperationMap() {
        List<JsonWebKey> keys = getKeys();
        if (keys == null) {
            return Collections.emptyMap();
        }
        Map<KeyOperation, List<JsonWebKey>> map = new LinkedHashMap<>();
        for (JsonWebKey key : keys) {
            List<KeyOperation> ops = key.getKeyOperation();
            if (ops != null) {
                for (KeyOperation op : ops) {
                    List<JsonWebKey> list = map.get(op);
                    if (list == null) {
                        list = new LinkedList<>();
                        map.put(op, list);
                    }
                    list.add(key);
                }
            }
        }
        return map;
    }
    public List<JsonWebKey> getKeys(String keyType) {
        KeyType kt = KeyType.getKeyType(keyType);
        if (kt == null) {
            return null;
        }
        return getKeyTypeMap().get(kt);
    }
    public List<JsonWebKey> getRsaKeys() {
        return getKeyTypeMap().get(KeyType.RSA);
    }
    public List<JsonWebKey> getEllipticKeys() {
        return getKeyTypeMap().get(KeyType.EC);
    }
    public List<JsonWebKey> getSecretKeys() {
        return getKeyTypeMap().get(KeyType.OCTET);
    }
}
",0
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwk/JsonWebKeys.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jwk;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.jaxrs.json.basic.JsonMapObject;

public class JsonWebKeys extends JsonMapObject {
    public static final String KEYS_PROPERTY = ""keys"";
    private static final long serialVersionUID = -8002543601655429723L;

    public JsonWebKeys() {

    }
    public JsonWebKeys(JsonWebKey key) {
        setKey(key);
    }

    public JsonWebKeys(List<JsonWebKey> keys) {
        setKeys(keys);
    }

    public List<JsonWebKey> getKeys() {
        List<?> list = (List<?>)super.getProperty(KEYS_PROPERTY);
        if (list != null && !list.isEmpty()) {
            Object first = list.get(0);
            if (first instanceof JsonWebKey) {
                return CastUtils.cast(list);
            }
            List<JsonWebKey> keys = new LinkedList<>();
            List<Map<String, Object>> listOfMaps =
                CastUtils.cast((List<?>)super.getProperty(KEYS_PROPERTY));
            for (Map<String, Object> map : listOfMaps) {
                keys.add(new JsonWebKey(map));
            }
            return keys;
        }
        return null;
    }
    public final void setKey(JsonWebKey key) {
        setKeys(Collections.singletonList(key));
    }
    public final void setKeys(List<JsonWebKey> keys) {
        super.setProperty(KEYS_PROPERTY, keys);
    }

    public Map<String, JsonWebKey> getKeyIdMap() {
        List<JsonWebKey> keys = getKeys();
        if (keys == null) {
            return Collections.emptyMap();
        }
        Map<String, JsonWebKey> map = new LinkedHashMap<>();
        for (JsonWebKey key : keys) {
            String kid = key.getKeyId();
            if (kid != null) {
                map.put(kid, key);
            }
        }
        return map;
    }
    public JsonWebKey getKey(String kid) {
        return getKeyIdMap().get(kid);
    }
    public Map<KeyType, List<JsonWebKey>> getKeyTypeMap() {
        List<JsonWebKey> keys = getKeys();
        if (keys == null) {
            return Collections.emptyMap();
        }
        Map<KeyType, List<JsonWebKey>> map = new LinkedHashMap<>();
        for (JsonWebKey key : keys) {
            KeyType type = key.getKeyType();
            if (type != null) {
                List<JsonWebKey> list = map.get(type);
                if (list == null) {
                    list = new LinkedList<>();
                    map.put(type, list);
                }
                list.add(key);
            }
        }
        return map;
    }

    public Map<KeyOperation, List<JsonWebKey>> getKeyOperationMap() {
        List<JsonWebKey> keys = getKeys();
        if (keys == null) {
            return Collections.emptyMap();
        }
        Map<KeyOperation, List<JsonWebKey>> map = new LinkedHashMap<>();
        for (JsonWebKey key : keys) {
            List<KeyOperation> ops = key.getKeyOperation();
            if (ops != null) {
                for (KeyOperation op : ops) {
                    List<JsonWebKey> list = map.get(op);
                    if (list == null) {
                        list = new LinkedList<>();
                        map.put(op, list);
                    }
                    list.add(key);
                }
            }
        }
        return map;
    }
    public List<JsonWebKey> getKeys(String keyType) {
        KeyType kt = KeyType.getKeyType(keyType);
        if (kt == null) {
            return null;
        }
        return getKeyTypeMap().get(kt);
    }
    public List<JsonWebKey> getRsaKeys() {
        return getKeyTypeMap().get(KeyType.RSA);
    }
    public List<JsonWebKey> getEllipticKeys() {
        return getKeyTypeMap().get(KeyType.EC);
    }
    public List<JsonWebKey> getSecretKeys() {
        return getKeyTypeMap().get(KeyType.OCTET);
    }
}
",1
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwk/JwkUtils.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jwk;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAPrivateCrtKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import javax.crypto.SecretKey;

import org.apache.cxf.Bus;
import org.apache.cxf.common.util.Base64UrlUtility;
import org.apache.cxf.common.util.StringUtils;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.helpers.IOUtils;
import org.apache.cxf.jaxrs.json.basic.JsonMapObjectReaderWriter;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageUtils;
import org.apache.cxf.rs.security.jose.common.JoseConstants;
import org.apache.cxf.rs.security.jose.common.JoseException;
import org.apache.cxf.rs.security.jose.common.JoseHeaders;
import org.apache.cxf.rs.security.jose.common.JoseUtils;
import org.apache.cxf.rs.security.jose.common.KeyManagementUtils;
import org.apache.cxf.rs.security.jose.jwa.AlgorithmUtils;
import org.apache.cxf.rs.security.jose.jwa.ContentAlgorithm;
import org.apache.cxf.rs.security.jose.jwa.KeyAlgorithm;
import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;
import org.apache.cxf.rs.security.jose.jwe.AesCbcHmacJweDecryption;
import org.apache.cxf.rs.security.jose.jwe.AesCbcHmacJweEncryption;
import org.apache.cxf.rs.security.jose.jwe.JweDecryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.JweEncryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.JweHeaders;
import org.apache.cxf.rs.security.jose.jwe.JweUtils;
import org.apache.cxf.rs.security.jose.jwe.KeyDecryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.KeyEncryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.PbesHmacAesWrapKeyDecryptionAlgorithm;
import org.apache.cxf.rs.security.jose.jwe.PbesHmacAesWrapKeyEncryptionAlgorithm;
import org.apache.cxf.rs.security.jose.jws.JwsUtils;
import org.apache.cxf.rt.security.crypto.CryptoUtils;
import org.apache.cxf.rt.security.crypto.MessageDigestUtils;
import org.apache.cxf.rt.security.rs.PrivateKeyPasswordProvider;

public final class JwkUtils {
    private static final Map<KeyType, List<String>> JWK_REQUIRED_FIELDS_MAP;
    static {
        JWK_REQUIRED_FIELDS_MAP = new HashMap<>();
        JWK_REQUIRED_FIELDS_MAP.put(KeyType.RSA, Arrays.asList(
            JsonWebKey.RSA_PUBLIC_EXP, JsonWebKey.KEY_TYPE, JsonWebKey.RSA_MODULUS));
        JWK_REQUIRED_FIELDS_MAP.put(KeyType.EC, Arrays.asList(
            JsonWebKey.EC_CURVE, JsonWebKey.KEY_TYPE, JsonWebKey.EC_X_COORDINATE, JsonWebKey.EC_Y_COORDINATE));
        JWK_REQUIRED_FIELDS_MAP.put(KeyType.OCTET, Arrays.asList(
            JsonWebKey.OCTET_KEY_VALUE, JsonWebKey.KEY_TYPE));
    }
    private JwkUtils() {

    }
    public static String getThumbprint(String keySequence) {
        return getThumbprint(readJwkKey(keySequence));
    }
    public static String getThumbprint(JsonWebKey key) {
        List<String> fields = getRequiredFields(key.getKeyType());
        JsonWebKey thumbprintKey = new JsonWebKey();
        for (String f : fields) {
            thumbprintKey.setProperty(f, key.getProperty(f));
        }
        String json = new JsonMapObjectReaderWriter().toJson(thumbprintKey);
        byte[] digest = MessageDigestUtils.createDigest(json, MessageDigestUtils.ALGO_SHA_256);
        return Base64UrlUtility.encode(digest);
    }
    public static List<String> getRequiredFields(KeyType keyType) {
        return JWK_REQUIRED_FIELDS_MAP.get(keyType);
    }
    public static JsonWebKey readJwkKey(URI uri) throws IOException {
        return readJwkKey(uri.toURL().openStream());
    }
    public static JsonWebKeys readJwkSet(URI uri) throws IOException {
        return readJwkSet(uri.toURL().openStream());
    }
    public static JsonWebKey readJwkKey(InputStream is) throws IOException {
        return readJwkKey(IOUtils.readStringFromStream(is));
    }
    public static JsonWebKeys readJwkSet(InputStream is) throws IOException {
        return readJwkSet(IOUtils.readStringFromStream(is));
    }
    public static JsonWebKey readJwkKey(String jwkJson) {
        return new JwkReaderWriter().jsonToJwk(jwkJson);
    }
    public static JsonWebKeys readJwkSet(String jwksJson) {
        return new JwkReaderWriter().jsonToJwkSet(jwksJson);
    }
    public static String jwkKeyToJson(JsonWebKey jwkKey) {
        return new JwkReaderWriter().jwkToJson(jwkKey);
    }
    public static void jwkKeyToJson(JsonWebKey jwkKey, OutputStream os) throws IOException {
        IOUtils.copy(new ByteArrayInputStream(StringUtils.toBytesUTF8(jwkKeyToJson(jwkKey))), os);
    }
    public static String jwkSetToJson(JsonWebKeys jwkSet) {
        return new JwkReaderWriter().jwkSetToJson(jwkSet);
    }
    public static void jwkSetToJson(JsonWebKeys jwkSet, OutputStream os) throws IOException {
        IOUtils.copy(new ByteArrayInputStream(StringUtils.toBytesUTF8(jwkSetToJson(jwkSet))), os);
    }
    public static String encodeJwkKey(JsonWebKey jwkKey) {
        return Base64UrlUtility.encode(jwkKeyToJson(jwkKey));
    }
    public static String encodeJwkSet(JsonWebKeys jwkSet) {
        return Base64UrlUtility.encode(jwkSetToJson(jwkSet));
    }
    public static JsonWebKey decodeJwkKey(String jwkJson) {
        return readJwkKey(JoseUtils.decodeToString(jwkJson));
    }
    public static JsonWebKeys decodeJwkSet(String jwksJson) {
        return readJwkSet(JoseUtils.decodeToString(jwksJson));
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, char[] password) {
        return encryptJwkSet(jwkSet, createDefaultEncryption(password));
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, JweEncryptionProvider jwe) {
        return jwe.encrypt(StringUtils.toBytesUTF8(new JwkReaderWriter().jwkSetToJson(jwkSet)),
                           toJweHeaders(""jwk-set+json""));
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, PublicKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkSetToJson(jwkSet)),
                                ""jwk-set+json"");
    }
    public static String signJwkSet(JsonWebKeys jwkSet, PrivateKey key, SignatureAlgorithm algo) {
        return JwsUtils.sign(key, algo, jwkSetToJson(jwkSet), ""jwk-set+json"");
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, SecretKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkSetToJson(jwkSet)),
                                ""jwk-set+json"");
    }
    public static JsonWebKeys decryptJwkSet(String jsonJwkSet, char[] password) {
        return decryptJwkSet(jsonJwkSet, createDefaultDecryption(password));
    }
    public static JsonWebKeys decryptJwkSet(String jsonJwkSet, JweDecryptionProvider jwe) {
        return new JwkReaderWriter().jsonToJwkSet(jwe.decrypt(jsonJwkSet).getContentText());
    }
    public static JsonWebKeys decryptJwkSet(PrivateKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                            String jsonJwkSet) {
        return readJwkSet(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwkSet)));
    }
    public static JsonWebKeys verifyJwkSet(PublicKey key, SignatureAlgorithm keyAlgo, String jsonJwk) {
        return readJwkSet(JwsUtils.verify(key, keyAlgo, jsonJwk));
    }
    public static JsonWebKeys decryptJwkSet(SecretKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                            String jsonJwkSet) {
        return readJwkSet(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwkSet)));
    }
    public static JsonWebKeys decryptJwkSet(InputStream is, char[] password)
        throws IOException {
        return decryptJwkSet(is, createDefaultDecryption(password));
    }
    public static JsonWebKeys decryptJwkSet(InputStream is, JweDecryptionProvider jwe)
        throws IOException {
        return new JwkReaderWriter().jsonToJwkSet(
            jwe.decrypt(IOUtils.readStringFromStream(is)).getContentText());
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, char[] password) {
        return encryptJwkKey(jwkKey, createDefaultEncryption(password));
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, JweEncryptionProvider jwe) {
        return jwe.encrypt(StringUtils.toBytesUTF8(new JwkReaderWriter().jwkToJson(jwkKey)),
                           toJweHeaders(""jwk+json""));
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, PublicKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkKeyToJson(jwkKey)),
                                ""jwk+json"");
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, SecretKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkKeyToJson(jwkKey)),
                                ""jwk+json"");
    }
    public static String signJwkKey(JsonWebKey jwkKey, PrivateKey key, SignatureAlgorithm algo) {
        return JwsUtils.sign(key, algo, jwkKeyToJson(jwkKey), ""jwk+json"");
    }
    public static JsonWebKey decryptJwkKey(String jsonJwkKey, char[] password) {
        return decryptJwkKey(jsonJwkKey, createDefaultDecryption(password));
    }
    public static JsonWebKey decryptJwkKey(PrivateKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                           String jsonJwk) {
        return readJwkKey(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwk)));
    }
    public static JsonWebKey verifyJwkKey(PublicKey key, SignatureAlgorithm keyAlgo, String jsonJwk) {
        return readJwkKey(JwsUtils.verify(key, keyAlgo, jsonJwk));
    }
    public static JsonWebKey decryptJwkKey(SecretKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                           String jsonJwk) {
        return readJwkKey(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwk)));
    }
    public static JsonWebKey decryptJwkKey(String jsonJwkKey, JweDecryptionProvider jwe) {
        return new JwkReaderWriter().jsonToJwk(jwe.decrypt(jsonJwkKey).getContentText());
    }
    public static JsonWebKey decryptJwkKey(InputStream is, char[] password)
        throws IOException {
        return decryptJwkKey(is, createDefaultDecryption(password));
    }
    public static JsonWebKey decryptJwkKey(InputStream is, JweDecryptionProvider jwe)
        throws IOException {
        return new JwkReaderWriter().jsonToJwk(
            jwe.decrypt(IOUtils.readStringFromStream(is)).getContentText());
    }
    public static JsonWebKeys loadPublicJwkSet(Message m, Properties props) {
        return loadJwkSet(m, props, null);
    }
    public static JsonWebKeys loadJwkSet(Message m, Properties props, PrivateKeyPasswordProvider cb) {
        String key = (String)props.get(JoseConstants.RSSEC_KEY_STORE_FILE);
        JsonWebKeys jwkSet = null;
        if (key != null && m != null) {
            Object jwkSetProp = m.getExchange().get(key);
            if (jwkSetProp != null && !(jwkSetProp instanceof JsonWebKeys)) {
                throw new JwkException(""Unexpected key store class: "" + jwkSetProp.getClass().getName());
            } else {
                jwkSet = (JsonWebKeys)jwkSetProp;
            }
        }
        if (jwkSet == null) {
            jwkSet = loadJwkSet(props, m != null ? m.getExchange().getBus() : null, cb);
            if (key != null && m != null) {
                m.getExchange().put(key, jwkSet);
            }
        }
        return jwkSet;
    }
    public static JsonWebKeys loadJwkSet(Properties props, Bus bus, PrivateKeyPasswordProvider cb) {
        JweDecryptionProvider decryption = cb != null
            ? new AesCbcHmacJweDecryption(new PbesHmacAesWrapKeyDecryptionAlgorithm(
                cb.getPassword(props))) : null;
        return loadJwkSet(props, bus, decryption);
    }
    public static JsonWebKeys loadJwkSet(Properties props, Bus bus, JweDecryptionProvider jwe) {
        String keyContent = null;
        String keyStoreLoc = props.getProperty(JoseConstants.RSSEC_KEY_STORE_FILE);
        if (keyStoreLoc != null) {
            try {
                InputStream is = JoseUtils.getResourceStream(keyStoreLoc, bus);
                if (is == null) {
                    throw new JwkException(""Error in loading keystore location: "" + keyStoreLoc);
                }
                try (InputStream isResource = is) {
                    keyContent = IOUtils.readStringFromStream(isResource);
                }
            } catch (Exception ex) {
                throw new JwkException(ex);
            }
        } else {
            keyContent = props.getProperty(JoseConstants.RSSEC_KEY_STORE_JWKSET);
            if (keyContent == null) {
                keyContent = props.getProperty(JoseConstants.RSSEC_KEY_STORE_JWKKEY);
            }
        }
        if (jwe != null) {
            keyContent = jwe.decrypt(keyContent).getContentText();
        }
        JwkReaderWriter reader = new JwkReaderWriter();
        if (props.getProperty(JoseConstants.RSSEC_KEY_STORE_JWKKEY) == null) {
            return reader.jsonToJwkSet(keyContent);
        }
        JsonWebKey jwk = reader.jsonToJwk(keyContent);
        return new JsonWebKeys(jwk);
    }

    public static JsonWebKey loadJsonWebKey(Message m, Properties props, KeyOperation keyOper) {
        return loadJsonWebKey(m, props, keyOper, null);
    }
    public static JsonWebKey loadJsonWebKey(Message m, Properties props, KeyOperation keyOper, String inHeaderKid) {
        PrivateKeyPasswordProvider cb = KeyManagementUtils.loadPasswordProvider(m, props, keyOper);
        JsonWebKeys jwkSet = loadJwkSet(m, props, cb);
        String kid = null;
        if (inHeaderKid != null
            && MessageUtils.getContextualBoolean(m, JoseConstants.RSSEC_ACCEPT_PUBLIC_KEY, false)) {
            kid = inHeaderKid;
        } else {
            kid = KeyManagementUtils.getKeyId(m, props, JoseConstants.RSSEC_KEY_STORE_ALIAS, keyOper);
        }
        if (kid != null) {
            return jwkSet.getKey(kid);
        } else if (keyOper != null) {
            List<JsonWebKey> keys = jwkSet.getKeyOperationMap().get(keyOper);
            if (keys != null && keys.size() == 1) {
                return keys.get(0);
            }
        }
        return null;
    }
    public static List<JsonWebKey> loadJsonWebKeys(Message m,
                                                   Properties props,
                                                   KeyOperation keyOper) {
        PrivateKeyPasswordProvider cb = KeyManagementUtils.loadPasswordProvider(m, props, keyOper);
        JsonWebKeys jwkSet = loadJwkSet(m, props, cb);
        String kid = KeyManagementUtils.getKeyId(m, props, JoseConstants.RSSEC_KEY_STORE_ALIAS, keyOper);
        if (kid != null) {
            return Collections.singletonList(jwkSet.getKey(kid));
        }
        String kids = KeyManagementUtils.getKeyId(m, props, JoseConstants.RSSEC_KEY_STORE_ALIASES, keyOper);
        if (kids != null) {
            String[] values = kids.split("","");
            List<JsonWebKey> keys = new ArrayList<>(values.length);
            for (String value : values) {
                keys.add(jwkSet.getKey(value));
            }
            return keys;
        }
        if (keyOper != null) {
            List<JsonWebKey> keys = jwkSet.getKeyOperationMap().get(keyOper);
            if (keys != null && keys.size() == 1) {
                return Collections.singletonList(keys.get(0));
            }
        }
        return null;
    }
    public static RSAPublicKey toRSAPublicKey(JsonWebKey jwk) {
        return toRSAPublicKey(jwk, false);
    }
    public static RSAPublicKey toRSAPublicKey(JsonWebKey jwk, boolean checkX509) {
        String encodedModulus = (String)jwk.getProperty(JsonWebKey.RSA_MODULUS);
        String encodedPublicExponent = (String)jwk.getProperty(JsonWebKey.RSA_PUBLIC_EXP);
        if (encodedModulus != null) {
            return CryptoUtils.getRSAPublicKey(encodedModulus, encodedPublicExponent);
        } else if (checkX509) {
            List<X509Certificate> chain = toX509CertificateChain(jwk);
            return (RSAPublicKey)chain.get(0).getPublicKey();
        }
        return null;
    }
    public static List<X509Certificate> toX509CertificateChain(JsonWebKey jwk) {
        List<String> base64EncodedChain = jwk.getX509Chain();
        return KeyManagementUtils.toX509CertificateChain(base64EncodedChain);
    }
    public static JsonWebKey fromECPublicKey(ECPublicKey pk, String curve) {
        return fromECPublicKey(pk, curve, null);
    }
    public static JsonWebKey fromECPublicKey(ECPublicKey pk, String curve, String kid) {
        JsonWebKey jwk = prepareECJwk(curve, kid);
        jwk.setProperty(JsonWebKey.EC_X_COORDINATE,
                        Base64UrlUtility.encode(pk.getW().getAffineX().toByteArray()));
        jwk.setProperty(JsonWebKey.EC_Y_COORDINATE,
                        Base64UrlUtility.encode(pk.getW().getAffineY().toByteArray()));
        return jwk;
    }
    public static JsonWebKey fromECPrivateKey(ECPrivateKey pk, String curve) {
        return fromECPrivateKey(pk, curve, null);
    }
    public static JsonWebKey fromECPrivateKey(ECPrivateKey pk, String curve, String kid) {
        JsonWebKey jwk = prepareECJwk(curve, kid);
        jwk.setProperty(JsonWebKey.EC_PRIVATE_KEY,
                        Base64UrlUtility.encode(pk.getS().toByteArray()));
        return jwk;
    }
    public static JsonWebKey fromRSAPublicKey(RSAPublicKey pk, String algo) {
        return fromRSAPublicKey(pk, algo, null);
    }
    public static JsonWebKey fromRSAPublicKey(RSAPublicKey pk, String algo, String kid) {
        JsonWebKey jwk = prepareRSAJwk(pk.getModulus(), algo, kid);
        String encodedPublicExponent = Base64UrlUtility.encode(pk.getPublicExponent().toByteArray());
        jwk.setProperty(JsonWebKey.RSA_PUBLIC_EXP, encodedPublicExponent);
        return jwk;
    }
    public static JsonWebKey fromPublicKey(PublicKey key, Properties props, String algoProp) {
        JsonWebKey jwk = null;
        if (key instanceof RSAPublicKey) {
            String algo = props.getProperty(algoProp);
            jwk = JwkUtils.fromRSAPublicKey((RSAPublicKey)key, algo);
        } else {
            jwk = JwkUtils.fromECPublicKey((ECPublicKey)key,
                                           props.getProperty(JoseConstants.RSSEC_EC_CURVE));
        }
        String kid = props.getProperty(JoseConstants.RSSEC_KEY_STORE_ALIAS);
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        return jwk;
    }
    public static JsonWebKey fromX509CertificateChain(List<X509Certificate> chain, String algo) {
        JsonWebKey jwk = new JsonWebKey();
        jwk.setAlgorithm(algo);
        List<String> encodedChain = KeyManagementUtils.encodeX509CertificateChain(chain);
        jwk.setX509Chain(encodedChain);
        return jwk;
    }

    public static RSAPrivateKey toRSAPrivateKey(JsonWebKey jwk) {
        String encodedModulus = (String)jwk.getProperty(JsonWebKey.RSA_MODULUS);
        String encodedPrivateExponent = (String)jwk.getProperty(JsonWebKey.RSA_PRIVATE_EXP);
        String encodedPrimeP = (String)jwk.getProperty(JsonWebKey.RSA_FIRST_PRIME_FACTOR);
        if (encodedPrimeP == null) {
            return CryptoUtils.getRSAPrivateKey(encodedModulus, encodedPrivateExponent);
        }
        String encodedPublicExponent = (String)jwk.getProperty(JsonWebKey.RSA_PUBLIC_EXP);
        if (encodedPublicExponent == null) {
            throw new JoseException(""JWK without the public exponent can not be converted to RSAPrivateKey"");
        }
        String encodedPrimeQ = (String)jwk.getProperty(JsonWebKey.RSA_SECOND_PRIME_FACTOR);
        String encodedPrimeExpP = (String)jwk.getProperty(JsonWebKey.RSA_FIRST_PRIME_CRT);
        String encodedPrimeExpQ = (String)jwk.getProperty(JsonWebKey.RSA_SECOND_PRIME_CRT);
        String encodedCrtCoefficient = (String)jwk.getProperty(JsonWebKey.RSA_FIRST_CRT_COEFFICIENT);
        return CryptoUtils.getRSAPrivateKey(encodedModulus,
                                            encodedPublicExponent,
                                            encodedPrivateExponent,
                                            encodedPrimeP,
                                            encodedPrimeQ,
                                            encodedPrimeExpP,
                                            encodedPrimeExpQ,
                                            encodedCrtCoefficient);
    }
    public static JsonWebKey fromRSAPrivateKey(RSAPrivateKey pk, String algo) {
        return fromRSAPrivateKey(pk, algo, null);
    }
    public static JsonWebKey fromRSAPrivateKey(RSAPrivateKey pk, String algo, String kid) {
        JsonWebKey jwk = prepareRSAJwk(pk.getModulus(), algo, kid);
        String encodedPrivateExponent = Base64UrlUtility.encode(pk.getPrivateExponent().toByteArray());
        jwk.setProperty(JsonWebKey.RSA_PRIVATE_EXP, encodedPrivateExponent);
        if (pk instanceof RSAPrivateCrtKey) {
            RSAPrivateCrtKey pkCrt = (RSAPrivateCrtKey)pk;
            jwk.setProperty(JsonWebKey.RSA_PUBLIC_EXP,
                            Base64UrlUtility.encode(pkCrt.getPublicExponent().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_PRIME_FACTOR,
                            Base64UrlUtility.encode(pkCrt.getPrimeP().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_SECOND_PRIME_FACTOR,
                            Base64UrlUtility.encode(pkCrt.getPrimeQ().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_PRIME_CRT,
                            Base64UrlUtility.encode(pkCrt.getPrimeExponentP().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_SECOND_PRIME_CRT,
                            Base64UrlUtility.encode(pkCrt.getPrimeExponentQ().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_CRT_COEFFICIENT,
                            Base64UrlUtility.encode(pkCrt.getCrtCoefficient().toByteArray()));
        }
        // ""oth"" can be populated too if needed
        return jwk;
    }
    public static ECPublicKey toECPublicKey(JsonWebKey jwk) {
        String eCurve = (String)jwk.getProperty(JsonWebKey.EC_CURVE);
        String encodedXCoord = (String)jwk.getProperty(JsonWebKey.EC_X_COORDINATE);
        String encodedYCoord = (String)jwk.getProperty(JsonWebKey.EC_Y_COORDINATE);
        return CryptoUtils.getECPublicKey(eCurve, encodedXCoord, encodedYCoord);
    }
    public static ECPrivateKey toECPrivateKey(JsonWebKey jwk) {
        String eCurve = (String)jwk.getProperty(JsonWebKey.EC_CURVE);
        String encodedPrivateKey = (String)jwk.getProperty(JsonWebKey.EC_PRIVATE_KEY);
        return CryptoUtils.getECPrivateKey(eCurve, encodedPrivateKey);
    }

    public static SecretKey toSecretKey(JsonWebKey jwk) {
        return CryptoUtils.createSecretKeySpec((String)jwk.getProperty(JsonWebKey.OCTET_KEY_VALUE),
                                               AlgorithmUtils.toJavaName(jwk.getAlgorithm()));
    }
    public static JsonWebKey fromSecretKey(SecretKey secretKey, String algo) {
        return fromSecretKey(secretKey, algo, null);
    }
    public static JsonWebKey fromSecretKey(SecretKey secretKey, String algo, String kid) {
        if (!AlgorithmUtils.isOctet(algo)) {
            throw new JwkException(""Invalid algorithm"");
        }
        JsonWebKey jwk = new JsonWebKey();
        jwk.setKeyType(KeyType.OCTET);
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        jwk.setAlgorithm(algo);
        String encodedSecretKey = Base64UrlUtility.encode(secretKey.getEncoded());
        jwk.setProperty(JsonWebKey.OCTET_KEY_VALUE, encodedSecretKey);
        return jwk;
    }


    private static JweEncryptionProvider createDefaultEncryption(char[] password) {
        KeyEncryptionProvider keyEncryption =
            new PbesHmacAesWrapKeyEncryptionAlgorithm(password, KeyAlgorithm.PBES2_HS256_A128KW);
        return new AesCbcHmacJweEncryption(ContentAlgorithm.A128CBC_HS256, keyEncryption);
    }
    private static JweDecryptionProvider createDefaultDecryption(char[] password) {
        KeyDecryptionProvider keyDecryption = new PbesHmacAesWrapKeyDecryptionAlgorithm(password);
        return new AesCbcHmacJweDecryption(keyDecryption);
    }
    private static JsonWebKey prepareRSAJwk(BigInteger modulus, String algo, String kid) {
        JsonWebKey jwk = new JsonWebKey();
        jwk.setKeyType(KeyType.RSA);
        if (algo != null) {
            if (!AlgorithmUtils.isRsa(algo)) {
                throw new JwkException(""Invalid algorithm"");
            }
            jwk.setAlgorithm(algo);
        }
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        byte[] modulusBytes = modulus.toByteArray();
        int extraBytesLength = modulusBytes.length - modulus.bitLength() / 8;
        if (extraBytesLength > 0) {
            modulusBytes = Arrays.copyOfRange(modulusBytes, extraBytesLength, modulusBytes.length);
        }
        String encodedModulus = Base64UrlUtility.encode(modulusBytes);
        jwk.setProperty(JsonWebKey.RSA_MODULUS, encodedModulus);
        return jwk;
    }
    private static JsonWebKey prepareECJwk(String curve, String kid) {
        JsonWebKey jwk = new JsonWebKey();
        jwk.setKeyType(KeyType.EC);
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        jwk.setProperty(JsonWebKey.EC_CURVE, curve);
        return jwk;
    }
    private static String toString(byte[] bytes) {
        try {
            return new String(bytes, StandardCharsets.UTF_8);
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }
    private static JweHeaders toJweHeaders(String ct) {
        return new JweHeaders(Collections.<String, Object>singletonMap(JoseConstants.HEADER_CONTENT_TYPE, ct));
    }

    public static void includeCertChain(JsonWebKey jwk, JoseHeaders headers, String algo) {
        if (KeyType.RSA.equals(jwk.getKeyType())) {
            List<String> chain = CastUtils.cast((List<?>)jwk.getProperty(JsonWebKey.X509_CHAIN));
            if (chain != null) {
                headers.setX509Chain(chain);
            }
        }
    }

    public static void includePublicKey(JsonWebKey jwk, JoseHeaders headers, String algo) {
        if (KeyType.RSA.equals(jwk.getKeyType())) {
            JsonWebKey jwkPublic = JwkUtils.fromRSAPublicKey(JwkUtils.toRSAPublicKey(jwk), algo);
            if (jwk.getKeyId() != null) {
                jwkPublic.setKeyId(jwk.getKeyId());
            }
            headers.setJsonWebKey(jwkPublic);
        }
    }
}
",0
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwk/JwkUtils.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jwk;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAPrivateCrtKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import javax.crypto.SecretKey;

import org.apache.cxf.Bus;
import org.apache.cxf.common.util.Base64UrlUtility;
import org.apache.cxf.common.util.StringUtils;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.helpers.IOUtils;
import org.apache.cxf.jaxrs.json.basic.JsonMapObjectReaderWriter;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageUtils;
import org.apache.cxf.rs.security.jose.common.JoseConstants;
import org.apache.cxf.rs.security.jose.common.JoseException;
import org.apache.cxf.rs.security.jose.common.JoseHeaders;
import org.apache.cxf.rs.security.jose.common.JoseUtils;
import org.apache.cxf.rs.security.jose.common.KeyManagementUtils;
import org.apache.cxf.rs.security.jose.jwa.AlgorithmUtils;
import org.apache.cxf.rs.security.jose.jwa.ContentAlgorithm;
import org.apache.cxf.rs.security.jose.jwa.KeyAlgorithm;
import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;
import org.apache.cxf.rs.security.jose.jwe.AesCbcHmacJweDecryption;
import org.apache.cxf.rs.security.jose.jwe.AesCbcHmacJweEncryption;
import org.apache.cxf.rs.security.jose.jwe.JweDecryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.JweEncryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.JweHeaders;
import org.apache.cxf.rs.security.jose.jwe.JweUtils;
import org.apache.cxf.rs.security.jose.jwe.KeyDecryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.KeyEncryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.PbesHmacAesWrapKeyDecryptionAlgorithm;
import org.apache.cxf.rs.security.jose.jwe.PbesHmacAesWrapKeyEncryptionAlgorithm;
import org.apache.cxf.rs.security.jose.jws.JwsUtils;
import org.apache.cxf.rt.security.crypto.CryptoUtils;
import org.apache.cxf.rt.security.crypto.MessageDigestUtils;
import org.apache.cxf.rt.security.rs.PrivateKeyPasswordProvider;

public final class JwkUtils {
    private static final Map<KeyType, List<String>> JWK_REQUIRED_FIELDS_MAP;
    static {
        JWK_REQUIRED_FIELDS_MAP = new HashMap<>();
        JWK_REQUIRED_FIELDS_MAP.put(KeyType.RSA, Arrays.asList(
            JsonWebKey.RSA_PUBLIC_EXP, JsonWebKey.KEY_TYPE, JsonWebKey.RSA_MODULUS));
        JWK_REQUIRED_FIELDS_MAP.put(KeyType.EC, Arrays.asList(
            JsonWebKey.EC_CURVE, JsonWebKey.KEY_TYPE, JsonWebKey.EC_X_COORDINATE, JsonWebKey.EC_Y_COORDINATE));
        JWK_REQUIRED_FIELDS_MAP.put(KeyType.OCTET, Arrays.asList(
            JsonWebKey.OCTET_KEY_VALUE, JsonWebKey.KEY_TYPE));
    }
    private JwkUtils() {

    }
    public static String getThumbprint(String keySequence) {
        return getThumbprint(readJwkKey(keySequence));
    }
    public static String getThumbprint(JsonWebKey key) {
        List<String> fields = getRequiredFields(key.getKeyType());
        JsonWebKey thumbprintKey = new JsonWebKey();
        for (String f : fields) {
            thumbprintKey.setProperty(f, key.getProperty(f));
        }
        String json = new JsonMapObjectReaderWriter().toJson(thumbprintKey);
        byte[] digest = MessageDigestUtils.createDigest(json, MessageDigestUtils.ALGO_SHA_256);
        return Base64UrlUtility.encode(digest);
    }
    public static List<String> getRequiredFields(KeyType keyType) {
        return JWK_REQUIRED_FIELDS_MAP.get(keyType);
    }
    public static JsonWebKey readJwkKey(URI uri) throws IOException {
        return readJwkKey(uri.toURL().openStream());
    }
    public static JsonWebKeys readJwkSet(URI uri) throws IOException {
        return readJwkSet(uri.toURL().openStream());
    }
    public static JsonWebKey readJwkKey(InputStream is) throws IOException {
        return readJwkKey(IOUtils.readStringFromStream(is));
    }
    public static JsonWebKeys readJwkSet(InputStream is) throws IOException {
        return readJwkSet(IOUtils.readStringFromStream(is));
    }
    public static JsonWebKey readJwkKey(String jwkJson) {
        return new JwkReaderWriter().jsonToJwk(jwkJson);
    }
    public static JsonWebKeys readJwkSet(String jwksJson) {
        return new JwkReaderWriter().jsonToJwkSet(jwksJson);
    }
    public static String jwkKeyToJson(JsonWebKey jwkKey) {
        return new JwkReaderWriter().jwkToJson(jwkKey);
    }
    public static void jwkKeyToJson(JsonWebKey jwkKey, OutputStream os) throws IOException {
        IOUtils.copy(new ByteArrayInputStream(StringUtils.toBytesUTF8(jwkKeyToJson(jwkKey))), os);
    }
    public static String jwkSetToJson(JsonWebKeys jwkSet) {
        return new JwkReaderWriter().jwkSetToJson(jwkSet);
    }
    public static void jwkSetToJson(JsonWebKeys jwkSet, OutputStream os) throws IOException {
        IOUtils.copy(new ByteArrayInputStream(StringUtils.toBytesUTF8(jwkSetToJson(jwkSet))), os);
    }
    public static String encodeJwkKey(JsonWebKey jwkKey) {
        return Base64UrlUtility.encode(jwkKeyToJson(jwkKey));
    }
    public static String encodeJwkSet(JsonWebKeys jwkSet) {
        return Base64UrlUtility.encode(jwkSetToJson(jwkSet));
    }
    public static JsonWebKey decodeJwkKey(String jwkJson) {
        return readJwkKey(JoseUtils.decodeToString(jwkJson));
    }
    public static JsonWebKeys decodeJwkSet(String jwksJson) {
        return readJwkSet(JoseUtils.decodeToString(jwksJson));
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, char[] password) {
        return encryptJwkSet(jwkSet, createDefaultEncryption(password));
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, JweEncryptionProvider jwe) {
        return jwe.encrypt(StringUtils.toBytesUTF8(new JwkReaderWriter().jwkSetToJson(jwkSet)),
                           toJweHeaders(""jwk-set+json""));
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, PublicKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkSetToJson(jwkSet)),
                                ""jwk-set+json"");
    }
    public static String signJwkSet(JsonWebKeys jwkSet, PrivateKey key, SignatureAlgorithm algo) {
        return JwsUtils.sign(key, algo, jwkSetToJson(jwkSet), ""jwk-set+json"");
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, SecretKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkSetToJson(jwkSet)),
                                ""jwk-set+json"");
    }
    public static JsonWebKeys decryptJwkSet(String jsonJwkSet, char[] password) {
        return decryptJwkSet(jsonJwkSet, createDefaultDecryption(password));
    }
    public static JsonWebKeys decryptJwkSet(String jsonJwkSet, JweDecryptionProvider jwe) {
        return new JwkReaderWriter().jsonToJwkSet(jwe.decrypt(jsonJwkSet).getContentText());
    }
    public static JsonWebKeys decryptJwkSet(PrivateKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                            String jsonJwkSet) {
        return readJwkSet(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwkSet)));
    }
    public static JsonWebKeys verifyJwkSet(PublicKey key, SignatureAlgorithm keyAlgo, String jsonJwk) {
        return readJwkSet(JwsUtils.verify(key, keyAlgo, jsonJwk));
    }
    public static JsonWebKeys decryptJwkSet(SecretKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                            String jsonJwkSet) {
        return readJwkSet(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwkSet)));
    }
    public static JsonWebKeys decryptJwkSet(InputStream is, char[] password)
        throws IOException {
        return decryptJwkSet(is, createDefaultDecryption(password));
    }
    public static JsonWebKeys decryptJwkSet(InputStream is, JweDecryptionProvider jwe)
        throws IOException {
        return new JwkReaderWriter().jsonToJwkSet(
            jwe.decrypt(IOUtils.readStringFromStream(is)).getContentText());
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, char[] password) {
        return encryptJwkKey(jwkKey, createDefaultEncryption(password));
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, JweEncryptionProvider jwe) {
        return jwe.encrypt(StringUtils.toBytesUTF8(new JwkReaderWriter().jwkToJson(jwkKey)),
                           toJweHeaders(""jwk+json""));
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, PublicKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkKeyToJson(jwkKey)),
                                ""jwk+json"");
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, SecretKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkKeyToJson(jwkKey)),
                                ""jwk+json"");
    }
    public static String signJwkKey(JsonWebKey jwkKey, PrivateKey key, SignatureAlgorithm algo) {
        return JwsUtils.sign(key, algo, jwkKeyToJson(jwkKey), ""jwk+json"");
    }
    public static JsonWebKey decryptJwkKey(String jsonJwkKey, char[] password) {
        return decryptJwkKey(jsonJwkKey, createDefaultDecryption(password));
    }
    public static JsonWebKey decryptJwkKey(PrivateKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                           String jsonJwk) {
        return readJwkKey(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwk)));
    }
    public static JsonWebKey verifyJwkKey(PublicKey key, SignatureAlgorithm keyAlgo, String jsonJwk) {
        return readJwkKey(JwsUtils.verify(key, keyAlgo, jsonJwk));
    }
    public static JsonWebKey decryptJwkKey(SecretKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                           String jsonJwk) {
        return readJwkKey(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwk)));
    }
    public static JsonWebKey decryptJwkKey(String jsonJwkKey, JweDecryptionProvider jwe) {
        return new JwkReaderWriter().jsonToJwk(jwe.decrypt(jsonJwkKey).getContentText());
    }
    public static JsonWebKey decryptJwkKey(InputStream is, char[] password)
        throws IOException {
        return decryptJwkKey(is, createDefaultDecryption(password));
    }
    public static JsonWebKey decryptJwkKey(InputStream is, JweDecryptionProvider jwe)
        throws IOException {
        return new JwkReaderWriter().jsonToJwk(
            jwe.decrypt(IOUtils.readStringFromStream(is)).getContentText());
    }
    public static JsonWebKeys loadPublicJwkSet(Message m, Properties props) {
        return loadJwkSet(m, props, null);
    }
    public static JsonWebKeys loadJwkSet(Message m, Properties props, PrivateKeyPasswordProvider cb) {
        String key = (String)props.get(JoseConstants.RSSEC_KEY_STORE_FILE);
        JsonWebKeys jwkSet = null;
        if (key != null && m != null) {
            Object jwkSetProp = m.getExchange().get(key);
            if (jwkSetProp != null && !(jwkSetProp instanceof JsonWebKeys)) {
                throw new JwkException(""Unexpected key store class: "" + jwkSetProp.getClass().getName());
            } else {
                jwkSet = (JsonWebKeys)jwkSetProp;
            }
        }
        if (jwkSet == null) {
            jwkSet = loadJwkSet(props, m != null ? m.getExchange().getBus() : null, cb);
            if (key != null && m != null) {
                m.getExchange().put(key, jwkSet);
            }
        }
        return jwkSet;
    }
    public static JsonWebKeys loadJwkSet(Properties props, Bus bus, PrivateKeyPasswordProvider cb) {
        JweDecryptionProvider decryption = cb != null
            ? new AesCbcHmacJweDecryption(new PbesHmacAesWrapKeyDecryptionAlgorithm(
                cb.getPassword(props))) : null;
        return loadJwkSet(props, bus, decryption);
    }
    public static JsonWebKeys loadJwkSet(Properties props, Bus bus, JweDecryptionProvider jwe) {
        String keyContent = null;
        String keyStoreLoc = props.getProperty(JoseConstants.RSSEC_KEY_STORE_FILE);
        if (keyStoreLoc != null) {
            try {
                InputStream is = JoseUtils.getResourceStream(keyStoreLoc, bus);
                if (is == null) {
                    throw new JwkException(""Error in loading keystore location: "" + keyStoreLoc);
                }
                try (InputStream isResource = is) {
                    keyContent = IOUtils.readStringFromStream(isResource);
                }
            } catch (Exception ex) {
                throw new JwkException(ex);
            }
        } else {
            keyContent = props.getProperty(JoseConstants.RSSEC_KEY_STORE_JWKSET);
            if (keyContent == null) {
                keyContent = props.getProperty(JoseConstants.RSSEC_KEY_STORE_JWKKEY);
            }
        }
        if (jwe != null) {
            keyContent = jwe.decrypt(keyContent).getContentText();
        }
        JwkReaderWriter reader = new JwkReaderWriter();
        if (props.getProperty(JoseConstants.RSSEC_KEY_STORE_JWKKEY) == null) {
            return reader.jsonToJwkSet(keyContent);
        }
        JsonWebKey jwk = reader.jsonToJwk(keyContent);
        return new JsonWebKeys(jwk);
    }

    public static JsonWebKey loadJsonWebKey(Message m, Properties props, KeyOperation keyOper) {
        return loadJsonWebKey(m, props, keyOper, null);
    }
    public static JsonWebKey loadJsonWebKey(Message m, Properties props, KeyOperation keyOper, String inHeaderKid) {
        PrivateKeyPasswordProvider cb = KeyManagementUtils.loadPasswordProvider(m, props, keyOper);
        JsonWebKeys jwkSet = loadJwkSet(m, props, cb);
        String kid = null;
        if (inHeaderKid != null
            && MessageUtils.getContextualBoolean(m, JoseConstants.RSSEC_ACCEPT_PUBLIC_KEY, false)) {
            kid = inHeaderKid;
        } else {
            kid = KeyManagementUtils.getKeyId(m, props, JoseConstants.RSSEC_KEY_STORE_ALIAS, keyOper);
        }
        if (kid != null) {
            return jwkSet.getKey(kid);
        } else if (keyOper != null) {
            List<JsonWebKey> keys = jwkSet.getKeyOperationMap().get(keyOper);
            if (keys != null && keys.size() == 1) {
                return keys.get(0);
            }
        }
        return null;
    }

    public static List<JsonWebKey> loadJsonWebKeys(Message m,
                                                   Properties props,
                                                   KeyOperation keyOper) {
        PrivateKeyPasswordProvider cb = KeyManagementUtils.loadPasswordProvider(m, props, keyOper);
        return loadJsonWebKeys(m, props, keyOper, cb);
    }

    public static List<JsonWebKey> loadJsonWebKeys(Message m,
                                                   Properties props,
                                                   KeyOperation keyOper,
                                                   PrivateKeyPasswordProvider cb) {
        JsonWebKeys jwkSet = loadJwkSet(m, props, cb);
        String kid = KeyManagementUtils.getKeyId(m, props, JoseConstants.RSSEC_KEY_STORE_ALIAS, keyOper);
        if (kid != null) {
            return Collections.singletonList(jwkSet.getKey(kid));
        }
        String kids = KeyManagementUtils.getKeyId(m, props, JoseConstants.RSSEC_KEY_STORE_ALIASES, keyOper);
        if (kids != null) {
            String[] values = kids.split("","");
            List<JsonWebKey> keys = new ArrayList<>(values.length);
            for (String value : values) {
                keys.add(jwkSet.getKey(value));
            }
            return keys;
        }
        if (keyOper != null) {
            List<JsonWebKey> keys = jwkSet.getKeyOperationMap().get(keyOper);
            if (keys != null && keys.size() == 1) {
                return Collections.singletonList(keys.get(0));
            }
        }
        return null;
    }
    public static RSAPublicKey toRSAPublicKey(JsonWebKey jwk) {
        return toRSAPublicKey(jwk, false);
    }
    public static RSAPublicKey toRSAPublicKey(JsonWebKey jwk, boolean checkX509) {
        String encodedModulus = (String)jwk.getProperty(JsonWebKey.RSA_MODULUS);
        String encodedPublicExponent = (String)jwk.getProperty(JsonWebKey.RSA_PUBLIC_EXP);
        if (encodedModulus != null) {
            return CryptoUtils.getRSAPublicKey(encodedModulus, encodedPublicExponent);
        } else if (checkX509) {
            List<X509Certificate> chain = toX509CertificateChain(jwk);
            return (RSAPublicKey)chain.get(0).getPublicKey();
        }
        return null;
    }
    public static List<X509Certificate> toX509CertificateChain(JsonWebKey jwk) {
        List<String> base64EncodedChain = jwk.getX509Chain();
        return KeyManagementUtils.toX509CertificateChain(base64EncodedChain);
    }
    public static JsonWebKey fromECPublicKey(ECPublicKey pk, String curve) {
        return fromECPublicKey(pk, curve, null);
    }
    public static JsonWebKey fromECPublicKey(ECPublicKey pk, String curve, String kid) {
        JsonWebKey jwk = prepareECJwk(curve, kid);
        jwk.setProperty(JsonWebKey.EC_X_COORDINATE,
                        Base64UrlUtility.encode(pk.getW().getAffineX().toByteArray()));
        jwk.setProperty(JsonWebKey.EC_Y_COORDINATE,
                        Base64UrlUtility.encode(pk.getW().getAffineY().toByteArray()));
        return jwk;
    }
    public static JsonWebKey fromECPrivateKey(ECPrivateKey pk, String curve) {
        return fromECPrivateKey(pk, curve, null);
    }
    public static JsonWebKey fromECPrivateKey(ECPrivateKey pk, String curve, String kid) {
        JsonWebKey jwk = prepareECJwk(curve, kid);
        jwk.setProperty(JsonWebKey.EC_PRIVATE_KEY,
                        Base64UrlUtility.encode(pk.getS().toByteArray()));
        return jwk;
    }
    public static JsonWebKey fromRSAPublicKey(RSAPublicKey pk, String algo) {
        return fromRSAPublicKey(pk, algo, null);
    }
    public static JsonWebKey fromRSAPublicKey(RSAPublicKey pk, String algo, String kid) {
        JsonWebKey jwk = prepareRSAJwk(pk.getModulus(), algo, kid);
        String encodedPublicExponent = Base64UrlUtility.encode(pk.getPublicExponent().toByteArray());
        jwk.setProperty(JsonWebKey.RSA_PUBLIC_EXP, encodedPublicExponent);
        return jwk;
    }
    public static JsonWebKey fromPublicKey(PublicKey key, Properties props, String algoProp) {
        JsonWebKey jwk = null;
        if (key instanceof RSAPublicKey) {
            String algo = props.getProperty(algoProp);
            jwk = JwkUtils.fromRSAPublicKey((RSAPublicKey)key, algo);
        } else {
            jwk = JwkUtils.fromECPublicKey((ECPublicKey)key,
                                           props.getProperty(JoseConstants.RSSEC_EC_CURVE));
        }
        String kid = props.getProperty(JoseConstants.RSSEC_KEY_STORE_ALIAS);
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        return jwk;
    }
    public static JsonWebKey fromX509CertificateChain(List<X509Certificate> chain, String algo) {
        JsonWebKey jwk = new JsonWebKey();
        jwk.setAlgorithm(algo);
        List<String> encodedChain = KeyManagementUtils.encodeX509CertificateChain(chain);
        jwk.setX509Chain(encodedChain);
        return jwk;
    }

    public static RSAPrivateKey toRSAPrivateKey(JsonWebKey jwk) {
        String encodedModulus = (String)jwk.getProperty(JsonWebKey.RSA_MODULUS);
        String encodedPrivateExponent = (String)jwk.getProperty(JsonWebKey.RSA_PRIVATE_EXP);
        String encodedPrimeP = (String)jwk.getProperty(JsonWebKey.RSA_FIRST_PRIME_FACTOR);
        if (encodedPrimeP == null) {
            return CryptoUtils.getRSAPrivateKey(encodedModulus, encodedPrivateExponent);
        }
        String encodedPublicExponent = (String)jwk.getProperty(JsonWebKey.RSA_PUBLIC_EXP);
        if (encodedPublicExponent == null) {
            throw new JoseException(""JWK without the public exponent can not be converted to RSAPrivateKey"");
        }
        String encodedPrimeQ = (String)jwk.getProperty(JsonWebKey.RSA_SECOND_PRIME_FACTOR);
        String encodedPrimeExpP = (String)jwk.getProperty(JsonWebKey.RSA_FIRST_PRIME_CRT);
        String encodedPrimeExpQ = (String)jwk.getProperty(JsonWebKey.RSA_SECOND_PRIME_CRT);
        String encodedCrtCoefficient = (String)jwk.getProperty(JsonWebKey.RSA_FIRST_CRT_COEFFICIENT);
        return CryptoUtils.getRSAPrivateKey(encodedModulus,
                                            encodedPublicExponent,
                                            encodedPrivateExponent,
                                            encodedPrimeP,
                                            encodedPrimeQ,
                                            encodedPrimeExpP,
                                            encodedPrimeExpQ,
                                            encodedCrtCoefficient);
    }
    public static JsonWebKey fromRSAPrivateKey(RSAPrivateKey pk, String algo) {
        return fromRSAPrivateKey(pk, algo, null);
    }
    public static JsonWebKey fromRSAPrivateKey(RSAPrivateKey pk, String algo, String kid) {
        JsonWebKey jwk = prepareRSAJwk(pk.getModulus(), algo, kid);
        String encodedPrivateExponent = Base64UrlUtility.encode(pk.getPrivateExponent().toByteArray());
        jwk.setProperty(JsonWebKey.RSA_PRIVATE_EXP, encodedPrivateExponent);
        if (pk instanceof RSAPrivateCrtKey) {
            RSAPrivateCrtKey pkCrt = (RSAPrivateCrtKey)pk;
            jwk.setProperty(JsonWebKey.RSA_PUBLIC_EXP,
                            Base64UrlUtility.encode(pkCrt.getPublicExponent().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_PRIME_FACTOR,
                            Base64UrlUtility.encode(pkCrt.getPrimeP().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_SECOND_PRIME_FACTOR,
                            Base64UrlUtility.encode(pkCrt.getPrimeQ().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_PRIME_CRT,
                            Base64UrlUtility.encode(pkCrt.getPrimeExponentP().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_SECOND_PRIME_CRT,
                            Base64UrlUtility.encode(pkCrt.getPrimeExponentQ().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_CRT_COEFFICIENT,
                            Base64UrlUtility.encode(pkCrt.getCrtCoefficient().toByteArray()));
        }
        // ""oth"" can be populated too if needed
        return jwk;
    }
    public static ECPublicKey toECPublicKey(JsonWebKey jwk) {
        String eCurve = (String)jwk.getProperty(JsonWebKey.EC_CURVE);
        String encodedXCoord = (String)jwk.getProperty(JsonWebKey.EC_X_COORDINATE);
        String encodedYCoord = (String)jwk.getProperty(JsonWebKey.EC_Y_COORDINATE);
        return CryptoUtils.getECPublicKey(eCurve, encodedXCoord, encodedYCoord);
    }
    public static ECPrivateKey toECPrivateKey(JsonWebKey jwk) {
        String eCurve = (String)jwk.getProperty(JsonWebKey.EC_CURVE);
        String encodedPrivateKey = (String)jwk.getProperty(JsonWebKey.EC_PRIVATE_KEY);
        return CryptoUtils.getECPrivateKey(eCurve, encodedPrivateKey);
    }

    public static SecretKey toSecretKey(JsonWebKey jwk) {
        return CryptoUtils.createSecretKeySpec((String)jwk.getProperty(JsonWebKey.OCTET_KEY_VALUE),
                                               AlgorithmUtils.toJavaName(jwk.getAlgorithm()));
    }
    public static JsonWebKey fromSecretKey(SecretKey secretKey, String algo) {
        return fromSecretKey(secretKey, algo, null);
    }
    public static JsonWebKey fromSecretKey(SecretKey secretKey, String algo, String kid) {
        if (!AlgorithmUtils.isOctet(algo)) {
            throw new JwkException(""Invalid algorithm"");
        }
        JsonWebKey jwk = new JsonWebKey();
        jwk.setKeyType(KeyType.OCTET);
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        jwk.setAlgorithm(algo);
        String encodedSecretKey = Base64UrlUtility.encode(secretKey.getEncoded());
        jwk.setProperty(JsonWebKey.OCTET_KEY_VALUE, encodedSecretKey);
        return jwk;
    }


    private static JweEncryptionProvider createDefaultEncryption(char[] password) {
        KeyEncryptionProvider keyEncryption =
            new PbesHmacAesWrapKeyEncryptionAlgorithm(password, KeyAlgorithm.PBES2_HS256_A128KW);
        return new AesCbcHmacJweEncryption(ContentAlgorithm.A128CBC_HS256, keyEncryption);
    }
    private static JweDecryptionProvider createDefaultDecryption(char[] password) {
        KeyDecryptionProvider keyDecryption = new PbesHmacAesWrapKeyDecryptionAlgorithm(password);
        return new AesCbcHmacJweDecryption(keyDecryption);
    }
    private static JsonWebKey prepareRSAJwk(BigInteger modulus, String algo, String kid) {
        JsonWebKey jwk = new JsonWebKey();
        jwk.setKeyType(KeyType.RSA);
        if (algo != null) {
            if (!AlgorithmUtils.isRsa(algo)) {
                throw new JwkException(""Invalid algorithm"");
            }
            jwk.setAlgorithm(algo);
        }
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        byte[] modulusBytes = modulus.toByteArray();
        int extraBytesLength = modulusBytes.length - modulus.bitLength() / 8;
        if (extraBytesLength > 0) {
            modulusBytes = Arrays.copyOfRange(modulusBytes, extraBytesLength, modulusBytes.length);
        }
        String encodedModulus = Base64UrlUtility.encode(modulusBytes);
        jwk.setProperty(JsonWebKey.RSA_MODULUS, encodedModulus);
        return jwk;
    }
    private static JsonWebKey prepareECJwk(String curve, String kid) {
        JsonWebKey jwk = new JsonWebKey();
        jwk.setKeyType(KeyType.EC);
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        jwk.setProperty(JsonWebKey.EC_CURVE, curve);
        return jwk;
    }
    private static String toString(byte[] bytes) {
        try {
            return new String(bytes, StandardCharsets.UTF_8);
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }
    private static JweHeaders toJweHeaders(String ct) {
        return new JweHeaders(Collections.<String, Object>singletonMap(JoseConstants.HEADER_CONTENT_TYPE, ct));
    }

    public static void includeCertChain(JsonWebKey jwk, JoseHeaders headers, String algo) {
        if (KeyType.RSA.equals(jwk.getKeyType())) {
            List<String> chain = CastUtils.cast((List<?>)jwk.getProperty(JsonWebKey.X509_CHAIN));
            if (chain != null) {
                headers.setX509Chain(chain);
            }
        }
    }

    public static void includePublicKey(JsonWebKey jwk, JoseHeaders headers, String algo) {
        if (KeyType.RSA.equals(jwk.getKeyType())) {
            JsonWebKey jwkPublic = JwkUtils.fromRSAPublicKey(JwkUtils.toRSAPublicKey(jwk), algo);
            if (jwk.getKeyId() != null) {
                jwkPublic.setKeyId(jwk.getKeyId());
            }
            headers.setJsonWebKey(jwkPublic);
        }
    }

    public static List<JsonWebKey> stripPrivateParameters(List<JsonWebKey> keys) {
        if (keys == null) {
            return Collections.emptyList();
        }

        List<JsonWebKey> parsedKeys = new ArrayList<>(keys.size());
        Iterator<JsonWebKey> iter = keys.iterator();
        while (iter.hasNext()) {
            JsonWebKey key = iter.next();
            if (!(key.containsProperty(""k"") || key.getKeyType() == KeyType.OCTET)) {
                // We don't allow secret keys in a public keyset
                key.removeProperty(JsonWebKey.RSA_PRIVATE_EXP);
                key.removeProperty(JsonWebKey.RSA_FIRST_PRIME_FACTOR);
                key.removeProperty(JsonWebKey.RSA_SECOND_PRIME_FACTOR);
                key.removeProperty(JsonWebKey.RSA_FIRST_PRIME_CRT);
                key.removeProperty(JsonWebKey.RSA_SECOND_PRIME_CRT);
                key.removeProperty(JsonWebKey.RSA_FIRST_CRT_COEFFICIENT);
                parsedKeys.add(key);
            }
        }
        return parsedKeys;
    }
}
",1
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsUtils.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jws;

import java.security.Key;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Logger;

import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.common.util.PropertyUtils;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageUtils;
import org.apache.cxf.phase.PhaseInterceptorChain;
import org.apache.cxf.rs.security.jose.common.JoseConstants;
import org.apache.cxf.rs.security.jose.common.JoseUtils;
import org.apache.cxf.rs.security.jose.common.KeyManagementUtils;
import org.apache.cxf.rs.security.jose.jwa.AlgorithmUtils;
import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKey;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKeys;
import org.apache.cxf.rs.security.jose.jwk.JwkUtils;
import org.apache.cxf.rs.security.jose.jwk.KeyOperation;
import org.apache.cxf.rs.security.jose.jwk.KeyType;
import org.apache.cxf.rs.security.jose.jwk.PublicKeyUse;
import org.apache.cxf.rt.security.crypto.MessageDigestUtils;

public final class JwsUtils {
    private static final Logger LOG = LogUtils.getL7dLogger(JwsUtils.class);

    private JwsUtils() {

    }
    public static String sign(PrivateKey key, SignatureAlgorithm algo, String content) {
        return sign(key, algo, content, null);
    }


    public static String sign(PrivateKey key, SignatureAlgorithm algo, String content, String ct) {
        return sign(getPrivateKeySignatureProvider(key, algo), content, ct);
    }
    public static String sign(String encodedKey, SignatureAlgorithm algo, String content) {
        return sign(JoseUtils.decode(encodedKey), algo, content);
    }
    public static String sign(byte[] key, SignatureAlgorithm algo, String content) {
        return sign(key, algo, content, null);
    }
    public static String sign(byte[] key, SignatureAlgorithm algo, String content, String ct) {
        return sign(getHmacSignatureProvider(key, algo), content, ct);
    }
    public static String verify(PublicKey key, SignatureAlgorithm algo, String content) {
        JwsCompactConsumer jws = verify(getPublicKeySignatureVerifier(key, algo), content);
        return jws.getDecodedJwsPayload();
    }
    public static String verify(String encodedKey, SignatureAlgorithm algo, String content) {
        return verify(JoseUtils.decode(encodedKey), algo, content);
    }
    public static String verify(byte[] key, SignatureAlgorithm algo, String content) {
        JwsCompactConsumer jws = verify(getHmacSignatureVerifier(key, algo), content);
        return jws.getDecodedJwsPayload();
    }
    public static JwsSignatureProvider getSignatureProvider(JsonWebKey jwk) {
        return getSignatureProvider(jwk, null);
    }
    public static JwsSignatureProvider getSignatureProvider(JsonWebKey jwk,
                                                            SignatureAlgorithm defaultAlgorithm) {
        SignatureAlgorithm sigAlgo = jwk.getAlgorithm() == null ? defaultAlgorithm
            : SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm());
        JwsSignatureProvider theSigProvider = null;
        KeyType keyType = jwk.getKeyType();
        if (KeyType.RSA == keyType) {
            theSigProvider = getPrivateKeySignatureProvider(JwkUtils.toRSAPrivateKey(jwk),
                                                            sigAlgo);
        } else if (KeyType.OCTET == keyType) {
            byte[] key = JoseUtils.decode((String)jwk.getProperty(JsonWebKey.OCTET_KEY_VALUE));
            theSigProvider = getHmacSignatureProvider(key, sigAlgo);
        } else if (KeyType.EC == jwk.getKeyType()) {
            theSigProvider = getPrivateKeySignatureProvider(JwkUtils.toECPrivateKey(jwk),
                                                            sigAlgo);
        }
        return theSigProvider;
    }
    public static JwsSignatureProvider getPrivateKeySignatureProvider(PrivateKey key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }
        if (key instanceof ECPrivateKey) {
            return new EcDsaJwsSignatureProvider((ECPrivateKey)key, algo);
        } else if (key instanceof RSAPrivateKey) {
            return new PrivateKeyJwsSignatureProvider(key, algo);
        }

        return null;
    }
    public static JwsSignatureProvider getHmacSignatureProvider(String encodedKey, SignatureAlgorithm algo) {
        return getHmacSignatureProvider(JoseUtils.decode(encodedKey), algo);
    }
    public static JwsSignatureProvider getHmacSignatureProvider(byte[] key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }
        if (AlgorithmUtils.isHmacSign(algo.getJwaName())) {
            return new HmacJwsSignatureProvider(key, algo);
        }
        return null;
    }
    public static JwsSignatureVerifier getSignatureVerifier(JsonWebKey jwk) {
        return getSignatureVerifier(jwk, null);
    }
    public static JwsSignatureVerifier getSignatureVerifier(JsonWebKey jwk, SignatureAlgorithm defaultAlgorithm) {
        SignatureAlgorithm sigAlgo = jwk.getAlgorithm() == null ? defaultAlgorithm
            : SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm());
        JwsSignatureVerifier theVerifier = null;
        KeyType keyType = jwk.getKeyType();
        if (KeyType.RSA == keyType) {
            theVerifier = getPublicKeySignatureVerifier(JwkUtils.toRSAPublicKey(jwk, true), sigAlgo);
        } else if (KeyType.OCTET == keyType) {
            byte[] key = JoseUtils.decode((String)jwk.getProperty(JsonWebKey.OCTET_KEY_VALUE));
            theVerifier = getHmacSignatureVerifier(key, sigAlgo);
        } else if (KeyType.EC == keyType) {
            theVerifier = getPublicKeySignatureVerifier(JwkUtils.toECPublicKey(jwk), sigAlgo);
        }
        return theVerifier;
    }
    public static JwsSignatureVerifier getPublicKeySignatureVerifier(X509Certificate cert, SignatureAlgorithm algo) {
        if (cert != null) {
            if (algo == null) {
                algo = getDefaultPublicKeyAlgorithm(cert.getPublicKey());
            }
            if (algo == null) {
                LOG.warning(""No signature algorithm was defined"");
                throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
            }    
            
            if (cert.getPublicKey() instanceof RSAPublicKey) {
                return new PublicKeyJwsSignatureVerifier(cert, algo);
            } else if (cert.getPublicKey() instanceof ECPublicKey) {
                return new EcDsaJwsSignatureVerifier(cert, algo);
            }
        }

        return null;
    }
    public static JwsSignatureVerifier getPublicKeySignatureVerifier(PublicKey key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }

        if (key instanceof RSAPublicKey) {
            return new PublicKeyJwsSignatureVerifier(key, algo);
        } else if (key instanceof ECPublicKey) {
            return new EcDsaJwsSignatureVerifier(key, algo);
        }

        return null;
    }
    public static JwsSignatureVerifier getHmacSignatureVerifier(String encodedKey, SignatureAlgorithm algo) {
        return getHmacSignatureVerifier(JoseUtils.decode(encodedKey), algo);
    }
    public static JwsSignatureVerifier getHmacSignatureVerifier(byte[] key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }

        if (AlgorithmUtils.isHmacSign(algo.getJwaName())) {
            return new HmacJwsSignatureVerifier(key, algo);
        }
        return null;
    }

    public static Map<SignatureAlgorithm, List<JwsJsonSignatureEntry>> getJwsJsonSignatureMap(
        List<JwsJsonSignatureEntry> signatures) {
        Map<SignatureAlgorithm, List<JwsJsonSignatureEntry>> map = new HashMap<>();
        for (JwsJsonSignatureEntry entry : signatures) {
            SignatureAlgorithm sigAlgorithm = entry.getUnionHeader().getSignatureAlgorithm();
            List<JwsJsonSignatureEntry> entries = map.get(sigAlgorithm);
            if (entries == null) {
                entries = new ArrayList<>();
            }
            entries.add(entry);
            map.put(sigAlgorithm, entries);
        }
        return map;
    }

    public static JwsSignatureProvider loadSignatureProvider(boolean required) {
        return loadSignatureProvider(null, required);
    }

    public static JwsSignatureProvider loadSignatureProvider(JwsHeaders headers, boolean required) {
        Properties props = loadSignatureOutProperties(required);
        if (props == null) {
            return null;
        }
        JwsSignatureProvider theSigProvider = loadSignatureProvider(props, headers);
        if (headers != null) {
            headers.setSignatureAlgorithm(theSigProvider.getAlgorithm());
        }
        return theSigProvider;
    }
    public static Properties loadSignatureOutProperties(boolean required) {
        Message m = PhaseInterceptorChain.getCurrentMessage();
        return KeyManagementUtils.loadStoreProperties(m, required,
                                                      JoseConstants.RSSEC_SIGNATURE_OUT_PROPS,
                                                      JoseConstants.RSSEC_SIGNATURE_PROPS);

    }
    public static Properties loadSignatureInProperties(boolean required) {
        Message m = PhaseInterceptorChain.getCurrentMessage();
        return KeyManagementUtils.loadStoreProperties(m, required,
                                                      JoseConstants.RSSEC_SIGNATURE_IN_PROPS,
                                                      JoseConstants.RSSEC_SIGNATURE_PROPS);

    }
    public static Properties loadSignatureProperties(String propertiesName, boolean required) {
        Message m = PhaseInterceptorChain.getCurrentMessage();
        return KeyManagementUtils.loadStoreProperties(m, required, propertiesName, null);

    }
    public static Properties loadSignatureProperties(String propertiesLoc, Bus bus) {
        try {
            return JoseUtils.loadProperties(propertiesLoc, bus);
        } catch (Exception ex) {
            throw new JwsException(JwsException.Error.NO_INIT_PROPERTIES, ex);
        }
    }
    public static JwsSignatureVerifier loadSignatureVerifier(boolean required) {
        return loadSignatureVerifier(null, required);
    }
    public static JwsSignatureVerifier loadSignatureVerifier(String propertiesLoc, Bus bus) {
        Properties props = loadSignatureProperties(propertiesLoc, bus);
        return loadSignatureVerifier(props, null);
    }
    public static JwsSignatureVerifier loadSignatureVerifier(JwsHeaders headers, boolean required) {
        Properties props = loadSignatureInProperties(required);
        return loadSignatureVerifier(props, headers);
    }
    
    
    public static boolean validateCriticalHeaders(JwsHeaders headers) {
        //TODO: validate JWS specific constraints
        return JoseUtils.validateCriticalHeaders(headers);
    }
    public static JwsSignatureProvider loadSignatureProvider(Properties props,
                                                             JwsHeaders headers) {
        return loadSignatureProvider(PhaseInterceptorChain.getCurrentMessage(),
                                     props, headers);
    }
    
    public static JwsSignatureProvider loadSignatureProvider(String propertiesLoc, Bus bus) {
        Properties props = loadSignatureProperties(propertiesLoc, bus);
        return loadSignatureProvider(props, null);
    }

    public static JwsSignatureProvider loadSignatureProvider(Message m,
                                                             Properties props,
                                                             JwsHeaders headers) {
        JwsSignatureProvider theSigProvider = null;

        boolean includeCert = 
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT);
        boolean includeCertSha1 = 
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT_SHA1);
        boolean includeCertSha256 =  
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT_SHA256);
        boolean includeKeyId =
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_KEY_ID);

        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {
            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.SIGN);
            if (jwk != null) {
                SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m,
                                                             props,
                                                             SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm()),
                                                             getDefaultKeyAlgorithm(jwk));
                theSigProvider = JwsUtils.getSignatureProvider(jwk, signatureAlgo);

                boolean includePublicKey = 
                    JoseUtils.checkBooleanProperty(headers, props, m, 
                                                   JoseConstants.RSSEC_SIGNATURE_INCLUDE_PUBLIC_KEY);

                if (includeCert) {
                    JwkUtils.includeCertChain(jwk, headers, signatureAlgo.getJwaName());
                }
                if (includeCertSha1) {
                    KeyManagementUtils.setSha1DigestHeader(headers, m, props);
                } else if (includeCertSha256) {
                    KeyManagementUtils.setSha256DigestHeader(headers, m, props);
                }
                if (includePublicKey) {
                    JwkUtils.includePublicKey(jwk, headers, signatureAlgo.getJwaName());
                }
                if (includeKeyId && jwk.getKeyId() != null) {
                    headers.setKeyId(jwk.getKeyId());
                }
            }
        } else {
            SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, null, null);
            if (signatureAlgo == SignatureAlgorithm.NONE) {
                theSigProvider = new NoneJwsSignatureProvider();
            } else {
                PrivateKey pk = KeyManagementUtils.loadPrivateKey(m, props, KeyOperation.SIGN);
                if (signatureAlgo == null) {
                    signatureAlgo = getDefaultPrivateKeyAlgorithm(pk);
                }
                
                theSigProvider = getPrivateKeySignatureProvider(pk, signatureAlgo);
                if (includeCert) {
                    headers.setX509Chain(KeyManagementUtils.loadAndEncodeX509CertificateOrChain(m, props));
                }
                if (includeCertSha1) {
                    KeyManagementUtils.setSha1DigestHeader(headers, m, props);
                } else if (includeCertSha256) {
                    KeyManagementUtils.setSha256DigestHeader(headers, m, props);
                }  
                if (includeKeyId && props.containsKey(JoseConstants.RSSEC_KEY_STORE_ALIAS)) {
                    headers.setKeyId(props.getProperty(JoseConstants.RSSEC_KEY_STORE_ALIAS));
                }
            }
        }
        if (theSigProvider == null) {
            LOG.warning(""Provider is not available"");
            throw new JwsException(JwsException.Error.NO_PROVIDER);
        }
        return theSigProvider;
    }
    public static JwsSignatureVerifier loadSignatureVerifier(Properties props,
                                                             JwsHeaders inHeaders) {
        return loadSignatureVerifier(PhaseInterceptorChain.getCurrentMessage(),
                                     props, inHeaders);
    }
    public static JwsSignatureVerifier loadSignatureVerifier(Message m,
                                                              Properties props,
                                                              JwsHeaders inHeaders) {
        JwsSignatureVerifier theVerifier = null;
        String inHeaderKid = null;
        if (inHeaders != null) {
            inHeaderKid = inHeaders.getKeyId();
            //TODO: optionally validate inHeaders.getAlgorithm against a property in props
            if (inHeaders.getHeader(JoseConstants.HEADER_JSON_WEB_KEY) != null) {
                JsonWebKey publicJwk = inHeaders.getJsonWebKey();
                if (inHeaderKid != null && !inHeaderKid.equals(publicJwk.getKeyId())
                    || !MessageUtils.getContextualBoolean(m, JoseConstants.RSSEC_ACCEPT_PUBLIC_KEY, false)) {
                    throw new JwsException(JwsException.Error.INVALID_KEY);
                }
                return getSignatureVerifier(publicJwk,
                                            inHeaders.getSignatureAlgorithm());
            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_CHAIN) != null) {
                List<X509Certificate> chain = KeyManagementUtils.toX509CertificateChain(inHeaders.getX509Chain());
                KeyManagementUtils.validateCertificateChain(props, chain);
                return getPublicKeySignatureVerifier(chain.get(0),
                                                     inHeaders.getSignatureAlgorithm());
            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_THUMBPRINT) != null) {
                X509Certificate foundCert =
                    KeyManagementUtils.getCertificateFromThumbprint(inHeaders.getX509Thumbprint(),
                                                                    MessageDigestUtils.ALGO_SHA_1,
                                                                    m, props);
                if (foundCert != null) {
                    return getPublicKeySignatureVerifier(foundCert,
                                                         inHeaders.getSignatureAlgorithm());
                }
            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_THUMBPRINT_SHA256) != null) {
                X509Certificate foundCert =
                    KeyManagementUtils.getCertificateFromThumbprint(inHeaders.getX509ThumbprintSHA256(),
                                                                    MessageDigestUtils.ALGO_SHA_256,
                                                                    m, props);
                if (foundCert != null) {
                    return getPublicKeySignatureVerifier(foundCert,
                                                         inHeaders.getSignatureAlgorithm());
                }
            }
        }

        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {
            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.VERIFY, inHeaderKid);
            if (jwk != null) {
                SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props,
                                                             SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm()),
                                                             getDefaultKeyAlgorithm(jwk));
                theVerifier = getSignatureVerifier(jwk, signatureAlgo);
            }

        } else {
            SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, null, null);
            if (signatureAlgo == SignatureAlgorithm.NONE
                && SignatureAlgorithm.NONE.getJwaName().equals(inHeaders.getAlgorithm())) {
                theVerifier = new NoneJwsSignatureVerifier();
            } else {
                X509Certificate[] certs = KeyManagementUtils.loadX509CertificateOrChain(m, props);
                if (certs != null && certs.length > 0) {
                    theVerifier = getPublicKeySignatureVerifier(certs[0], signatureAlgo);
                }
            }
        }
        if (theVerifier == null) {
            LOG.warning(""Verifier is not available"");
            throw new JwsException(JwsException.Error.NO_VERIFIER);
        }
        return theVerifier;
    }
    public static Properties loadJwsProperties(Message m, String propLoc) {
        try {
            return JoseUtils.loadProperties(propLoc, m.getExchange().getBus());
        } catch (Exception ex) {
            LOG.warning(""JWS init properties are not available"");
            throw new JwsException(JwsException.Error.NO_INIT_PROPERTIES);
        }
    }

    public static SignatureAlgorithm getSignatureAlgorithm(Message m, Properties props,
                                               SignatureAlgorithm algo,
                                               SignatureAlgorithm defaultAlgo) {
        if (algo == null) {
            algo = getSignatureAlgorithm(m, props, defaultAlgo);
        }
        return algo;
    }
    public static SignatureAlgorithm getSignatureAlgorithm(Properties props,
                                                           SignatureAlgorithm defaultAlgo) {
        return getSignatureAlgorithm(PhaseInterceptorChain.getCurrentMessage(),
                                     props, defaultAlgo);
    }
    public static SignatureAlgorithm getSignatureAlgorithm(Message m,
                                                           Properties props,
                                                           SignatureAlgorithm defaultAlgo) {
        String algo = KeyManagementUtils.getKeyAlgorithm(m,
                                                  props,
                                                  JoseConstants.RSSEC_SIGNATURE_ALGORITHM,
                                                  defaultAlgo == null ? null : defaultAlgo.getJwaName());
        return SignatureAlgorithm.getAlgorithm(algo);
    }
    private static SignatureAlgorithm getDefaultKeyAlgorithm(JsonWebKey jwk) {
        KeyType keyType = jwk.getKeyType();
        if (KeyType.OCTET == keyType) {
            return SignatureAlgorithm.HS256;
        } else if (KeyType.EC == keyType) {
            return SignatureAlgorithm.ES256;
        } else {
            return SignatureAlgorithm.RS256;
        }
    }
    private static SignatureAlgorithm getDefaultPrivateKeyAlgorithm(PrivateKey key) {
        if (key instanceof RSAPrivateKey) {
            return SignatureAlgorithm.RS256;
        } else if (key instanceof ECPrivateKey) {
            return SignatureAlgorithm.ES256;
        } else {
            return null;
        }
    }
    private static SignatureAlgorithm getDefaultPublicKeyAlgorithm(PublicKey key) {
        if (key instanceof RSAPublicKey) {
            return SignatureAlgorithm.RS256;
        } else if (key instanceof ECPublicKey) {
            return SignatureAlgorithm.ES256;
        } else {
            return null;
        }
    }
    public static JwsCompactConsumer verify(JwsSignatureVerifier v, String content) {
        JwsCompactConsumer jws = new JwsCompactConsumer(content);
        if (!jws.verifySignatureWith(v)) {
            throw new JwsException(JwsException.Error.INVALID_SIGNATURE);
        }
        return jws;
    }
    public static String sign(JwsSignatureProvider jwsSig, String content, String ct) {
        JwsHeaders headers = new JwsHeaders();
        if (ct != null) {
            headers.setContentType(ct);
        }
        JwsCompactProducer jws = new JwsCompactProducer(headers, content);
        jws.signWith(jwsSig);
        return jws.getSignedEncodedJws();
    }
    public static void validateJwsCertificateChain(List<X509Certificate> certs) {

        Properties props = loadSignatureInProperties(true);
        KeyManagementUtils.validateCertificateChain(props, certs);
    }
    public static boolean isPayloadUnencoded(JwsHeaders jwsHeaders) {
        return jwsHeaders.getPayloadEncodingStatus() == Boolean.FALSE;
    }

    public static void checkSignatureKeySize(Key key) {
        if (key instanceof RSAKey && ((RSAKey)key).getModulus().bitLength() < 2048) {
            LOG.fine(""A key of size: "" + ((RSAKey)key).getModulus().bitLength()
                     + "" was used with an RSA signature algorithm. 2048 is the minimum size that is accepted"");
            throw new JwsException(JwsException.Error.INVALID_KEY);
        }
    }
    public static JsonWebKeys loadPublicVerificationKeys(Message m, Properties props) {
        String storeType = props.getProperty(JoseConstants.RSSEC_KEY_STORE_TYPE);
        if (""jwk"".equals(storeType)) {
            return JwkUtils.loadPublicJwkSet(m, props);
        }
        X509Certificate[] certs = null;
        if (PropertyUtils.isTrue(props.get(JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT))) {
            certs = KeyManagementUtils.loadX509CertificateOrChain(m, props);
        }
        PublicKey key = certs != null && certs.length > 0
            ? certs[0].getPublicKey() : KeyManagementUtils.loadPublicKey(m, props);
        JsonWebKey jwk = JwkUtils.fromPublicKey(key, props, JoseConstants.RSSEC_SIGNATURE_ALGORITHM);
        jwk.setPublicKeyUse(PublicKeyUse.SIGN);
        if (certs != null) {
            jwk.setX509Chain(KeyManagementUtils.encodeX509CertificateChain(certs));
        }
        return new JsonWebKeys(jwk);
    }
}
",0
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsUtils.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jws;

import java.security.Key;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Logger;

import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.common.util.PropertyUtils;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageUtils;
import org.apache.cxf.phase.PhaseInterceptorChain;
import org.apache.cxf.rs.security.jose.common.JoseConstants;
import org.apache.cxf.rs.security.jose.common.JoseException;
import org.apache.cxf.rs.security.jose.common.JoseUtils;
import org.apache.cxf.rs.security.jose.common.KeyManagementUtils;
import org.apache.cxf.rs.security.jose.jwa.AlgorithmUtils;
import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKey;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKeys;
import org.apache.cxf.rs.security.jose.jwk.JwkUtils;
import org.apache.cxf.rs.security.jose.jwk.KeyOperation;
import org.apache.cxf.rs.security.jose.jwk.KeyType;
import org.apache.cxf.rs.security.jose.jwk.PublicKeyUse;
import org.apache.cxf.rt.security.crypto.MessageDigestUtils;

public final class JwsUtils {
    private static final Logger LOG = LogUtils.getL7dLogger(JwsUtils.class);

    private JwsUtils() {

    }
    public static String sign(PrivateKey key, SignatureAlgorithm algo, String content) {
        return sign(key, algo, content, null);
    }


    public static String sign(PrivateKey key, SignatureAlgorithm algo, String content, String ct) {
        return sign(getPrivateKeySignatureProvider(key, algo), content, ct);
    }
    public static String sign(String encodedKey, SignatureAlgorithm algo, String content) {
        return sign(JoseUtils.decode(encodedKey), algo, content);
    }
    public static String sign(byte[] key, SignatureAlgorithm algo, String content) {
        return sign(key, algo, content, null);
    }
    public static String sign(byte[] key, SignatureAlgorithm algo, String content, String ct) {
        return sign(getHmacSignatureProvider(key, algo), content, ct);
    }
    public static String verify(PublicKey key, SignatureAlgorithm algo, String content) {
        JwsCompactConsumer jws = verify(getPublicKeySignatureVerifier(key, algo), content);
        return jws.getDecodedJwsPayload();
    }
    public static String verify(String encodedKey, SignatureAlgorithm algo, String content) {
        return verify(JoseUtils.decode(encodedKey), algo, content);
    }
    public static String verify(byte[] key, SignatureAlgorithm algo, String content) {
        JwsCompactConsumer jws = verify(getHmacSignatureVerifier(key, algo), content);
        return jws.getDecodedJwsPayload();
    }
    public static JwsSignatureProvider getSignatureProvider(JsonWebKey jwk) {
        return getSignatureProvider(jwk, null);
    }
    public static JwsSignatureProvider getSignatureProvider(JsonWebKey jwk,
                                                            SignatureAlgorithm defaultAlgorithm) {
        SignatureAlgorithm sigAlgo = jwk.getAlgorithm() == null ? defaultAlgorithm
            : SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm());
        JwsSignatureProvider theSigProvider = null;
        KeyType keyType = jwk.getKeyType();
        if (KeyType.RSA == keyType) {
            theSigProvider = getPrivateKeySignatureProvider(JwkUtils.toRSAPrivateKey(jwk),
                                                            sigAlgo);
        } else if (KeyType.OCTET == keyType) {
            byte[] key = JoseUtils.decode((String)jwk.getProperty(JsonWebKey.OCTET_KEY_VALUE));
            theSigProvider = getHmacSignatureProvider(key, sigAlgo);
        } else if (KeyType.EC == jwk.getKeyType()) {
            theSigProvider = getPrivateKeySignatureProvider(JwkUtils.toECPrivateKey(jwk),
                                                            sigAlgo);
        }
        return theSigProvider;
    }
    public static JwsSignatureProvider getPrivateKeySignatureProvider(PrivateKey key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }
        if (key instanceof ECPrivateKey) {
            return new EcDsaJwsSignatureProvider((ECPrivateKey)key, algo);
        } else if (key instanceof RSAPrivateKey) {
            return new PrivateKeyJwsSignatureProvider(key, algo);
        }

        return null;
    }
    public static JwsSignatureProvider getHmacSignatureProvider(String encodedKey, SignatureAlgorithm algo) {
        return getHmacSignatureProvider(JoseUtils.decode(encodedKey), algo);
    }
    public static JwsSignatureProvider getHmacSignatureProvider(byte[] key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }
        if (AlgorithmUtils.isHmacSign(algo.getJwaName())) {
            return new HmacJwsSignatureProvider(key, algo);
        }
        return null;
    }
    public static JwsSignatureVerifier getSignatureVerifier(JsonWebKey jwk) {
        return getSignatureVerifier(jwk, null);
    }
    public static JwsSignatureVerifier getSignatureVerifier(JsonWebKey jwk, SignatureAlgorithm defaultAlgorithm) {
        SignatureAlgorithm sigAlgo = jwk.getAlgorithm() == null ? defaultAlgorithm
            : SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm());
        JwsSignatureVerifier theVerifier = null;
        KeyType keyType = jwk.getKeyType();
        if (KeyType.RSA == keyType) {
            theVerifier = getPublicKeySignatureVerifier(JwkUtils.toRSAPublicKey(jwk, true), sigAlgo);
        } else if (KeyType.OCTET == keyType) {
            byte[] key = JoseUtils.decode((String)jwk.getProperty(JsonWebKey.OCTET_KEY_VALUE));
            theVerifier = getHmacSignatureVerifier(key, sigAlgo);
        } else if (KeyType.EC == keyType) {
            theVerifier = getPublicKeySignatureVerifier(JwkUtils.toECPublicKey(jwk), sigAlgo);
        }
        return theVerifier;
    }
    public static JwsSignatureVerifier getPublicKeySignatureVerifier(X509Certificate cert, SignatureAlgorithm algo) {
        if (cert != null) {
            if (algo == null) {
                algo = getDefaultPublicKeyAlgorithm(cert.getPublicKey());
            }
            if (algo == null) {
                LOG.warning(""No signature algorithm was defined"");
                throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
            }

            if (cert.getPublicKey() instanceof RSAPublicKey) {
                return new PublicKeyJwsSignatureVerifier(cert, algo);
            } else if (cert.getPublicKey() instanceof ECPublicKey) {
                return new EcDsaJwsSignatureVerifier(cert, algo);
            }
        }

        return null;
    }
    public static JwsSignatureVerifier getPublicKeySignatureVerifier(PublicKey key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }

        if (key instanceof RSAPublicKey) {
            return new PublicKeyJwsSignatureVerifier(key, algo);
        } else if (key instanceof ECPublicKey) {
            return new EcDsaJwsSignatureVerifier(key, algo);
        }

        return null;
    }
    public static JwsSignatureVerifier getHmacSignatureVerifier(String encodedKey, SignatureAlgorithm algo) {
        return getHmacSignatureVerifier(JoseUtils.decode(encodedKey), algo);
    }
    public static JwsSignatureVerifier getHmacSignatureVerifier(byte[] key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }

        if (AlgorithmUtils.isHmacSign(algo.getJwaName())) {
            return new HmacJwsSignatureVerifier(key, algo);
        }
        return null;
    }

    public static Map<SignatureAlgorithm, List<JwsJsonSignatureEntry>> getJwsJsonSignatureMap(
        List<JwsJsonSignatureEntry> signatures) {
        Map<SignatureAlgorithm, List<JwsJsonSignatureEntry>> map = new HashMap<>();
        for (JwsJsonSignatureEntry entry : signatures) {
            SignatureAlgorithm sigAlgorithm = entry.getUnionHeader().getSignatureAlgorithm();
            List<JwsJsonSignatureEntry> entries = map.get(sigAlgorithm);
            if (entries == null) {
                entries = new ArrayList<>();
            }
            entries.add(entry);
            map.put(sigAlgorithm, entries);
        }
        return map;
    }

    public static JwsSignatureProvider loadSignatureProvider(boolean required) {
        return loadSignatureProvider(null, required);
    }

    public static JwsSignatureProvider loadSignatureProvider(JwsHeaders headers, boolean required) {
        Properties props = loadSignatureOutProperties(required);
        if (props == null) {
            return null;
        }
        JwsSignatureProvider theSigProvider = loadSignatureProvider(props, headers);
        if (headers != null) {
            headers.setSignatureAlgorithm(theSigProvider.getAlgorithm());
        }
        return theSigProvider;
    }
    public static Properties loadSignatureOutProperties(boolean required) {
        Message m = PhaseInterceptorChain.getCurrentMessage();
        return KeyManagementUtils.loadStoreProperties(m, required,
                                                      JoseConstants.RSSEC_SIGNATURE_OUT_PROPS,
                                                      JoseConstants.RSSEC_SIGNATURE_PROPS);

    }
    public static Properties loadSignatureInProperties(boolean required) {
        Message m = PhaseInterceptorChain.getCurrentMessage();
        return KeyManagementUtils.loadStoreProperties(m, required,
                                                      JoseConstants.RSSEC_SIGNATURE_IN_PROPS,
                                                      JoseConstants.RSSEC_SIGNATURE_PROPS);

    }
    public static Properties loadSignatureProperties(String propertiesName, boolean required) {
        Message m = PhaseInterceptorChain.getCurrentMessage();
        return KeyManagementUtils.loadStoreProperties(m, required, propertiesName, null);

    }
    public static Properties loadSignatureProperties(String propertiesLoc, Bus bus) {
        try {
            return JoseUtils.loadProperties(propertiesLoc, bus);
        } catch (Exception ex) {
            throw new JwsException(JwsException.Error.NO_INIT_PROPERTIES, ex);
        }
    }
    public static JwsSignatureVerifier loadSignatureVerifier(boolean required) {
        return loadSignatureVerifier(null, required);
    }
    public static JwsSignatureVerifier loadSignatureVerifier(String propertiesLoc, Bus bus) {
        Properties props = loadSignatureProperties(propertiesLoc, bus);
        return loadSignatureVerifier(props, null);
    }
    public static JwsSignatureVerifier loadSignatureVerifier(JwsHeaders headers, boolean required) {
        Properties props = loadSignatureInProperties(required);
        return loadSignatureVerifier(props, headers);
    }


    public static boolean validateCriticalHeaders(JwsHeaders headers) {
        //TODO: validate JWS specific constraints
        return JoseUtils.validateCriticalHeaders(headers);
    }
    public static JwsSignatureProvider loadSignatureProvider(Properties props,
                                                             JwsHeaders headers) {
        return loadSignatureProvider(PhaseInterceptorChain.getCurrentMessage(),
                                     props, headers);
    }

    public static JwsSignatureProvider loadSignatureProvider(String propertiesLoc, Bus bus) {
        Properties props = loadSignatureProperties(propertiesLoc, bus);
        return loadSignatureProvider(props, null);
    }

    public static JwsSignatureProvider loadSignatureProvider(Message m,
                                                             Properties props,
                                                             JwsHeaders headers) {
        JwsSignatureProvider theSigProvider = null;

        boolean includeCert =
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT);
        boolean includeCertSha1 =
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT_SHA1);
        boolean includeCertSha256 =
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT_SHA256);
        boolean includeKeyId =
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_KEY_ID);

        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {
            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.SIGN);
            if (jwk != null) {
                SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m,
                                                             props,
                                                             SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm()),
                                                             getDefaultKeyAlgorithm(jwk));
                theSigProvider = JwsUtils.getSignatureProvider(jwk, signatureAlgo);

                boolean includePublicKey =
                    JoseUtils.checkBooleanProperty(headers, props, m,
                                                   JoseConstants.RSSEC_SIGNATURE_INCLUDE_PUBLIC_KEY);

                if (includeCert) {
                    JwkUtils.includeCertChain(jwk, headers, signatureAlgo.getJwaName());
                }
                if (includeCertSha1) {
                    KeyManagementUtils.setSha1DigestHeader(headers, m, props);
                } else if (includeCertSha256) {
                    KeyManagementUtils.setSha256DigestHeader(headers, m, props);
                }
                if (includePublicKey) {
                    JwkUtils.includePublicKey(jwk, headers, signatureAlgo.getJwaName());
                }
                if (includeKeyId && jwk.getKeyId() != null) {
                    headers.setKeyId(jwk.getKeyId());
                }
            }
        } else {
            SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, null, null);
            if (signatureAlgo == SignatureAlgorithm.NONE) {
                theSigProvider = new NoneJwsSignatureProvider();
            } else {
                PrivateKey pk = KeyManagementUtils.loadPrivateKey(m, props, KeyOperation.SIGN);
                if (signatureAlgo == null) {
                    signatureAlgo = getDefaultPrivateKeyAlgorithm(pk);
                }

                theSigProvider = getPrivateKeySignatureProvider(pk, signatureAlgo);
                if (includeCert) {
                    headers.setX509Chain(KeyManagementUtils.loadAndEncodeX509CertificateOrChain(m, props));
                }
                if (includeCertSha1) {
                    KeyManagementUtils.setSha1DigestHeader(headers, m, props);
                } else if (includeCertSha256) {
                    KeyManagementUtils.setSha256DigestHeader(headers, m, props);
                }
                if (includeKeyId && props.containsKey(JoseConstants.RSSEC_KEY_STORE_ALIAS)) {
                    headers.setKeyId(props.getProperty(JoseConstants.RSSEC_KEY_STORE_ALIAS));
                }
            }
        }
        if (theSigProvider == null) {
            LOG.warning(""Provider is not available"");
            throw new JwsException(JwsException.Error.NO_PROVIDER);
        }
        return theSigProvider;
    }
    public static JwsSignatureVerifier loadSignatureVerifier(Properties props,
                                                             JwsHeaders inHeaders) {
        return loadSignatureVerifier(PhaseInterceptorChain.getCurrentMessage(),
                                     props, inHeaders);
    }
    public static JwsSignatureVerifier loadSignatureVerifier(Message m,
                                                              Properties props,
                                                              JwsHeaders inHeaders) {
        JwsSignatureVerifier theVerifier = null;
        String inHeaderKid = null;
        if (inHeaders != null) {
            inHeaderKid = inHeaders.getKeyId();
            //TODO: optionally validate inHeaders.getAlgorithm against a property in props
            if (inHeaders.getHeader(JoseConstants.HEADER_JSON_WEB_KEY) != null) {
                JsonWebKey publicJwk = inHeaders.getJsonWebKey();
                if (inHeaderKid != null && !inHeaderKid.equals(publicJwk.getKeyId())
                    || !MessageUtils.getContextualBoolean(m, JoseConstants.RSSEC_ACCEPT_PUBLIC_KEY, false)) {
                    throw new JwsException(JwsException.Error.INVALID_KEY);
                }
                return getSignatureVerifier(publicJwk,
                                            inHeaders.getSignatureAlgorithm());
            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_CHAIN) != null) {
                List<X509Certificate> chain = KeyManagementUtils.toX509CertificateChain(inHeaders.getX509Chain());
                KeyManagementUtils.validateCertificateChain(props, chain);
                return getPublicKeySignatureVerifier(chain.get(0),
                                                     inHeaders.getSignatureAlgorithm());
            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_THUMBPRINT) != null) {
                X509Certificate foundCert =
                    KeyManagementUtils.getCertificateFromThumbprint(inHeaders.getX509Thumbprint(),
                                                                    MessageDigestUtils.ALGO_SHA_1,
                                                                    m, props);
                if (foundCert != null) {
                    return getPublicKeySignatureVerifier(foundCert,
                                                         inHeaders.getSignatureAlgorithm());
                }
            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_THUMBPRINT_SHA256) != null) {
                X509Certificate foundCert =
                    KeyManagementUtils.getCertificateFromThumbprint(inHeaders.getX509ThumbprintSHA256(),
                                                                    MessageDigestUtils.ALGO_SHA_256,
                                                                    m, props);
                if (foundCert != null) {
                    return getPublicKeySignatureVerifier(foundCert,
                                                         inHeaders.getSignatureAlgorithm());
                }
            }
        }

        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {
            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.VERIFY, inHeaderKid);
            if (jwk != null) {
                SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props,
                                                             SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm()),
                                                             getDefaultKeyAlgorithm(jwk));
                theVerifier = getSignatureVerifier(jwk, signatureAlgo);
            }

        } else {
            SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, null, null);
            if (signatureAlgo == SignatureAlgorithm.NONE
                && SignatureAlgorithm.NONE.getJwaName().equals(inHeaders.getAlgorithm())) {
                theVerifier = new NoneJwsSignatureVerifier();
            } else {
                X509Certificate[] certs = KeyManagementUtils.loadX509CertificateOrChain(m, props);
                if (certs != null && certs.length > 0) {
                    theVerifier = getPublicKeySignatureVerifier(certs[0], signatureAlgo);
                }
            }
        }
        if (theVerifier == null) {
            LOG.warning(""Verifier is not available"");
            throw new JwsException(JwsException.Error.NO_VERIFIER);
        }
        return theVerifier;
    }
    public static Properties loadJwsProperties(Message m, String propLoc) {
        try {
            return JoseUtils.loadProperties(propLoc, m.getExchange().getBus());
        } catch (Exception ex) {
            LOG.warning(""JWS init properties are not available"");
            throw new JwsException(JwsException.Error.NO_INIT_PROPERTIES);
        }
    }

    public static SignatureAlgorithm getSignatureAlgorithm(Message m, Properties props,
                                               SignatureAlgorithm algo,
                                               SignatureAlgorithm defaultAlgo) {
        if (algo == null) {
            algo = getSignatureAlgorithm(m, props, defaultAlgo);
        }
        return algo;
    }
    public static SignatureAlgorithm getSignatureAlgorithm(Properties props,
                                                           SignatureAlgorithm defaultAlgo) {
        return getSignatureAlgorithm(PhaseInterceptorChain.getCurrentMessage(),
                                     props, defaultAlgo);
    }
    public static SignatureAlgorithm getSignatureAlgorithm(Message m,
                                                           Properties props,
                                                           SignatureAlgorithm defaultAlgo) {
        String algo = KeyManagementUtils.getKeyAlgorithm(m,
                                                  props,
                                                  JoseConstants.RSSEC_SIGNATURE_ALGORITHM,
                                                  defaultAlgo == null ? null : defaultAlgo.getJwaName());
        return SignatureAlgorithm.getAlgorithm(algo);
    }
    private static SignatureAlgorithm getDefaultKeyAlgorithm(JsonWebKey jwk) {
        KeyType keyType = jwk.getKeyType();
        if (KeyType.OCTET == keyType) {
            return SignatureAlgorithm.HS256;
        } else if (KeyType.EC == keyType) {
            return SignatureAlgorithm.ES256;
        } else {
            return SignatureAlgorithm.RS256;
        }
    }
    private static SignatureAlgorithm getDefaultPrivateKeyAlgorithm(PrivateKey key) {
        if (key instanceof RSAPrivateKey) {
            return SignatureAlgorithm.RS256;
        } else if (key instanceof ECPrivateKey) {
            return SignatureAlgorithm.ES256;
        } else {
            return null;
        }
    }
    private static SignatureAlgorithm getDefaultPublicKeyAlgorithm(PublicKey key) {
        if (key instanceof RSAPublicKey) {
            return SignatureAlgorithm.RS256;
        } else if (key instanceof ECPublicKey) {
            return SignatureAlgorithm.ES256;
        } else {
            return null;
        }
    }
    public static JwsCompactConsumer verify(JwsSignatureVerifier v, String content) {
        JwsCompactConsumer jws = new JwsCompactConsumer(content);
        if (!jws.verifySignatureWith(v)) {
            throw new JwsException(JwsException.Error.INVALID_SIGNATURE);
        }
        return jws;
    }
    public static String sign(JwsSignatureProvider jwsSig, String content, String ct) {
        JwsHeaders headers = new JwsHeaders();
        if (ct != null) {
            headers.setContentType(ct);
        }
        JwsCompactProducer jws = new JwsCompactProducer(headers, content);
        jws.signWith(jwsSig);
        return jws.getSignedEncodedJws();
    }
    public static void validateJwsCertificateChain(List<X509Certificate> certs) {

        Properties props = loadSignatureInProperties(true);
        KeyManagementUtils.validateCertificateChain(props, certs);
    }
    public static boolean isPayloadUnencoded(JwsHeaders jwsHeaders) {
        return jwsHeaders.getPayloadEncodingStatus() == Boolean.FALSE;
    }

    public static void checkSignatureKeySize(Key key) {
        if (key instanceof RSAKey && ((RSAKey)key).getModulus().bitLength() < 2048) {
            LOG.fine(""A key of size: "" + ((RSAKey)key).getModulus().bitLength()
                     + "" was used with an RSA signature algorithm. 2048 is the minimum size that is accepted"");
            throw new JwsException(JwsException.Error.INVALID_KEY);
        }
    }

    @Deprecated
    public static JsonWebKeys loadPublicVerificationKeys(Message m, Properties props) {
        return loadPublicVerificationKeys(m, props, true);
    }

    public static JsonWebKeys loadPublicVerificationKeys(Message m, Properties props, boolean stripPrivateParameters) {
        String storeType = props.getProperty(JoseConstants.RSSEC_KEY_STORE_TYPE);
        if (""jwk"".equals(storeType)) {
            List<JsonWebKey> jsonWebKeys = JwkUtils.loadJsonWebKeys(m, props, KeyOperation.SIGN, null);
            if (jsonWebKeys == null || jsonWebKeys.isEmpty()) {
                throw new JoseException(""Error loading keys"");
            }
            return new JsonWebKeys(stripPrivateParameters ? JwkUtils.stripPrivateParameters(jsonWebKeys) : jsonWebKeys);
        }
        X509Certificate[] certs = null;
        if (PropertyUtils.isTrue(props.get(JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT))) {
            certs = KeyManagementUtils.loadX509CertificateOrChain(m, props);
        }
        PublicKey key = certs != null && certs.length > 0
            ? certs[0].getPublicKey() : KeyManagementUtils.loadPublicKey(m, props);
        JsonWebKey jwk = JwkUtils.fromPublicKey(key, props, JoseConstants.RSSEC_SIGNATURE_ALGORITHM);
        jwk.setPublicKeyUse(PublicKeyUse.SIGN);
        if (certs != null) {
            jwk.setX509Chain(KeyManagementUtils.encodeX509CertificateChain(certs));
        }
        return new JsonWebKeys(jwk);
    }
}
",1
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/test/java/org/apache/cxf/rs/security/jose/jws/JwsUtilsTest.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jws;

import java.util.List;
import java.util.Properties;

import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.rs.security.jose.common.JoseConstants;
import org.apache.cxf.rs.security.jose.jwa.AlgorithmUtils;
import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKey;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKeys;
import org.apache.cxf.rs.security.jose.jwk.KeyType;

import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

public class JwsUtilsTest {

    @Test
    public void testSignatureAlgorithm() {
        assertTrue(AlgorithmUtils.isRsaSign(SignatureAlgorithm.RS256));
        assertFalse(AlgorithmUtils.isRsaSign(SignatureAlgorithm.NONE));

        try {
            AlgorithmUtils.RSA_SHA_SIGN_SET.add(SignatureAlgorithm.NONE.getJwaName());
            fail(""Failure expected on trying to modify the algorithm lists"");
        } catch (UnsupportedOperationException ex) {
            // expected
        }
    }

    @Test
    public void testLoadSignatureProviderFromJKS() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        JwsHeaders headers = new JwsHeaders();
        JwsSignatureProvider jws = JwsUtils.loadSignatureProvider(createMessage(),
                                                                  p,
                                                                  headers);
        assertNotNull(jws);
        assertEquals(""alice"", headers.getKeyId());
    }
    @Test
    public void testLoadSignatureVerifierFromJKS() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        JwsSignatureVerifier jws = JwsUtils.loadSignatureVerifier(createMessage(),
                                                                  p,
                                                                  new JwsHeaders());
        assertNotNull(jws);
    }
    @Test
    public void testLoadVerificationKey() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        JsonWebKeys keySet = JwsUtils.loadPublicVerificationKeys(createMessage(), p);
        assertEquals(1, keySet.asMap().size());
        List<JsonWebKey> keys = keySet.getRsaKeys();
        assertEquals(1, keys.size());
        JsonWebKey key = keys.get(0);
        assertEquals(KeyType.RSA, key.getKeyType());
        assertEquals(""alice"", key.getKeyId());
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_PUBLIC_EXP));
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_MODULUS));
        assertNull(key.getKeyProperty(JsonWebKey.RSA_PRIVATE_EXP));
        assertNull(key.getX509Chain());
    }
    @Test
    public void testLoadVerificationKeyWithCert() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        p.put(JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT, true);
        JsonWebKeys keySet = JwsUtils.loadPublicVerificationKeys(createMessage(), p);
        assertEquals(1, keySet.asMap().size());
        List<JsonWebKey> keys = keySet.getRsaKeys();
        assertEquals(1, keys.size());
        JsonWebKey key = keys.get(0);
        assertEquals(KeyType.RSA, key.getKeyType());
        assertEquals(""alice"", key.getKeyId());
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_PUBLIC_EXP));
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_MODULUS));
        assertNull(key.getKeyProperty(JsonWebKey.RSA_PRIVATE_EXP));
        List<String> chain = key.getX509Chain();
        assertNotNull(chain);
        assertEquals(2, chain.size());
    }

    private Message createMessage() {
        Message m = new MessageImpl();
        Exchange e = new ExchangeImpl();
        e.put(Bus.class, BusFactory.getThreadDefaultBus());
        m.setExchange(e);
        m.put(JoseConstants.RSSEC_SIGNATURE_INCLUDE_KEY_ID, ""true"");
        e.setInMessage(m);
        return m;
    }
}",0
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/test/java/org/apache/cxf/rs/security/jose/jws/JwsUtilsTest.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jws;

import java.util.List;
import java.util.Properties;

import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.rs.security.jose.common.JoseConstants;
import org.apache.cxf.rs.security.jose.jwa.AlgorithmUtils;
import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKey;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKeys;
import org.apache.cxf.rs.security.jose.jwk.KeyType;

import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

public class JwsUtilsTest {

    @Test
    public void testSignatureAlgorithm() {
        assertTrue(AlgorithmUtils.isRsaSign(SignatureAlgorithm.RS256));
        assertFalse(AlgorithmUtils.isRsaSign(SignatureAlgorithm.NONE));

        try {
            AlgorithmUtils.RSA_SHA_SIGN_SET.add(SignatureAlgorithm.NONE.getJwaName());
            fail(""Failure expected on trying to modify the algorithm lists"");
        } catch (UnsupportedOperationException ex) {
            // expected
        }
    }

    @Test
    public void testLoadSignatureProviderFromJKS() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        JwsHeaders headers = new JwsHeaders();
        JwsSignatureProvider jws = JwsUtils.loadSignatureProvider(createMessage(),
                                                                  p,
                                                                  headers);
        assertNotNull(jws);
        assertEquals(""alice"", headers.getKeyId());
    }
    @Test
    public void testLoadSignatureVerifierFromJKS() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        JwsSignatureVerifier jws = JwsUtils.loadSignatureVerifier(createMessage(),
                                                                  p,
                                                                  new JwsHeaders());
        assertNotNull(jws);
    }
    @Test
    public void testLoadVerificationKey() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        JsonWebKeys keySet = JwsUtils.loadPublicVerificationKeys(createMessage(), p, true);
        assertEquals(1, keySet.asMap().size());
        List<JsonWebKey> keys = keySet.getRsaKeys();
        assertEquals(1, keys.size());
        JsonWebKey key = keys.get(0);
        assertEquals(KeyType.RSA, key.getKeyType());
        assertEquals(""alice"", key.getKeyId());
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_PUBLIC_EXP));
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_MODULUS));
        assertNull(key.getKeyProperty(JsonWebKey.RSA_PRIVATE_EXP));
        assertNull(key.getX509Chain());
    }
    @Test
    public void testLoadVerificationKeyWithCert() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        p.put(JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT, true);
        JsonWebKeys keySet = JwsUtils.loadPublicVerificationKeys(createMessage(), p, true);
        assertEquals(1, keySet.asMap().size());
        List<JsonWebKey> keys = keySet.getRsaKeys();
        assertEquals(1, keys.size());
        JsonWebKey key = keys.get(0);
        assertEquals(KeyType.RSA, key.getKeyType());
        assertEquals(""alice"", key.getKeyId());
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_PUBLIC_EXP));
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_MODULUS));
        assertNull(key.getKeyProperty(JsonWebKey.RSA_PRIVATE_EXP));
        List<String> chain = key.getX509Chain();
        assertNotNull(chain);
        assertEquals(2, chain.size());
    }

    private Message createMessage() {
        Message m = new MessageImpl();
        Exchange e = new ExchangeImpl();
        e.put(Bus.class, BusFactory.getThreadDefaultBus());
        m.setExchange(e);
        m.put(JoseConstants.RSSEC_SIGNATURE_INCLUDE_KEY_ID, ""true"");
        e.setInMessage(m);
        return m;
    }
}
",1
CVE-2019-12423,rt/rs/security/sso/oidc/src/main/java/org/apache/cxf/rs/security/oidc/idp/OidcKeysService.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.oidc.idp;

import java.util.Properties;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;

import org.apache.cxf.jaxrs.client.WebClient;
import org.apache.cxf.jaxrs.utils.JAXRSUtils;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKeys;
import org.apache.cxf.rs.security.jose.jws.JwsUtils;

@Path(""keys"")
public class OidcKeysService {

    private volatile JsonWebKeys keySet;
    private WebClient keyServiceClient;

    @GET
    @Produces(""application/json"")
    public JsonWebKeys getPublicVerificationKeys() {
        if (keySet == null) {
            if (keyServiceClient == null) {
                keySet = getFromLocalStore();
            } else {
                keySet = keyServiceClient.get(JsonWebKeys.class);
            }

        }
        return keySet;
    }

    private static JsonWebKeys getFromLocalStore() {
        Properties props = JwsUtils.loadSignatureInProperties(true);
        return JwsUtils.loadPublicVerificationKeys(JAXRSUtils.getCurrentMessage(), props);
    }

    public void setKeyServiceClient(WebClient keyServiceClient) {
        this.keyServiceClient = keyServiceClient;
    }

}
",0
CVE-2019-12423,rt/rs/security/sso/oidc/src/main/java/org/apache/cxf/rs/security/oidc/idp/OidcKeysService.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.oidc.idp;

import java.util.Properties;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;

import org.apache.cxf.jaxrs.client.WebClient;
import org.apache.cxf.jaxrs.utils.JAXRSUtils;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKeys;
import org.apache.cxf.rs.security.jose.jws.JwsUtils;

@Path(""keys"")
public class OidcKeysService {

    private volatile JsonWebKeys keySet;
    private WebClient keyServiceClient;
    private boolean stripPrivateParameters = true;

    @GET
    @Produces(""application/json"")
    public JsonWebKeys getPublicVerificationKeys() {
        if (keySet == null) {
            if (keyServiceClient == null) {
                keySet = getFromLocalStore(stripPrivateParameters);
            } else {
                keySet = keyServiceClient.get(JsonWebKeys.class);
            }

        }
        return keySet;
    }

    private static JsonWebKeys getFromLocalStore(boolean stripPrivateParameters) {
        Properties props = JwsUtils.loadSignatureInProperties(true);
        return JwsUtils.loadPublicVerificationKeys(JAXRSUtils.getCurrentMessage(), props, stripPrivateParameters);
    }

    public void setKeyServiceClient(WebClient keyServiceClient) {
        this.keyServiceClient = keyServiceClient;
    }

    public boolean isStripPrivateParameters() {
        return stripPrivateParameters;
    }

    /**
     * Whether to strip private parameters from the keys that are returned. The default is true.
     */
    public void setStripPrivateParameters(boolean stripPrivateParameters) {
        this.stripPrivateParameters = stripPrivateParameters;
    }

}
",1
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwk/JsonWebKeys.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jwk;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.jaxrs.json.basic.JsonMapObject;

public class JsonWebKeys extends JsonMapObject {
    public static final String KEYS_PROPERTY = ""keys"";
    private static final long serialVersionUID = -8002543601655429723L;

    public JsonWebKeys() {

    }
    public JsonWebKeys(JsonWebKey key) {
        setInitKey(key);
    }
    private void setInitKey(JsonWebKey key) {
        setKey(key);
    }
    public List<JsonWebKey> getKeys() {
        List<?> list = (List<?>)super.getProperty(KEYS_PROPERTY);
        if (list != null && !list.isEmpty()) {
            Object first = list.get(0);
            if (first instanceof JsonWebKey) {
                return CastUtils.cast(list);
            }
            List<JsonWebKey> keys = new LinkedList<JsonWebKey>();
            List<Map<String, Object>> listOfMaps =
                CastUtils.cast((List<?>)super.getProperty(KEYS_PROPERTY));
            for (Map<String, Object> map : listOfMaps) {
                keys.add(new JsonWebKey(map));
            }
            return keys;
        }
        return null;
    }
    public final void setKey(JsonWebKey key) {
        setKeys(Collections.singletonList(key));
    }
    public final void setKeys(List<JsonWebKey> keys) {
        super.setProperty(KEYS_PROPERTY, keys);
    }

    public Map<String, JsonWebKey> getKeyIdMap() {
        List<JsonWebKey> keys = getKeys();
        if (keys == null) {
            return Collections.emptyMap();
        }
        Map<String, JsonWebKey> map = new LinkedHashMap<String, JsonWebKey>();
        for (JsonWebKey key : keys) {
            String kid = key.getKeyId();
            if (kid != null) {
                map.put(kid, key);
            }
        }
        return map;
    }
    public JsonWebKey getKey(String kid) {
        return getKeyIdMap().get(kid);
    }
    public Map<KeyType, List<JsonWebKey>> getKeyTypeMap() {
        List<JsonWebKey> keys = getKeys();
        if (keys == null) {
            return Collections.emptyMap();
        }
        Map<KeyType, List<JsonWebKey>> map = new LinkedHashMap<KeyType, List<JsonWebKey>>();
        for (JsonWebKey key : keys) {
            KeyType type = key.getKeyType();
            if (type != null) {
                List<JsonWebKey> list = map.get(type);
                if (list == null) {
                    list = new LinkedList<JsonWebKey>();
                    map.put(type, list);
                }
                list.add(key);
            }
        }
        return map;
    }

    public Map<KeyOperation, List<JsonWebKey>> getKeyOperationMap() {
        List<JsonWebKey> keys = getKeys();
        if (keys == null) {
            return Collections.emptyMap();
        }
        Map<KeyOperation, List<JsonWebKey>> map = new LinkedHashMap<KeyOperation, List<JsonWebKey>>();
        for (JsonWebKey key : keys) {
            List<KeyOperation> ops = key.getKeyOperation();
            if (ops != null) {
                for (KeyOperation op : ops) {
                    List<JsonWebKey> list = map.get(op);
                    if (list == null) {
                        list = new LinkedList<JsonWebKey>();
                        map.put(op, list);
                    }
                    list.add(key);
                }
            }
        }
        return map;
    }
    public List<JsonWebKey> getKeys(String keyType) {
        KeyType kt = KeyType.getKeyType(keyType);
        if (kt == null) {
            return null;
        }
        return getKeyTypeMap().get(kt);
    }
    public List<JsonWebKey> getRsaKeys() {
        return getKeyTypeMap().get(KeyType.RSA);
    }
    public List<JsonWebKey> getEllipticKeys() {
        return getKeyTypeMap().get(KeyType.EC);
    }
    public List<JsonWebKey> getSecretKeys() {
        return getKeyTypeMap().get(KeyType.OCTET);
    }
}
",0
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwk/JsonWebKeys.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jwk;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.jaxrs.json.basic.JsonMapObject;

public class JsonWebKeys extends JsonMapObject {
    public static final String KEYS_PROPERTY = ""keys"";
    private static final long serialVersionUID = -8002543601655429723L;

    public JsonWebKeys() {

    }
    public JsonWebKeys(JsonWebKey key) {
        setKey(key);
    }

    public JsonWebKeys(List<JsonWebKey> keys) {
        setKeys(keys);
    }

    public List<JsonWebKey> getKeys() {
        List<?> list = (List<?>)super.getProperty(KEYS_PROPERTY);
        if (list != null && !list.isEmpty()) {
            Object first = list.get(0);
            if (first instanceof JsonWebKey) {
                return CastUtils.cast(list);
            }
            List<JsonWebKey> keys = new LinkedList<JsonWebKey>();
            List<Map<String, Object>> listOfMaps =
                CastUtils.cast((List<?>)super.getProperty(KEYS_PROPERTY));
            for (Map<String, Object> map : listOfMaps) {
                keys.add(new JsonWebKey(map));
            }
            return keys;
        }
        return null;
    }
    public final void setKey(JsonWebKey key) {
        setKeys(Collections.singletonList(key));
    }
    public final void setKeys(List<JsonWebKey> keys) {
        super.setProperty(KEYS_PROPERTY, keys);
    }

    public Map<String, JsonWebKey> getKeyIdMap() {
        List<JsonWebKey> keys = getKeys();
        if (keys == null) {
            return Collections.emptyMap();
        }
        Map<String, JsonWebKey> map = new LinkedHashMap<String, JsonWebKey>();
        for (JsonWebKey key : keys) {
            String kid = key.getKeyId();
            if (kid != null) {
                map.put(kid, key);
            }
        }
        return map;
    }
    public JsonWebKey getKey(String kid) {
        return getKeyIdMap().get(kid);
    }
    public Map<KeyType, List<JsonWebKey>> getKeyTypeMap() {
        List<JsonWebKey> keys = getKeys();
        if (keys == null) {
            return Collections.emptyMap();
        }
        Map<KeyType, List<JsonWebKey>> map = new LinkedHashMap<KeyType, List<JsonWebKey>>();
        for (JsonWebKey key : keys) {
            KeyType type = key.getKeyType();
            if (type != null) {
                List<JsonWebKey> list = map.get(type);
                if (list == null) {
                    list = new LinkedList<JsonWebKey>();
                    map.put(type, list);
                }
                list.add(key);
            }
        }
        return map;
    }

    public Map<KeyOperation, List<JsonWebKey>> getKeyOperationMap() {
        List<JsonWebKey> keys = getKeys();
        if (keys == null) {
            return Collections.emptyMap();
        }
        Map<KeyOperation, List<JsonWebKey>> map = new LinkedHashMap<KeyOperation, List<JsonWebKey>>();
        for (JsonWebKey key : keys) {
            List<KeyOperation> ops = key.getKeyOperation();
            if (ops != null) {
                for (KeyOperation op : ops) {
                    List<JsonWebKey> list = map.get(op);
                    if (list == null) {
                        list = new LinkedList<JsonWebKey>();
                        map.put(op, list);
                    }
                    list.add(key);
                }
            }
        }
        return map;
    }
    public List<JsonWebKey> getKeys(String keyType) {
        KeyType kt = KeyType.getKeyType(keyType);
        if (kt == null) {
            return null;
        }
        return getKeyTypeMap().get(kt);
    }
    public List<JsonWebKey> getRsaKeys() {
        return getKeyTypeMap().get(KeyType.RSA);
    }
    public List<JsonWebKey> getEllipticKeys() {
        return getKeyTypeMap().get(KeyType.EC);
    }
    public List<JsonWebKey> getSecretKeys() {
        return getKeyTypeMap().get(KeyType.OCTET);
    }
}
",1
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwk/JwkUtils.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jwk;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAPrivateCrtKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import javax.crypto.SecretKey;

import org.apache.cxf.Bus;
import org.apache.cxf.common.util.Base64UrlUtility;
import org.apache.cxf.common.util.StringUtils;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.helpers.IOUtils;
import org.apache.cxf.jaxrs.json.basic.JsonMapObjectReaderWriter;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageUtils;
import org.apache.cxf.rs.security.jose.common.JoseConstants;
import org.apache.cxf.rs.security.jose.common.JoseException;
import org.apache.cxf.rs.security.jose.common.JoseHeaders;
import org.apache.cxf.rs.security.jose.common.JoseUtils;
import org.apache.cxf.rs.security.jose.common.KeyManagementUtils;
import org.apache.cxf.rs.security.jose.common.PrivateKeyPasswordProvider;
import org.apache.cxf.rs.security.jose.jwa.AlgorithmUtils;
import org.apache.cxf.rs.security.jose.jwa.ContentAlgorithm;
import org.apache.cxf.rs.security.jose.jwa.KeyAlgorithm;
import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;
import org.apache.cxf.rs.security.jose.jwe.AesCbcHmacJweDecryption;
import org.apache.cxf.rs.security.jose.jwe.AesCbcHmacJweEncryption;
import org.apache.cxf.rs.security.jose.jwe.JweDecryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.JweEncryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.JweHeaders;
import org.apache.cxf.rs.security.jose.jwe.JweUtils;
import org.apache.cxf.rs.security.jose.jwe.KeyDecryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.KeyEncryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.PbesHmacAesWrapKeyDecryptionAlgorithm;
import org.apache.cxf.rs.security.jose.jwe.PbesHmacAesWrapKeyEncryptionAlgorithm;
import org.apache.cxf.rs.security.jose.jws.JwsUtils;
import org.apache.cxf.rt.security.crypto.CryptoUtils;
import org.apache.cxf.rt.security.crypto.MessageDigestUtils;

public final class JwkUtils {
    private static final Map<KeyType, List<String>> JWK_REQUIRED_FIELDS_MAP;
    static {
        JWK_REQUIRED_FIELDS_MAP = new HashMap<>();
        JWK_REQUIRED_FIELDS_MAP.put(KeyType.RSA, Arrays.asList(
            JsonWebKey.RSA_PUBLIC_EXP, JsonWebKey.KEY_TYPE, JsonWebKey.RSA_MODULUS));
        JWK_REQUIRED_FIELDS_MAP.put(KeyType.EC, Arrays.asList(
            JsonWebKey.EC_CURVE, JsonWebKey.KEY_TYPE, JsonWebKey.EC_X_COORDINATE, JsonWebKey.EC_Y_COORDINATE));
        JWK_REQUIRED_FIELDS_MAP.put(KeyType.OCTET, Arrays.asList(
            JsonWebKey.OCTET_KEY_VALUE, JsonWebKey.KEY_TYPE));
    }
    private JwkUtils() {

    }
    public static String getThumbprint(String keySequence) {
        return getThumbprint(readJwkKey(keySequence));
    }
    public static String getThumbprint(JsonWebKey key) {
        List<String> fields = getRequiredFields(key.getKeyType());
        JsonWebKey thumbprintKey = new JsonWebKey();
        for (String f : fields) {
            thumbprintKey.setProperty(f, key.getProperty(f));
        }
        String json = new JsonMapObjectReaderWriter().toJson(thumbprintKey);
        byte[] digest = MessageDigestUtils.createDigest(json, MessageDigestUtils.ALGO_SHA_256);
        return Base64UrlUtility.encode(digest);
    }
    public static List<String> getRequiredFields(KeyType keyType) {
        return JWK_REQUIRED_FIELDS_MAP.get(keyType);
    }
    public static JsonWebKey readJwkKey(URI uri) throws IOException {
        return readJwkKey(uri.toURL().openStream());
    }
    public static JsonWebKeys readJwkSet(URI uri) throws IOException {
        return readJwkSet(uri.toURL().openStream());
    }
    public static JsonWebKey readJwkKey(InputStream is) throws IOException {
        return readJwkKey(IOUtils.readStringFromStream(is));
    }
    public static JsonWebKeys readJwkSet(InputStream is) throws IOException {
        return readJwkSet(IOUtils.readStringFromStream(is));
    }
    public static JsonWebKey readJwkKey(String jwkJson) {
        return new JwkReaderWriter().jsonToJwk(jwkJson);
    }
    public static JsonWebKeys readJwkSet(String jwksJson) {
        return new JwkReaderWriter().jsonToJwkSet(jwksJson);
    }
    public static String jwkKeyToJson(JsonWebKey jwkKey) {
        return new JwkReaderWriter().jwkToJson(jwkKey);
    }
    public static void jwkKeyToJson(JsonWebKey jwkKey, OutputStream os) throws IOException {
        IOUtils.copy(new ByteArrayInputStream(StringUtils.toBytesUTF8(jwkKeyToJson(jwkKey))), os);
    }
    public static String jwkSetToJson(JsonWebKeys jwkSet) {
        return new JwkReaderWriter().jwkSetToJson(jwkSet);
    }
    public static void jwkSetToJson(JsonWebKeys jwkSet, OutputStream os) throws IOException {
        IOUtils.copy(new ByteArrayInputStream(StringUtils.toBytesUTF8(jwkSetToJson(jwkSet))), os);
    }
    public static String encodeJwkKey(JsonWebKey jwkKey) {
        return Base64UrlUtility.encode(jwkKeyToJson(jwkKey));
    }
    public static String encodeJwkSet(JsonWebKeys jwkSet) {
        return Base64UrlUtility.encode(jwkSetToJson(jwkSet));
    }
    public static JsonWebKey decodeJwkKey(String jwkJson) {
        return readJwkKey(JoseUtils.decodeToString(jwkJson));
    }
    public static JsonWebKeys decodeJwkSet(String jwksJson) {
        return readJwkSet(JoseUtils.decodeToString(jwksJson));
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, char[] password) {
        return encryptJwkSet(jwkSet, createDefaultEncryption(password));
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, JweEncryptionProvider jwe) {
        return jwe.encrypt(StringUtils.toBytesUTF8(new JwkReaderWriter().jwkSetToJson(jwkSet)),
                           toJweHeaders(""jwk-set+json""));
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, PublicKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkSetToJson(jwkSet)),
                                ""jwk-set+json"");
    }
    public static String signJwkSet(JsonWebKeys jwkSet, PrivateKey key, SignatureAlgorithm algo) {
        return JwsUtils.sign(key, algo, jwkSetToJson(jwkSet), ""jwk-set+json"");
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, SecretKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkSetToJson(jwkSet)),
                                ""jwk-set+json"");
    }
    public static JsonWebKeys decryptJwkSet(String jsonJwkSet, char[] password) {
        return decryptJwkSet(jsonJwkSet, createDefaultDecryption(password));
    }
    public static JsonWebKeys decryptJwkSet(String jsonJwkSet, JweDecryptionProvider jwe) {
        return new JwkReaderWriter().jsonToJwkSet(jwe.decrypt(jsonJwkSet).getContentText());
    }
    public static JsonWebKeys decryptJwkSet(PrivateKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                            String jsonJwkSet) {
        return readJwkSet(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwkSet)));
    }
    public static JsonWebKeys verifyJwkSet(PublicKey key, SignatureAlgorithm keyAlgo, String jsonJwk) {
        return readJwkSet(JwsUtils.verify(key, keyAlgo, jsonJwk));
    }
    public static JsonWebKeys decryptJwkSet(SecretKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                            String jsonJwkSet) {
        return readJwkSet(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwkSet)));
    }
    public static JsonWebKeys decryptJwkSet(InputStream is, char[] password)
        throws IOException {
        return decryptJwkSet(is, createDefaultDecryption(password));
    }
    public static JsonWebKeys decryptJwkSet(InputStream is, JweDecryptionProvider jwe)
        throws IOException {
        return new JwkReaderWriter().jsonToJwkSet(
            jwe.decrypt(IOUtils.readStringFromStream(is)).getContentText());
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, char[] password) {
        return encryptJwkKey(jwkKey, createDefaultEncryption(password));
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, JweEncryptionProvider jwe) {
        return jwe.encrypt(StringUtils.toBytesUTF8(new JwkReaderWriter().jwkToJson(jwkKey)),
                           toJweHeaders(""jwk+json""));
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, PublicKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkKeyToJson(jwkKey)),
                                ""jwk+json"");
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, SecretKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkKeyToJson(jwkKey)),
                                ""jwk+json"");
    }
    public static String signJwkKey(JsonWebKey jwkKey, PrivateKey key, SignatureAlgorithm algo) {
        return JwsUtils.sign(key, algo, jwkKeyToJson(jwkKey), ""jwk+json"");
    }
    public static JsonWebKey decryptJwkKey(String jsonJwkKey, char[] password) {
        return decryptJwkKey(jsonJwkKey, createDefaultDecryption(password));
    }
    public static JsonWebKey decryptJwkKey(PrivateKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                           String jsonJwk) {
        return readJwkKey(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwk)));
    }
    public static JsonWebKey verifyJwkKey(PublicKey key, SignatureAlgorithm keyAlgo, String jsonJwk) {
        return readJwkKey(JwsUtils.verify(key, keyAlgo, jsonJwk));
    }
    public static JsonWebKey decryptJwkKey(SecretKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                           String jsonJwk) {
        return readJwkKey(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwk)));
    }
    public static JsonWebKey decryptJwkKey(String jsonJwkKey, JweDecryptionProvider jwe) {
        return new JwkReaderWriter().jsonToJwk(jwe.decrypt(jsonJwkKey).getContentText());
    }
    public static JsonWebKey decryptJwkKey(InputStream is, char[] password)
        throws IOException {
        return decryptJwkKey(is, createDefaultDecryption(password));
    }
    public static JsonWebKey decryptJwkKey(InputStream is, JweDecryptionProvider jwe)
        throws IOException {
        return new JwkReaderWriter().jsonToJwk(
            jwe.decrypt(IOUtils.readStringFromStream(is)).getContentText());
    }
    public static JsonWebKeys loadPublicJwkSet(Message m, Properties props) {
        return loadJwkSet(m, props, null);
    }
    public static JsonWebKeys loadJwkSet(Message m, Properties props, PrivateKeyPasswordProvider cb) {
        String key = (String)props.get(JoseConstants.RSSEC_KEY_STORE_FILE);
        JsonWebKeys jwkSet = null;
        if (key != null && m != null) {
            Object jwkSetProp = m.getExchange().get(key);
            if (jwkSetProp != null && !(jwkSetProp instanceof JsonWebKeys)) {
                throw new JwkException(""Unexpected key store class: "" + jwkSetProp.getClass().getName());
            } else {
                jwkSet = (JsonWebKeys)jwkSetProp;
            }
        }
        if (jwkSet == null) {
            jwkSet = loadJwkSet(props, m != null ? m.getExchange().getBus() : null, cb);
            if (key != null && m != null) {
                m.getExchange().put(key, jwkSet);
            }
        }
        return jwkSet;
    }
    public static JsonWebKeys loadJwkSet(Properties props, Bus bus, PrivateKeyPasswordProvider cb) {
        JweDecryptionProvider decryption = cb != null
            ? new AesCbcHmacJweDecryption(new PbesHmacAesWrapKeyDecryptionAlgorithm(
                cb.getPassword(props))) : null;
        return loadJwkSet(props, bus, decryption);
    }
    public static JsonWebKeys loadJwkSet(Properties props, Bus bus, JweDecryptionProvider jwe) {
        String keyContent = null;
        String keyStoreLoc = props.getProperty(JoseConstants.RSSEC_KEY_STORE_FILE);
        if (keyStoreLoc != null) {
            try {
                InputStream is = JoseUtils.getResourceStream(keyStoreLoc, bus);
                if (is == null) {
                    throw new JwkException(""Error in loading keystore location: "" + keyStoreLoc);
                }
                try (InputStream isResource = is) {
                    keyContent = IOUtils.readStringFromStream(isResource);
                }
            } catch (Exception ex) {
                throw new JwkException(ex);
            }
        } else {
            keyContent = props.getProperty(JoseConstants.RSSEC_KEY_STORE_JWKSET);
            if (keyContent == null) {
                keyContent = props.getProperty(JoseConstants.RSSEC_KEY_STORE_JWKKEY);
            }
        }
        if (jwe != null) {
            keyContent = jwe.decrypt(keyContent).getContentText();
        }
        JwkReaderWriter reader = new JwkReaderWriter();
        if (props.getProperty(JoseConstants.RSSEC_KEY_STORE_JWKKEY) == null) {
            return reader.jsonToJwkSet(keyContent);
        }
        JsonWebKey jwk = reader.jsonToJwk(keyContent);
        return new JsonWebKeys(jwk);
    }

    public static JsonWebKey loadJsonWebKey(Message m, Properties props, KeyOperation keyOper) {
        return loadJsonWebKey(m, props, keyOper, null);
    }
    public static JsonWebKey loadJsonWebKey(Message m, Properties props, KeyOperation keyOper, String inHeaderKid) {
        PrivateKeyPasswordProvider cb = KeyManagementUtils.loadPasswordProvider(m, props, keyOper);
        JsonWebKeys jwkSet = loadJwkSet(m, props, cb);
        String kid = null;
        if (inHeaderKid != null
            && MessageUtils.getContextualBoolean(m, JoseConstants.RSSEC_ACCEPT_PUBLIC_KEY, false)) {
            kid = inHeaderKid;
        } else {
            kid = KeyManagementUtils.getKeyId(m, props, JoseConstants.RSSEC_KEY_STORE_ALIAS, keyOper);
        }
        if (kid != null) {
            return jwkSet.getKey(kid);
        } else if (keyOper != null) {
            List<JsonWebKey> keys = jwkSet.getKeyOperationMap().get(keyOper);
            if (keys != null && keys.size() == 1) {
                return keys.get(0);
            }
        }
        return null;
    }
    public static List<JsonWebKey> loadJsonWebKeys(Message m,
                                                   Properties props,
                                                   KeyOperation keyOper) {
        PrivateKeyPasswordProvider cb = KeyManagementUtils.loadPasswordProvider(m, props, keyOper);
        JsonWebKeys jwkSet = loadJwkSet(m, props, cb);
        String kid = KeyManagementUtils.getKeyId(m, props, JoseConstants.RSSEC_KEY_STORE_ALIAS, keyOper);
        if (kid != null) {
            return Collections.singletonList(jwkSet.getKey(kid));
        }
        String kids = KeyManagementUtils.getKeyId(m, props, JoseConstants.RSSEC_KEY_STORE_ALIASES, keyOper);
        if (kids != null) {
            String[] values = kids.split("","");
            List<JsonWebKey> keys = new ArrayList<>(values.length);
            for (String value : values) {
                keys.add(jwkSet.getKey(value));
            }
            return keys;
        }
        if (keyOper != null) {
            List<JsonWebKey> keys = jwkSet.getKeyOperationMap().get(keyOper);
            if (keys != null && keys.size() == 1) {
                return Collections.singletonList(keys.get(0));
            }
        }
        return null;
    }
    public static RSAPublicKey toRSAPublicKey(JsonWebKey jwk) {
        return toRSAPublicKey(jwk, false);
    }
    public static RSAPublicKey toRSAPublicKey(JsonWebKey jwk, boolean checkX509) {
        String encodedModulus = (String)jwk.getProperty(JsonWebKey.RSA_MODULUS);
        String encodedPublicExponent = (String)jwk.getProperty(JsonWebKey.RSA_PUBLIC_EXP);
        if (encodedModulus != null) {
            return CryptoUtils.getRSAPublicKey(encodedModulus, encodedPublicExponent);
        } else if (checkX509) {
            List<X509Certificate> chain = toX509CertificateChain(jwk);
            return (RSAPublicKey)chain.get(0).getPublicKey();
        }
        return null;
    }
    public static List<X509Certificate> toX509CertificateChain(JsonWebKey jwk) {
        List<String> base64EncodedChain = jwk.getX509Chain();
        return KeyManagementUtils.toX509CertificateChain(base64EncodedChain);
    }
    public static JsonWebKey fromECPublicKey(ECPublicKey pk, String curve) {
        return fromECPublicKey(pk, curve, null);
    }
    public static JsonWebKey fromECPublicKey(ECPublicKey pk, String curve, String kid) {
        JsonWebKey jwk = prepareECJwk(curve, kid);
        jwk.setProperty(JsonWebKey.EC_X_COORDINATE,
                        Base64UrlUtility.encode(pk.getW().getAffineX().toByteArray()));
        jwk.setProperty(JsonWebKey.EC_Y_COORDINATE,
                        Base64UrlUtility.encode(pk.getW().getAffineY().toByteArray()));
        return jwk;
    }
    public static JsonWebKey fromECPrivateKey(ECPrivateKey pk, String curve) {
        return fromECPrivateKey(pk, curve, null);
    }
    public static JsonWebKey fromECPrivateKey(ECPrivateKey pk, String curve, String kid) {
        JsonWebKey jwk = prepareECJwk(curve, kid);
        jwk.setProperty(JsonWebKey.EC_PRIVATE_KEY,
                        Base64UrlUtility.encode(pk.getS().toByteArray()));
        return jwk;
    }
    public static JsonWebKey fromRSAPublicKey(RSAPublicKey pk, String algo) {
        return fromRSAPublicKey(pk, algo, null);
    }
    public static JsonWebKey fromRSAPublicKey(RSAPublicKey pk, String algo, String kid) {
        JsonWebKey jwk = prepareRSAJwk(pk.getModulus(), algo, kid);
        String encodedPublicExponent = Base64UrlUtility.encode(pk.getPublicExponent().toByteArray());
        jwk.setProperty(JsonWebKey.RSA_PUBLIC_EXP, encodedPublicExponent);
        return jwk;
    }
    public static JsonWebKey fromPublicKey(PublicKey key, Properties props, String algoProp) {
        JsonWebKey jwk = null;
        if (key instanceof RSAPublicKey) {
            String algo = props.getProperty(algoProp);
            jwk = JwkUtils.fromRSAPublicKey((RSAPublicKey)key, algo);
        } else {
            jwk = JwkUtils.fromECPublicKey((ECPublicKey)key,
                                           props.getProperty(JoseConstants.RSSEC_EC_CURVE));
        }
        String kid = props.getProperty(JoseConstants.RSSEC_KEY_STORE_ALIAS);
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        return jwk;
    }
    public static JsonWebKey fromX509CertificateChain(List<X509Certificate> chain, String algo) {
        JsonWebKey jwk = new JsonWebKey();
        jwk.setAlgorithm(algo);
        List<String> encodedChain = KeyManagementUtils.encodeX509CertificateChain(chain);
        jwk.setX509Chain(encodedChain);
        return jwk;
    }

    public static RSAPrivateKey toRSAPrivateKey(JsonWebKey jwk) {
        String encodedModulus = (String)jwk.getProperty(JsonWebKey.RSA_MODULUS);
        String encodedPrivateExponent = (String)jwk.getProperty(JsonWebKey.RSA_PRIVATE_EXP);
        String encodedPrimeP = (String)jwk.getProperty(JsonWebKey.RSA_FIRST_PRIME_FACTOR);
        if (encodedPrimeP == null) {
            return CryptoUtils.getRSAPrivateKey(encodedModulus, encodedPrivateExponent);
        }
        String encodedPublicExponent = (String)jwk.getProperty(JsonWebKey.RSA_PUBLIC_EXP);
        if (encodedPublicExponent == null) {
            throw new JoseException(""JWK without the public exponent can not be converted to RSAPrivateKey"");
        }
        String encodedPrimeQ = (String)jwk.getProperty(JsonWebKey.RSA_SECOND_PRIME_FACTOR);
        String encodedPrimeExpP = (String)jwk.getProperty(JsonWebKey.RSA_FIRST_PRIME_CRT);
        String encodedPrimeExpQ = (String)jwk.getProperty(JsonWebKey.RSA_SECOND_PRIME_CRT);
        String encodedCrtCoefficient = (String)jwk.getProperty(JsonWebKey.RSA_FIRST_CRT_COEFFICIENT);
        return CryptoUtils.getRSAPrivateKey(encodedModulus,
                                            encodedPublicExponent,
                                            encodedPrivateExponent,
                                            encodedPrimeP,
                                            encodedPrimeQ,
                                            encodedPrimeExpP,
                                            encodedPrimeExpQ,
                                            encodedCrtCoefficient);
    }
    public static JsonWebKey fromRSAPrivateKey(RSAPrivateKey pk, String algo) {
        return fromRSAPrivateKey(pk, algo, null);
    }
    public static JsonWebKey fromRSAPrivateKey(RSAPrivateKey pk, String algo, String kid) {
        JsonWebKey jwk = prepareRSAJwk(pk.getModulus(), algo, kid);
        String encodedPrivateExponent = Base64UrlUtility.encode(pk.getPrivateExponent().toByteArray());
        jwk.setProperty(JsonWebKey.RSA_PRIVATE_EXP, encodedPrivateExponent);
        if (pk instanceof RSAPrivateCrtKey) {
            RSAPrivateCrtKey pkCrt = (RSAPrivateCrtKey)pk;
            jwk.setProperty(JsonWebKey.RSA_PUBLIC_EXP,
                            Base64UrlUtility.encode(pkCrt.getPublicExponent().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_PRIME_FACTOR,
                            Base64UrlUtility.encode(pkCrt.getPrimeP().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_SECOND_PRIME_FACTOR,
                            Base64UrlUtility.encode(pkCrt.getPrimeQ().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_PRIME_CRT,
                            Base64UrlUtility.encode(pkCrt.getPrimeExponentP().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_SECOND_PRIME_CRT,
                            Base64UrlUtility.encode(pkCrt.getPrimeExponentQ().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_CRT_COEFFICIENT,
                            Base64UrlUtility.encode(pkCrt.getCrtCoefficient().toByteArray()));
        }
        // ""oth"" can be populated too if needed
        return jwk;
    }
    public static ECPublicKey toECPublicKey(JsonWebKey jwk) {
        String eCurve = (String)jwk.getProperty(JsonWebKey.EC_CURVE);
        String encodedXCoord = (String)jwk.getProperty(JsonWebKey.EC_X_COORDINATE);
        String encodedYCoord = (String)jwk.getProperty(JsonWebKey.EC_Y_COORDINATE);
        return CryptoUtils.getECPublicKey(eCurve, encodedXCoord, encodedYCoord);
    }
    public static ECPrivateKey toECPrivateKey(JsonWebKey jwk) {
        String eCurve = (String)jwk.getProperty(JsonWebKey.EC_CURVE);
        String encodedPrivateKey = (String)jwk.getProperty(JsonWebKey.EC_PRIVATE_KEY);
        return CryptoUtils.getECPrivateKey(eCurve, encodedPrivateKey);
    }

    public static SecretKey toSecretKey(JsonWebKey jwk) {
        return CryptoUtils.createSecretKeySpec((String)jwk.getProperty(JsonWebKey.OCTET_KEY_VALUE),
                                               AlgorithmUtils.toJavaName(jwk.getAlgorithm()));
    }
    public static JsonWebKey fromSecretKey(SecretKey secretKey, String algo) {
        return fromSecretKey(secretKey, algo, null);
    }
    public static JsonWebKey fromSecretKey(SecretKey secretKey, String algo, String kid) {
        if (!AlgorithmUtils.isOctet(algo)) {
            throw new JwkException(""Invalid algorithm"");
        }
        JsonWebKey jwk = new JsonWebKey();
        jwk.setKeyType(KeyType.OCTET);
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        jwk.setAlgorithm(algo);
        String encodedSecretKey = Base64UrlUtility.encode(secretKey.getEncoded());
        jwk.setProperty(JsonWebKey.OCTET_KEY_VALUE, encodedSecretKey);
        return jwk;
    }


    private static JweEncryptionProvider createDefaultEncryption(char[] password) {
        KeyEncryptionProvider keyEncryption =
            new PbesHmacAesWrapKeyEncryptionAlgorithm(password, KeyAlgorithm.PBES2_HS256_A128KW);
        return new AesCbcHmacJweEncryption(ContentAlgorithm.A128CBC_HS256, keyEncryption);
    }
    private static JweDecryptionProvider createDefaultDecryption(char[] password) {
        KeyDecryptionProvider keyDecryption = new PbesHmacAesWrapKeyDecryptionAlgorithm(password);
        return new AesCbcHmacJweDecryption(keyDecryption);
    }
    private static JsonWebKey prepareRSAJwk(BigInteger modulus, String algo, String kid) {
        JsonWebKey jwk = new JsonWebKey();
        jwk.setKeyType(KeyType.RSA);
        if (algo != null) {
            if (!AlgorithmUtils.isRsa(algo)) {
                throw new JwkException(""Invalid algorithm"");
            }
            jwk.setAlgorithm(algo);
        }
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        byte[] modulusBytes = modulus.toByteArray();
        int extraBytesLength = modulusBytes.length - modulus.bitLength() / 8;
        if (extraBytesLength > 0) {
            modulusBytes = Arrays.copyOfRange(modulusBytes, extraBytesLength, modulusBytes.length);
        }
        String encodedModulus = Base64UrlUtility.encode(modulusBytes);
        jwk.setProperty(JsonWebKey.RSA_MODULUS, encodedModulus);
        return jwk;
    }
    private static JsonWebKey prepareECJwk(String curve, String kid) {
        JsonWebKey jwk = new JsonWebKey();
        jwk.setKeyType(KeyType.EC);
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        jwk.setProperty(JsonWebKey.EC_CURVE, curve);
        return jwk;
    }
    private static String toString(byte[] bytes) {
        try {
            return new String(bytes, StandardCharsets.UTF_8);
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }
    private static JweHeaders toJweHeaders(String ct) {
        return new JweHeaders(Collections.<String, Object>singletonMap(JoseConstants.HEADER_CONTENT_TYPE, ct));
    }

    public static void includeCertChain(JsonWebKey jwk, JoseHeaders headers, String algo) {
        if (KeyType.RSA.equals(jwk.getKeyType())) {
            List<String> chain = CastUtils.cast((List<?>)jwk.getProperty(JsonWebKey.X509_CHAIN));
            if (chain != null) {
                headers.setX509Chain(chain);
            }
        }
    }

    public static void includePublicKey(JsonWebKey jwk, JoseHeaders headers, String algo) {
        if (KeyType.RSA.equals(jwk.getKeyType())) {
            JsonWebKey jwkPublic = JwkUtils.fromRSAPublicKey(JwkUtils.toRSAPublicKey(jwk), algo);
            if (jwk.getKeyId() != null) {
                jwkPublic.setKeyId(jwk.getKeyId());
            }
            headers.setJsonWebKey(jwkPublic);
        }
    }
}
",0
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jwk/JwkUtils.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jwk;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAPrivateCrtKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import javax.crypto.SecretKey;

import org.apache.cxf.Bus;
import org.apache.cxf.common.util.Base64UrlUtility;
import org.apache.cxf.common.util.StringUtils;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.helpers.IOUtils;
import org.apache.cxf.jaxrs.json.basic.JsonMapObjectReaderWriter;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageUtils;
import org.apache.cxf.rs.security.jose.common.JoseConstants;
import org.apache.cxf.rs.security.jose.common.JoseException;
import org.apache.cxf.rs.security.jose.common.JoseHeaders;
import org.apache.cxf.rs.security.jose.common.JoseUtils;
import org.apache.cxf.rs.security.jose.common.KeyManagementUtils;
import org.apache.cxf.rs.security.jose.common.PrivateKeyPasswordProvider;
import org.apache.cxf.rs.security.jose.jwa.AlgorithmUtils;
import org.apache.cxf.rs.security.jose.jwa.ContentAlgorithm;
import org.apache.cxf.rs.security.jose.jwa.KeyAlgorithm;
import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;
import org.apache.cxf.rs.security.jose.jwe.AesCbcHmacJweDecryption;
import org.apache.cxf.rs.security.jose.jwe.AesCbcHmacJweEncryption;
import org.apache.cxf.rs.security.jose.jwe.JweDecryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.JweEncryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.JweHeaders;
import org.apache.cxf.rs.security.jose.jwe.JweUtils;
import org.apache.cxf.rs.security.jose.jwe.KeyDecryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.KeyEncryptionProvider;
import org.apache.cxf.rs.security.jose.jwe.PbesHmacAesWrapKeyDecryptionAlgorithm;
import org.apache.cxf.rs.security.jose.jwe.PbesHmacAesWrapKeyEncryptionAlgorithm;
import org.apache.cxf.rs.security.jose.jws.JwsUtils;
import org.apache.cxf.rt.security.crypto.CryptoUtils;
import org.apache.cxf.rt.security.crypto.MessageDigestUtils;

public final class JwkUtils {
    private static final Map<KeyType, List<String>> JWK_REQUIRED_FIELDS_MAP;
    static {
        JWK_REQUIRED_FIELDS_MAP = new HashMap<>();
        JWK_REQUIRED_FIELDS_MAP.put(KeyType.RSA, Arrays.asList(
            JsonWebKey.RSA_PUBLIC_EXP, JsonWebKey.KEY_TYPE, JsonWebKey.RSA_MODULUS));
        JWK_REQUIRED_FIELDS_MAP.put(KeyType.EC, Arrays.asList(
            JsonWebKey.EC_CURVE, JsonWebKey.KEY_TYPE, JsonWebKey.EC_X_COORDINATE, JsonWebKey.EC_Y_COORDINATE));
        JWK_REQUIRED_FIELDS_MAP.put(KeyType.OCTET, Arrays.asList(
            JsonWebKey.OCTET_KEY_VALUE, JsonWebKey.KEY_TYPE));
    }
    private JwkUtils() {

    }
    public static String getThumbprint(String keySequence) {
        return getThumbprint(readJwkKey(keySequence));
    }
    public static String getThumbprint(JsonWebKey key) {
        List<String> fields = getRequiredFields(key.getKeyType());
        JsonWebKey thumbprintKey = new JsonWebKey();
        for (String f : fields) {
            thumbprintKey.setProperty(f, key.getProperty(f));
        }
        String json = new JsonMapObjectReaderWriter().toJson(thumbprintKey);
        byte[] digest = MessageDigestUtils.createDigest(json, MessageDigestUtils.ALGO_SHA_256);
        return Base64UrlUtility.encode(digest);
    }
    public static List<String> getRequiredFields(KeyType keyType) {
        return JWK_REQUIRED_FIELDS_MAP.get(keyType);
    }
    public static JsonWebKey readJwkKey(URI uri) throws IOException {
        return readJwkKey(uri.toURL().openStream());
    }
    public static JsonWebKeys readJwkSet(URI uri) throws IOException {
        return readJwkSet(uri.toURL().openStream());
    }
    public static JsonWebKey readJwkKey(InputStream is) throws IOException {
        return readJwkKey(IOUtils.readStringFromStream(is));
    }
    public static JsonWebKeys readJwkSet(InputStream is) throws IOException {
        return readJwkSet(IOUtils.readStringFromStream(is));
    }
    public static JsonWebKey readJwkKey(String jwkJson) {
        return new JwkReaderWriter().jsonToJwk(jwkJson);
    }
    public static JsonWebKeys readJwkSet(String jwksJson) {
        return new JwkReaderWriter().jsonToJwkSet(jwksJson);
    }
    public static String jwkKeyToJson(JsonWebKey jwkKey) {
        return new JwkReaderWriter().jwkToJson(jwkKey);
    }
    public static void jwkKeyToJson(JsonWebKey jwkKey, OutputStream os) throws IOException {
        IOUtils.copy(new ByteArrayInputStream(StringUtils.toBytesUTF8(jwkKeyToJson(jwkKey))), os);
    }
    public static String jwkSetToJson(JsonWebKeys jwkSet) {
        return new JwkReaderWriter().jwkSetToJson(jwkSet);
    }
    public static void jwkSetToJson(JsonWebKeys jwkSet, OutputStream os) throws IOException {
        IOUtils.copy(new ByteArrayInputStream(StringUtils.toBytesUTF8(jwkSetToJson(jwkSet))), os);
    }
    public static String encodeJwkKey(JsonWebKey jwkKey) {
        return Base64UrlUtility.encode(jwkKeyToJson(jwkKey));
    }
    public static String encodeJwkSet(JsonWebKeys jwkSet) {
        return Base64UrlUtility.encode(jwkSetToJson(jwkSet));
    }
    public static JsonWebKey decodeJwkKey(String jwkJson) {
        return readJwkKey(JoseUtils.decodeToString(jwkJson));
    }
    public static JsonWebKeys decodeJwkSet(String jwksJson) {
        return readJwkSet(JoseUtils.decodeToString(jwksJson));
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, char[] password) {
        return encryptJwkSet(jwkSet, createDefaultEncryption(password));
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, JweEncryptionProvider jwe) {
        return jwe.encrypt(StringUtils.toBytesUTF8(new JwkReaderWriter().jwkSetToJson(jwkSet)),
                           toJweHeaders(""jwk-set+json""));
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, PublicKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkSetToJson(jwkSet)),
                                ""jwk-set+json"");
    }
    public static String signJwkSet(JsonWebKeys jwkSet, PrivateKey key, SignatureAlgorithm algo) {
        return JwsUtils.sign(key, algo, jwkSetToJson(jwkSet), ""jwk-set+json"");
    }
    public static String encryptJwkSet(JsonWebKeys jwkSet, SecretKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkSetToJson(jwkSet)),
                                ""jwk-set+json"");
    }
    public static JsonWebKeys decryptJwkSet(String jsonJwkSet, char[] password) {
        return decryptJwkSet(jsonJwkSet, createDefaultDecryption(password));
    }
    public static JsonWebKeys decryptJwkSet(String jsonJwkSet, JweDecryptionProvider jwe) {
        return new JwkReaderWriter().jsonToJwkSet(jwe.decrypt(jsonJwkSet).getContentText());
    }
    public static JsonWebKeys decryptJwkSet(PrivateKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                            String jsonJwkSet) {
        return readJwkSet(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwkSet)));
    }
    public static JsonWebKeys verifyJwkSet(PublicKey key, SignatureAlgorithm keyAlgo, String jsonJwk) {
        return readJwkSet(JwsUtils.verify(key, keyAlgo, jsonJwk));
    }
    public static JsonWebKeys decryptJwkSet(SecretKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                            String jsonJwkSet) {
        return readJwkSet(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwkSet)));
    }
    public static JsonWebKeys decryptJwkSet(InputStream is, char[] password)
        throws IOException {
        return decryptJwkSet(is, createDefaultDecryption(password));
    }
    public static JsonWebKeys decryptJwkSet(InputStream is, JweDecryptionProvider jwe)
        throws IOException {
        return new JwkReaderWriter().jsonToJwkSet(
            jwe.decrypt(IOUtils.readStringFromStream(is)).getContentText());
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, char[] password) {
        return encryptJwkKey(jwkKey, createDefaultEncryption(password));
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, JweEncryptionProvider jwe) {
        return jwe.encrypt(StringUtils.toBytesUTF8(new JwkReaderWriter().jwkToJson(jwkKey)),
                           toJweHeaders(""jwk+json""));
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, PublicKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkKeyToJson(jwkKey)),
                                ""jwk+json"");
    }
    public static String encryptJwkKey(JsonWebKey jwkKey, SecretKey key, KeyAlgorithm keyAlgo,
                                       ContentAlgorithm contentAlgo) {
        return JweUtils.encrypt(key, keyAlgo, contentAlgo, StringUtils.toBytesUTF8(jwkKeyToJson(jwkKey)),
                                ""jwk+json"");
    }
    public static String signJwkKey(JsonWebKey jwkKey, PrivateKey key, SignatureAlgorithm algo) {
        return JwsUtils.sign(key, algo, jwkKeyToJson(jwkKey), ""jwk+json"");
    }
    public static JsonWebKey decryptJwkKey(String jsonJwkKey, char[] password) {
        return decryptJwkKey(jsonJwkKey, createDefaultDecryption(password));
    }
    public static JsonWebKey decryptJwkKey(PrivateKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                           String jsonJwk) {
        return readJwkKey(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwk)));
    }
    public static JsonWebKey verifyJwkKey(PublicKey key, SignatureAlgorithm keyAlgo, String jsonJwk) {
        return readJwkKey(JwsUtils.verify(key, keyAlgo, jsonJwk));
    }
    public static JsonWebKey decryptJwkKey(SecretKey key, KeyAlgorithm keyAlgo, ContentAlgorithm ctAlgo,
                                           String jsonJwk) {
        return readJwkKey(toString(JweUtils.decrypt(key, keyAlgo, ctAlgo, jsonJwk)));
    }
    public static JsonWebKey decryptJwkKey(String jsonJwkKey, JweDecryptionProvider jwe) {
        return new JwkReaderWriter().jsonToJwk(jwe.decrypt(jsonJwkKey).getContentText());
    }
    public static JsonWebKey decryptJwkKey(InputStream is, char[] password)
        throws IOException {
        return decryptJwkKey(is, createDefaultDecryption(password));
    }
    public static JsonWebKey decryptJwkKey(InputStream is, JweDecryptionProvider jwe)
        throws IOException {
        return new JwkReaderWriter().jsonToJwk(
            jwe.decrypt(IOUtils.readStringFromStream(is)).getContentText());
    }
    public static JsonWebKeys loadPublicJwkSet(Message m, Properties props) {
        return loadJwkSet(m, props, null);
    }
    public static JsonWebKeys loadJwkSet(Message m, Properties props, PrivateKeyPasswordProvider cb) {
        String key = (String)props.get(JoseConstants.RSSEC_KEY_STORE_FILE);
        JsonWebKeys jwkSet = null;
        if (key != null && m != null) {
            Object jwkSetProp = m.getExchange().get(key);
            if (jwkSetProp != null && !(jwkSetProp instanceof JsonWebKeys)) {
                throw new JwkException(""Unexpected key store class: "" + jwkSetProp.getClass().getName());
            } else {
                jwkSet = (JsonWebKeys)jwkSetProp;
            }
        }
        if (jwkSet == null) {
            jwkSet = loadJwkSet(props, m != null ? m.getExchange().getBus() : null, cb);
            if (key != null && m != null) {
                m.getExchange().put(key, jwkSet);
            }
        }
        return jwkSet;
    }
    public static JsonWebKeys loadJwkSet(Properties props, Bus bus, PrivateKeyPasswordProvider cb) {
        JweDecryptionProvider decryption = cb != null
            ? new AesCbcHmacJweDecryption(new PbesHmacAesWrapKeyDecryptionAlgorithm(
                cb.getPassword(props))) : null;
        return loadJwkSet(props, bus, decryption);
    }
    public static JsonWebKeys loadJwkSet(Properties props, Bus bus, JweDecryptionProvider jwe) {
        String keyContent = null;
        String keyStoreLoc = props.getProperty(JoseConstants.RSSEC_KEY_STORE_FILE);
        if (keyStoreLoc != null) {
            try {
                InputStream is = JoseUtils.getResourceStream(keyStoreLoc, bus);
                if (is == null) {
                    throw new JwkException(""Error in loading keystore location: "" + keyStoreLoc);
                }
                try (InputStream isResource = is) {
                    keyContent = IOUtils.readStringFromStream(isResource);
                }
            } catch (Exception ex) {
                throw new JwkException(ex);
            }
        } else {
            keyContent = props.getProperty(JoseConstants.RSSEC_KEY_STORE_JWKSET);
            if (keyContent == null) {
                keyContent = props.getProperty(JoseConstants.RSSEC_KEY_STORE_JWKKEY);
            }
        }
        if (jwe != null) {
            keyContent = jwe.decrypt(keyContent).getContentText();
        }
        JwkReaderWriter reader = new JwkReaderWriter();
        if (props.getProperty(JoseConstants.RSSEC_KEY_STORE_JWKKEY) == null) {
            return reader.jsonToJwkSet(keyContent);
        }
        JsonWebKey jwk = reader.jsonToJwk(keyContent);
        return new JsonWebKeys(jwk);
    }

    public static JsonWebKey loadJsonWebKey(Message m, Properties props, KeyOperation keyOper) {
        return loadJsonWebKey(m, props, keyOper, null);
    }
    public static JsonWebKey loadJsonWebKey(Message m, Properties props, KeyOperation keyOper, String inHeaderKid) {
        PrivateKeyPasswordProvider cb = KeyManagementUtils.loadPasswordProvider(m, props, keyOper);
        JsonWebKeys jwkSet = loadJwkSet(m, props, cb);
        String kid = null;
        if (inHeaderKid != null
            && MessageUtils.getContextualBoolean(m, JoseConstants.RSSEC_ACCEPT_PUBLIC_KEY, false)) {
            kid = inHeaderKid;
        } else {
            kid = KeyManagementUtils.getKeyId(m, props, JoseConstants.RSSEC_KEY_STORE_ALIAS, keyOper);
        }
        if (kid != null) {
            return jwkSet.getKey(kid);
        } else if (keyOper != null) {
            List<JsonWebKey> keys = jwkSet.getKeyOperationMap().get(keyOper);
            if (keys != null && keys.size() == 1) {
                return keys.get(0);
            }
        }
        return null;
    }

    public static List<JsonWebKey> loadJsonWebKeys(Message m,
                                                   Properties props,
                                                   KeyOperation keyOper) {
        PrivateKeyPasswordProvider cb = KeyManagementUtils.loadPasswordProvider(m, props, keyOper);
        return loadJsonWebKeys(m, props, keyOper, cb);
    }

    public static List<JsonWebKey> loadJsonWebKeys(Message m,
                                                   Properties props,
                                                   KeyOperation keyOper,
                                                   PrivateKeyPasswordProvider cb) {
        JsonWebKeys jwkSet = loadJwkSet(m, props, cb);
        String kid = KeyManagementUtils.getKeyId(m, props, JoseConstants.RSSEC_KEY_STORE_ALIAS, keyOper);
        if (kid != null) {
            return Collections.singletonList(jwkSet.getKey(kid));
        }
        String kids = KeyManagementUtils.getKeyId(m, props, JoseConstants.RSSEC_KEY_STORE_ALIASES, keyOper);
        if (kids != null) {
            String[] values = kids.split("","");
            List<JsonWebKey> keys = new ArrayList<>(values.length);
            for (String value : values) {
                keys.add(jwkSet.getKey(value));
            }
            return keys;
        }
        if (keyOper != null) {
            List<JsonWebKey> keys = jwkSet.getKeyOperationMap().get(keyOper);
            if (keys != null && keys.size() == 1) {
                return Collections.singletonList(keys.get(0));
            }
        }
        return null;
    }
    public static RSAPublicKey toRSAPublicKey(JsonWebKey jwk) {
        return toRSAPublicKey(jwk, false);
    }
    public static RSAPublicKey toRSAPublicKey(JsonWebKey jwk, boolean checkX509) {
        String encodedModulus = (String)jwk.getProperty(JsonWebKey.RSA_MODULUS);
        String encodedPublicExponent = (String)jwk.getProperty(JsonWebKey.RSA_PUBLIC_EXP);
        if (encodedModulus != null) {
            return CryptoUtils.getRSAPublicKey(encodedModulus, encodedPublicExponent);
        } else if (checkX509) {
            List<X509Certificate> chain = toX509CertificateChain(jwk);
            return (RSAPublicKey)chain.get(0).getPublicKey();
        }
        return null;
    }
    public static List<X509Certificate> toX509CertificateChain(JsonWebKey jwk) {
        List<String> base64EncodedChain = jwk.getX509Chain();
        return KeyManagementUtils.toX509CertificateChain(base64EncodedChain);
    }
    public static JsonWebKey fromECPublicKey(ECPublicKey pk, String curve) {
        return fromECPublicKey(pk, curve, null);
    }
    public static JsonWebKey fromECPublicKey(ECPublicKey pk, String curve, String kid) {
        JsonWebKey jwk = prepareECJwk(curve, kid);
        jwk.setProperty(JsonWebKey.EC_X_COORDINATE,
                        Base64UrlUtility.encode(pk.getW().getAffineX().toByteArray()));
        jwk.setProperty(JsonWebKey.EC_Y_COORDINATE,
                        Base64UrlUtility.encode(pk.getW().getAffineY().toByteArray()));
        return jwk;
    }
    public static JsonWebKey fromECPrivateKey(ECPrivateKey pk, String curve) {
        return fromECPrivateKey(pk, curve, null);
    }
    public static JsonWebKey fromECPrivateKey(ECPrivateKey pk, String curve, String kid) {
        JsonWebKey jwk = prepareECJwk(curve, kid);
        jwk.setProperty(JsonWebKey.EC_PRIVATE_KEY,
                        Base64UrlUtility.encode(pk.getS().toByteArray()));
        return jwk;
    }
    public static JsonWebKey fromRSAPublicKey(RSAPublicKey pk, String algo) {
        return fromRSAPublicKey(pk, algo, null);
    }
    public static JsonWebKey fromRSAPublicKey(RSAPublicKey pk, String algo, String kid) {
        JsonWebKey jwk = prepareRSAJwk(pk.getModulus(), algo, kid);
        String encodedPublicExponent = Base64UrlUtility.encode(pk.getPublicExponent().toByteArray());
        jwk.setProperty(JsonWebKey.RSA_PUBLIC_EXP, encodedPublicExponent);
        return jwk;
    }
    public static JsonWebKey fromPublicKey(PublicKey key, Properties props, String algoProp) {
        JsonWebKey jwk = null;
        if (key instanceof RSAPublicKey) {
            String algo = props.getProperty(algoProp);
            jwk = JwkUtils.fromRSAPublicKey((RSAPublicKey)key, algo);
        } else {
            jwk = JwkUtils.fromECPublicKey((ECPublicKey)key,
                                           props.getProperty(JoseConstants.RSSEC_EC_CURVE));
        }
        String kid = props.getProperty(JoseConstants.RSSEC_KEY_STORE_ALIAS);
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        return jwk;
    }
    public static JsonWebKey fromX509CertificateChain(List<X509Certificate> chain, String algo) {
        JsonWebKey jwk = new JsonWebKey();
        jwk.setAlgorithm(algo);
        List<String> encodedChain = KeyManagementUtils.encodeX509CertificateChain(chain);
        jwk.setX509Chain(encodedChain);
        return jwk;
    }

    public static RSAPrivateKey toRSAPrivateKey(JsonWebKey jwk) {
        String encodedModulus = (String)jwk.getProperty(JsonWebKey.RSA_MODULUS);
        String encodedPrivateExponent = (String)jwk.getProperty(JsonWebKey.RSA_PRIVATE_EXP);
        String encodedPrimeP = (String)jwk.getProperty(JsonWebKey.RSA_FIRST_PRIME_FACTOR);
        if (encodedPrimeP == null) {
            return CryptoUtils.getRSAPrivateKey(encodedModulus, encodedPrivateExponent);
        }
        String encodedPublicExponent = (String)jwk.getProperty(JsonWebKey.RSA_PUBLIC_EXP);
        if (encodedPublicExponent == null) {
            throw new JoseException(""JWK without the public exponent can not be converted to RSAPrivateKey"");
        }
        String encodedPrimeQ = (String)jwk.getProperty(JsonWebKey.RSA_SECOND_PRIME_FACTOR);
        String encodedPrimeExpP = (String)jwk.getProperty(JsonWebKey.RSA_FIRST_PRIME_CRT);
        String encodedPrimeExpQ = (String)jwk.getProperty(JsonWebKey.RSA_SECOND_PRIME_CRT);
        String encodedCrtCoefficient = (String)jwk.getProperty(JsonWebKey.RSA_FIRST_CRT_COEFFICIENT);
        return CryptoUtils.getRSAPrivateKey(encodedModulus,
                                            encodedPublicExponent,
                                            encodedPrivateExponent,
                                            encodedPrimeP,
                                            encodedPrimeQ,
                                            encodedPrimeExpP,
                                            encodedPrimeExpQ,
                                            encodedCrtCoefficient);
    }
    public static JsonWebKey fromRSAPrivateKey(RSAPrivateKey pk, String algo) {
        return fromRSAPrivateKey(pk, algo, null);
    }
    public static JsonWebKey fromRSAPrivateKey(RSAPrivateKey pk, String algo, String kid) {
        JsonWebKey jwk = prepareRSAJwk(pk.getModulus(), algo, kid);
        String encodedPrivateExponent = Base64UrlUtility.encode(pk.getPrivateExponent().toByteArray());
        jwk.setProperty(JsonWebKey.RSA_PRIVATE_EXP, encodedPrivateExponent);
        if (pk instanceof RSAPrivateCrtKey) {
            RSAPrivateCrtKey pkCrt = (RSAPrivateCrtKey)pk;
            jwk.setProperty(JsonWebKey.RSA_PUBLIC_EXP,
                            Base64UrlUtility.encode(pkCrt.getPublicExponent().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_PRIME_FACTOR,
                            Base64UrlUtility.encode(pkCrt.getPrimeP().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_SECOND_PRIME_FACTOR,
                            Base64UrlUtility.encode(pkCrt.getPrimeQ().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_PRIME_CRT,
                            Base64UrlUtility.encode(pkCrt.getPrimeExponentP().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_SECOND_PRIME_CRT,
                            Base64UrlUtility.encode(pkCrt.getPrimeExponentQ().toByteArray()));
            jwk.setProperty(JsonWebKey.RSA_FIRST_CRT_COEFFICIENT,
                            Base64UrlUtility.encode(pkCrt.getCrtCoefficient().toByteArray()));
        }
        // ""oth"" can be populated too if needed
        return jwk;
    }
    public static ECPublicKey toECPublicKey(JsonWebKey jwk) {
        String eCurve = (String)jwk.getProperty(JsonWebKey.EC_CURVE);
        String encodedXCoord = (String)jwk.getProperty(JsonWebKey.EC_X_COORDINATE);
        String encodedYCoord = (String)jwk.getProperty(JsonWebKey.EC_Y_COORDINATE);
        return CryptoUtils.getECPublicKey(eCurve, encodedXCoord, encodedYCoord);
    }
    public static ECPrivateKey toECPrivateKey(JsonWebKey jwk) {
        String eCurve = (String)jwk.getProperty(JsonWebKey.EC_CURVE);
        String encodedPrivateKey = (String)jwk.getProperty(JsonWebKey.EC_PRIVATE_KEY);
        return CryptoUtils.getECPrivateKey(eCurve, encodedPrivateKey);
    }

    public static SecretKey toSecretKey(JsonWebKey jwk) {
        return CryptoUtils.createSecretKeySpec((String)jwk.getProperty(JsonWebKey.OCTET_KEY_VALUE),
                                               AlgorithmUtils.toJavaName(jwk.getAlgorithm()));
    }
    public static JsonWebKey fromSecretKey(SecretKey secretKey, String algo) {
        return fromSecretKey(secretKey, algo, null);
    }
    public static JsonWebKey fromSecretKey(SecretKey secretKey, String algo, String kid) {
        if (!AlgorithmUtils.isOctet(algo)) {
            throw new JwkException(""Invalid algorithm"");
        }
        JsonWebKey jwk = new JsonWebKey();
        jwk.setKeyType(KeyType.OCTET);
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        jwk.setAlgorithm(algo);
        String encodedSecretKey = Base64UrlUtility.encode(secretKey.getEncoded());
        jwk.setProperty(JsonWebKey.OCTET_KEY_VALUE, encodedSecretKey);
        return jwk;
    }


    private static JweEncryptionProvider createDefaultEncryption(char[] password) {
        KeyEncryptionProvider keyEncryption =
            new PbesHmacAesWrapKeyEncryptionAlgorithm(password, KeyAlgorithm.PBES2_HS256_A128KW);
        return new AesCbcHmacJweEncryption(ContentAlgorithm.A128CBC_HS256, keyEncryption);
    }
    private static JweDecryptionProvider createDefaultDecryption(char[] password) {
        KeyDecryptionProvider keyDecryption = new PbesHmacAesWrapKeyDecryptionAlgorithm(password);
        return new AesCbcHmacJweDecryption(keyDecryption);
    }
    private static JsonWebKey prepareRSAJwk(BigInteger modulus, String algo, String kid) {
        JsonWebKey jwk = new JsonWebKey();
        jwk.setKeyType(KeyType.RSA);
        if (algo != null) {
            if (!AlgorithmUtils.isRsa(algo)) {
                throw new JwkException(""Invalid algorithm"");
            }
            jwk.setAlgorithm(algo);
        }
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        byte[] modulusBytes = modulus.toByteArray();
        int extraBytesLength = modulusBytes.length - modulus.bitLength() / 8;
        if (extraBytesLength > 0) {
            modulusBytes = Arrays.copyOfRange(modulusBytes, extraBytesLength, modulusBytes.length);
        }
        String encodedModulus = Base64UrlUtility.encode(modulusBytes);
        jwk.setProperty(JsonWebKey.RSA_MODULUS, encodedModulus);
        return jwk;
    }
    private static JsonWebKey prepareECJwk(String curve, String kid) {
        JsonWebKey jwk = new JsonWebKey();
        jwk.setKeyType(KeyType.EC);
        if (kid != null) {
            jwk.setKeyId(kid);
        }
        jwk.setProperty(JsonWebKey.EC_CURVE, curve);
        return jwk;
    }
    private static String toString(byte[] bytes) {
        try {
            return new String(bytes, StandardCharsets.UTF_8);
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }
    private static JweHeaders toJweHeaders(String ct) {
        return new JweHeaders(Collections.<String, Object>singletonMap(JoseConstants.HEADER_CONTENT_TYPE, ct));
    }

    public static void includeCertChain(JsonWebKey jwk, JoseHeaders headers, String algo) {
        if (KeyType.RSA.equals(jwk.getKeyType())) {
            List<String> chain = CastUtils.cast((List<?>)jwk.getProperty(JsonWebKey.X509_CHAIN));
            if (chain != null) {
                headers.setX509Chain(chain);
            }
        }
    }

    public static void includePublicKey(JsonWebKey jwk, JoseHeaders headers, String algo) {
        if (KeyType.RSA.equals(jwk.getKeyType())) {
            JsonWebKey jwkPublic = JwkUtils.fromRSAPublicKey(JwkUtils.toRSAPublicKey(jwk), algo);
            if (jwk.getKeyId() != null) {
                jwkPublic.setKeyId(jwk.getKeyId());
            }
            headers.setJsonWebKey(jwkPublic);
        }
    }

    public static List<JsonWebKey> stripPrivateParameters(List<JsonWebKey> keys) {
        if (keys == null) {
            return Collections.emptyList();
        }

        List<JsonWebKey> parsedKeys = new ArrayList<>(keys.size());
        Iterator<JsonWebKey> iter = keys.iterator();
        while (iter.hasNext()) {
            JsonWebKey key = iter.next();
            if (!(key.containsProperty(""k"") || key.getKeyType() == KeyType.OCTET)) {
                // We don't allow secret keys in a public keyset
                key.removeProperty(JsonWebKey.RSA_PRIVATE_EXP);
                key.removeProperty(JsonWebKey.RSA_FIRST_PRIME_FACTOR);
                key.removeProperty(JsonWebKey.RSA_SECOND_PRIME_FACTOR);
                key.removeProperty(JsonWebKey.RSA_FIRST_PRIME_CRT);
                key.removeProperty(JsonWebKey.RSA_SECOND_PRIME_CRT);
                key.removeProperty(JsonWebKey.RSA_FIRST_CRT_COEFFICIENT);
                parsedKeys.add(key);
            }
        }
        return parsedKeys;
    }
}
",1
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsUtils.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jws;

import java.security.Key;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Logger;

import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.common.util.PropertyUtils;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageUtils;
import org.apache.cxf.phase.PhaseInterceptorChain;
import org.apache.cxf.rs.security.jose.common.JoseConstants;
import org.apache.cxf.rs.security.jose.common.JoseUtils;
import org.apache.cxf.rs.security.jose.common.KeyManagementUtils;
import org.apache.cxf.rs.security.jose.jwa.AlgorithmUtils;
import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKey;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKeys;
import org.apache.cxf.rs.security.jose.jwk.JwkUtils;
import org.apache.cxf.rs.security.jose.jwk.KeyOperation;
import org.apache.cxf.rs.security.jose.jwk.KeyType;
import org.apache.cxf.rs.security.jose.jwk.PublicKeyUse;
import org.apache.cxf.rt.security.crypto.MessageDigestUtils;

public final class JwsUtils {
    private static final Logger LOG = LogUtils.getL7dLogger(JwsUtils.class);

    private JwsUtils() {

    }
    public static String sign(PrivateKey key, SignatureAlgorithm algo, String content) {
        return sign(key, algo, content, null);
    }


    public static String sign(PrivateKey key, SignatureAlgorithm algo, String content, String ct) {
        return sign(getPrivateKeySignatureProvider(key, algo), content, ct);
    }
    public static String sign(String encodedKey, SignatureAlgorithm algo, String content) {
        return sign(JoseUtils.decode(encodedKey), algo, content);
    }
    public static String sign(byte[] key, SignatureAlgorithm algo, String content) {
        return sign(key, algo, content, null);
    }
    public static String sign(byte[] key, SignatureAlgorithm algo, String content, String ct) {
        return sign(getHmacSignatureProvider(key, algo), content, ct);
    }
    public static String verify(PublicKey key, SignatureAlgorithm algo, String content) {
        JwsCompactConsumer jws = verify(getPublicKeySignatureVerifier(key, algo), content);
        return jws.getDecodedJwsPayload();
    }
    public static String verify(String encodedKey, SignatureAlgorithm algo, String content) {
        return verify(JoseUtils.decode(encodedKey), algo, content);
    }
    public static String verify(byte[] key, SignatureAlgorithm algo, String content) {
        JwsCompactConsumer jws = verify(getHmacSignatureVerifier(key, algo), content);
        return jws.getDecodedJwsPayload();
    }
    public static JwsSignatureProvider getSignatureProvider(JsonWebKey jwk) {
        return getSignatureProvider(jwk, null);
    }
    public static JwsSignatureProvider getSignatureProvider(JsonWebKey jwk,
                                                            SignatureAlgorithm defaultAlgorithm) {
        SignatureAlgorithm sigAlgo = jwk.getAlgorithm() == null ? defaultAlgorithm
            : SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm());
        JwsSignatureProvider theSigProvider = null;
        KeyType keyType = jwk.getKeyType();
        if (KeyType.RSA == keyType) {
            theSigProvider = getPrivateKeySignatureProvider(JwkUtils.toRSAPrivateKey(jwk),
                                                            sigAlgo);
        } else if (KeyType.OCTET == keyType) {
            byte[] key = JoseUtils.decode((String)jwk.getProperty(JsonWebKey.OCTET_KEY_VALUE));
            theSigProvider = getHmacSignatureProvider(key, sigAlgo);
        } else if (KeyType.EC == jwk.getKeyType()) {
            theSigProvider = getPrivateKeySignatureProvider(JwkUtils.toECPrivateKey(jwk),
                                                            sigAlgo);
        }
        return theSigProvider;
    }
    public static JwsSignatureProvider getPrivateKeySignatureProvider(PrivateKey key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }
        if (key instanceof ECPrivateKey) {
            return new EcDsaJwsSignatureProvider((ECPrivateKey)key, algo);
        } else if (key instanceof RSAPrivateKey) {
            return new PrivateKeyJwsSignatureProvider(key, algo);
        }

        return null;
    }
    public static JwsSignatureProvider getHmacSignatureProvider(String encodedKey, SignatureAlgorithm algo) {
        return getHmacSignatureProvider(JoseUtils.decode(encodedKey), algo);
    }
    public static JwsSignatureProvider getHmacSignatureProvider(byte[] key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }
        if (AlgorithmUtils.isHmacSign(algo.getJwaName())) {
            return new HmacJwsSignatureProvider(key, algo);
        }
        return null;
    }
    public static JwsSignatureVerifier getSignatureVerifier(JsonWebKey jwk) {
        return getSignatureVerifier(jwk, null);
    }
    public static JwsSignatureVerifier getSignatureVerifier(JsonWebKey jwk, SignatureAlgorithm defaultAlgorithm) {
        SignatureAlgorithm sigAlgo = jwk.getAlgorithm() == null ? defaultAlgorithm
            : SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm());
        JwsSignatureVerifier theVerifier = null;
        KeyType keyType = jwk.getKeyType();
        if (KeyType.RSA == keyType) {
            theVerifier = getPublicKeySignatureVerifier(JwkUtils.toRSAPublicKey(jwk, true), sigAlgo);
        } else if (KeyType.OCTET == keyType) {
            byte[] key = JoseUtils.decode((String)jwk.getProperty(JsonWebKey.OCTET_KEY_VALUE));
            theVerifier = getHmacSignatureVerifier(key, sigAlgo);
        } else if (KeyType.EC == keyType) {
            theVerifier = getPublicKeySignatureVerifier(JwkUtils.toECPublicKey(jwk), sigAlgo);
        }
        return theVerifier;
    }
    public static JwsSignatureVerifier getPublicKeySignatureVerifier(X509Certificate cert, SignatureAlgorithm algo) {
        if (cert != null) {
            if (algo == null) {
                algo = getDefaultPublicKeyAlgorithm(cert.getPublicKey());
            }
            if (algo == null) {
                LOG.warning(""No signature algorithm was defined"");
                throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
            }    
            
            if (cert.getPublicKey() instanceof RSAPublicKey) {
                return new PublicKeyJwsSignatureVerifier(cert, algo);
            } else if (cert.getPublicKey() instanceof ECPublicKey) {
                return new EcDsaJwsSignatureVerifier(cert, algo);
            }
        }

        return null;
    }
    public static JwsSignatureVerifier getPublicKeySignatureVerifier(PublicKey key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }

        if (key instanceof RSAPublicKey) {
            return new PublicKeyJwsSignatureVerifier(key, algo);
        } else if (key instanceof ECPublicKey) {
            return new EcDsaJwsSignatureVerifier(key, algo);
        }

        return null;
    }
    public static JwsSignatureVerifier getHmacSignatureVerifier(String encodedKey, SignatureAlgorithm algo) {
        return getHmacSignatureVerifier(JoseUtils.decode(encodedKey), algo);
    }
    public static JwsSignatureVerifier getHmacSignatureVerifier(byte[] key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }

        if (AlgorithmUtils.isHmacSign(algo.getJwaName())) {
            return new HmacJwsSignatureVerifier(key, algo);
        }
        return null;
    }

    public static Map<SignatureAlgorithm, List<JwsJsonSignatureEntry>> getJwsJsonSignatureMap(
        List<JwsJsonSignatureEntry> signatures) {
        Map<SignatureAlgorithm, List<JwsJsonSignatureEntry>> map = new HashMap<>();
        for (JwsJsonSignatureEntry entry : signatures) {
            SignatureAlgorithm sigAlgorithm = entry.getUnionHeader().getSignatureAlgorithm();
            List<JwsJsonSignatureEntry> entries = map.get(sigAlgorithm);
            if (entries == null) {
                entries = new ArrayList<>();
            }
            entries.add(entry);
            map.put(sigAlgorithm, entries);
        }
        return map;
    }

    public static JwsSignatureProvider loadSignatureProvider(boolean required) {
        return loadSignatureProvider(null, required);
    }

    public static JwsSignatureProvider loadSignatureProvider(JwsHeaders headers, boolean required) {
        Properties props = loadSignatureOutProperties(required);
        if (props == null) {
            return null;
        }
        JwsSignatureProvider theSigProvider = loadSignatureProvider(props, headers);
        if (headers != null) {
            headers.setSignatureAlgorithm(theSigProvider.getAlgorithm());
        }
        return theSigProvider;
    }
    public static Properties loadSignatureOutProperties(boolean required) {
        Message m = PhaseInterceptorChain.getCurrentMessage();
        return KeyManagementUtils.loadStoreProperties(m, required,
                                                      JoseConstants.RSSEC_SIGNATURE_OUT_PROPS,
                                                      JoseConstants.RSSEC_SIGNATURE_PROPS);

    }
    public static Properties loadSignatureInProperties(boolean required) {
        Message m = PhaseInterceptorChain.getCurrentMessage();
        return KeyManagementUtils.loadStoreProperties(m, required,
                                                      JoseConstants.RSSEC_SIGNATURE_IN_PROPS,
                                                      JoseConstants.RSSEC_SIGNATURE_PROPS);

    }
    public static Properties loadSignatureProperties(String propertiesName, boolean required) {
        Message m = PhaseInterceptorChain.getCurrentMessage();
        return KeyManagementUtils.loadStoreProperties(m, required, propertiesName, null);

    }
    public static Properties loadSignatureProperties(String propertiesLoc, Bus bus) {
        try {
            return JoseUtils.loadProperties(propertiesLoc, bus);
        } catch (Exception ex) {
            throw new JwsException(JwsException.Error.NO_INIT_PROPERTIES, ex);
        }
    }
    public static JwsSignatureVerifier loadSignatureVerifier(boolean required) {
        return loadSignatureVerifier(null, required);
    }
    public static JwsSignatureVerifier loadSignatureVerifier(String propertiesLoc, Bus bus) {
        Properties props = loadSignatureProperties(propertiesLoc, bus);
        return loadSignatureVerifier(props, null);
    }
    public static JwsSignatureVerifier loadSignatureVerifier(JwsHeaders headers, boolean required) {
        Properties props = loadSignatureInProperties(required);
        return loadSignatureVerifier(props, headers);
    }
    
    
    public static boolean validateCriticalHeaders(JwsHeaders headers) {
        //TODO: validate JWS specific constraints
        return JoseUtils.validateCriticalHeaders(headers);
    }
    public static JwsSignatureProvider loadSignatureProvider(Properties props,
                                                             JwsHeaders headers) {
        return loadSignatureProvider(PhaseInterceptorChain.getCurrentMessage(),
                                     props, headers);
    }
    
    public static JwsSignatureProvider loadSignatureProvider(String propertiesLoc, Bus bus) {
        Properties props = loadSignatureProperties(propertiesLoc, bus);
        return loadSignatureProvider(props, null);
    }

    public static JwsSignatureProvider loadSignatureProvider(Message m,
                                                             Properties props,
                                                             JwsHeaders headers) {
        JwsSignatureProvider theSigProvider = null;

        boolean includeCert = 
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT);
        boolean includeCertSha1 = 
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT_SHA1);
        boolean includeCertSha256 =  
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT_SHA256);
        boolean includeKeyId =
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_KEY_ID);

        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {
            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.SIGN);
            if (jwk != null) {
                SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m,
                                                             props,
                                                             SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm()),
                                                             getDefaultKeyAlgorithm(jwk));
                theSigProvider = JwsUtils.getSignatureProvider(jwk, signatureAlgo);

                boolean includePublicKey = 
                    JoseUtils.checkBooleanProperty(headers, props, m, 
                                                   JoseConstants.RSSEC_SIGNATURE_INCLUDE_PUBLIC_KEY);

                if (includeCert) {
                    JwkUtils.includeCertChain(jwk, headers, signatureAlgo.getJwaName());
                }
                if (includeCertSha1) {
                    KeyManagementUtils.setSha1DigestHeader(headers, m, props);
                } else if (includeCertSha256) {
                    KeyManagementUtils.setSha256DigestHeader(headers, m, props);
                }
                if (includePublicKey) {
                    JwkUtils.includePublicKey(jwk, headers, signatureAlgo.getJwaName());
                }
                if (includeKeyId && jwk.getKeyId() != null) {
                    headers.setKeyId(jwk.getKeyId());
                }
            }
        } else {
            SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, null, null);
            if (signatureAlgo == SignatureAlgorithm.NONE) {
                theSigProvider = new NoneJwsSignatureProvider();
            } else {
                PrivateKey pk = KeyManagementUtils.loadPrivateKey(m, props, KeyOperation.SIGN);
                if (signatureAlgo == null) {
                    signatureAlgo = getDefaultPrivateKeyAlgorithm(pk);
                }
                
                theSigProvider = getPrivateKeySignatureProvider(pk, signatureAlgo);
                if (includeCert) {
                    headers.setX509Chain(KeyManagementUtils.loadAndEncodeX509CertificateOrChain(m, props));
                }
                if (includeCertSha1) {
                    KeyManagementUtils.setSha1DigestHeader(headers, m, props);
                } else if (includeCertSha256) {
                    KeyManagementUtils.setSha256DigestHeader(headers, m, props);
                }  
                if (includeKeyId && props.containsKey(JoseConstants.RSSEC_KEY_STORE_ALIAS)) {
                    headers.setKeyId(props.getProperty(JoseConstants.RSSEC_KEY_STORE_ALIAS));
                }
            }
        }
        if (theSigProvider == null) {
            LOG.warning(""Provider is not available"");
            throw new JwsException(JwsException.Error.NO_PROVIDER);
        }
        return theSigProvider;
    }
    public static JwsSignatureVerifier loadSignatureVerifier(Properties props,
                                                             JwsHeaders inHeaders) {
        return loadSignatureVerifier(PhaseInterceptorChain.getCurrentMessage(),
                                     props, inHeaders);
    }
    public static JwsSignatureVerifier loadSignatureVerifier(Message m,
                                                              Properties props,
                                                              JwsHeaders inHeaders) {
        JwsSignatureVerifier theVerifier = null;
        String inHeaderKid = null;
        if (inHeaders != null) {
            inHeaderKid = inHeaders.getKeyId();
            //TODO: optionally validate inHeaders.getAlgorithm against a property in props
            if (inHeaders.getHeader(JoseConstants.HEADER_JSON_WEB_KEY) != null) {
                JsonWebKey publicJwk = inHeaders.getJsonWebKey();
                if (inHeaderKid != null && !inHeaderKid.equals(publicJwk.getKeyId())
                    || !MessageUtils.getContextualBoolean(m, JoseConstants.RSSEC_ACCEPT_PUBLIC_KEY, false)) {
                    throw new JwsException(JwsException.Error.INVALID_KEY);
                }
                return getSignatureVerifier(publicJwk,
                                            inHeaders.getSignatureAlgorithm());
            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_CHAIN) != null) {
                List<X509Certificate> chain = KeyManagementUtils.toX509CertificateChain(inHeaders.getX509Chain());
                KeyManagementUtils.validateCertificateChain(props, chain);
                return getPublicKeySignatureVerifier(chain.get(0),
                                                     inHeaders.getSignatureAlgorithm());
            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_THUMBPRINT) != null) {
                X509Certificate foundCert =
                    KeyManagementUtils.getCertificateFromThumbprint(inHeaders.getX509Thumbprint(),
                                                                    MessageDigestUtils.ALGO_SHA_1,
                                                                    m, props);
                if (foundCert != null) {
                    return getPublicKeySignatureVerifier(foundCert,
                                                         inHeaders.getSignatureAlgorithm());
                }
            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_THUMBPRINT_SHA256) != null) {
                X509Certificate foundCert =
                    KeyManagementUtils.getCertificateFromThumbprint(inHeaders.getX509ThumbprintSHA256(),
                                                                    MessageDigestUtils.ALGO_SHA_256,
                                                                    m, props);
                if (foundCert != null) {
                    return getPublicKeySignatureVerifier(foundCert,
                                                         inHeaders.getSignatureAlgorithm());
                }
            }
        }

        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {
            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.VERIFY, inHeaderKid);
            if (jwk != null) {
                SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props,
                                                             SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm()),
                                                             getDefaultKeyAlgorithm(jwk));
                theVerifier = getSignatureVerifier(jwk, signatureAlgo);
            }

        } else {
            SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, null, null);
            if (signatureAlgo == SignatureAlgorithm.NONE
                && SignatureAlgorithm.NONE.getJwaName().equals(inHeaders.getAlgorithm())) {
                theVerifier = new NoneJwsSignatureVerifier();
            } else {
                X509Certificate[] certs = KeyManagementUtils.loadX509CertificateOrChain(m, props);
                if (certs != null && certs.length > 0) {
                    theVerifier = getPublicKeySignatureVerifier(certs[0], signatureAlgo);
                }
            }
        }
        if (theVerifier == null) {
            LOG.warning(""Verifier is not available"");
            throw new JwsException(JwsException.Error.NO_VERIFIER);
        }
        return theVerifier;
    }
    public static Properties loadJwsProperties(Message m, String propLoc) {
        try {
            return JoseUtils.loadProperties(propLoc, m.getExchange().getBus());
        } catch (Exception ex) {
            LOG.warning(""JWS init properties are not available"");
            throw new JwsException(JwsException.Error.NO_INIT_PROPERTIES);
        }
    }

    public static SignatureAlgorithm getSignatureAlgorithm(Message m, Properties props,
                                               SignatureAlgorithm algo,
                                               SignatureAlgorithm defaultAlgo) {
        if (algo == null) {
            algo = getSignatureAlgorithm(m, props, defaultAlgo);
        }
        return algo;
    }
    public static SignatureAlgorithm getSignatureAlgorithm(Properties props,
                                                           SignatureAlgorithm defaultAlgo) {
        return getSignatureAlgorithm(PhaseInterceptorChain.getCurrentMessage(),
                                     props, defaultAlgo);
    }
    public static SignatureAlgorithm getSignatureAlgorithm(Message m,
                                                           Properties props,
                                                           SignatureAlgorithm defaultAlgo) {
        String algo = KeyManagementUtils.getKeyAlgorithm(m,
                                                  props,
                                                  JoseConstants.RSSEC_SIGNATURE_ALGORITHM,
                                                  defaultAlgo == null ? null : defaultAlgo.getJwaName());
        return SignatureAlgorithm.getAlgorithm(algo);
    }
    private static SignatureAlgorithm getDefaultKeyAlgorithm(JsonWebKey jwk) {
        KeyType keyType = jwk.getKeyType();
        if (KeyType.OCTET == keyType) {
            return SignatureAlgorithm.HS256;
        } else if (KeyType.EC == keyType) {
            return SignatureAlgorithm.ES256;
        } else {
            return SignatureAlgorithm.RS256;
        }
    }
    private static SignatureAlgorithm getDefaultPrivateKeyAlgorithm(PrivateKey key) {
        if (key instanceof RSAPrivateKey) {
            return SignatureAlgorithm.RS256;
        } else if (key instanceof ECPrivateKey) {
            return SignatureAlgorithm.ES256;
        } else {
            return null;
        }
    }
    private static SignatureAlgorithm getDefaultPublicKeyAlgorithm(PublicKey key) {
        if (key instanceof RSAPublicKey) {
            return SignatureAlgorithm.RS256;
        } else if (key instanceof ECPublicKey) {
            return SignatureAlgorithm.ES256;
        } else {
            return null;
        }
    }
    public static JwsCompactConsumer verify(JwsSignatureVerifier v, String content) {
        JwsCompactConsumer jws = new JwsCompactConsumer(content);
        if (!jws.verifySignatureWith(v)) {
            throw new JwsException(JwsException.Error.INVALID_SIGNATURE);
        }
        return jws;
    }
    public static String sign(JwsSignatureProvider jwsSig, String content, String ct) {
        JwsHeaders headers = new JwsHeaders();
        if (ct != null) {
            headers.setContentType(ct);
        }
        JwsCompactProducer jws = new JwsCompactProducer(headers, content);
        jws.signWith(jwsSig);
        return jws.getSignedEncodedJws();
    }
    public static void validateJwsCertificateChain(List<X509Certificate> certs) {

        Properties props = loadSignatureInProperties(true);
        KeyManagementUtils.validateCertificateChain(props, certs);
    }
    public static boolean isPayloadUnencoded(JwsHeaders jwsHeaders) {
        return jwsHeaders.getPayloadEncodingStatus() == Boolean.FALSE;
    }

    public static void checkSignatureKeySize(Key key) {
        if (key instanceof RSAKey && ((RSAKey)key).getModulus().bitLength() < 2048) {
            LOG.fine(""A key of size: "" + ((RSAKey)key).getModulus().bitLength()
                     + "" was used with an RSA signature algorithm. 2048 is the minimum size that is accepted"");
            throw new JwsException(JwsException.Error.INVALID_KEY);
        }
    }
    public static JsonWebKeys loadPublicVerificationKeys(Message m, Properties props) {
        String storeType = props.getProperty(JoseConstants.RSSEC_KEY_STORE_TYPE);
        if (""jwk"".equals(storeType)) {
            return JwkUtils.loadPublicJwkSet(m, props);
        }
        X509Certificate[] certs = null;
        if (PropertyUtils.isTrue(props.get(JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT))) {
            certs = KeyManagementUtils.loadX509CertificateOrChain(m, props);
        }
        PublicKey key = certs != null && certs.length > 0
            ? certs[0].getPublicKey() : KeyManagementUtils.loadPublicKey(m, props);
        JsonWebKey jwk = JwkUtils.fromPublicKey(key, props, JoseConstants.RSSEC_SIGNATURE_ALGORITHM);
        jwk.setPublicKeyUse(PublicKeyUse.SIGN);
        if (certs != null) {
            jwk.setX509Chain(KeyManagementUtils.encodeX509CertificateChain(certs));
        }
        return new JsonWebKeys(jwk);
    }
}
",0
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/main/java/org/apache/cxf/rs/security/jose/jws/JwsUtils.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jws;

import java.security.Key;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Logger;

import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.common.util.PropertyUtils;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageUtils;
import org.apache.cxf.phase.PhaseInterceptorChain;
import org.apache.cxf.rs.security.jose.common.JoseConstants;
import org.apache.cxf.rs.security.jose.common.JoseException;
import org.apache.cxf.rs.security.jose.common.JoseUtils;
import org.apache.cxf.rs.security.jose.common.KeyManagementUtils;
import org.apache.cxf.rs.security.jose.jwa.AlgorithmUtils;
import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKey;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKeys;
import org.apache.cxf.rs.security.jose.jwk.JwkUtils;
import org.apache.cxf.rs.security.jose.jwk.KeyOperation;
import org.apache.cxf.rs.security.jose.jwk.KeyType;
import org.apache.cxf.rs.security.jose.jwk.PublicKeyUse;
import org.apache.cxf.rt.security.crypto.MessageDigestUtils;

public final class JwsUtils {
    private static final Logger LOG = LogUtils.getL7dLogger(JwsUtils.class);

    private JwsUtils() {

    }
    public static String sign(PrivateKey key, SignatureAlgorithm algo, String content) {
        return sign(key, algo, content, null);
    }


    public static String sign(PrivateKey key, SignatureAlgorithm algo, String content, String ct) {
        return sign(getPrivateKeySignatureProvider(key, algo), content, ct);
    }
    public static String sign(String encodedKey, SignatureAlgorithm algo, String content) {
        return sign(JoseUtils.decode(encodedKey), algo, content);
    }
    public static String sign(byte[] key, SignatureAlgorithm algo, String content) {
        return sign(key, algo, content, null);
    }
    public static String sign(byte[] key, SignatureAlgorithm algo, String content, String ct) {
        return sign(getHmacSignatureProvider(key, algo), content, ct);
    }
    public static String verify(PublicKey key, SignatureAlgorithm algo, String content) {
        JwsCompactConsumer jws = verify(getPublicKeySignatureVerifier(key, algo), content);
        return jws.getDecodedJwsPayload();
    }
    public static String verify(String encodedKey, SignatureAlgorithm algo, String content) {
        return verify(JoseUtils.decode(encodedKey), algo, content);
    }
    public static String verify(byte[] key, SignatureAlgorithm algo, String content) {
        JwsCompactConsumer jws = verify(getHmacSignatureVerifier(key, algo), content);
        return jws.getDecodedJwsPayload();
    }
    public static JwsSignatureProvider getSignatureProvider(JsonWebKey jwk) {
        return getSignatureProvider(jwk, null);
    }
    public static JwsSignatureProvider getSignatureProvider(JsonWebKey jwk,
                                                            SignatureAlgorithm defaultAlgorithm) {
        SignatureAlgorithm sigAlgo = jwk.getAlgorithm() == null ? defaultAlgorithm
            : SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm());
        JwsSignatureProvider theSigProvider = null;
        KeyType keyType = jwk.getKeyType();
        if (KeyType.RSA == keyType) {
            theSigProvider = getPrivateKeySignatureProvider(JwkUtils.toRSAPrivateKey(jwk),
                                                            sigAlgo);
        } else if (KeyType.OCTET == keyType) {
            byte[] key = JoseUtils.decode((String)jwk.getProperty(JsonWebKey.OCTET_KEY_VALUE));
            theSigProvider = getHmacSignatureProvider(key, sigAlgo);
        } else if (KeyType.EC == jwk.getKeyType()) {
            theSigProvider = getPrivateKeySignatureProvider(JwkUtils.toECPrivateKey(jwk),
                                                            sigAlgo);
        }
        return theSigProvider;
    }
    public static JwsSignatureProvider getPrivateKeySignatureProvider(PrivateKey key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }
        if (key instanceof ECPrivateKey) {
            return new EcDsaJwsSignatureProvider((ECPrivateKey)key, algo);
        } else if (key instanceof RSAPrivateKey) {
            return new PrivateKeyJwsSignatureProvider(key, algo);
        }

        return null;
    }
    public static JwsSignatureProvider getHmacSignatureProvider(String encodedKey, SignatureAlgorithm algo) {
        return getHmacSignatureProvider(JoseUtils.decode(encodedKey), algo);
    }
    public static JwsSignatureProvider getHmacSignatureProvider(byte[] key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }
        if (AlgorithmUtils.isHmacSign(algo.getJwaName())) {
            return new HmacJwsSignatureProvider(key, algo);
        }
        return null;
    }
    public static JwsSignatureVerifier getSignatureVerifier(JsonWebKey jwk) {
        return getSignatureVerifier(jwk, null);
    }
    public static JwsSignatureVerifier getSignatureVerifier(JsonWebKey jwk, SignatureAlgorithm defaultAlgorithm) {
        SignatureAlgorithm sigAlgo = jwk.getAlgorithm() == null ? defaultAlgorithm
            : SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm());
        JwsSignatureVerifier theVerifier = null;
        KeyType keyType = jwk.getKeyType();
        if (KeyType.RSA == keyType) {
            theVerifier = getPublicKeySignatureVerifier(JwkUtils.toRSAPublicKey(jwk, true), sigAlgo);
        } else if (KeyType.OCTET == keyType) {
            byte[] key = JoseUtils.decode((String)jwk.getProperty(JsonWebKey.OCTET_KEY_VALUE));
            theVerifier = getHmacSignatureVerifier(key, sigAlgo);
        } else if (KeyType.EC == keyType) {
            theVerifier = getPublicKeySignatureVerifier(JwkUtils.toECPublicKey(jwk), sigAlgo);
        }
        return theVerifier;
    }
    public static JwsSignatureVerifier getPublicKeySignatureVerifier(X509Certificate cert, SignatureAlgorithm algo) {
        if (cert != null) {
            if (algo == null) {
                algo = getDefaultPublicKeyAlgorithm(cert.getPublicKey());
            }
            if (algo == null) {
                LOG.warning(""No signature algorithm was defined"");
                throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
            }

            if (cert.getPublicKey() instanceof RSAPublicKey) {
                return new PublicKeyJwsSignatureVerifier(cert, algo);
            } else if (cert.getPublicKey() instanceof ECPublicKey) {
                return new EcDsaJwsSignatureVerifier(cert, algo);
            }
        }

        return null;
    }
    public static JwsSignatureVerifier getPublicKeySignatureVerifier(PublicKey key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }

        if (key instanceof RSAPublicKey) {
            return new PublicKeyJwsSignatureVerifier(key, algo);
        } else if (key instanceof ECPublicKey) {
            return new EcDsaJwsSignatureVerifier(key, algo);
        }

        return null;
    }
    public static JwsSignatureVerifier getHmacSignatureVerifier(String encodedKey, SignatureAlgorithm algo) {
        return getHmacSignatureVerifier(JoseUtils.decode(encodedKey), algo);
    }
    public static JwsSignatureVerifier getHmacSignatureVerifier(byte[] key, SignatureAlgorithm algo) {
        if (algo == null) {
            LOG.warning(""No signature algorithm was defined"");
            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);
        }

        if (AlgorithmUtils.isHmacSign(algo.getJwaName())) {
            return new HmacJwsSignatureVerifier(key, algo);
        }
        return null;
    }

    public static Map<SignatureAlgorithm, List<JwsJsonSignatureEntry>> getJwsJsonSignatureMap(
        List<JwsJsonSignatureEntry> signatures) {
        Map<SignatureAlgorithm, List<JwsJsonSignatureEntry>> map = new HashMap<>();
        for (JwsJsonSignatureEntry entry : signatures) {
            SignatureAlgorithm sigAlgorithm = entry.getUnionHeader().getSignatureAlgorithm();
            List<JwsJsonSignatureEntry> entries = map.get(sigAlgorithm);
            if (entries == null) {
                entries = new ArrayList<>();
            }
            entries.add(entry);
            map.put(sigAlgorithm, entries);
        }
        return map;
    }

    public static JwsSignatureProvider loadSignatureProvider(boolean required) {
        return loadSignatureProvider(null, required);
    }

    public static JwsSignatureProvider loadSignatureProvider(JwsHeaders headers, boolean required) {
        Properties props = loadSignatureOutProperties(required);
        if (props == null) {
            return null;
        }
        JwsSignatureProvider theSigProvider = loadSignatureProvider(props, headers);
        if (headers != null) {
            headers.setSignatureAlgorithm(theSigProvider.getAlgorithm());
        }
        return theSigProvider;
    }
    public static Properties loadSignatureOutProperties(boolean required) {
        Message m = PhaseInterceptorChain.getCurrentMessage();
        return KeyManagementUtils.loadStoreProperties(m, required,
                                                      JoseConstants.RSSEC_SIGNATURE_OUT_PROPS,
                                                      JoseConstants.RSSEC_SIGNATURE_PROPS);

    }
    public static Properties loadSignatureInProperties(boolean required) {
        Message m = PhaseInterceptorChain.getCurrentMessage();
        return KeyManagementUtils.loadStoreProperties(m, required,
                                                      JoseConstants.RSSEC_SIGNATURE_IN_PROPS,
                                                      JoseConstants.RSSEC_SIGNATURE_PROPS);

    }
    public static Properties loadSignatureProperties(String propertiesName, boolean required) {
        Message m = PhaseInterceptorChain.getCurrentMessage();
        return KeyManagementUtils.loadStoreProperties(m, required, propertiesName, null);

    }
    public static Properties loadSignatureProperties(String propertiesLoc, Bus bus) {
        try {
            return JoseUtils.loadProperties(propertiesLoc, bus);
        } catch (Exception ex) {
            throw new JwsException(JwsException.Error.NO_INIT_PROPERTIES, ex);
        }
    }
    public static JwsSignatureVerifier loadSignatureVerifier(boolean required) {
        return loadSignatureVerifier(null, required);
    }
    public static JwsSignatureVerifier loadSignatureVerifier(String propertiesLoc, Bus bus) {
        Properties props = loadSignatureProperties(propertiesLoc, bus);
        return loadSignatureVerifier(props, null);
    }
    public static JwsSignatureVerifier loadSignatureVerifier(JwsHeaders headers, boolean required) {
        Properties props = loadSignatureInProperties(required);
        return loadSignatureVerifier(props, headers);
    }


    public static boolean validateCriticalHeaders(JwsHeaders headers) {
        //TODO: validate JWS specific constraints
        return JoseUtils.validateCriticalHeaders(headers);
    }
    public static JwsSignatureProvider loadSignatureProvider(Properties props,
                                                             JwsHeaders headers) {
        return loadSignatureProvider(PhaseInterceptorChain.getCurrentMessage(),
                                     props, headers);
    }

    public static JwsSignatureProvider loadSignatureProvider(String propertiesLoc, Bus bus) {
        Properties props = loadSignatureProperties(propertiesLoc, bus);
        return loadSignatureProvider(props, null);
    }

    public static JwsSignatureProvider loadSignatureProvider(Message m,
                                                             Properties props,
                                                             JwsHeaders headers) {
        JwsSignatureProvider theSigProvider = null;

        boolean includeCert =
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT);
        boolean includeCertSha1 =
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT_SHA1);
        boolean includeCertSha256 =
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT_SHA256);
        boolean includeKeyId =
            JoseUtils.checkBooleanProperty(headers, props, m, JoseConstants.RSSEC_SIGNATURE_INCLUDE_KEY_ID);

        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {
            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.SIGN);
            if (jwk != null) {
                SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m,
                                                             props,
                                                             SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm()),
                                                             getDefaultKeyAlgorithm(jwk));
                theSigProvider = JwsUtils.getSignatureProvider(jwk, signatureAlgo);

                boolean includePublicKey =
                    JoseUtils.checkBooleanProperty(headers, props, m,
                                                   JoseConstants.RSSEC_SIGNATURE_INCLUDE_PUBLIC_KEY);

                if (includeCert) {
                    JwkUtils.includeCertChain(jwk, headers, signatureAlgo.getJwaName());
                }
                if (includeCertSha1) {
                    KeyManagementUtils.setSha1DigestHeader(headers, m, props);
                } else if (includeCertSha256) {
                    KeyManagementUtils.setSha256DigestHeader(headers, m, props);
                }
                if (includePublicKey) {
                    JwkUtils.includePublicKey(jwk, headers, signatureAlgo.getJwaName());
                }
                if (includeKeyId && jwk.getKeyId() != null) {
                    headers.setKeyId(jwk.getKeyId());
                }
            }
        } else {
            SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, null, null);
            if (signatureAlgo == SignatureAlgorithm.NONE) {
                theSigProvider = new NoneJwsSignatureProvider();
            } else {
                PrivateKey pk = KeyManagementUtils.loadPrivateKey(m, props, KeyOperation.SIGN);
                if (signatureAlgo == null) {
                    signatureAlgo = getDefaultPrivateKeyAlgorithm(pk);
                }

                theSigProvider = getPrivateKeySignatureProvider(pk, signatureAlgo);
                if (includeCert) {
                    headers.setX509Chain(KeyManagementUtils.loadAndEncodeX509CertificateOrChain(m, props));
                }
                if (includeCertSha1) {
                    KeyManagementUtils.setSha1DigestHeader(headers, m, props);
                } else if (includeCertSha256) {
                    KeyManagementUtils.setSha256DigestHeader(headers, m, props);
                }
                if (includeKeyId && props.containsKey(JoseConstants.RSSEC_KEY_STORE_ALIAS)) {
                    headers.setKeyId(props.getProperty(JoseConstants.RSSEC_KEY_STORE_ALIAS));
                }
            }
        }
        if (theSigProvider == null) {
            LOG.warning(""Provider is not available"");
            throw new JwsException(JwsException.Error.NO_PROVIDER);
        }
        return theSigProvider;
    }
    public static JwsSignatureVerifier loadSignatureVerifier(Properties props,
                                                             JwsHeaders inHeaders) {
        return loadSignatureVerifier(PhaseInterceptorChain.getCurrentMessage(),
                                     props, inHeaders);
    }
    public static JwsSignatureVerifier loadSignatureVerifier(Message m,
                                                              Properties props,
                                                              JwsHeaders inHeaders) {
        JwsSignatureVerifier theVerifier = null;
        String inHeaderKid = null;
        if (inHeaders != null) {
            inHeaderKid = inHeaders.getKeyId();
            //TODO: optionally validate inHeaders.getAlgorithm against a property in props
            if (inHeaders.getHeader(JoseConstants.HEADER_JSON_WEB_KEY) != null) {
                JsonWebKey publicJwk = inHeaders.getJsonWebKey();
                if (inHeaderKid != null && !inHeaderKid.equals(publicJwk.getKeyId())
                    || !MessageUtils.getContextualBoolean(m, JoseConstants.RSSEC_ACCEPT_PUBLIC_KEY, false)) {
                    throw new JwsException(JwsException.Error.INVALID_KEY);
                }
                return getSignatureVerifier(publicJwk,
                                            inHeaders.getSignatureAlgorithm());
            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_CHAIN) != null) {
                List<X509Certificate> chain = KeyManagementUtils.toX509CertificateChain(inHeaders.getX509Chain());
                KeyManagementUtils.validateCertificateChain(props, chain);
                return getPublicKeySignatureVerifier(chain.get(0),
                                                     inHeaders.getSignatureAlgorithm());
            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_THUMBPRINT) != null) {
                X509Certificate foundCert =
                    KeyManagementUtils.getCertificateFromThumbprint(inHeaders.getX509Thumbprint(),
                                                                    MessageDigestUtils.ALGO_SHA_1,
                                                                    m, props);
                if (foundCert != null) {
                    return getPublicKeySignatureVerifier(foundCert,
                                                         inHeaders.getSignatureAlgorithm());
                }
            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_THUMBPRINT_SHA256) != null) {
                X509Certificate foundCert =
                    KeyManagementUtils.getCertificateFromThumbprint(inHeaders.getX509ThumbprintSHA256(),
                                                                    MessageDigestUtils.ALGO_SHA_256,
                                                                    m, props);
                if (foundCert != null) {
                    return getPublicKeySignatureVerifier(foundCert,
                                                         inHeaders.getSignatureAlgorithm());
                }
            }
        }

        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {
            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.VERIFY, inHeaderKid);
            if (jwk != null) {
                SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props,
                                                             SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm()),
                                                             getDefaultKeyAlgorithm(jwk));
                theVerifier = getSignatureVerifier(jwk, signatureAlgo);
            }

        } else {
            SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, null, null);
            if (signatureAlgo == SignatureAlgorithm.NONE
                && SignatureAlgorithm.NONE.getJwaName().equals(inHeaders.getAlgorithm())) {
                theVerifier = new NoneJwsSignatureVerifier();
            } else {
                X509Certificate[] certs = KeyManagementUtils.loadX509CertificateOrChain(m, props);
                if (certs != null && certs.length > 0) {
                    theVerifier = getPublicKeySignatureVerifier(certs[0], signatureAlgo);
                }
            }
        }
        if (theVerifier == null) {
            LOG.warning(""Verifier is not available"");
            throw new JwsException(JwsException.Error.NO_VERIFIER);
        }
        return theVerifier;
    }
    public static Properties loadJwsProperties(Message m, String propLoc) {
        try {
            return JoseUtils.loadProperties(propLoc, m.getExchange().getBus());
        } catch (Exception ex) {
            LOG.warning(""JWS init properties are not available"");
            throw new JwsException(JwsException.Error.NO_INIT_PROPERTIES);
        }
    }

    public static SignatureAlgorithm getSignatureAlgorithm(Message m, Properties props,
                                               SignatureAlgorithm algo,
                                               SignatureAlgorithm defaultAlgo) {
        if (algo == null) {
            algo = getSignatureAlgorithm(m, props, defaultAlgo);
        }
        return algo;
    }
    public static SignatureAlgorithm getSignatureAlgorithm(Properties props,
                                                           SignatureAlgorithm defaultAlgo) {
        return getSignatureAlgorithm(PhaseInterceptorChain.getCurrentMessage(),
                                     props, defaultAlgo);
    }
    public static SignatureAlgorithm getSignatureAlgorithm(Message m,
                                                           Properties props,
                                                           SignatureAlgorithm defaultAlgo) {
        String algo = KeyManagementUtils.getKeyAlgorithm(m,
                                                  props,
                                                  JoseConstants.RSSEC_SIGNATURE_ALGORITHM,
                                                  defaultAlgo == null ? null : defaultAlgo.getJwaName());
        return SignatureAlgorithm.getAlgorithm(algo);
    }
    private static SignatureAlgorithm getDefaultKeyAlgorithm(JsonWebKey jwk) {
        KeyType keyType = jwk.getKeyType();
        if (KeyType.OCTET == keyType) {
            return SignatureAlgorithm.HS256;
        } else if (KeyType.EC == keyType) {
            return SignatureAlgorithm.ES256;
        } else {
            return SignatureAlgorithm.RS256;
        }
    }
    private static SignatureAlgorithm getDefaultPrivateKeyAlgorithm(PrivateKey key) {
        if (key instanceof RSAPrivateKey) {
            return SignatureAlgorithm.RS256;
        } else if (key instanceof ECPrivateKey) {
            return SignatureAlgorithm.ES256;
        } else {
            return null;
        }
    }
    private static SignatureAlgorithm getDefaultPublicKeyAlgorithm(PublicKey key) {
        if (key instanceof RSAPublicKey) {
            return SignatureAlgorithm.RS256;
        } else if (key instanceof ECPublicKey) {
            return SignatureAlgorithm.ES256;
        } else {
            return null;
        }
    }
    public static JwsCompactConsumer verify(JwsSignatureVerifier v, String content) {
        JwsCompactConsumer jws = new JwsCompactConsumer(content);
        if (!jws.verifySignatureWith(v)) {
            throw new JwsException(JwsException.Error.INVALID_SIGNATURE);
        }
        return jws;
    }
    public static String sign(JwsSignatureProvider jwsSig, String content, String ct) {
        JwsHeaders headers = new JwsHeaders();
        if (ct != null) {
            headers.setContentType(ct);
        }
        JwsCompactProducer jws = new JwsCompactProducer(headers, content);
        jws.signWith(jwsSig);
        return jws.getSignedEncodedJws();
    }
    public static void validateJwsCertificateChain(List<X509Certificate> certs) {

        Properties props = loadSignatureInProperties(true);
        KeyManagementUtils.validateCertificateChain(props, certs);
    }
    public static boolean isPayloadUnencoded(JwsHeaders jwsHeaders) {
        return jwsHeaders.getPayloadEncodingStatus() == Boolean.FALSE;
    }

    public static void checkSignatureKeySize(Key key) {
        if (key instanceof RSAKey && ((RSAKey)key).getModulus().bitLength() < 2048) {
            LOG.fine(""A key of size: "" + ((RSAKey)key).getModulus().bitLength()
                     + "" was used with an RSA signature algorithm. 2048 is the minimum size that is accepted"");
            throw new JwsException(JwsException.Error.INVALID_KEY);
        }
    }

    @Deprecated
    public static JsonWebKeys loadPublicVerificationKeys(Message m, Properties props) {
        return loadPublicVerificationKeys(m, props, true);
    }

    public static JsonWebKeys loadPublicVerificationKeys(Message m, Properties props, boolean stripPrivateParameters) {
        String storeType = props.getProperty(JoseConstants.RSSEC_KEY_STORE_TYPE);
        if (""jwk"".equals(storeType)) {
            List<JsonWebKey> jsonWebKeys = JwkUtils.loadJsonWebKeys(m, props, KeyOperation.SIGN, null);
            if (jsonWebKeys == null || jsonWebKeys.isEmpty()) {
                throw new JoseException(""Error loading keys"");
            }
            return new JsonWebKeys(stripPrivateParameters ? JwkUtils.stripPrivateParameters(jsonWebKeys) : jsonWebKeys);
        }
        X509Certificate[] certs = null;
        if (PropertyUtils.isTrue(props.get(JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT))) {
            certs = KeyManagementUtils.loadX509CertificateOrChain(m, props);
        }
        PublicKey key = certs != null && certs.length > 0
            ? certs[0].getPublicKey() : KeyManagementUtils.loadPublicKey(m, props);
        JsonWebKey jwk = JwkUtils.fromPublicKey(key, props, JoseConstants.RSSEC_SIGNATURE_ALGORITHM);
        jwk.setPublicKeyUse(PublicKeyUse.SIGN);
        if (certs != null) {
            jwk.setX509Chain(KeyManagementUtils.encodeX509CertificateChain(certs));
        }
        return new JsonWebKeys(jwk);
    }
}
",1
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/test/java/org/apache/cxf/rs/security/jose/jws/JwsUtilsTest.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jws;

import java.util.List;
import java.util.Properties;

import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.rs.security.jose.common.JoseConstants;
import org.apache.cxf.rs.security.jose.jwa.AlgorithmUtils;
import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKey;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKeys;
import org.apache.cxf.rs.security.jose.jwk.KeyType;

import org.junit.Assert;
import org.junit.Test;

public class JwsUtilsTest extends Assert {

    @Test
    public void testSignatureAlgorithm() {
        assertTrue(AlgorithmUtils.isRsaSign(SignatureAlgorithm.RS256));
        assertFalse(AlgorithmUtils.isRsaSign(SignatureAlgorithm.NONE));

        try {
            AlgorithmUtils.RSA_SHA_SIGN_SET.add(SignatureAlgorithm.NONE.getJwaName());
            fail(""Failure expected on trying to modify the algorithm lists"");
        } catch (UnsupportedOperationException ex) {
            // expected
        }
    }

    @Test
    public void testLoadSignatureProviderFromJKS() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        JwsHeaders headers = new JwsHeaders();
        JwsSignatureProvider jws = JwsUtils.loadSignatureProvider(createMessage(),
                                                                  p,
                                                                  headers);
        assertNotNull(jws);
        assertEquals(""alice"", headers.getKeyId());
    }
    @Test
    public void testLoadSignatureVerifierFromJKS() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        JwsSignatureVerifier jws = JwsUtils.loadSignatureVerifier(createMessage(),
                                                                  p,
                                                                  new JwsHeaders());
        assertNotNull(jws);
    }
    @Test
    public void testLoadVerificationKey() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        JsonWebKeys keySet = JwsUtils.loadPublicVerificationKeys(createMessage(), p);
        assertEquals(1, keySet.asMap().size());
        List<JsonWebKey> keys = keySet.getRsaKeys();
        assertEquals(1, keys.size());
        JsonWebKey key = keys.get(0);
        assertEquals(KeyType.RSA, key.getKeyType());
        assertEquals(""alice"", key.getKeyId());
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_PUBLIC_EXP));
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_MODULUS));
        assertNull(key.getKeyProperty(JsonWebKey.RSA_PRIVATE_EXP));
        assertNull(key.getX509Chain());
    }
    @Test
    public void testLoadVerificationKeyWithCert() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        p.put(JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT, true);
        JsonWebKeys keySet = JwsUtils.loadPublicVerificationKeys(createMessage(), p);
        assertEquals(1, keySet.asMap().size());
        List<JsonWebKey> keys = keySet.getRsaKeys();
        assertEquals(1, keys.size());
        JsonWebKey key = keys.get(0);
        assertEquals(KeyType.RSA, key.getKeyType());
        assertEquals(""alice"", key.getKeyId());
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_PUBLIC_EXP));
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_MODULUS));
        assertNull(key.getKeyProperty(JsonWebKey.RSA_PRIVATE_EXP));
        List<String> chain = key.getX509Chain();
        assertNotNull(chain);
        assertEquals(2, chain.size());
    }

    private Message createMessage() {
        Message m = new MessageImpl();
        Exchange e = new ExchangeImpl();
        e.put(Bus.class, BusFactory.getThreadDefaultBus());
        m.setExchange(e);
        m.put(JoseConstants.RSSEC_SIGNATURE_INCLUDE_KEY_ID, ""true"");
        e.setInMessage(m);
        return m;
    }
}
",0
CVE-2019-12423,rt/rs/security/jose-parent/jose/src/test/java/org/apache/cxf/rs/security/jose/jws/JwsUtilsTest.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.jose.jws;

import java.util.List;
import java.util.Properties;

import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.rs.security.jose.common.JoseConstants;
import org.apache.cxf.rs.security.jose.jwa.AlgorithmUtils;
import org.apache.cxf.rs.security.jose.jwa.SignatureAlgorithm;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKey;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKeys;
import org.apache.cxf.rs.security.jose.jwk.KeyType;

import org.junit.Assert;
import org.junit.Test;

public class JwsUtilsTest extends Assert {

    @Test
    public void testSignatureAlgorithm() {
        assertTrue(AlgorithmUtils.isRsaSign(SignatureAlgorithm.RS256));
        assertFalse(AlgorithmUtils.isRsaSign(SignatureAlgorithm.NONE));

        try {
            AlgorithmUtils.RSA_SHA_SIGN_SET.add(SignatureAlgorithm.NONE.getJwaName());
            fail(""Failure expected on trying to modify the algorithm lists"");
        } catch (UnsupportedOperationException ex) {
            // expected
        }
    }

    @Test
    public void testLoadSignatureProviderFromJKS() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        JwsHeaders headers = new JwsHeaders();
        JwsSignatureProvider jws = JwsUtils.loadSignatureProvider(createMessage(),
                                                                  p,
                                                                  headers);
        assertNotNull(jws);
        assertEquals(""alice"", headers.getKeyId());
    }
    @Test
    public void testLoadSignatureVerifierFromJKS() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        JwsSignatureVerifier jws = JwsUtils.loadSignatureVerifier(createMessage(),
                                                                  p,
                                                                  new JwsHeaders());
        assertNotNull(jws);
    }
    @Test
    public void testLoadVerificationKey() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        JsonWebKeys keySet = JwsUtils.loadPublicVerificationKeys(createMessage(), p, true);
        assertEquals(1, keySet.asMap().size());
        List<JsonWebKey> keys = keySet.getRsaKeys();
        assertEquals(1, keys.size());
        JsonWebKey key = keys.get(0);
        assertEquals(KeyType.RSA, key.getKeyType());
        assertEquals(""alice"", key.getKeyId());
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_PUBLIC_EXP));
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_MODULUS));
        assertNull(key.getKeyProperty(JsonWebKey.RSA_PRIVATE_EXP));
        assertNull(key.getX509Chain());
    }
    @Test
    public void testLoadVerificationKeyWithCert() throws Exception {
        Properties p = new Properties();
        p.put(JoseConstants.RSSEC_KEY_STORE_FILE,
            ""org/apache/cxf/rs/security/jose/jws/alice.jks"");
        p.put(JoseConstants.RSSEC_KEY_STORE_PSWD, ""password"");
        p.put(JoseConstants.RSSEC_KEY_STORE_ALIAS, ""alice"");
        p.put(JoseConstants.RSSEC_SIGNATURE_INCLUDE_CERT, true);
        JsonWebKeys keySet = JwsUtils.loadPublicVerificationKeys(createMessage(), p, true);
        assertEquals(1, keySet.asMap().size());
        List<JsonWebKey> keys = keySet.getRsaKeys();
        assertEquals(1, keys.size());
        JsonWebKey key = keys.get(0);
        assertEquals(KeyType.RSA, key.getKeyType());
        assertEquals(""alice"", key.getKeyId());
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_PUBLIC_EXP));
        assertNotNull(key.getKeyProperty(JsonWebKey.RSA_MODULUS));
        assertNull(key.getKeyProperty(JsonWebKey.RSA_PRIVATE_EXP));
        List<String> chain = key.getX509Chain();
        assertNotNull(chain);
        assertEquals(2, chain.size());
    }

    private Message createMessage() {
        Message m = new MessageImpl();
        Exchange e = new ExchangeImpl();
        e.put(Bus.class, BusFactory.getThreadDefaultBus());
        m.setExchange(e);
        m.put(JoseConstants.RSSEC_SIGNATURE_INCLUDE_KEY_ID, ""true"");
        e.setInMessage(m);
        return m;
    }
}
",1
CVE-2019-12423,rt/rs/security/sso/oidc/src/main/java/org/apache/cxf/rs/security/oidc/idp/OidcKeysService.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.oidc.idp;

import java.util.Properties;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;

import org.apache.cxf.jaxrs.client.WebClient;
import org.apache.cxf.jaxrs.utils.JAXRSUtils;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKeys;
import org.apache.cxf.rs.security.jose.jws.JwsUtils;

@Path(""keys"")
public class OidcKeysService {

    private volatile JsonWebKeys keySet;
    private WebClient keyServiceClient;

    @GET
    @Produces(""application/json"")
    public JsonWebKeys getPublicVerificationKeys() {
        if (keySet == null) {
            if (keyServiceClient == null) {
                keySet = getFromLocalStore();
            } else {
                keySet = keyServiceClient.get(JsonWebKeys.class);
            }

        }
        return keySet;
    }

    private static JsonWebKeys getFromLocalStore() {
        Properties props = JwsUtils.loadSignatureInProperties(true);
        return JwsUtils.loadPublicVerificationKeys(JAXRSUtils.getCurrentMessage(), props);
    }

    public void setKeyServiceClient(WebClient keyServiceClient) {
        this.keyServiceClient = keyServiceClient;
    }

}
",0
CVE-2019-12423,rt/rs/security/sso/oidc/src/main/java/org/apache/cxf/rs/security/oidc/idp/OidcKeysService.java,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.cxf.rs.security.oidc.idp;

import java.util.Properties;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;

import org.apache.cxf.jaxrs.client.WebClient;
import org.apache.cxf.jaxrs.utils.JAXRSUtils;
import org.apache.cxf.rs.security.jose.jwk.JsonWebKeys;
import org.apache.cxf.rs.security.jose.jws.JwsUtils;

@Path(""keys"")
public class OidcKeysService {

    private volatile JsonWebKeys keySet;
    private WebClient keyServiceClient;
    private boolean stripPrivateParameters = true;

    @GET
    @Produces(""application/json"")
    public JsonWebKeys getPublicVerificationKeys() {
        if (keySet == null) {
            if (keyServiceClient == null) {
                keySet = getFromLocalStore(stripPrivateParameters);
            } else {
                keySet = keyServiceClient.get(JsonWebKeys.class);
            }

        }
        return keySet;
    }

    private static JsonWebKeys getFromLocalStore(boolean stripPrivateParameters) {
        Properties props = JwsUtils.loadSignatureInProperties(true);
        return JwsUtils.loadPublicVerificationKeys(JAXRSUtils.getCurrentMessage(), props, stripPrivateParameters);
    }

    public void setKeyServiceClient(WebClient keyServiceClient) {
        this.keyServiceClient = keyServiceClient;
    }

    public boolean isStripPrivateParameters() {
        return stripPrivateParameters;
    }

    /**
     * Whether to strip private parameters from the keys that are returned. The default is true.
     */
    public void setStripPrivateParameters(boolean stripPrivateParameters) {
        this.stripPrivateParameters = stripPrivateParameters;
    }

}
",1
CVE-2019-1010245,apps/yang/web/src/main/java/org/onosproject/yang/web/YangWebResource.java,"/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.onosproject.yang.web;

import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.apache.commons.io.IOUtils;
import org.glassfish.jersey.media.multipart.FormDataParam;
import org.onosproject.app.ApplicationAdminService;
import org.onosproject.rest.AbstractWebResource;
import org.onosproject.yang.YangLiveCompilerService;
import org.onosproject.yang.model.DefaultYangModuleId;
import org.onosproject.yang.model.YangModel;
import org.onosproject.yang.model.YangModule;
import org.onosproject.yang.runtime.YangModelRegistry;
import org.slf4j.Logger;

import javax.ws.rs.Consumes;
import javax.ws.rs.DefaultValue;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Set;

import static javax.ws.rs.core.Response.Status.NOT_FOUND;
import static org.slf4j.LoggerFactory.getLogger;

/**
 * Yang files upload resource.
 */
@Path(""models"")
public class YangWebResource extends AbstractWebResource {

    private final Logger log = getLogger(getClass());
    private YangModelRegistry modelRegistry = getService(YangModelRegistry.class);

    /**
     * Compiles and registers the given yang files.
     *
     * @param modelId model identifier
     * @param stream  YANG, ZIP or JAR file
     * @return 200 OK
     * @throws IOException when fails to generate a file
     */
    @POST
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    public Response upload(@QueryParam(""modelId"") @DefaultValue(""org.onosproject.model.unknown"") String modelId,
                           @FormDataParam(""file"") InputStream stream) throws IOException {
        YangLiveCompilerService compiler = get(YangLiveCompilerService.class);
        ApplicationAdminService appService = get(ApplicationAdminService.class);
        modelId = getValidModelId(modelId);
        appService.install(compiler.compileYangFiles(modelId, stream));
        appService.activate(appService.getId(modelId));
        return Response.ok().build();
    }

    /**
     * Returns the valid model id by removing the special character with
     * underscore.
     *
     * @param id user given model id
     * @return model id
     * @throws IllegalArgumentException if user defined model id does not
     *                                  contain at least a alphanumeric character
     */
    public static String getValidModelId(String id) throws
            IllegalArgumentException {
        // checking weather modelId contains the alphanumeric character or not.
        if (id.matches("".*[A-Za-z0-9].*"")) {
            // replacing special characters with '_'
            id = id.replaceAll(""[\\s\\/:*?\""\\[\\]<>|$@!#%&(){}';.,-]"", ""_"");
            // remove leading and trailing underscore
            id = id.replaceAll(""^_+|_+$"", """");
            // replacing the consecutive underscores '_' to single _
            id = id.replaceAll(""_+"", ""_"");
            return id;
        } else {
            throw new IllegalArgumentException(""Invalid model id "" + id);
        }
    }

    /**
     * Returns all models registered with YANG runtime. If the operation is
     * successful, the JSON presentation of the resource plus HTTP status
     * code ""200 OK"" is returned.Otherwise,
     * HTTP error status code ""400 Bad Request"" is returned.
     *
     * @onos.rsModel YangModelsGet
     * @return HTTP response
     */
    @GET
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response getModels() {

        modelRegistry = getService(YangModelRegistry.class);
        ObjectNode result = mapper().createObjectNode();
        Set<YangModel> models = modelRegistry.getModels();
        ArrayNode ids = result.putArray(""model_ids"");
        for (YangModel m : models) {
            ids.add(m.getYangModelId());
        }
        return Response.ok(result.toString()).build();
    }

    /**
     * Returns all modules registered with YANG runtime under given model
     * identifier.If the operation is successful, the JSON presentation of the
     * resource plus HTTP status code ""200 OK"" is returned. Otherwise,
     * HTTP error status code ""400 Bad Request"" is returned.
     *
     * @onos.rsModel YangModulesGet
     * @param id for model
     * @return HTTP response
     */
    @GET
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Path(""/{id}"")
    public Response getModules(@PathParam(""id"") String
                                       id) {
        modelRegistry = getService(YangModelRegistry.class);
        ObjectNode result = mapper().createObjectNode();
        YangModel model = modelRegistry.getModel(id);
        if (model == null) {
            return Response.status(NOT_FOUND).build();
        }
        Set<YangModule> modules = model.getYangModules();
        ArrayNode ids = result.putArray(id);
        for (YangModule m : modules) {
            ids.add(m.getYangModuleId().moduleName() + ""@"" + m
                    .getYangModuleId().revision());
        }
        return Response.ok(result).build();
    }

    /**
     * Returns module registered with YANG runtime with given module
     * identifier.
     * If the operation is successful, the JSON presentation of the resource
     * plus HTTP status code ""200 OK"" is returned. Otherwise,
     * HTTP error status code ""400 Bad Request"" is returned.
     *
     * @param n for module name
     * @param r for module revision
     * @return HTTP response
     */
    @GET
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.TEXT_PLAIN)
    @Path(""/{name}@{revision}"")
    public String getModule(@PathParam(""name"") String n,
                            @PathParam(""revision"") String r) {

        modelRegistry = getService(YangModelRegistry.class);
        YangModule m = modelRegistry.getModule(new DefaultYangModuleId(n, r));
        if (m == null) {
            return Response.status(NOT_FOUND).build().toString();
        }
        String x;
        try {
            x = IOUtils.toString(m.getYangSource(), StandardCharsets.UTF_8);
        } catch (IOException e) {
            log.error(""ERROR: handleModuleGetRequest"", e.getMessage());
            log.debug(""Exception in handleModuleGetRequest:"", e);
            return e.getMessage();
        }
        return x;
    }
}
",0
CVE-2019-1010245,apps/yang/web/src/main/java/org/onosproject/yang/web/YangWebResource.java,"/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.onosproject.yang.web;

import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.apache.commons.io.IOUtils;
import org.glassfish.jersey.media.multipart.FormDataParam;
import org.onosproject.app.ApplicationAdminService;
import org.onosproject.rest.AbstractWebResource;
import org.onosproject.yang.YangLiveCompilerService;
import org.onosproject.yang.model.DefaultYangModuleId;
import org.onosproject.yang.model.YangModel;
import org.onosproject.yang.model.YangModule;
import org.onosproject.yang.runtime.YangModelRegistry;
import org.slf4j.Logger;

import javax.ws.rs.Consumes;
import javax.ws.rs.DefaultValue;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Set;

import static javax.ws.rs.core.Response.Status.NOT_FOUND;
import static org.slf4j.LoggerFactory.getLogger;

/**
 * Yang files upload resource.
 */
@Path(""models"")
public class YangWebResource extends AbstractWebResource {

    private final Logger log = getLogger(getClass());
    private YangModelRegistry modelRegistry = getService(YangModelRegistry.class);

    /**
     * Compiles and registers the given yang files.
     *
     * @param modelId model identifier
     * @param stream  YANG, ZIP or JAR file
     * @return 200 OK
     * @throws IOException when fails to generate a file
     */
    @POST
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    public Response upload(@QueryParam(""modelId"") @DefaultValue(""org.onosproject.model.unknown"") String modelId,
                           @FormDataParam(""file"") InputStream stream) throws IOException {
        YangLiveCompilerService compiler = get(YangLiveCompilerService.class);
        ApplicationAdminService appService = get(ApplicationAdminService.class);
        modelId = getValidModelId(modelId);
        appService.install(compiler.compileYangFiles(modelId, stream));
        appService.activate(appService.getId(modelId));
        return Response.ok().build();
    }

    /**
     * Returns the valid model id by removing the special character with
     * underscore.
     *
     * @param id user given model id
     * @return model id
     * @throws IllegalArgumentException if user defined model id does not
     *                                  contain at least a alphanumeric character
     */
    public static String getValidModelId(String id) throws
            IllegalArgumentException {
        // checking whether modelId contains the alphanumeric character or not.
        if (id.matches("".*[A-Za-z0-9].*"")) {
            // replacing special characters with '_'
            id = id.replaceAll(""[\\s\\/:*?\""\\[\\]<>|$@!#%&(){}'`;.,-]"", ""_"");
            // remove leading and trailing underscore
            id = id.replaceAll(""^_+|_+$"", """");
            // replacing the consecutive underscores '_' to single _
            id = id.replaceAll(""_+"", ""_"");
            return id;
        } else {
            throw new IllegalArgumentException(""Invalid model id "" + id);
        }
    }

    /**
     * Returns all models registered with YANG runtime. If the operation is
     * successful, the JSON presentation of the resource plus HTTP status
     * code ""200 OK"" is returned.Otherwise,
     * HTTP error status code ""400 Bad Request"" is returned.
     *
     * @onos.rsModel YangModelsGet
     * @return HTTP response
     */
    @GET
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response getModels() {

        modelRegistry = getService(YangModelRegistry.class);
        ObjectNode result = mapper().createObjectNode();
        Set<YangModel> models = modelRegistry.getModels();
        ArrayNode ids = result.putArray(""model_ids"");
        for (YangModel m : models) {
            ids.add(m.getYangModelId());
        }
        return Response.ok(result.toString()).build();
    }

    /**
     * Returns all modules registered with YANG runtime under given model
     * identifier.If the operation is successful, the JSON presentation of the
     * resource plus HTTP status code ""200 OK"" is returned. Otherwise,
     * HTTP error status code ""400 Bad Request"" is returned.
     *
     * @onos.rsModel YangModulesGet
     * @param id for model
     * @return HTTP response
     */
    @GET
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Path(""/{id}"")
    public Response getModules(@PathParam(""id"") String
                                       id) {
        modelRegistry = getService(YangModelRegistry.class);
        ObjectNode result = mapper().createObjectNode();
        YangModel model = modelRegistry.getModel(id);
        if (model == null) {
            return Response.status(NOT_FOUND).build();
        }
        Set<YangModule> modules = model.getYangModules();
        ArrayNode ids = result.putArray(id);
        for (YangModule m : modules) {
            ids.add(m.getYangModuleId().moduleName() + ""@"" + m
                    .getYangModuleId().revision());
        }
        return Response.ok(result).build();
    }

    /**
     * Returns module registered with YANG runtime with given module
     * identifier.
     * If the operation is successful, the JSON presentation of the resource
     * plus HTTP status code ""200 OK"" is returned. Otherwise,
     * HTTP error status code ""400 Bad Request"" is returned.
     *
     * @param n for module name
     * @param r for module revision
     * @return HTTP response
     */
    @GET
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.TEXT_PLAIN)
    @Path(""/{name}@{revision}"")
    public String getModule(@PathParam(""name"") String n,
                            @PathParam(""revision"") String r) {

        modelRegistry = getService(YangModelRegistry.class);
        YangModule m = modelRegistry.getModule(new DefaultYangModuleId(n, r));
        if (m == null) {
            return Response.status(NOT_FOUND).build().toString();
        }
        String x;
        try {
            x = IOUtils.toString(m.getYangSource(), StandardCharsets.UTF_8);
        } catch (IOException e) {
            log.error(""ERROR: handleModuleGetRequest"", e.getMessage());
            log.debug(""Exception in handleModuleGetRequest:"", e);
            return e.getMessage();
        }
        return x;
    }
}
",1
CVE-2018-1305,java/org/apache/catalina/Wrapper.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package org.apache.catalina;


import javax.servlet.MultipartConfigElement;
import javax.servlet.Servlet;
import javax.servlet.ServletException;
import javax.servlet.UnavailableException;


/**
 * A <b>Wrapper</b> is a Container that represents an individual servlet
 * definition from the deployment descriptor of the web application.  It
 * provides a convenient mechanism to use Interceptors that see every single
 * request to the servlet represented by this definition.
 * <p>
 * Implementations of Wrapper are responsible for managing the servlet life
 * cycle for their underlying servlet class, including calling init() and
 * destroy() at appropriate times, as well as respecting the existence of
 * the SingleThreadModel declaration on the servlet class itself.
 * <p>
 * The parent Container attached to a Wrapper will generally be an
 * implementation of Context, representing the servlet context (and
 * therefore the web application) within which this servlet executes.
 * <p>
 * Child Containers are not allowed on Wrapper implementations, so the
 * <code>addChild()</code> method should throw an
 * <code>IllegalArgumentException</code>.
 *
 * @author Craig R. McClanahan
 */
public interface Wrapper extends Container {

    /**
     * Container event for adding a wrapper.
     */
    public static final String ADD_MAPPING_EVENT = ""addMapping"";

    /**
     * Container event for removing a wrapper.
     */
    public static final String REMOVE_MAPPING_EVENT = ""removeMapping"";

    // ------------------------------------------------------------- Properties


    /**
     * @return the available date/time for this servlet, in milliseconds since
     * the epoch.  If this date/time is in the future, any request for this
     * servlet will return an SC_SERVICE_UNAVAILABLE error.  If it is zero,
     * the servlet is currently available.  A value equal to Long.MAX_VALUE
     * is considered to mean that unavailability is permanent.
     */
    public long getAvailable();


    /**
     * Set the available date/time for this servlet, in milliseconds since the
     * epoch.  If this date/time is in the future, any request for this servlet
     * will return an SC_SERVICE_UNAVAILABLE error.  A value equal to
     * Long.MAX_VALUE is considered to mean that unavailability is permanent.
     *
     * @param available The new available date/time
     */
    public void setAvailable(long available);


    /**
     * @return the load-on-startup order value (negative value means
     * load on first call).
     */
    public int getLoadOnStartup();


    /**
     * Set the load-on-startup order value (negative value means
     * load on first call).
     *
     * @param value New load-on-startup value
     */
    public void setLoadOnStartup(int value);


    /**
     * @return the run-as identity for this servlet.
     */
    public String getRunAs();


    /**
     * Set the run-as identity for this servlet.
     *
     * @param runAs New run-as identity value
     */
    public void setRunAs(String runAs);


    /**
     * @return the fully qualified servlet class name for this servlet.
     */
    public String getServletClass();


    /**
     * Set the fully qualified servlet class name for this servlet.
     *
     * @param servletClass Servlet class name
     */
    public void setServletClass(String servletClass);


    /**
     * Gets the names of the methods supported by the underlying servlet.
     *
     * This is the same set of methods included in the Allow response header
     * in response to an OPTIONS request method processed by the underlying
     * servlet.
     *
     * @return Array of names of the methods supported by the underlying
     *         servlet
     *
     * @throws ServletException If the target servlet cannot be loaded
     */
    public String[] getServletMethods() throws ServletException;


    /**
     * @return <code>true</code> if this Servlet is currently unavailable.
     */
    public boolean isUnavailable();


    /**
     * @return the associated Servlet instance.
     */
    public Servlet getServlet();


    /**
     * Set the associated Servlet instance
     *
     * @param servlet The associated Servlet
     */
    public void setServlet(Servlet servlet);

    // --------------------------------------------------------- Public Methods


    /**
     * Add a new servlet initialization parameter for this servlet.
     *
     * @param name Name of this initialization parameter to add
     * @param value Value of this initialization parameter to add
     */
    public void addInitParameter(String name, String value);


    /**
     * Add a mapping associated with the Wrapper.
     *
     * @param mapping The new wrapper mapping
     */
    public void addMapping(String mapping);


    /**
     * Add a new security role reference record to the set of records for
     * this servlet.
     *
     * @param name Role name used within this servlet
     * @param link Role name used within the web application
     */
    public void addSecurityReference(String name, String link);


    /**
     * Allocate an initialized instance of this Servlet that is ready to have
     * its <code>service()</code> method called.  If the Servlet class does
     * not implement <code>SingleThreadModel</code>, the (only) initialized
     * instance may be returned immediately.  If the Servlet class implements
     * <code>SingleThreadModel</code>, the Wrapper implementation must ensure
     * that this instance is not allocated again until it is deallocated by a
     * call to <code>deallocate()</code>.
     *
     * @exception ServletException if the Servlet init() method threw
     *  an exception
     * @exception ServletException if a loading error occurs
     * @return a new Servlet instance
     */
    public Servlet allocate() throws ServletException;


    /**
     * Return this previously allocated servlet to the pool of available
     * instances.  If this servlet class does not implement SingleThreadModel,
     * no action is actually required.
     *
     * @param servlet The servlet to be returned
     *
     * @exception ServletException if a deallocation error occurs
     */
    public void deallocate(Servlet servlet) throws ServletException;


    /**
     * @return the value for the specified initialization parameter name,
     * if any; otherwise return <code>null</code>.
     *
     * @param name Name of the requested initialization parameter
     */
    public String findInitParameter(String name);


    /**
     * @return the names of all defined initialization parameters for this
     * servlet.
     */
    public String[] findInitParameters();


    /**
     * @return the mappings associated with this wrapper.
     */
    public String[] findMappings();


    /**
     * @return the security role link for the specified security role
     * reference name, if any; otherwise return <code>null</code>.
     *
     * @param name Security role reference used within this servlet
     */
    public String findSecurityReference(String name);


    /**
     * @return the set of security role reference names associated with
     * this servlet, if any; otherwise return a zero-length array.
     */
    public String[] findSecurityReferences();


    /**
     * Increment the error count value used when monitoring.
     */
    public void incrementErrorCount();


    /**
     * Load and initialize an instance of this Servlet, if there is not already
     * at least one initialized instance.  This can be used, for example, to
     * load Servlets that are marked in the deployment descriptor to be loaded
     * at server startup time.
     *
     * @exception ServletException if the Servlet init() method threw
     *  an exception or if some other loading problem occurs
     */
    public void load() throws ServletException;


    /**
     * Remove the specified initialization parameter from this Servlet.
     *
     * @param name Name of the initialization parameter to remove
     */
    public void removeInitParameter(String name);


    /**
     * Remove a mapping associated with the wrapper.
     *
     * @param mapping The pattern to remove
     */
    public void removeMapping(String mapping);


    /**
     * Remove any security role reference for the specified role name.
     *
     * @param name Security role used within this servlet to be removed
     */
    public void removeSecurityReference(String name);


    /**
     * Process an UnavailableException, marking this Servlet as unavailable
     * for the specified amount of time.
     *
     * @param unavailable The exception that occurred, or <code>null</code>
     *  to mark this Servlet as permanently unavailable
     */
    public void unavailable(UnavailableException unavailable);


    /**
     * Unload all initialized instances of this servlet, after calling the
     * <code>destroy()</code> method for each instance.  This can be used,
     * for example, prior to shutting down the entire servlet engine, or
     * prior to reloading all of the classes from the Loader associated with
     * our Loader's repository.
     *
     * @exception ServletException if an unload error occurs
     */
    public void unload() throws ServletException;


    /**
     * @return the multi-part configuration for the associated Servlet. If no
     * multi-part configuration has been defined, then <code>null</code> will be
     * returned.
     */
    public MultipartConfigElement getMultipartConfigElement();


    /**
     * Set the multi-part configuration for the associated Servlet. To clear the
     * multi-part configuration specify <code>null</code> as the new value.
     *
     * @param multipartConfig The configuration associated with the Servlet
     */
    public void setMultipartConfigElement(
            MultipartConfigElement multipartConfig);

    /**
     * Does the associated Servlet support async processing? Defaults to
     * <code>false</code>.
     *
     * @return <code>true</code> if the Servlet supports async
     */
    public boolean isAsyncSupported();

    /**
     * Set the async support for the associated Servlet.
     *
     * @param asyncSupport the new value
     */
    public void setAsyncSupported(boolean asyncSupport);

    /**
     * Is the associated Servlet enabled? Defaults to <code>true</code>.
     *
     * @return <code>true</code> if the Servlet is enabled
     */
    public boolean isEnabled();

    /**
     * Sets the enabled attribute for the associated servlet.
     *
     * @param enabled the new value
     */
    public void setEnabled(boolean enabled);

    /**
     * Set the flag that indicates
     * {@link javax.servlet.annotation.ServletSecurity} annotations must be
     * scanned when the Servlet is first used.
     *
     * @param b The new value of the flag
     */
    public void setServletSecurityAnnotationScanRequired(boolean b);

    /**
     * Scan for (if necessary) and process (if found) the
     * {@link javax.servlet.annotation.ServletSecurity} annotations for the
     * Servlet associated with this wrapper.
     *
     * @throws ServletException if an annotation scanning error occurs
     */
    public void servletSecurityAnnotationScan() throws ServletException;

    /**
     * Is the Servlet overridable by a ServletContainerInitializer?
     *
     * @return <code>true</code> if the Servlet can be overridden in a ServletContainerInitializer
     */
    public boolean isOverridable();

    /**
     * Sets the overridable attribute for this Servlet.
     *
     * @param overridable the new value
     */
    public void setOverridable(boolean overridable);
}
",0
CVE-2018-1305,java/org/apache/catalina/Wrapper.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package org.apache.catalina;


import javax.servlet.MultipartConfigElement;
import javax.servlet.Servlet;
import javax.servlet.ServletException;
import javax.servlet.UnavailableException;


/**
 * A <b>Wrapper</b> is a Container that represents an individual servlet
 * definition from the deployment descriptor of the web application.  It
 * provides a convenient mechanism to use Interceptors that see every single
 * request to the servlet represented by this definition.
 * <p>
 * Implementations of Wrapper are responsible for managing the servlet life
 * cycle for their underlying servlet class, including calling init() and
 * destroy() at appropriate times, as well as respecting the existence of
 * the SingleThreadModel declaration on the servlet class itself.
 * <p>
 * The parent Container attached to a Wrapper will generally be an
 * implementation of Context, representing the servlet context (and
 * therefore the web application) within which this servlet executes.
 * <p>
 * Child Containers are not allowed on Wrapper implementations, so the
 * <code>addChild()</code> method should throw an
 * <code>IllegalArgumentException</code>.
 *
 * @author Craig R. McClanahan
 */
public interface Wrapper extends Container {

    /**
     * Container event for adding a wrapper.
     */
    public static final String ADD_MAPPING_EVENT = ""addMapping"";

    /**
     * Container event for removing a wrapper.
     */
    public static final String REMOVE_MAPPING_EVENT = ""removeMapping"";

    // ------------------------------------------------------------- Properties


    /**
     * @return the available date/time for this servlet, in milliseconds since
     * the epoch.  If this date/time is in the future, any request for this
     * servlet will return an SC_SERVICE_UNAVAILABLE error.  If it is zero,
     * the servlet is currently available.  A value equal to Long.MAX_VALUE
     * is considered to mean that unavailability is permanent.
     */
    public long getAvailable();


    /**
     * Set the available date/time for this servlet, in milliseconds since the
     * epoch.  If this date/time is in the future, any request for this servlet
     * will return an SC_SERVICE_UNAVAILABLE error.  A value equal to
     * Long.MAX_VALUE is considered to mean that unavailability is permanent.
     *
     * @param available The new available date/time
     */
    public void setAvailable(long available);


    /**
     * @return the load-on-startup order value (negative value means
     * load on first call).
     */
    public int getLoadOnStartup();


    /**
     * Set the load-on-startup order value (negative value means
     * load on first call).
     *
     * @param value New load-on-startup value
     */
    public void setLoadOnStartup(int value);


    /**
     * @return the run-as identity for this servlet.
     */
    public String getRunAs();


    /**
     * Set the run-as identity for this servlet.
     *
     * @param runAs New run-as identity value
     */
    public void setRunAs(String runAs);


    /**
     * @return the fully qualified servlet class name for this servlet.
     */
    public String getServletClass();


    /**
     * Set the fully qualified servlet class name for this servlet.
     *
     * @param servletClass Servlet class name
     */
    public void setServletClass(String servletClass);


    /**
     * Gets the names of the methods supported by the underlying servlet.
     *
     * This is the same set of methods included in the Allow response header
     * in response to an OPTIONS request method processed by the underlying
     * servlet.
     *
     * @return Array of names of the methods supported by the underlying
     *         servlet
     *
     * @throws ServletException If the target servlet cannot be loaded
     */
    public String[] getServletMethods() throws ServletException;


    /**
     * @return <code>true</code> if this Servlet is currently unavailable.
     */
    public boolean isUnavailable();


    /**
     * @return the associated Servlet instance.
     */
    public Servlet getServlet();


    /**
     * Set the associated Servlet instance
     *
     * @param servlet The associated Servlet
     */
    public void setServlet(Servlet servlet);

    // --------------------------------------------------------- Public Methods


    /**
     * Add a new servlet initialization parameter for this servlet.
     *
     * @param name Name of this initialization parameter to add
     * @param value Value of this initialization parameter to add
     */
    public void addInitParameter(String name, String value);


    /**
     * Add a mapping associated with the Wrapper.
     *
     * @param mapping The new wrapper mapping
     */
    public void addMapping(String mapping);


    /**
     * Add a new security role reference record to the set of records for
     * this servlet.
     *
     * @param name Role name used within this servlet
     * @param link Role name used within the web application
     */
    public void addSecurityReference(String name, String link);


    /**
     * Allocate an initialized instance of this Servlet that is ready to have
     * its <code>service()</code> method called.  If the Servlet class does
     * not implement <code>SingleThreadModel</code>, the (only) initialized
     * instance may be returned immediately.  If the Servlet class implements
     * <code>SingleThreadModel</code>, the Wrapper implementation must ensure
     * that this instance is not allocated again until it is deallocated by a
     * call to <code>deallocate()</code>.
     *
     * @exception ServletException if the Servlet init() method threw
     *  an exception
     * @exception ServletException if a loading error occurs
     * @return a new Servlet instance
     */
    public Servlet allocate() throws ServletException;


    /**
     * Return this previously allocated servlet to the pool of available
     * instances.  If this servlet class does not implement SingleThreadModel,
     * no action is actually required.
     *
     * @param servlet The servlet to be returned
     *
     * @exception ServletException if a deallocation error occurs
     */
    public void deallocate(Servlet servlet) throws ServletException;


    /**
     * @return the value for the specified initialization parameter name,
     * if any; otherwise return <code>null</code>.
     *
     * @param name Name of the requested initialization parameter
     */
    public String findInitParameter(String name);


    /**
     * @return the names of all defined initialization parameters for this
     * servlet.
     */
    public String[] findInitParameters();


    /**
     * @return the mappings associated with this wrapper.
     */
    public String[] findMappings();


    /**
     * @return the security role link for the specified security role
     * reference name, if any; otherwise return <code>null</code>.
     *
     * @param name Security role reference used within this servlet
     */
    public String findSecurityReference(String name);


    /**
     * @return the set of security role reference names associated with
     * this servlet, if any; otherwise return a zero-length array.
     */
    public String[] findSecurityReferences();


    /**
     * Increment the error count value used when monitoring.
     */
    public void incrementErrorCount();


    /**
     * Load and initialize an instance of this Servlet, if there is not already
     * at least one initialized instance.  This can be used, for example, to
     * load Servlets that are marked in the deployment descriptor to be loaded
     * at server startup time.
     *
     * @exception ServletException if the Servlet init() method threw
     *  an exception or if some other loading problem occurs
     */
    public void load() throws ServletException;


    /**
     * Remove the specified initialization parameter from this Servlet.
     *
     * @param name Name of the initialization parameter to remove
     */
    public void removeInitParameter(String name);


    /**
     * Remove a mapping associated with the wrapper.
     *
     * @param mapping The pattern to remove
     */
    public void removeMapping(String mapping);


    /**
     * Remove any security role reference for the specified role name.
     *
     * @param name Security role used within this servlet to be removed
     */
    public void removeSecurityReference(String name);


    /**
     * Process an UnavailableException, marking this Servlet as unavailable
     * for the specified amount of time.
     *
     * @param unavailable The exception that occurred, or <code>null</code>
     *  to mark this Servlet as permanently unavailable
     */
    public void unavailable(UnavailableException unavailable);


    /**
     * Unload all initialized instances of this servlet, after calling the
     * <code>destroy()</code> method for each instance.  This can be used,
     * for example, prior to shutting down the entire servlet engine, or
     * prior to reloading all of the classes from the Loader associated with
     * our Loader's repository.
     *
     * @exception ServletException if an unload error occurs
     */
    public void unload() throws ServletException;


    /**
     * @return the multi-part configuration for the associated Servlet. If no
     * multi-part configuration has been defined, then <code>null</code> will be
     * returned.
     */
    public MultipartConfigElement getMultipartConfigElement();


    /**
     * Set the multi-part configuration for the associated Servlet. To clear the
     * multi-part configuration specify <code>null</code> as the new value.
     *
     * @param multipartConfig The configuration associated with the Servlet
     */
    public void setMultipartConfigElement(
            MultipartConfigElement multipartConfig);

    /**
     * Does the associated Servlet support async processing? Defaults to
     * <code>false</code>.
     *
     * @return <code>true</code> if the Servlet supports async
     */
    public boolean isAsyncSupported();

    /**
     * Set the async support for the associated Servlet.
     *
     * @param asyncSupport the new value
     */
    public void setAsyncSupported(boolean asyncSupport);

    /**
     * Is the associated Servlet enabled? Defaults to <code>true</code>.
     *
     * @return <code>true</code> if the Servlet is enabled
     */
    public boolean isEnabled();

    /**
     * Sets the enabled attribute for the associated servlet.
     *
     * @param enabled the new value
     */
    public void setEnabled(boolean enabled);

    /**
     * This method is no longer used. All implementations should be NO-OPs.
     *
     * @param b Unused.
     *
     * @deprecated This will be removed in Tomcat 9.
     */
    @Deprecated
    public void setServletSecurityAnnotationScanRequired(boolean b);

    /**
     * This method is no longer used. All implementations should be NO-OPs.
     *
     * @throws ServletException Never thrown
     *
     * @deprecated This will be removed in Tomcat 9.
     */
    @Deprecated
    public void servletSecurityAnnotationScan() throws ServletException;

    /**
     * Is the Servlet overridable by a ServletContainerInitializer?
     *
     * @return <code>true</code> if the Servlet can be overridden in a ServletContainerInitializer
     */
    public boolean isOverridable();

    /**
     * Sets the overridable attribute for this Servlet.
     *
     * @param overridable the new value
     */
    public void setOverridable(boolean overridable);
}
",1
CVE-2018-21234,jodd-json/src/main/java/jodd/json/JsonParser.java,"// Copyright (c) 2003-present, Jodd Team (http://jodd.org)
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

package jodd.json;

import jodd.introspector.ClassDescriptor;
import jodd.introspector.ClassIntrospector;
import jodd.introspector.PropertyDescriptor;
import jodd.json.meta.JsonAnnotationManager;
import jodd.json.meta.TypeData;
import jodd.util.CharArraySequence;
import jodd.util.CharUtil;
import jodd.util.StringPool;
import jodd.util.UnsafeUtil;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;

/**
 * Simple, developer-friendly JSON parser. It focuses on easy usage
 * and type mappings. Uses Jodd's type converters, so it is natural
 * companion for Jodd projects.
 * <p>
 * This JSON parser also works in {@link #lazy(boolean)} mode. This
 * mode is for top performance usage: parsing is done very, very lazy.
 * While you can use all the mappings and other tools, for best performance
 * the lazy mode should be used only with maps and lists (no special mappings).
 * Also, the performance has it's price: more memory consumption, because the
 * original input is hold until the result is in use.
 * <p>
 * See: http://www.ietf.org/rfc/rfc4627.txt
 */
public class JsonParser extends JsonParserBase {

	public static class Defaults {

		public static final String DEFAULT_CLASS_METADATA_NAME = ""__class"";

		/**
		 * Flag for enabling the lazy mode.
		 */
		public static boolean lazy = false;
		/**
		 * Defines if parser will use extended paths information
		 * and path matching.
		 */
		public static boolean useAltPathsByParser = false;
		/**
		 * Default value for loose mode.
		 */
		public static boolean loose = false;

		/**
		 * Specifies if 'class' metadata is used and its value. When set, class metadata
		 * is used by {@link jodd.json.JsonSerializer} and all objects
		 * will have additional field with the class type in the resulting JSON.
		 * {@link jodd.json.JsonParser} will also consider this flag to build
		 * correct object type. If <code>null</code>, class information is not used.
		 */
		public static String classMetadataName = null;
	}

	/**
	 * Static ctor.
	 */
	public static JsonParser create() {
		return new JsonParser();
	}

	/**
	 * Creates a lazy implementation of the JSON parser.
	 */
	public static JsonParser createLazyOne() {
		return new JsonParser().lazy(true);
	}

	private static final char[] T_RUE = new char[] {'r', 'u', 'e'};
	private static final char[] F_ALSE = new char[] {'a', 'l', 's', 'e'};
	private static final char[] N_ULL = new char[] {'u', 'l', 'l'};

	/**
	 * Map keys.
	 */
	public static final String KEYS = ""keys"";
	/**
	 * Array or map values.
	 */
	public static final String VALUES = ""values"";

	protected int ndx = 0;
	protected char[] input;
	protected int total;
	protected Path path;
	protected boolean useAltPaths = Defaults.useAltPathsByParser;
	protected boolean lazy = Defaults.lazy;
	protected boolean looseMode = Defaults.loose;
	protected Class rootType;
	protected MapToBean mapToBean;
	private boolean notFirstObject = false;

	private final JsonAnnotationManager jsonAnnotationManager;

	public JsonParser() {
		this.text = new char[512];
		this.jsonAnnotationManager = JsonAnnotationManager.get();
	}

	/**
	 * Resets JSON parser, so it can be reused.
	 */
	protected void reset() {
		this.ndx = 0;
		this.textLen = 0;
		this.path = new Path();
		if (useAltPaths) {
			path.altPath = new Path();
		}

		if (classMetadataName != null) {
			mapToBean = createMapToBean(classMetadataName);
		}
	}

	/**
	 * Enables usage of additional paths.
	 */
	public JsonParser useAltPaths() {
		this.useAltPaths = true;
		return this;
	}

	/**
	 * Enables 'loose' mode for parsing. When 'loose' mode is enabled,
	 * JSON parsers swallows also invalid JSONs:
	 * <ul>
	 *     <li>invalid escape character sequence is simply added to the output</li>
	 *     <li>strings can be quoted with single-quotes</li>
	 *     <li>strings can be unquoted, but may not contain escapes</li>
	 * </ul>
	 */
	public JsonParser looseMode(final boolean looseMode) {
		this.looseMode = looseMode;
		return this;
	}

	/**
	 * Defines how JSON parser works. In non-lazy mode, the whole JSON is parsed as it is.
	 * In the lazy mode, not everything is parsed, but some things are left lazy.
	 * This way we gain performance, especially on partial usage of the whole JSON.
	 * However, be aware that parser holds the input memory until the returned
	 * objects are disposed.
	 */
	public JsonParser lazy(final boolean lazy) {
		this.lazy = lazy;
		this.mapSupplier = lazy ? LAZYMAP_SUPPLIER : HASMAP_SUPPLIER;
		this.listSupplier = lazy ? LAZYLIST_SUPPLIER : ARRAYLIST_SUPPLIER;
		return this;
	}

	// ---------------------------------------------------------------- mappings

	protected Map<Path, Class> mappings;

	/**
	 * Maps a class to JSONs root.
	 */
	public JsonParser map(final Class target) {
		rootType = target;
		return this;
	}

	/**
	 * Maps a class to given path. For arrays, append <code>values</code>
	 * to the path to specify component type (if not specified by
	 * generics).
	 */
	public JsonParser map(final String path, final Class target) {
		if (path == null) {
			rootType = target;
			return this;
		}
		if (mappings == null) {
			mappings = new HashMap<>();
		}
		mappings.put(Path.parse(path), target);
		return this;
	}

	/**
	 * Replaces type with mapped type for current path.
	 */
	protected Class replaceWithMappedTypeForPath(final Class target) {
		if (mappings == null) {
			return target;
		}

		Class newType;

		// first try alt paths

		Path altPath = path.getAltPath();

		if (altPath != null) {
			if (!altPath.equals(path)) {
				newType = mappings.get(altPath);

				if (newType != null) {
					return newType;
				}
			}
		}

		// now check regular paths

		newType = mappings.get(path);

		if (newType != null) {
			return newType;
		}

		return target;
	}

	// ---------------------------------------------------------------- converters

	protected Map<Path, ValueConverter> convs;

	/**
	 * Defines {@link jodd.json.ValueConverter} to use on given path.
	 */
	public JsonParser withValueConverter(final String path, final ValueConverter valueConverter) {
		if (convs == null) {
			convs = new HashMap<>();
		}
		convs.put(Path.parse(path), valueConverter);
		return this;
	}

	/**
	 * Lookups for value converter for current path.
	 */
	protected ValueConverter lookupValueConverter() {
		if (convs == null) {
			return null;
		}
		return convs.get(path);
	}

	// ---------------------------------------------------------------- class meta data name

	protected String classMetadataName = Defaults.classMetadataName;

	/**
	 * Sets local class meta-data name.
	 * <p>
	 * Note that by using the class meta-data name you may expose a security hole in case untrusted source
	 * manages to specify a class that is accessible through class loader and exposes set of methods and/or fields,
	 * access of which opens an actual security hole. Such classes are known as “deserialization gadget”s.
	 *
	 * Because of this, use of ""default typing"" is not encouraged in general, and in particular is recommended against
	 * if the source of content is not trusted. Conversely, default typing may be used for processing content in
	 * cases where both ends (sender and receiver) are controlled by same entity.
	 */
	public JsonParser setClassMetadataName(final String name) {
		classMetadataName = name;
		return this;
	}

	/**
	 * Sets usage of default class meta-data name.
	 * Using it may introduce a security hole, see {@link #setClassMetadataName(String)} for more details.
	 * @see #setClassMetadataName(String)
	 */
	public JsonParser withClassMetadata(final boolean useMetadata) {
		if (useMetadata) {
			classMetadataName = Defaults.DEFAULT_CLASS_METADATA_NAME;
		}
		else {
			classMetadataName = null;
		}
		return this;
	}

	/**
	 * Adds a {@link jodd.util.Wildcard wildcard} pattern for white-listing classes.
	 * @see #setClassMetadataName(String)
	 */
	public JsonParser allowClass(final String classPattern) {
		if (super.classnameWhitelist == null) {
			super.classnameWhitelist = new ArrayList<>();
		}
		classnameWhitelist.add(classPattern);
		return this;
	}

	/**
	 * Removes the whitelist of allowed classes.
	 * @see #setClassMetadataName(String)
	 */
	public JsonParser allowAllClasses() {
		classnameWhitelist = null;
		return this;
	}

	// ---------------------------------------------------------------- parse

	/**
	 * Parses input JSON as given type.
	 */
	@SuppressWarnings(""unchecked"")
	public <T> T parse(final String input, final Class<T> targetType) {
		rootType = targetType;
		return _parse(UnsafeUtil.getChars(input));
	}

	/**
	 * Parses input JSON to {@link JsonObject}, special case of {@link #parse(String, Class)}.
	 */
	public JsonObject parseAsJsonObject(final String input) {
		return new JsonObject(parse(input));
	}

	/**
	 * Parses input JSON to {@link JsonArray}, special case of parsing.
	 */
	public JsonArray parseAsJsonArray(final String input) {
		return new JsonArray(parse(input));
	}

	/**
	 * Parses input JSON to a list with specified component type.
	 */
	public <T> List<T> parseAsList(final String string, final Class<T> componentType) {
		return new JsonParser()
			.map(JsonParser.VALUES, componentType)
			.parse(string);
	}

	/**
	 * Parses input JSON to a list with specified key and value types.
	 */
	public <K, V> Map<K, V> parseAsMap(
		final String string, final Class<K> keyType, final Class<V> valueType) {

		return new JsonParser()
			.map(JsonParser.KEYS, keyType)
			.map(JsonParser.VALUES, valueType)
			.parse(string);
	}

	/**
	 * Parses input JSON string.
	 */
	public <T> T parse(final String input) {
		return _parse(UnsafeUtil.getChars(input));
	}

	/**
	 * Parses input JSON as given type.
	 */
	@SuppressWarnings(""unchecked"")
	public <T> T parse(final char[] input, final Class<T> targetType) {
		rootType = targetType;
		return _parse(input);
	}

	/**
	 * Parses input JSON char array.
	 */
	public <T> T parse(final char[] input) {
		return _parse(input);
	}


	private <T> T _parse(final char[] input) {
		this.input = input;
		this.total = input.length;

		reset();

		skipWhiteSpaces();

		Object value;

		try {
			value = parseValue(rootType, null, null);
		}
		catch (IndexOutOfBoundsException iofbex) {
			syntaxError(""End of JSON"");
			return null;
		}

		skipWhiteSpaces();

		if (ndx != total) {
			syntaxError(""Trailing chars"");
			return null;
		}

		if (lazy) {
			// lets resolve root lazy values
			value = resolveLazyValue(value);
		}

		// convert map to target type

		if (classMetadataName != null && rootType == null) {
			if (value instanceof Map) {
				Map map = (Map) value;

				value = mapToBean.map2bean(map, null);
			}
		}

		return (T) value;
	}

	// ---------------------------------------------------------------- parser

	/**
	 * Parses a JSON value.
	 * @param targetType target type to convert, may be <code>null</code>
	 * @param componentType component type for maps and arrays, may be <code>null</code>
	 */
	protected Object parseValue(final Class targetType, final Class keyType, final Class componentType) {
		final ValueConverter valueConverter;

		final char c = input[ndx];

		switch (c) {
			case '\'':
				if (!looseMode) {
					break;
				}
			case '""':
				ndx++;
				Object string = parseStringContent(c);

				valueConverter = lookupValueConverter();
				if (valueConverter != null) {
					return valueConverter.convert(string);
				}

				if (targetType != null && targetType != String.class) {
					string = convertType(string, targetType);
				}
				return string;

			case '{':
				ndx++;
				if (lazy) {
					if (notFirstObject) {
						final Object value = new ObjectParser(this, targetType, keyType, componentType);

						skipObject();

						return value;
					}
					else {
						notFirstObject = true;
					}
				}

				return parseObjectContent(targetType, keyType, componentType);

			case '[':
				ndx++;
				return parseArrayContent(targetType, componentType);

			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case '-':
				Object number = parseNumber();

				valueConverter = lookupValueConverter();
				if (valueConverter != null) {
					return valueConverter.convert(number);
				}

				if (targetType != null) {
					number = convertType(number, targetType);
				}
				return number;

			case 'n':
				ndx++;
				if (match(N_ULL)) {
					valueConverter = lookupValueConverter();
					if (valueConverter != null) {
						return valueConverter.convert(null);
					}
					return null;
				}
				break;

			case 't':
				ndx++;
				if (match(T_RUE)) {
					Object value = Boolean.TRUE;

					valueConverter = lookupValueConverter();
					if (valueConverter != null) {
						return valueConverter.convert(value);
					}

					if (targetType != null) {
						value = convertType(value, targetType);
					}
					return value;
				}
				break;

			case 'f':
				ndx++;
				if (match(F_ALSE)) {
					Object value = Boolean.FALSE;

					valueConverter = lookupValueConverter();
					if (valueConverter != null) {
						return valueConverter.convert(value);
					}

					if (targetType != null) {
						value = convertType(value, targetType);
					}
					return value;
				}
				break;
		}

		if (looseMode) {
			// try to parse unquoted string
			Object string = parseUnquotedStringContent();

			valueConverter = lookupValueConverter();
			if (valueConverter != null) {
				return valueConverter.convert(string);
			}

			if (targetType != null && targetType != String.class) {
				string = convertType(string, targetType);
			}
			return string;
		}

		syntaxError(""Invalid char: "" + input[ndx]);
		return null;
	}


	// ---------------------------------------------------------------- lazy

	/**
	 * Resolves lazy value during the parsing runtime.
	 */
	private Object resolveLazyValue(Object value) {
		if (value instanceof Supplier) {
			value = ((Supplier)value).get();
		}
		return value;
	}

	/**
	 * Skips over complete object. It is not parsed, just skipped. It will be
	 * parsed later, but oonly if required.
	 */
	private void skipObject() {
		int bracketCount = 1;
		boolean insideString = false;

		while (ndx < total) {
			final char c = input[ndx];

			if (insideString) {
				if (c == '\""') {
					insideString = false;
				}
			}
			else {
				if (c == '\""') {
					insideString = true;
				}
				if (c == '{') {
					bracketCount++;
				} else if (c == '}') {
					bracketCount--;
					if (bracketCount == 0) {
						ndx++;
						return;
					}
				}
			}
			ndx++;
		}
	}

	// ---------------------------------------------------------------- string

	protected char[] text;
	protected int textLen;

	/**
	 * Parses a string.
	 */
	protected String parseString() {
		char quote = '\""';
		if (looseMode) {
			quote = consumeOneOf('\""', '\'');
			if (quote == 0) {
				return parseUnquotedStringContent();
			}
		} else {
			consume(quote);
		}

		return parseStringContent(quote);
	}

	/**
	 * Parses string content, once when starting quote has been consumed.
	 */
	protected String parseStringContent(final char quote) {
		final int startNdx = ndx;

		// roll-out until the end of the string or the escape char
		while (true) {
			final char c = input[ndx];

			if (c == quote) {
				// no escapes found, just use existing string
				ndx++;
				return new String(input, startNdx, ndx - 1 - startNdx);
			}

			if (c == '\\') {
				break;
			}

			ndx++;
		}

		// escapes found, proceed differently

		textLen = ndx - startNdx;

		growEmpty();

//		for (int i = startNdx, j = 0; j < textLen; i++, j++) {
//			text[j] = input[i];
//		}
		System.arraycopy(input, startNdx, text, 0, textLen);

		// escape char, process everything until the end
		while (true) {
			char c = input[ndx];

			if (c == quote) {
				// done
				ndx++;
				final String str = new String(text, 0, textLen);
				textLen = 0;
				return str;
			}

			if (c == '\\') {
				// escape char found
				ndx++;

				c = input[ndx];

				switch (c) {
					case '\""' : c = '\""'; break;
					case '\\' : c = '\\'; break;
					case '/' : c = '/'; break;
					case 'b' : c = '\b'; break;
					case 'f' : c = '\f'; break;
					case 'n' : c = '\n'; break;
					case 'r' : c = '\r'; break;
					case 't' : c = '\t'; break;
					case 'u' :
						ndx++;
						c = parseUnicode();
						break;
					default:
						if (looseMode) {
							if (c != '\'') {
								c = '\\';
								ndx--;
							}
						}
						else {
							syntaxError(""Invalid escape char: "" + c);
						}
				}
			}

			text[textLen] = c;

			textLen++;

			growAndCopy();

			ndx++;
		}
	}

	/**
	 * Grows empty text array.
	 */
	protected void growEmpty() {
		if (textLen >= text.length) {
			int newSize = textLen << 1;

			text = new char[newSize];
		}
	}

	/**
	 * Grows text array when {@code text.length == textLen}.
	 */
	protected void growAndCopy() {
		if (textLen == text.length) {
			int newSize = text.length << 1;

			char[] newText = new char[newSize];

			if (textLen > 0) {
				System.arraycopy(text, 0, newText, 0, textLen);
			}

			text = newText;
		}
	}

	/**
	 * Parses 4 characters and returns unicode character.
	 */
	protected char parseUnicode() {
		int i0 = CharUtil.hex2int(input[ndx++]);
		int i1 = CharUtil.hex2int(input[ndx++]);
		int i2 = CharUtil.hex2int(input[ndx++]);
		int i3 = CharUtil.hex2int(input[ndx]);

		return (char) ((i0 << 12) + (i1 << 8) + (i2 << 4) + i3);
	}

	// ---------------------------------------------------------------- un-quoted

	private final static char[] UNQOUTED_DELIMETERS = "",:[]{}\\\""'"".toCharArray();

	/**
	 * Parses un-quoted string content.
	 */
	protected String parseUnquotedStringContent() {
		final int startNdx = ndx;

		while (true) {
			final char c = input[ndx];

			if (c <= ' ' || CharUtil.equalsOne(c, UNQOUTED_DELIMETERS)) {
				final int currentNdx = ndx;

				// done
				skipWhiteSpaces();

				return new String(input, startNdx, currentNdx - startNdx);
			}

			ndx++;
		}
	}


	// ---------------------------------------------------------------- number

	/**
	 * Parses JSON numbers.
	 */
	protected Number parseNumber() {
		final int startIndex = ndx;

		char c = input[ndx];

		boolean isDouble = false;
		boolean isExp = false;

		if (c == '-') {
			ndx++;
		}

		while (true) {
			if (isEOF()) {
				break;
			}

			c = input[ndx];

			if (c >= '0' && c <= '9') {
				ndx++;
				continue;
			}
			if (c <= 32) {		// white space
				break;
			}
			if (c == ',' || c == '}' || c == ']') {	// delimiter
				break;
			}

			if (c == '.') {
				isDouble = true;
			}
			else if (c == 'e' || c == 'E') {
				isExp = true;
			}
			ndx++;
		}


		final String value = new String(input, startIndex, ndx - startIndex);

		if (isDouble) {
			return Double.valueOf(value);
		}

		long longNumber;

		if (isExp) {
			longNumber = Double.valueOf(value).longValue();
		}
		else {
			if (value.length() >= 19) {
				// if string is 19 chars and longer, it can be over the limit
				BigInteger bigInteger = new BigInteger(value);

				if (isGreaterThenLong(bigInteger)) {
					return bigInteger;
				}
				longNumber = bigInteger.longValue();
			}
			else {
				longNumber = Long.parseLong(value);
			}
		}

		if ((longNumber >= Integer.MIN_VALUE) && (longNumber <= Integer.MAX_VALUE)) {
			return Integer.valueOf((int) longNumber);
		}
		return Long.valueOf(longNumber);
	}

	private static boolean isGreaterThenLong(final BigInteger bigInteger) {
		if (bigInteger.compareTo(MAX_LONG) > 0) {
			return true;
		}
		if (bigInteger.compareTo(MIN_LONG) < 0) {
			return true;
		}
		return false;
	}

	private static final BigInteger MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);
	private static final BigInteger MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE);

	// ---------------------------------------------------------------- array

	/**
	 * Parses arrays, once when open bracket has been consumed.
	 */
	protected Object parseArrayContent(Class targetType, Class componentType) {
		// detect special case

		if (targetType == Object.class) {
			targetType = List.class;
		}

		// continue

		targetType = replaceWithMappedTypeForPath(targetType);

		if (componentType == null && targetType != null && targetType.isArray()) {
			componentType = targetType.getComponentType();
		}

		path.push(VALUES);

		componentType = replaceWithMappedTypeForPath(componentType);

		Collection<Object> target = newArrayInstance(targetType);

		boolean koma = false;

		mainloop:
		while (true) {
			skipWhiteSpaces();

			char c = input[ndx];

			if (c == ']') {
				if (koma) {
					syntaxError(""Trailing comma"");
				}

				ndx++;
				path.pop();
				return target;
			}

			Object value = parseValue(componentType, null, null);

			target.add(value);

			skipWhiteSpaces();

			c = input[ndx];

			switch (c) {
				case ']': ndx++; break mainloop;
				case ',': ndx++; koma = true; break;
				default: syntaxError(""Invalid char: expected ] or ,"");
			}

		}

		path.pop();

		if (targetType != null) {
			return convertType(target, targetType);
		}

		return target;
	}

	// ---------------------------------------------------------------- object

	/**
	 * Parses object, once when open bracket has been consumed.
	 */
	protected Object parseObjectContent(Class targetType, Class valueKeyType, Class valueType) {
		// detect special case

		if (targetType == Object.class) {
			targetType = Map.class;
		}

		// continue

		targetType = replaceWithMappedTypeForPath(targetType);

		Object target;
		boolean isTargetTypeMap = true;
		boolean isTargetRealTypeMap = true;
		ClassDescriptor targetTypeClassDescriptor = null;
		TypeData typeData = null;

		if (targetType != null) {
			targetTypeClassDescriptor = ClassIntrospector.get().lookup(targetType);

			// find if the target is really a map
			// because when classMetadataName != null we are forcing
			// map usage locally in this method

			isTargetRealTypeMap = targetTypeClassDescriptor.isMap();

			typeData = jsonAnnotationManager.lookupTypeData(targetType);
		}

		if (isTargetRealTypeMap) {
			// resolve keys only for real maps
			path.push(KEYS);
			valueKeyType = replaceWithMappedTypeForPath(valueKeyType);
			path.pop();
		}

		if (classMetadataName == null) {
			// create instance of target type, no 'class' information
			target = newObjectInstance(targetType);

			isTargetTypeMap = isTargetRealTypeMap;
		} else {
			// all beans will be created first as a map
			target = mapSupplier.get();
		}

		boolean koma = false;

		mainloop:
		while (true) {
			skipWhiteSpaces();

			char c = input[ndx];

			if (c == '}') {
				if (koma) {
					syntaxError(""Trailing comma"");
				}

				ndx++;
				break;
			}

			koma = false;

			String key = parseString();
			String keyOriginal = key;

			skipWhiteSpaces();

			consume(':');

			skipWhiteSpaces();

			// read the type of the simple property

			PropertyDescriptor pd = null;
			Class propertyType = null;
			Class keyType = null;
			Class componentType = null;

			// resolve simple property

			if (!isTargetRealTypeMap) {
				// replace key with real property value
				key = jsonAnnotationManager.resolveRealName(targetType, key);
			}

			if (!isTargetTypeMap) {
				pd = targetTypeClassDescriptor.getPropertyDescriptor(key, true);

				if (pd != null) {
					propertyType = pd.getType();
					keyType = pd.resolveKeyType(true);
					componentType = pd.resolveComponentType(true);
				}
			}

			Object value;

			if (!isTargetTypeMap) {
				// *** inject into bean
					path.push(key);

					value = parseValue(propertyType, keyType, componentType);

					path.pop();

				if (typeData.rules.match(keyOriginal, !typeData.strict)) {

					if (pd != null) {
						if (lazy) {
							// need to resolve lazy value before injecting objects into it
							value = resolveLazyValue(value);
						}

						// only inject values if target property exist
						injectValueIntoObject(target, pd, value);
					}
				}
			}
			else {
				Object keyValue = key;

				if (valueKeyType != null) {
					keyValue = convertType(key, valueKeyType);
				}

				// *** add to map
				if (isTargetRealTypeMap) {
					path.push(VALUES, key);

					valueType = replaceWithMappedTypeForPath(valueType);
				} else {
					path.push(key);
				}


				value = parseValue(valueType, null, null);

				path.pop();

				((Map) target).put(keyValue, value);
			}

			skipWhiteSpaces();

			c = input[ndx];

			switch (c) {
				case '}': ndx++; break mainloop;
				case ',': ndx++; koma = true; break;
				default: syntaxError(""Invalid char: expected } or ,"");
			}
		}

		// done

		// convert Map to target type
		if (classMetadataName != null) {
			target = mapToBean.map2bean((Map) target, targetType);
		}

		return target;
	}

	// ---------------------------------------------------------------- scanning tools

	/**
	 * Consumes char at current position. If char is different, throws the exception.
	 */
	protected void consume(final char c) {
		if (input[ndx] != c) {
			syntaxError(""Invalid char: expected "" + c);
		}

		ndx++;
	}

	/**
	 * Consumes one of the allowed char at current position.
	 * If char is different, return <code>0</code>.
	 * If matched, returns matched char.
	 */
	protected char consumeOneOf(final char c1, final char c2) {
		char c = input[ndx];

		if ((c != c1) && (c != c2)) {
			return 0;
		}

		ndx++;

		return c;
	}

	/**
	 * Returns <code>true</code> if scanning is at the end.
	 */
	protected boolean isEOF() {
		return ndx >= total;
	}

	/**
	 * Skips whitespaces. For the simplification, whitespaces are
	 * considered any characters less or equal to 32 (space).
	 */
	protected final void skipWhiteSpaces() {
		while (true) {
			if (isEOF()) {
				return;
			}
			if (input[ndx] > 32) {
				return;
			}
			ndx++;
		}
    }

	/**
	 * Matches char buffer with content on given location.
	 */
	protected final boolean match(final char[] target) {
		for (char c : target) {
			if (input[ndx] != c) {
				return false;
			}
			ndx++;
		}

		return true;
	}


	// ---------------------------------------------------------------- error

	/**
	 * Throws {@link jodd.json.JsonException} indicating a syntax error.
	 */
	protected void syntaxError(final String message) {
		String left = ""..."";
		String right = ""..."";
		int offset = 10;

		int from = ndx - offset;
		if (from < 0) {
			from = 0;
			left = StringPool.EMPTY;
		}

		int to = ndx + offset;
		if (to > input.length) {
			to = input.length;
			right = StringPool.EMPTY;
		}

		final CharSequence str = CharArraySequence.of(input, from, to - from);

		throw new JsonException(
				""Syntax error! "" + message + ""\n"" +
				""offset: "" + ndx + "" near: \"""" + left + str + right + ""\"""");
	}

}",1
CVE-2018-21234,jodd-json/src/main/java/jodd/json/JsonParserBase.java,"// Copyright (c) 2003-present, Jodd Team (http://jodd.org)
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

package jodd.json;

import jodd.introspector.ClassDescriptor;
import jodd.introspector.ClassIntrospector;
import jodd.introspector.CtorDescriptor;
import jodd.introspector.PropertyDescriptor;
import jodd.introspector.Setter;
import jodd.typeconverter.TypeConverterManager;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Supplier;

/**
 * Just a base class of {@link jodd.json.JsonParser} that contains
 * various utilities, to reduce the size of a parser.
 */
public abstract class JsonParserBase {

	protected static final Supplier<Map> HASMAP_SUPPLIER = LinkedHashMap::new;
	protected static final Supplier<Map> LAZYMAP_SUPPLIER = LazyMap::new;

	protected static final Supplier<List> ARRAYLIST_SUPPLIER = ArrayList::new;
	protected static final Supplier<List> LAZYLIST_SUPPLIER = LazyList::new;

	protected Supplier<Map> mapSupplier = HASMAP_SUPPLIER;
	protected Supplier<List> listSupplier = ARRAYLIST_SUPPLIER;

	/**
	 * Creates new instance of {@link jodd.json.MapToBean}.
	 */
	protected MapToBean createMapToBean(final String classMetadataName) {
		return new MapToBean(this, classMetadataName);
	}

	// ---------------------------------------------------------------- object tools

	/**
	 * Creates new type for JSON array objects.
	 * It returns a collection.
	 * Later, the collection will be converted into the target type.
	 */
	@SuppressWarnings(""unchecked"")
	protected Collection<Object> newArrayInstance(final Class targetType) {
		if (targetType == null ||
			targetType == List.class ||
			targetType == Collection.class ||
			targetType.isArray()) {

			return listSupplier.get();
		}

		if (targetType == Set.class) {
			return new HashSet<>();
		}

		try {
			return (Collection<Object>) targetType.getDeclaredConstructor().newInstance();
		} catch (Exception e) {
			throw new JsonException(e);
		}
	}

	/**
	 * Creates new object or a <code>HashMap</code> if type is not specified.
	 */
	protected Object newObjectInstance(final Class targetType) {
		if (targetType == null ||
			targetType == Map.class) {

			return mapSupplier.get();
		}

		ClassDescriptor cd = ClassIntrospector.get().lookup(targetType);

		CtorDescriptor ctorDescriptor = cd.getDefaultCtorDescriptor(true);
		if (ctorDescriptor == null) {
			throw new JsonException(""Default ctor not found for: "" + targetType.getName());
		}

		try {
//			return ClassUtil.newInstance(targetType);
			return ctorDescriptor.getConstructor().newInstance();
		} catch (Exception e) {
			throw new JsonException(e);
		}
	}

	/**
	 * Injects value into the targets property.
	 */
	protected void injectValueIntoObject(final Object target, final PropertyDescriptor pd, final Object value) {
		Object convertedValue = value;

		if (value != null) {
			Class targetClass = pd.getType();

			convertedValue = convertType(value, targetClass);
		}

		try {
			Setter setter = pd.getSetter(true);
			if (setter != null) {
				setter.invokeSetter(target, convertedValue);
			}
		} catch (Exception ex) {
			throw new JsonException(ex);
		}
	}

	/**
	 * Converts type of the given value.
	 */
	protected Object convertType(final Object value, final Class targetType) {
		Class valueClass = value.getClass();

		if (valueClass == targetType) {
			return value;
		}

		try {
			return TypeConverterManager.get().convertType(value, targetType);
		}
		catch (Exception ex) {
			throw new JsonException(""Type conversion failed"", ex);
		}
	}

}",0
CVE-2018-21234,jodd-json/src/main/java/jodd/json/JsonParserBase.java,"// Copyright (c) 2003-present, Jodd Team (http://jodd.org)
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

package jodd.json;

import jodd.introspector.ClassDescriptor;
import jodd.introspector.ClassIntrospector;
import jodd.introspector.CtorDescriptor;
import jodd.introspector.PropertyDescriptor;
import jodd.introspector.Setter;
import jodd.typeconverter.TypeConverterManager;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Supplier;

/**
 * Just a base class of {@link jodd.json.JsonParser} that contains
 * various utilities, to reduce the size of a parser.
 */
public abstract class JsonParserBase {

	protected static final Supplier<Map> HASMAP_SUPPLIER = LinkedHashMap::new;
	protected static final Supplier<Map> LAZYMAP_SUPPLIER = LazyMap::new;

	protected static final Supplier<List> ARRAYLIST_SUPPLIER = ArrayList::new;
	protected static final Supplier<List> LAZYLIST_SUPPLIER = LazyList::new;

	protected Supplier<Map> mapSupplier = HASMAP_SUPPLIER;
	protected Supplier<List> listSupplier = ARRAYLIST_SUPPLIER;
	protected List<String> classnameWhitelist;

	/**
	 * Creates new instance of {@link jodd.json.MapToBean}.
	 */
	protected MapToBean createMapToBean(final String classMetadataName) {
		return new MapToBean(this, classMetadataName);
	}

	// ---------------------------------------------------------------- object tools

	/**
	 * Creates new type for JSON array objects.
	 * It returns a collection.
	 * Later, the collection will be converted into the target type.
	 */
	@SuppressWarnings(""unchecked"")
	protected Collection<Object> newArrayInstance(final Class targetType) {
		if (targetType == null ||
			targetType == List.class ||
			targetType == Collection.class ||
			targetType.isArray()) {

			return listSupplier.get();
		}

		if (targetType == Set.class) {
			return new HashSet<>();
		}

		try {
			return (Collection<Object>) targetType.getDeclaredConstructor().newInstance();
		} catch (Exception e) {
			throw new JsonException(e);
		}
	}

	/**
	 * Creates new object or a <code>HashMap</code> if type is not specified.
	 */
	protected Object newObjectInstance(final Class targetType) {
		if (targetType == null ||
			targetType == Map.class) {

			return mapSupplier.get();
		}

		ClassDescriptor cd = ClassIntrospector.get().lookup(targetType);

		CtorDescriptor ctorDescriptor = cd.getDefaultCtorDescriptor(true);
		if (ctorDescriptor == null) {
			throw new JsonException(""Default ctor not found for: "" + targetType.getName());
		}

		try {
//			return ClassUtil.newInstance(targetType);
			return ctorDescriptor.getConstructor().newInstance();
		} catch (Exception e) {
			throw new JsonException(e);
		}
	}

	/**
	 * Injects value into the targets property.
	 */
	protected void injectValueIntoObject(final Object target, final PropertyDescriptor pd, final Object value) {
		Object convertedValue = value;

		if (value != null) {
			Class targetClass = pd.getType();

			convertedValue = convertType(value, targetClass);
		}

		try {
			Setter setter = pd.getSetter(true);
			if (setter != null) {
				setter.invokeSetter(target, convertedValue);
			}
		} catch (Exception ex) {
			throw new JsonException(ex);
		}
	}

	/**
	 * Converts type of the given value.
	 */
	protected Object convertType(final Object value, final Class targetType) {
		Class valueClass = value.getClass();

		if (valueClass == targetType) {
			return value;
		}

		try {
			return TypeConverterManager.get().convertType(value, targetType);
		}
		catch (Exception ex) {
			throw new JsonException(""Type conversion failed"", ex);
		}
	}

}",1
CVE-2018-21234,jodd-json/src/main/java/jodd/json/MapToBean.java,"// Copyright (c) 2003-present, Jodd Team (http://jodd.org)
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

package jodd.json;

import jodd.introspector.ClassDescriptor;
import jodd.introspector.ClassIntrospector;
import jodd.introspector.PropertyDescriptor;
import jodd.introspector.Setter;
import jodd.typeconverter.TypeConverterManager;
import jodd.util.ClassLoaderUtil;
import jodd.util.ClassUtil;

import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Map to bean converter.
 * Used when parsing with class metadata enabled.
 */
public class MapToBean {

	protected boolean declared = true;
	protected final JsonParserBase jsonParser;
	protected final String classMetadataName;

	public MapToBean(final JsonParserBase jsonParser, final String classMetadataName) {
		this.jsonParser = jsonParser;
		this.classMetadataName = classMetadataName;
	}

	/**
	 * Converts map to target type.
	 */
	public Object map2bean(final Map map, Class targetType) {
		Object target = null;

		// create targets type
		String className = (String) map.get(classMetadataName);

		if (className == null) {
			if (targetType == null) {
				// nothing to do, no information about target type found
				target = map;
			}
		}
		else {
			try {
				targetType = ClassLoaderUtil.loadClass(className);
			} catch (ClassNotFoundException cnfex) {
				throw new JsonException(cnfex);
			}
		}

		if (target == null) {
			target = jsonParser.newObjectInstance(targetType);
		}

		ClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass());

		boolean targetIsMap = target instanceof Map;

		for (Object key : map.keySet()) {
			String keyName = key.toString();

			if (classMetadataName != null) {
				if (keyName.equals(classMetadataName)) {
					continue;
				}
			}

			PropertyDescriptor pd = cd.getPropertyDescriptor(keyName, declared);

			if (!targetIsMap && pd == null) {
				// target property does not exist, continue
				continue;
			}

			// value is one of JSON basic types, like Number, Map, List...
			Object value = map.get(key);

			Class propertyType = pd == null ? null : pd.getType();
			Class componentType = pd == null ? null : pd.resolveComponentType(true);

			if (value != null) {
				if (value instanceof List) {
					if (componentType != null && componentType != String.class) {
						value = generifyList((List) value, componentType);
					}
				}
				else if (value instanceof Map) {
					// if the value we want to inject is a Map...
					if (!ClassUtil.isTypeOf(propertyType, Map.class)) {
						// ... and if target is NOT a map
						value = map2bean((Map) value, propertyType);
					}
					else {
						// target is also a Map, but we might need to generify it
						Class keyType = pd == null ? null : pd.resolveKeyType(true);

						if (keyType != String.class || componentType != String.class) {
							// generify
							value = generifyMap((Map) value, keyType, componentType);
						}
					}
				}
			}

			if (targetIsMap) {
				((Map)target).put(keyName, value);
			}
			else {
				try {
					setValue(target, pd, value);
				} catch (Exception ignore) {
					ignore.printStackTrace();
				}
			}
		}

		return target;
	}

	/**
	 * Converts type of all list elements to match the component type.
	 */
	private Object generifyList(final List list, final Class componentType) {
		for (int i = 0; i < list.size(); i++) {
			Object element = list.get(i);

			if (element != null) {
				if (element instanceof Map) {
					Object bean = map2bean((Map) element, componentType);
					list.set(i, bean);
				} else {
					Object value = convert(element, componentType);
					list.set(i, value);
				}
			}
		}

		return list;
	}

	/**
	 * Sets the property value.
	 */
	private void setValue(final Object target, final PropertyDescriptor pd, Object value) throws InvocationTargetException, IllegalAccessException {
		Class propertyType;

		Setter setter = pd.getSetter(true);
		if (setter != null) {
			if (value != null) {
				propertyType = setter.getSetterRawType();
				value = jsonParser.convertType(value, propertyType);
			}
			setter.invokeSetter(target, value);
		}
	}

	/**
	 * Change map elements to match key and value types.
	 */
	protected <K,V> Map<K, V> generifyMap(final Map<Object, Object> map, final Class<K> keyType, final Class<V> valueType) {

		if (keyType == String.class) {
			// only value type is changed, we can make value replacements
			for (Map.Entry<Object, Object> entry : map.entrySet()) {
				Object value = entry.getValue();
				Object newValue = convert(value, valueType);

				if (value != newValue) {
					entry.setValue(newValue);
				}
			}
			return (Map<K, V>) map;
		}

		// key is changed too, we need a new map
		Map<K, V> newMap = new HashMap<>(map.size());

		for (Map.Entry<Object, Object> entry : map.entrySet()) {
			Object key = entry.getKey();
			Object newKey = convert(key, keyType);

			Object value = entry.getValue();
			Object newValue = convert(value, valueType);

			newMap.put((K)newKey, (V)newValue);
		}

		return newMap;
	}

	protected Object convert(final Object value, final Class targetType) {
		Class valueClass = value.getClass();

		if (valueClass == targetType) {
			return value;
		}

		if (value instanceof Map) {
			if (targetType == Map.class) {
				return value;
			}

			return map2bean((Map) value, targetType);
		}

		try {
			return TypeConverterManager.get().convertType(value, targetType);
		}
		catch (Exception ex) {
			throw new JsonException(""Type conversion failed"", ex);
		}
	}

}",0
CVE-2018-21234,jodd-json/src/main/java/jodd/json/MapToBean.java,"// Copyright (c) 2003-present, Jodd Team (http://jodd.org)
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

package jodd.json;

import jodd.introspector.ClassDescriptor;
import jodd.introspector.ClassIntrospector;
import jodd.introspector.PropertyDescriptor;
import jodd.introspector.Setter;
import jodd.typeconverter.TypeConverterManager;
import jodd.util.ClassLoaderUtil;
import jodd.util.ClassUtil;
import jodd.util.Wildcard;

import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Map to bean converter.
 * Used when parsing with class metadata enabled.
 */
public class MapToBean {

	protected boolean declared = true;
	protected final JsonParserBase jsonParser;
	protected final String classMetadataName;

	public MapToBean(final JsonParserBase jsonParser, final String classMetadataName) {
		this.jsonParser = jsonParser;
		this.classMetadataName = classMetadataName;
	}

	/**
	 * Converts map to target type.
	 */
	public Object map2bean(final Map map, Class targetType) {
		Object target = null;

		// create targets type
		String className = (String) map.get(classMetadataName);

		if (className == null) {
			if (targetType == null) {
				// nothing to do, no information about target type found
				target = map;
			}
		}
		else {
			checkClassName(jsonParser.classnameWhitelist, className);

			try {
				targetType = ClassLoaderUtil.loadClass(className);
			} catch (ClassNotFoundException cnfex) {
				throw new JsonException(cnfex);
			}
		}

		if (target == null) {
			target = jsonParser.newObjectInstance(targetType);
		}

		ClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass());

		boolean targetIsMap = target instanceof Map;

		for (Object key : map.keySet()) {
			String keyName = key.toString();

			if (classMetadataName != null) {
				if (keyName.equals(classMetadataName)) {
					continue;
				}
			}

			PropertyDescriptor pd = cd.getPropertyDescriptor(keyName, declared);

			if (!targetIsMap && pd == null) {
				// target property does not exist, continue
				continue;
			}

			// value is one of JSON basic types, like Number, Map, List...
			Object value = map.get(key);

			Class propertyType = pd == null ? null : pd.getType();
			Class componentType = pd == null ? null : pd.resolveComponentType(true);

			if (value != null) {
				if (value instanceof List) {
					if (componentType != null && componentType != String.class) {
						value = generifyList((List) value, componentType);
					}
				}
				else if (value instanceof Map) {
					// if the value we want to inject is a Map...
					if (!ClassUtil.isTypeOf(propertyType, Map.class)) {
						// ... and if target is NOT a map
						value = map2bean((Map) value, propertyType);
					}
					else {
						// target is also a Map, but we might need to generify it
						Class keyType = pd == null ? null : pd.resolveKeyType(true);

						if (keyType != String.class || componentType != String.class) {
							// generify
							value = generifyMap((Map) value, keyType, componentType);
						}
					}
				}
			}

			if (targetIsMap) {
				((Map)target).put(keyName, value);
			}
			else {
				try {
					setValue(target, pd, value);
				} catch (Exception ignore) {
					ignore.printStackTrace();
				}
			}
		}

		return target;
	}

	private void checkClassName(final List<String> classnameWhitelist, final String className) {
		if (classnameWhitelist == null) {
			return;
		}
		classnameWhitelist.forEach(pattern -> {
			if (!Wildcard.equalsOrMatch(className, pattern)) {
				throw new JsonException(""Class can't be loaded as it is not whitelisted: "" + className);
			}
		});
	}

	/**
	 * Converts type of all list elements to match the component type.
	 */
	private Object generifyList(final List list, final Class componentType) {
		for (int i = 0; i < list.size(); i++) {
			Object element = list.get(i);

			if (element != null) {
				if (element instanceof Map) {
					Object bean = map2bean((Map) element, componentType);
					list.set(i, bean);
				} else {
					Object value = convert(element, componentType);
					list.set(i, value);
				}
			}
		}

		return list;
	}

	/**
	 * Sets the property value.
	 */
	private void setValue(final Object target, final PropertyDescriptor pd, Object value) throws InvocationTargetException, IllegalAccessException {
		Class propertyType;

		Setter setter = pd.getSetter(true);
		if (setter != null) {
			if (value != null) {
				propertyType = setter.getSetterRawType();
				value = jsonParser.convertType(value, propertyType);
			}
			setter.invokeSetter(target, value);
		}
	}

	/**
	 * Change map elements to match key and value types.
	 */
	protected <K,V> Map<K, V> generifyMap(final Map<Object, Object> map, final Class<K> keyType, final Class<V> valueType) {

		if (keyType == String.class) {
			// only value type is changed, we can make value replacements
			for (Map.Entry<Object, Object> entry : map.entrySet()) {
				Object value = entry.getValue();
				Object newValue = convert(value, valueType);

				if (value != newValue) {
					entry.setValue(newValue);
				}
			}
			return (Map<K, V>) map;
		}

		// key is changed too, we need a new map
		Map<K, V> newMap = new HashMap<>(map.size());

		for (Map.Entry<Object, Object> entry : map.entrySet()) {
			Object key = entry.getKey();
			Object newKey = convert(key, keyType);

			Object value = entry.getValue();
			Object newValue = convert(value, valueType);

			newMap.put((K)newKey, (V)newValue);
		}

		return newMap;
	}

	protected Object convert(final Object value, final Class targetType) {
		Class valueClass = value.getClass();

		if (valueClass == targetType) {
			return value;
		}

		if (value instanceof Map) {
			if (targetType == Map.class) {
				return value;
			}

			return map2bean((Map) value, targetType);
		}

		try {
			return TypeConverterManager.get().convertType(value, targetType);
		}
		catch (Exception ex) {
			throw new JsonException(""Type conversion failed"", ex);
		}
	}

}",1
CVE-2018-21234,jodd-json/src/test/java/jodd/json/JSONDeserializerTest.java,"// Copyright (c) 2003-present, Jodd Team (http://jodd.org)
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

package jodd.json;

import jodd.json.fixtures.JsonParsers;
import jodd.json.fixtures.mock.Employee;
import jodd.json.fixtures.mock.Group;
import jodd.json.fixtures.mock.Network;
import jodd.json.fixtures.mock.Pair;
import jodd.json.fixtures.mock.Person;
import jodd.json.fixtures.mock.Phone;
import jodd.json.fixtures.mock.Spiderman;
import jodd.json.fixtures.mock.superhero.Hero;
import jodd.json.fixtures.mock.superhero.SecretIdentity;
import jodd.json.fixtures.mock.superhero.SecretLair;
import jodd.json.fixtures.mock.superhero.SuperPower;
import jodd.json.fixtures.mock.superhero.Villian;
import jodd.json.fixtures.mock.superhero.XRayVision;
import jodd.json.fixtures.model.Account;
import jodd.json.impl.DateJsonSerializer;
import jodd.util.StringUtil;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.awt.geom.Point2D;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

class JSONDeserializerTest {

	private static final double DELTA = 0.000000001;

	private DataCreator creator;

	@BeforeEach
	void setUp() {
		creator = new DataCreator();
	}

	@AfterEach
	void tearDown() {
		JsonParser.Defaults.classMetadataName = null;
		JsonSerializer.Defaults.classMetadataName = null;
	}

	@Test
	void testDeserializeNoIncludes() {
		JsonParsers.forEachParser(jsonParser -> {
			Person jodder = creator.createJodder();
			String json = new JsonSerializer().serialize(jodder);
			Person jsonJodder = jsonParser.parse(json, Person.class);

			assertNotNull(jsonJodder);

			assertEquals(jodder.getLastname(), jsonJodder.getLastname());
			assertEquals(jodder.getFirstname(), jsonJodder.getFirstname());
			assertEquals(jodder.getBirthdate(), jsonJodder.getBirthdate());

			assertEquals(jodder.getHome().getState(), jsonJodder.getHome().getState());
			assertEquals(jodder.getHome().getStreet(), jsonJodder.getHome().getStreet());
			assertEquals(jodder.getHome().getCity(), jsonJodder.getHome().getCity());

			assertEquals(jodder.getWork().getCity(), jsonJodder.getWork().getCity());

			assertEquals(jsonJodder, jsonJodder.getWork().getPerson());

			assertEquals(0, jsonJodder.getHobbies().size());
		});
	}

	@Test
	void testDeserializeWithPath() {
		JsonParsers.forEachParser(jsonParser -> {

			Person igor = creator.createJodder();
			Map map = new HashMap();
			map.put(""person"", igor);

			String json = new JsonSerializer().serialize(map);

			map = jsonParser.map(""values"", Person.class).parse(json);
			Person jsonIgor = (Person) map.get(""person"");

			assertNotNull(jsonIgor);

			assertEquals(igor.getLastname(), jsonIgor.getLastname());
			assertEquals(igor.getFirstname(), jsonIgor.getFirstname());
			assertEquals(igor.getBirthdate(), jsonIgor.getBirthdate());

			assertEquals(igor.getHome().getState(), jsonIgor.getHome().getState());
			assertEquals(igor.getHome().getStreet(), jsonIgor.getHome().getStreet());
			assertEquals(igor.getHome().getCity(), jsonIgor.getHome().getCity());

			assertEquals(igor.getWork().getCity(), jsonIgor.getWork().getCity());

			assertEquals(jsonIgor, jsonIgor.getWork().getPerson());
		});
	}

	@Test
	void testDeserializeWithIncludes() {
		JsonParsers.forEachParser(jsonParser -> {

			Person igor = creator.createJodder();
			String json = new JsonSerializer().include(""phones"", ""hobbies"").serialize(igor);
			Person jsonIgor = jsonParser.parse(json, Person.class);

			assertEquals(2, jsonIgor.getPhones().size());
			assertEquals(0, jsonIgor.getHobbies().size());
		});
	}

	@Test
	void testSubClassDeserialize() {
		JsonParsers.forEachParser(jsonParser -> {

			Employee dilbert = creator.createDilbert();

			String json = new JsonSerializer().include(""phones"", ""hobbies"").serialize(dilbert);
			Person jsonDilbert = jsonParser.parse(json, Employee.class);

			assertNotNull(jsonDilbert);
			assertTrue(jsonDilbert instanceof Employee);
			assertEquals(dilbert.getCompany(), ((Employee) jsonDilbert).getCompany());
		});
	}

	@Test
	void testDeserializeInterfaces() {
		JsonParsers.forEachParser(jsonParser -> {

			Hero superman = creator.createSuperman();
			String json = new JsonSerializer().include(""powers"").setClassMetadataName(""class"").serialize(superman);
			Hero jsonSuperMan = jsonParser.setClassMetadataName(""class"").parse(json, Hero.class);

			assertNotNull(jsonSuperMan);
			assertEquals(4, jsonSuperMan.getPowers().size());
			assertHeroHasSuperPowers(jsonSuperMan);
		});
	}

	@Test
	void testDeserializeInterfaces2() {
		JsonParsers.forEachParser(jsonParser -> {

			Hero superman = creator.createSuperman();
			String json = new JsonSerializer().include(""powers"").withClassMetadata(true).serialize(superman);
			Hero jsonSuperMan = jsonParser.withClassMetadata(true).parse(json, Hero.class);

			assertNotNull(jsonSuperMan);
			assertEquals(4, jsonSuperMan.getPowers().size());
			assertHeroHasSuperPowers(jsonSuperMan);
		});
	}

	@Test
	void testNoClassHints() {
		JsonParsers.forEachParser(jsonParser -> {
			Hero superman = creator.createSuperman();
			String json = new JsonSerializer().exclude(""*.class"").serialize(superman);

			Hero jsonSuperMan = jsonParser
				.map(Hero.class)
				.map(""lair"", SecretLair.class)
				.map(""secretIdentity"", SecretIdentity.class)
				.parse(json);

			assertNotNull(jsonSuperMan);
			assertEquals(""Super Man"", jsonSuperMan.getName());
			assertNotNull(jsonSuperMan.getIdentity());
			assertEquals(""Clark Kent"", jsonSuperMan.getIdentity().getName());
			assertNotNull(jsonSuperMan.getLair());
			assertEquals(""Fortress of Solitude"", jsonSuperMan.getLair().getName());
		});
	}

	@Test
	void testNoHintsButClassesForCollection() {
		JsonParser.Defaults.classMetadataName = ""class"";
		JsonSerializer.Defaults.classMetadataName = ""class"";

		JsonParsers.forEachParser(jsonParser -> {

			Hero superman = creator.createSuperman();
			String json = new JsonSerializer()
				.exclude(""*.class"")
				.include(""powers.class"")
				.serialize(superman);
			Hero jsonSuperMan = jsonParser.parse(json, Hero.class);
			assertHeroHasSuperPowers(jsonSuperMan);
		});
	}

	@Test
	void testNoClassHintsForCollections() {
		JsonParser.Defaults.classMetadataName = ""class"";
		JsonSerializer.Defaults.classMetadataName = ""class"";

		JsonParsers.forEachParser(jsonParser -> {

			Hero superman = creator.createSuperman();
			String json = new JsonSerializer()
				.include(""powers"")        // redudant
				.include(""powers.class"")
				.withSerializer(""powers.class"", new SimpleClassnameTransformer())
				.exclude(""*.class"")
				.serialize(superman);

			int count = StringUtil.count(json, ""***"");
			assertEquals(4, count);

			json = StringUtil.remove(json, ""***"");

			Hero jsonSuperMan = jsonParser
				.map(""lair"", SecretLair.class)
				.map(""secretIdentity"", SecretIdentity.class)
				.parse(json, Hero.class);

			assertEquals(""Fortress of Solitude"", jsonSuperMan.getLair().getName());
			assertHeroHasSuperPowers(jsonSuperMan);
		});
	}

	@Test
	void testListSerialization() {
		JsonParser.Defaults.classMetadataName = ""class"";
		JsonSerializer.Defaults.classMetadataName = ""class"";

		Person modesty = creator.createModesty();
		Person igor = creator.createJodder();
		Person pedro = creator.createPedro();
		List<Person> list = new ArrayList<>(3);
		list.add(modesty);
		list.add(igor);
		list.add(pedro);

		JsonParsers.forEachParser(jsonParser -> {
			String json = new JsonSerializer().serialize(list);

			List<Person> people = jsonParser.parse(json);
			assertTrue(people instanceof List);

			json = new JsonSerializer().exclude(""*.class"").serialize(list);
			people = jsonParser.map(""values"", Person.class).parse(json);

			assertEquals(3, people.size());
			assertEquals(Person.class, people.get(0).getClass());
		});

		JsonParsers.forEachParser(jsonParser -> {
			String json = new JsonSerializer().exclude(""*.class"").serialize(list);

			List<Map> peopleMap = jsonParser.parse(json);

			assertEquals(3, peopleMap.size());
			assertTrue(peopleMap.get(0) instanceof Map);
		});
	}

	@Test
	void testGenericTypeDeserialization() {
		JsonParser.Defaults.classMetadataName = ""class"";
		JsonSerializer.Defaults.classMetadataName = ""class"";

		JsonParsers.forEachParser(jsonParser -> {

			Pair<Hero, Villian> archenemies = new Pair<>(creator.createSuperman(), creator.createLexLuthor());

			String json = new JsonSerializer()
				.exclude(""*.class"")
				.serialize(archenemies);

			Pair<Hero, Villian> deserialArchEnemies = jsonParser
				.map(""first"", Hero.class)
				.map(""second"", Villian.class)
				.parse(json, Pair.class);

			assertEquals(archenemies.getFirst().getClass(), deserialArchEnemies.getFirst().getClass());
			assertEquals(archenemies.getSecond().getClass(), deserialArchEnemies.getSecond().getClass());

			assertEquals(archenemies.getFirst().getIdentity(), deserialArchEnemies.getFirst().getIdentity());
			assertEquals(archenemies.getFirst().getLair(), deserialArchEnemies.getFirst().getLair());
			assertEquals(archenemies.getFirst().getName(), deserialArchEnemies.getFirst().getName());

			assertEquals(archenemies.getSecond().getName(), deserialArchEnemies.getSecond().getName());
			assertEquals(archenemies.getSecond().getLair(), deserialArchEnemies.getSecond().getLair());
		});
	}

	@Test
	void testGenericTypeDeserialization2() {
		JsonParsers.forEachParser(jsonParser -> {
			Pair<Hero, Villian> archenemies = new Pair<>(creator.createSuperman(), creator.createLexLuthor());

			String json = new JsonSerializer()
				.serialize(archenemies);

			Pair<Hero, Villian> deserialArchEnemies = jsonParser
				.map(""first"", Hero.class)
				.map(""second"", Villian.class)
				.parse(json, Pair.class);

			assertEquals(archenemies.getFirst().getClass(), deserialArchEnemies.getFirst().getClass());
			assertEquals(archenemies.getSecond().getClass(), deserialArchEnemies.getSecond().getClass());

			assertEquals(archenemies.getFirst().getIdentity(), deserialArchEnemies.getFirst().getIdentity());
			assertEquals(archenemies.getFirst().getLair(), deserialArchEnemies.getFirst().getLair());
			assertEquals(archenemies.getFirst().getName(), deserialArchEnemies.getFirst().getName());

			assertEquals(archenemies.getSecond().getName(), deserialArchEnemies.getSecond().getName());
			assertEquals(archenemies.getSecond().getLair(), deserialArchEnemies.getSecond().getLair());
		});
	}

	@Test
	void testGeneralMapDeserialization() {
		JsonParser.Defaults.classMetadataName = ""class"";
		JsonSerializer.Defaults.classMetadataName = ""class"";

		JsonParsers.forEachParser(jsonParser -> {

			String json = new JsonSerializer().exclude(""*.class"").serialize(creator.createJodder());
			Map<String, Object> deserialized = jsonParser.parse(json);

			assertEquals(""Igor"", deserialized.get(""firstname""));
			assertEquals(""Spasic"", deserialized.get(""lastname""));
			assertTrue(Map.class.isAssignableFrom(deserialized.get(""work"").getClass()));
			assertTrue(Map.class.isAssignableFrom(deserialized.get(""home"").getClass()));
		});
	}

	@Test
	void testGeneralMapDeserialization2() {
		JsonParsers.forEachParser(jsonParser -> {
			String json = new JsonSerializer().serialize(creator.createJodder());
			Map<String, Object> deserialized = jsonParser.parse(json);

			assertEquals(""Igor"", deserialized.get(""firstname""));
			assertEquals(""Spasic"", deserialized.get(""lastname""));
			assertTrue(Map.class.isAssignableFrom(deserialized.get(""work"").getClass()));
			assertTrue(Map.class.isAssignableFrom(deserialized.get(""home"").getClass()));
		});
	}

	@Test
	void testListDeserializationNoClass() {
		JsonParser.Defaults.classMetadataName = ""class"";
		JsonSerializer.Defaults.classMetadataName = ""class"";

		JsonParsers.forEachParser(jsonParser -> {

			Person modesty = creator.createModesty();
			Person igor = creator.createJodder();
			Person pedro = creator.createPedro();
			List<Person> list = new ArrayList<>(3);
			list.add(modesty);
			list.add(igor);
			list.add(pedro);

			String json = new JsonSerializer().exclude(""*.class"").serialize(list);
			List<Person> people = jsonParser.map(""values"", Person.class).parse(json);
			assertEquals(3, list.size());
			assertEquals(modesty.getFirstname(), list.get(0).getFirstname());
			assertEquals(igor.getFirstname(), list.get(1).getFirstname());
			assertEquals(pedro.getFirstname(), list.get(2).getFirstname());
		});
	}

	@Test
	void testListDeserializationNoClass2() {
		JsonParsers.forEachParser(jsonParser -> {
			Person modesty = creator.createModesty();
			Person igor = creator.createJodder();
			Person pedro = creator.createPedro();
			List<Person> list = new ArrayList<>(3);
			list.add(modesty);
			list.add(igor);
			list.add(pedro);

			String json = new JsonSerializer().serialize(list);
			List<Person> people = jsonParser.map(""values"", Person.class).parse(json);
			assertEquals(3, list.size());
			assertEquals(modesty.getFirstname(), list.get(0).getFirstname());
			assertEquals(igor.getFirstname(), list.get(1).getFirstname());
			assertEquals(pedro.getFirstname(), list.get(2).getFirstname());
		});
	}

	@Test
	void testDateTransforming() {
		JsonParsers.forEachParser(jsonParser -> {
			final SimpleDateFormat df = new SimpleDateFormat(""yyyy/MM/dd"");
			Person foo = new Person(""Foo"", ""Bar"", new Date(), null, null);
			try {
				foo.setBirthdate(df.parse(""2009/01/02""));
			} catch (ParseException pe) {
				fail(pe);
			}


			String json = new JsonSerializer().withSerializer(""birthdate"", new DateJsonSerializer() {
				@Override
				public boolean serialize(JsonContext jsonContext, Date date) {
					jsonContext.writeString(df.format(date));
					return true;
				}
			}).serialize(foo);

			Person newUser = jsonParser
				.withValueConverter(""birthdate"", (ValueConverter<String, Date>) data -> {
					try {
						return df.parse(data);
					} catch (ParseException pe) {
						throw new JsonException(pe);
					}
				})
				.parse(json, Person.class);

			assertEquals(foo.getBirthdate(), newUser.getBirthdate());
			assertEquals(""2009/01/02"", df.format(newUser.getBirthdate()));
		});
	}

	@Test
	void testMapWithEmbeddedObject() {
		JsonParsers.forEachParser(jsonParser -> {
			Map<String, Network> networks = jsonParser
				.setClassMetadataName(""class"")
				.parse(""{\""1\"": {\""class\"":\"""" + Network.class.getName() + ""\"", \""name\"": \""Jodd\""} }"");

			assertNotNull(networks);
			assertEquals(1, networks.size());
			assertTrue(networks.containsKey(""1""));
			assertNotNull(networks.get(""1""));
			assertEquals(Network.class, networks.get(""1"").getClass());
			assertEquals(""Jodd"", networks.get(""1"").getName());
		});
	}

	@Test
	void testMapWithEmbeddedObject2() {
		JsonParsers.forEachParser(jsonParser -> {
			Map<String, Pair<Phone, Network>> complex = jsonParser
				.map(""values"", Pair.class)
				.map(""values.first"", Phone.class)
				.map(""values.second"", Network.class)
				.parse(""{\""1\"": { \""first\"": { \""areaCode\"": \""404\"" }, \""second\"": {\""name\"": \""Jodd\""} } }"");
			assertNotNull(complex);
			assertEquals(1, complex.size());
			assertTrue(complex.containsKey(""1""));
			assertNotNull(complex.get(""1""));
			assertEquals(Pair.class, complex.get(""1"").getClass());
			assertEquals(Phone.class, complex.get(""1"").getFirst().getClass());
			assertEquals(Network.class, complex.get(""1"").getSecond().getClass());
			assertEquals(""404"", complex.get(""1"").getFirst().getAreaCode());
			assertEquals(""Jodd"", complex.get(""1"").getSecond().getName());
		});
	}

	@Test
	void testListWithEmbeddedObject() {
		JsonParsers.forEachParser(jsonParser -> {
			List<Network> networks = jsonParser
				.setClassMetadataName(""class"")
				.parse(""["" +
					""	{\""class\"":\"""" + Network.class.getName() + ""\"", \""name\"": \""Jodd\""},"" +
					""	{\""class\"":\"""" + Network.class.getName() + ""\"", \""name\"": \""Mojo\""}"" +
					""]"");

			assertNotNull(networks);
			assertEquals(2, networks.size());
			Network network = networks.get(0);
			assertEquals(""Jodd"", network.getName());
			network = networks.get(1);
			assertEquals(""Mojo"", network.getName());
		});
	}


	@Test
	void testArrayType() {
		JsonParsers.forEachParser(jsonParser -> {
			Person igor = creator.createJodder();
			Person modesty = creator.createModesty();

			Group group = new Group(""brothers"", igor, modesty);
			String json = new JsonSerializer().include(""people"").exclude(""*.class"").serialize(group);
			Group bro = jsonParser.map(Group.class).parse(json);

			assertNotNull(bro);
			assertEquals(""brothers"", bro.getGroupName());
			assertEquals(2, bro.getPeople().length);
			assertEquals(""Igor"", bro.getPeople()[0].getFirstname());
			assertEquals(""Modesty"", bro.getPeople()[1].getFirstname());
		});
	}

	@Test
	void testEmptyArray() {
		JsonParsers.forEachParser(jsonParser -> {
			Group group = jsonParser.parse(""{\""people\"": [], \""groupName\"": \""Nobody\"" }"", Group.class);
			assertEquals(""Nobody"", group.getGroupName());
			assertEquals(0, group.getPeople().length);
		});
	}


	@Test
	void testNullDeserialization() {
		JsonParsers.forEachParser(jsonParser -> {
			String input = ""{\""property\"": null, \""property2\"":5, \""property3\"":\""abc\""}"";

			JsonParser deserializer = jsonParser;
			deserializer.map(null, HashMap.class);
			Map<String, Object> result = deserializer.parse(input);

			assertNotNull(result);
			// fails on this line, because the first property is not deserialized
			assertEquals(3, result.size());
			assertTrue(result.containsKey(""property""));
			assertNull(result.get(""property""), ""the value should be null"");
		});
	}

	@Test
	void testPrimitives() {
		JsonParsers.forEachParser(jsonParser -> {
			List<Date> dates = new ArrayList<>();
			dates.add(new Date());
			dates.add(new Date(1970, 1, 12));
			dates.add(new Date(1986, 3, 21));

			String json = new JsonSerializer().serialize(dates);
			List<Date> jsonDates = jsonParser
				.map(null, ArrayList.class)
				.map(""values"", Date.class)
				.parse(json);

			assertEquals(jsonDates.size(), dates.size());
			assertEquals(Date.class, jsonDates.get(0).getClass());
		});

		JsonParsers.forEachParser(jsonParser -> {
			List<? extends Number> numbers = Arrays.asList(1, 0.5, 100.4f, (short) 5);
			String json = new JsonSerializer().serialize(numbers);
			List<Number> jsonNumbers = jsonParser.parse(json);

			assertEquals(numbers.size(), jsonNumbers.size());
			for (int i = 0; i < numbers.size(); i++) {
				assertEquals(numbers.get(i).floatValue(), jsonNumbers.get(i).floatValue(), DELTA);
			}

			assertEquals(numbers.size(), jsonNumbers.size());
		});

		JsonParsers.forEachParser(jsonParser -> {
			List<Boolean> bools = Arrays.asList(true, false, true, false, false);
			String json = new JsonSerializer().serialize(bools);
			List<Boolean> jsonBools = jsonParser.parse(json);

			assertEquals(bools.size(), jsonBools.size());
			for (int i = 0; i < bools.size(); i++) {
				assertEquals(bools.get(i), jsonBools.get(i));
			}
		});
	}

	@Test
	void testArray() {
		JsonParsers.forEachParser(jsonParser -> {
			Person[] p = new Person[3];
			p[0] = creator.createJodder();
			p[1] = creator.createDilbert();
			p[2] = creator.createModesty();

			String json = new JsonSerializer().serialize(p);

			Person[] jsonP = jsonParser.parse(json, Person[].class);

			assertEquals(3, jsonP.length);
			assertEquals(""Igor"", jsonP[0].getFirstname());
			assertEquals(""Dilbert"", jsonP[1].getFirstname());
			assertEquals(""Modesty"", jsonP[2].getFirstname());
		});
	}

	@Test
	void testArray_boolean() {
		JsonParsers.forEachParser(jsonParser -> {
			final boolean[] input = new boolean[]{true, false, true};
			final boolean[] expected_bools = input;
			final String expected_json = ""[true,false,true]"";

			final String actual_json = new JsonSerializer().serialize(input);
			final boolean[] actual_bools = jsonParser.parse(actual_json, boolean[].class);

			// asserts
			assertNotNull(actual_json);
			assertNotNull(actual_bools);
			assertEquals(expected_json, actual_json);
			assertArrayEquals(expected_bools, actual_bools);
		});
	}

	@Test
	void testDeserializationIntoPublicFields() {
		JsonParser.Defaults.classMetadataName = ""class"";
		JsonSerializer.Defaults.classMetadataName = ""class"";

		JsonParsers.forEachParser(jsonParser -> {
			Spiderman spiderman = new Spiderman();
			spiderman.spideySense = false;
			spiderman.superpower = ""Creates Many Webs and Super Tough"";

			String json = new JsonSerializer().serialize(spiderman);
			Spiderman jsonSpiderman = jsonParser.parse(json);

			assertEquals(spiderman.spideySense, jsonSpiderman.spideySense);
			assertEquals(spiderman.superpower, jsonSpiderman.superpower);
		});
	}

	@Test
	void testAutoTypeConvertToNumerical() {
		JsonParsers.forEachParser(jsonParser -> {
			Account account = jsonParser
				.parse(""{\""id\"": \""5\"", \""accountNumber\"": \""1234567-123\""}"", Account.class);
			assertEquals(new Integer(5), account.getId());

			XRayVision xray = jsonParser.parse(""{ \""power\"": \""2.3\"" }"", XRayVision.class);
			assertEquals(2.3f, xray.getPower(), DELTA);
		});
	}

	@Test
	void testDeserializeURL() {
		JsonParsers.forEachParser(jsonParser -> {
			String json = ""{\n"" +
				""  \""oslc_cm:next\"": \""http:\\/\\/localhost:9080\\/results\\/3\"",\n"" +
				""  \""oslc_cm:previous\"": \""http:\\/\\/localhost:9080\\/results\\/1\"", \n"" +
				""  \""oslc_cm:totalCount\"" : 27,\n"" +
				""  \""oslc_cm:results\"": [\n"" +
				""    {\n"" +
				""      \""rdf:resource\"": \""http:\\/\\/localhost:9080\\/records\\/1234\""\n"" +
				""    },\n"" +
				""    {\n"" +
				""      \""rdf:resource\"": \""http:\\/\\/localhost:9080\\/records\\/1235\""\n"" +
				""    },\n"" +
				""    {\n"" +
				""      \""rdf:resource\"": \""http:\\/\\/localhost:9080\\/records\\/1236\""\n"" +
				""    }   \n"" +
				""  ]\n"" +
				""}"";
			Map<String, Object> page2 = jsonParser.parse(json);
			assertEquals(""http://localhost:9080/results/3"", page2.get(""oslc_cm:next""));
			assertEquals(3, ((List) page2.get(""oslc_cm:results"")).size());
		});
	}

	@Test
	void testPoint() {
		JsonParser.Defaults.classMetadataName = ""__class"";
		JsonSerializer.Defaults.classMetadataName = ""__class"";

		JsonParsers.forEachParser(jsonParser -> {
			String json = new JsonSerializer().serialize(new Point2D.Float(1.0f, 2.0f));
			Point2D.Float point = jsonParser.parse(json);
			assertEquals(1.0f, point.x, DELTA);
			assertEquals(2.0f, point.y, DELTA);
		});
	}

	@Test
	void testUnixEpoch() {
		JsonParsers.forEachParser(jsonParser -> {
			Calendar cal = Calendar.getInstance();
			cal.setTimeZone(TimeZone.getTimeZone(""GMT""));

			cal.set(Calendar.YEAR, 1970);
			cal.set(Calendar.MONTH, 0);
			cal.set(Calendar.DAY_OF_MONTH, 1);
			cal.set(Calendar.AM_PM, Calendar.AM);
			cal.set(Calendar.HOUR, 0);
			cal.set(Calendar.MINUTE, 0);
			cal.set(Calendar.SECOND, 0);
			cal.set(Calendar.MILLISECOND, 0);

			Person hank = new Person(""Hank"", ""Paulsen"", cal.getTime(), null, null);

			String json = new JsonSerializer().serialize(hank);
			Person deHank = jsonParser.parse(json, Person.class);

			assertEquals(hank.getFirstname(), deHank.getFirstname());
			assertEquals(hank.getLastname(), deHank.getLastname());
			assertEquals(hank.getBirthdate(), deHank.getBirthdate());
		});
	}

	public static class SimpleClassnameTransformer implements TypeJsonSerializer {
		@Override
		public boolean serialize(JsonContext jsonContext, Object value) {
			String name = value.toString() + ""***"";
			jsonContext.writeString(name);
			return true;
		}
	}

	private void assertHeroHasSuperPowers(Hero hero) {
		for (int i = 0; i < hero.getPowers().size(); i++) {
			assertTrue(hero.getPowers().get(i) instanceof SuperPower);
		}
	}

}
",0
CVE-2018-21234,jodd-json/src/test/java/jodd/json/JSONDeserializerTest.java,"// Copyright (c) 2003-present, Jodd Team (http://jodd.org)
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

package jodd.json;

import jodd.json.fixtures.JsonParsers;
import jodd.json.fixtures.mock.Employee;
import jodd.json.fixtures.mock.Group;
import jodd.json.fixtures.mock.Network;
import jodd.json.fixtures.mock.Pair;
import jodd.json.fixtures.mock.Person;
import jodd.json.fixtures.mock.Phone;
import jodd.json.fixtures.mock.Spiderman;
import jodd.json.fixtures.mock.superhero.Hero;
import jodd.json.fixtures.mock.superhero.SecretIdentity;
import jodd.json.fixtures.mock.superhero.SecretLair;
import jodd.json.fixtures.mock.superhero.SuperPower;
import jodd.json.fixtures.mock.superhero.Villian;
import jodd.json.fixtures.mock.superhero.XRayVision;
import jodd.json.fixtures.model.Account;
import jodd.json.impl.DateJsonSerializer;
import jodd.util.StringUtil;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.awt.geom.Point2D;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

class JSONDeserializerTest {

	private static final double DELTA = 0.000000001;

	private DataCreator creator;

	@BeforeEach
	void setUp() {
		creator = new DataCreator();
	}

	@AfterEach
	void tearDown() {
		JsonParser.Defaults.classMetadataName = null;
		JsonSerializer.Defaults.classMetadataName = null;
	}

	@Test
	void testDeserializeNoIncludes() {
		JsonParsers.forEachParser(jsonParser -> {
			Person jodder = creator.createJodder();
			String json = new JsonSerializer().serialize(jodder);
			Person jsonJodder = jsonParser.parse(json, Person.class);

			assertNotNull(jsonJodder);

			assertEquals(jodder.getLastname(), jsonJodder.getLastname());
			assertEquals(jodder.getFirstname(), jsonJodder.getFirstname());
			assertEquals(jodder.getBirthdate(), jsonJodder.getBirthdate());

			assertEquals(jodder.getHome().getState(), jsonJodder.getHome().getState());
			assertEquals(jodder.getHome().getStreet(), jsonJodder.getHome().getStreet());
			assertEquals(jodder.getHome().getCity(), jsonJodder.getHome().getCity());

			assertEquals(jodder.getWork().getCity(), jsonJodder.getWork().getCity());

			assertEquals(jsonJodder, jsonJodder.getWork().getPerson());

			assertEquals(0, jsonJodder.getHobbies().size());
		});
	}

	@Test
	void testDeserializeWithPath() {
		JsonParsers.forEachParser(jsonParser -> {

			Person igor = creator.createJodder();
			Map map = new HashMap();
			map.put(""person"", igor);

			String json = new JsonSerializer().serialize(map);

			map = jsonParser.map(""values"", Person.class).parse(json);
			Person jsonIgor = (Person) map.get(""person"");

			assertNotNull(jsonIgor);

			assertEquals(igor.getLastname(), jsonIgor.getLastname());
			assertEquals(igor.getFirstname(), jsonIgor.getFirstname());
			assertEquals(igor.getBirthdate(), jsonIgor.getBirthdate());

			assertEquals(igor.getHome().getState(), jsonIgor.getHome().getState());
			assertEquals(igor.getHome().getStreet(), jsonIgor.getHome().getStreet());
			assertEquals(igor.getHome().getCity(), jsonIgor.getHome().getCity());

			assertEquals(igor.getWork().getCity(), jsonIgor.getWork().getCity());

			assertEquals(jsonIgor, jsonIgor.getWork().getPerson());
		});
	}

	@Test
	void testDeserializeWithIncludes() {
		JsonParsers.forEachParser(jsonParser -> {

			Person igor = creator.createJodder();
			String json = new JsonSerializer().include(""phones"", ""hobbies"").serialize(igor);
			Person jsonIgor = jsonParser.parse(json, Person.class);

			assertEquals(2, jsonIgor.getPhones().size());
			assertEquals(0, jsonIgor.getHobbies().size());
		});
	}

	@Test
	void testSubClassDeserialize() {
		JsonParsers.forEachParser(jsonParser -> {

			Employee dilbert = creator.createDilbert();

			String json = new JsonSerializer().include(""phones"", ""hobbies"").serialize(dilbert);
			Person jsonDilbert = jsonParser.parse(json, Employee.class);

			assertNotNull(jsonDilbert);
			assertTrue(jsonDilbert instanceof Employee);
			assertEquals(dilbert.getCompany(), ((Employee) jsonDilbert).getCompany());
		});
	}

	@Test
	void testDeserializeInterfaces() {
		JsonParsers.forEachParser(jsonParser -> {

			Hero superman = creator.createSuperman();
			String json = new JsonSerializer().include(""powers"").setClassMetadataName(""class"").serialize(superman);
			Hero jsonSuperMan = jsonParser.setClassMetadataName(""class"").parse(json, Hero.class);

			assertNotNull(jsonSuperMan);
			assertEquals(4, jsonSuperMan.getPowers().size());
			assertHeroHasSuperPowers(jsonSuperMan);
		});
	}

	@Test
	void testDeserializeInterfaces2() {
		JsonParsers.forEachParser(jsonParser -> {

			Hero superman = creator.createSuperman();
			String json = new JsonSerializer().include(""powers"").withClassMetadata(true).serialize(superman);
			Hero jsonSuperMan = jsonParser.withClassMetadata(true).parse(json, Hero.class);

			assertNotNull(jsonSuperMan);
			assertEquals(4, jsonSuperMan.getPowers().size());
			assertHeroHasSuperPowers(jsonSuperMan);
		});
	}

	@Test
	void testNoClassHints() {
		JsonParsers.forEachParser(jsonParser -> {
			Hero superman = creator.createSuperman();
			String json = new JsonSerializer().exclude(""*.class"").serialize(superman);

			Hero jsonSuperMan = jsonParser
				.map(Hero.class)
				.map(""lair"", SecretLair.class)
				.map(""secretIdentity"", SecretIdentity.class)
				.parse(json);

			assertNotNull(jsonSuperMan);
			assertEquals(""Super Man"", jsonSuperMan.getName());
			assertNotNull(jsonSuperMan.getIdentity());
			assertEquals(""Clark Kent"", jsonSuperMan.getIdentity().getName());
			assertNotNull(jsonSuperMan.getLair());
			assertEquals(""Fortress of Solitude"", jsonSuperMan.getLair().getName());
		});
	}

	@Test
	void testNoHintsButClassesForCollection() {
		JsonParser.Defaults.classMetadataName = ""class"";
		JsonSerializer.Defaults.classMetadataName = ""class"";

		JsonParsers.forEachParser(jsonParser -> {

			Hero superman = creator.createSuperman();
			String json = new JsonSerializer()
				.exclude(""*.class"")
				.include(""powers.class"")
				.serialize(superman);
			Hero jsonSuperMan = jsonParser.parse(json, Hero.class);
			assertHeroHasSuperPowers(jsonSuperMan);
		});
	}

	@Test
	void testNoClassHintsForCollections() {
		JsonParser.Defaults.classMetadataName = ""class"";
		JsonSerializer.Defaults.classMetadataName = ""class"";

		JsonParsers.forEachParser(jsonParser -> {

			Hero superman = creator.createSuperman();
			String json = new JsonSerializer()
				.include(""powers"")        // redudant
				.include(""powers.class"")
				.withSerializer(""powers.class"", new SimpleClassnameTransformer())
				.exclude(""*.class"")
				.serialize(superman);

			int count = StringUtil.count(json, ""***"");
			assertEquals(4, count);

			json = StringUtil.remove(json, ""***"");

			Hero jsonSuperMan = jsonParser
				.map(""lair"", SecretLair.class)
				.map(""secretIdentity"", SecretIdentity.class)
				.parse(json, Hero.class);

			assertEquals(""Fortress of Solitude"", jsonSuperMan.getLair().getName());
			assertHeroHasSuperPowers(jsonSuperMan);
		});
	}

	@Test
	void testListSerialization() {
		JsonParser.Defaults.classMetadataName = ""class"";
		JsonSerializer.Defaults.classMetadataName = ""class"";

		Person modesty = creator.createModesty();
		Person igor = creator.createJodder();
		Person pedro = creator.createPedro();
		List<Person> list = new ArrayList<>(3);
		list.add(modesty);
		list.add(igor);
		list.add(pedro);

		JsonParsers.forEachParser(jsonParser -> {
			String json = new JsonSerializer().serialize(list);

			List<Person> people = jsonParser.parse(json);
			assertTrue(people instanceof List);

			json = new JsonSerializer().exclude(""*.class"").serialize(list);
			people = jsonParser.map(""values"", Person.class).parse(json);

			assertEquals(3, people.size());
			assertEquals(Person.class, people.get(0).getClass());
		});

		JsonParsers.forEachParser(jsonParser -> {
			String json = new JsonSerializer().exclude(""*.class"").serialize(list);

			List<Map> peopleMap = jsonParser.parse(json);

			assertEquals(3, peopleMap.size());
			assertTrue(peopleMap.get(0) instanceof Map);
		});
	}

	@Test
	void testGenericTypeDeserialization() {
		JsonParser.Defaults.classMetadataName = ""class"";
		JsonSerializer.Defaults.classMetadataName = ""class"";

		JsonParsers.forEachParser(jsonParser -> {

			Pair<Hero, Villian> archenemies = new Pair<>(creator.createSuperman(), creator.createLexLuthor());

			String json = new JsonSerializer()
				.exclude(""*.class"")
				.serialize(archenemies);

			Pair<Hero, Villian> deserialArchEnemies = jsonParser
				.map(""first"", Hero.class)
				.map(""second"", Villian.class)
				.parse(json, Pair.class);

			assertEquals(archenemies.getFirst().getClass(), deserialArchEnemies.getFirst().getClass());
			assertEquals(archenemies.getSecond().getClass(), deserialArchEnemies.getSecond().getClass());

			assertEquals(archenemies.getFirst().getIdentity(), deserialArchEnemies.getFirst().getIdentity());
			assertEquals(archenemies.getFirst().getLair(), deserialArchEnemies.getFirst().getLair());
			assertEquals(archenemies.getFirst().getName(), deserialArchEnemies.getFirst().getName());

			assertEquals(archenemies.getSecond().getName(), deserialArchEnemies.getSecond().getName());
			assertEquals(archenemies.getSecond().getLair(), deserialArchEnemies.getSecond().getLair());
		});
	}

	@Test
	void testGenericTypeDeserialization2() {
		JsonParsers.forEachParser(jsonParser -> {
			Pair<Hero, Villian> archenemies = new Pair<>(creator.createSuperman(), creator.createLexLuthor());

			String json = new JsonSerializer()
				.serialize(archenemies);

			Pair<Hero, Villian> deserialArchEnemies = jsonParser
				.map(""first"", Hero.class)
				.map(""second"", Villian.class)
				.parse(json, Pair.class);

			assertEquals(archenemies.getFirst().getClass(), deserialArchEnemies.getFirst().getClass());
			assertEquals(archenemies.getSecond().getClass(), deserialArchEnemies.getSecond().getClass());

			assertEquals(archenemies.getFirst().getIdentity(), deserialArchEnemies.getFirst().getIdentity());
			assertEquals(archenemies.getFirst().getLair(), deserialArchEnemies.getFirst().getLair());
			assertEquals(archenemies.getFirst().getName(), deserialArchEnemies.getFirst().getName());

			assertEquals(archenemies.getSecond().getName(), deserialArchEnemies.getSecond().getName());
			assertEquals(archenemies.getSecond().getLair(), deserialArchEnemies.getSecond().getLair());
		});
	}

	@Test
	void testGeneralMapDeserialization() {
		JsonParser.Defaults.classMetadataName = ""class"";
		JsonSerializer.Defaults.classMetadataName = ""class"";

		JsonParsers.forEachParser(jsonParser -> {

			String json = new JsonSerializer().exclude(""*.class"").serialize(creator.createJodder());
			Map<String, Object> deserialized = jsonParser.parse(json);

			assertEquals(""Igor"", deserialized.get(""firstname""));
			assertEquals(""Spasic"", deserialized.get(""lastname""));
			assertTrue(Map.class.isAssignableFrom(deserialized.get(""work"").getClass()));
			assertTrue(Map.class.isAssignableFrom(deserialized.get(""home"").getClass()));
		});
	}

	@Test
	void testGeneralMapDeserialization2() {
		JsonParsers.forEachParser(jsonParser -> {
			String json = new JsonSerializer().serialize(creator.createJodder());
			Map<String, Object> deserialized = jsonParser.parse(json);

			assertEquals(""Igor"", deserialized.get(""firstname""));
			assertEquals(""Spasic"", deserialized.get(""lastname""));
			assertTrue(Map.class.isAssignableFrom(deserialized.get(""work"").getClass()));
			assertTrue(Map.class.isAssignableFrom(deserialized.get(""home"").getClass()));
		});
	}

	@Test
	void testListDeserializationNoClass() {
		JsonParser.Defaults.classMetadataName = ""class"";
		JsonSerializer.Defaults.classMetadataName = ""class"";

		JsonParsers.forEachParser(jsonParser -> {

			Person modesty = creator.createModesty();
			Person igor = creator.createJodder();
			Person pedro = creator.createPedro();
			List<Person> list = new ArrayList<>(3);
			list.add(modesty);
			list.add(igor);
			list.add(pedro);

			String json = new JsonSerializer().exclude(""*.class"").serialize(list);
			List<Person> people = jsonParser.map(""values"", Person.class).parse(json);
			assertEquals(3, list.size());
			assertEquals(modesty.getFirstname(), list.get(0).getFirstname());
			assertEquals(igor.getFirstname(), list.get(1).getFirstname());
			assertEquals(pedro.getFirstname(), list.get(2).getFirstname());
		});
	}

	@Test
	void testListDeserializationNoClass2() {
		JsonParsers.forEachParser(jsonParser -> {
			Person modesty = creator.createModesty();
			Person igor = creator.createJodder();
			Person pedro = creator.createPedro();
			List<Person> list = new ArrayList<>(3);
			list.add(modesty);
			list.add(igor);
			list.add(pedro);

			String json = new JsonSerializer().serialize(list);
			List<Person> people = jsonParser.map(""values"", Person.class).parse(json);
			assertEquals(3, list.size());
			assertEquals(modesty.getFirstname(), list.get(0).getFirstname());
			assertEquals(igor.getFirstname(), list.get(1).getFirstname());
			assertEquals(pedro.getFirstname(), list.get(2).getFirstname());
		});
	}

	@Test
	void testDateTransforming() {
		JsonParsers.forEachParser(jsonParser -> {
			final SimpleDateFormat df = new SimpleDateFormat(""yyyy/MM/dd"");
			Person foo = new Person(""Foo"", ""Bar"", new Date(), null, null);
			try {
				foo.setBirthdate(df.parse(""2009/01/02""));
			} catch (ParseException pe) {
				fail(pe);
			}


			String json = new JsonSerializer().withSerializer(""birthdate"", new DateJsonSerializer() {
				@Override
				public boolean serialize(JsonContext jsonContext, Date date) {
					jsonContext.writeString(df.format(date));
					return true;
				}
			}).serialize(foo);

			Person newUser = jsonParser
				.withValueConverter(""birthdate"", (ValueConverter<String, Date>) data -> {
					try {
						return df.parse(data);
					} catch (ParseException pe) {
						throw new JsonException(pe);
					}
				})
				.parse(json, Person.class);

			assertEquals(foo.getBirthdate(), newUser.getBirthdate());
			assertEquals(""2009/01/02"", df.format(newUser.getBirthdate()));
		});
	}

	@Test
	void testMapWithEmbeddedObject() {
		JsonParsers.forEachParser(jsonParser -> {
			Map<String, Network> networks = jsonParser
				.setClassMetadataName(""class"")
				.parse(""{\""1\"": {\""class\"":\"""" + Network.class.getName() + ""\"", \""name\"": \""Jodd\""} }"");

			assertNotNull(networks);
			assertEquals(1, networks.size());
			assertTrue(networks.containsKey(""1""));
			assertNotNull(networks.get(""1""));
			assertEquals(Network.class, networks.get(""1"").getClass());
			assertEquals(""Jodd"", networks.get(""1"").getName());
		});
	}

	@Test
	void testMapWithEmbeddedObject2() {
		JsonParsers.forEachParser(jsonParser -> {
			Map<String, Pair<Phone, Network>> complex = jsonParser
				.map(""values"", Pair.class)
				.map(""values.first"", Phone.class)
				.map(""values.second"", Network.class)
				.parse(""{\""1\"": { \""first\"": { \""areaCode\"": \""404\"" }, \""second\"": {\""name\"": \""Jodd\""} } }"");
			assertNotNull(complex);
			assertEquals(1, complex.size());
			assertTrue(complex.containsKey(""1""));
			assertNotNull(complex.get(""1""));
			assertEquals(Pair.class, complex.get(""1"").getClass());
			assertEquals(Phone.class, complex.get(""1"").getFirst().getClass());
			assertEquals(Network.class, complex.get(""1"").getSecond().getClass());
			assertEquals(""404"", complex.get(""1"").getFirst().getAreaCode());
			assertEquals(""Jodd"", complex.get(""1"").getSecond().getName());
		});
	}

	@Test
	void testListWithEmbeddedObject() {
		JsonParsers.forEachParser(jsonParser -> {
			List<Network> networks = jsonParser
				.setClassMetadataName(""class"")
				.parse(""["" +
					""	{\""class\"":\"""" + Network.class.getName() + ""\"", \""name\"": \""Jodd\""},"" +
					""	{\""class\"":\"""" + Network.class.getName() + ""\"", \""name\"": \""Mojo\""}"" +
					""]"");

			assertNotNull(networks);
			assertEquals(2, networks.size());
			Network network = networks.get(0);
			assertEquals(""Jodd"", network.getName());
			network = networks.get(1);
			assertEquals(""Mojo"", network.getName());
		});
	}


	@Test
	void testArrayType() {
		JsonParsers.forEachParser(jsonParser -> {
			Person igor = creator.createJodder();
			Person modesty = creator.createModesty();

			Group group = new Group(""brothers"", igor, modesty);
			String json = new JsonSerializer().include(""people"").exclude(""*.class"").serialize(group);
			Group bro = jsonParser.map(Group.class).parse(json);

			assertNotNull(bro);
			assertEquals(""brothers"", bro.getGroupName());
			assertEquals(2, bro.getPeople().length);
			assertEquals(""Igor"", bro.getPeople()[0].getFirstname());
			assertEquals(""Modesty"", bro.getPeople()[1].getFirstname());
		});
	}

	@Test
	void testEmptyArray() {
		JsonParsers.forEachParser(jsonParser -> {
			Group group = jsonParser.parse(""{\""people\"": [], \""groupName\"": \""Nobody\"" }"", Group.class);
			assertEquals(""Nobody"", group.getGroupName());
			assertEquals(0, group.getPeople().length);
		});
	}


	@Test
	void testNullDeserialization() {
		JsonParsers.forEachParser(jsonParser -> {
			String input = ""{\""property\"": null, \""property2\"":5, \""property3\"":\""abc\""}"";

			JsonParser deserializer = jsonParser;
			deserializer.map(null, HashMap.class);
			Map<String, Object> result = deserializer.parse(input);

			assertNotNull(result);
			// fails on this line, because the first property is not deserialized
			assertEquals(3, result.size());
			assertTrue(result.containsKey(""property""));
			assertNull(result.get(""property""), ""the value should be null"");
		});
	}

	@Test
	void testPrimitives() {
		JsonParsers.forEachParser(jsonParser -> {
			List<Date> dates = new ArrayList<>();
			dates.add(new Date());
			dates.add(new Date(1970, 1, 12));
			dates.add(new Date(1986, 3, 21));

			String json = new JsonSerializer().serialize(dates);
			List<Date> jsonDates = jsonParser
				.map(null, ArrayList.class)
				.map(""values"", Date.class)
				.parse(json);

			assertEquals(jsonDates.size(), dates.size());
			assertEquals(Date.class, jsonDates.get(0).getClass());
		});

		JsonParsers.forEachParser(jsonParser -> {
			List<? extends Number> numbers = Arrays.asList(1, 0.5, 100.4f, (short) 5);
			String json = new JsonSerializer().serialize(numbers);
			List<Number> jsonNumbers = jsonParser.parse(json);

			assertEquals(numbers.size(), jsonNumbers.size());
			for (int i = 0; i < numbers.size(); i++) {
				assertEquals(numbers.get(i).floatValue(), jsonNumbers.get(i).floatValue(), DELTA);
			}

			assertEquals(numbers.size(), jsonNumbers.size());
		});

		JsonParsers.forEachParser(jsonParser -> {
			List<Boolean> bools = Arrays.asList(true, false, true, false, false);
			String json = new JsonSerializer().serialize(bools);
			List<Boolean> jsonBools = jsonParser.parse(json);

			assertEquals(bools.size(), jsonBools.size());
			for (int i = 0; i < bools.size(); i++) {
				assertEquals(bools.get(i), jsonBools.get(i));
			}
		});
	}

	@Test
	void testArray() {
		JsonParsers.forEachParser(jsonParser -> {
			Person[] p = new Person[3];
			p[0] = creator.createJodder();
			p[1] = creator.createDilbert();
			p[2] = creator.createModesty();

			String json = new JsonSerializer().serialize(p);

			Person[] jsonP = jsonParser.parse(json, Person[].class);

			assertEquals(3, jsonP.length);
			assertEquals(""Igor"", jsonP[0].getFirstname());
			assertEquals(""Dilbert"", jsonP[1].getFirstname());
			assertEquals(""Modesty"", jsonP[2].getFirstname());
		});
	}

	@Test
	void testArray_boolean() {
		JsonParsers.forEachParser(jsonParser -> {
			final boolean[] input = new boolean[]{true, false, true};
			final boolean[] expected_bools = input;
			final String expected_json = ""[true,false,true]"";

			final String actual_json = new JsonSerializer().serialize(input);
			final boolean[] actual_bools = jsonParser.parse(actual_json, boolean[].class);

			// asserts
			assertNotNull(actual_json);
			assertNotNull(actual_bools);
			assertEquals(expected_json, actual_json);
			assertArrayEquals(expected_bools, actual_bools);
		});
	}

	@Test
	void testDeserializationIntoPublicFields() {
		JsonParser.Defaults.classMetadataName = ""class"";
		JsonSerializer.Defaults.classMetadataName = ""class"";

		JsonParsers.forEachParser(jsonParser -> {
			Spiderman spiderman = new Spiderman();
			spiderman.spideySense = false;
			spiderman.superpower = ""Creates Many Webs and Super Tough"";

			String json = new JsonSerializer().serialize(spiderman);
			Spiderman jsonSpiderman = jsonParser.parse(json);

			assertEquals(spiderman.spideySense, jsonSpiderman.spideySense);
			assertEquals(spiderman.superpower, jsonSpiderman.superpower);
		});
	}

	@Test
	void testAutoTypeConvertToNumerical() {
		JsonParsers.forEachParser(jsonParser -> {
			Account account = jsonParser
				.parse(""{\""id\"": \""5\"", \""accountNumber\"": \""1234567-123\""}"", Account.class);
			assertEquals(new Integer(5), account.getId());

			XRayVision xray = jsonParser.parse(""{ \""power\"": \""2.3\"" }"", XRayVision.class);
			assertEquals(2.3f, xray.getPower(), DELTA);
		});
	}

	@Test
	void testDeserializeURL() {
		JsonParsers.forEachParser(jsonParser -> {
			String json = ""{\n"" +
				""  \""oslc_cm:next\"": \""http:\\/\\/localhost:9080\\/results\\/3\"",\n"" +
				""  \""oslc_cm:previous\"": \""http:\\/\\/localhost:9080\\/results\\/1\"", \n"" +
				""  \""oslc_cm:totalCount\"" : 27,\n"" +
				""  \""oslc_cm:results\"": [\n"" +
				""    {\n"" +
				""      \""rdf:resource\"": \""http:\\/\\/localhost:9080\\/records\\/1234\""\n"" +
				""    },\n"" +
				""    {\n"" +
				""      \""rdf:resource\"": \""http:\\/\\/localhost:9080\\/records\\/1235\""\n"" +
				""    },\n"" +
				""    {\n"" +
				""      \""rdf:resource\"": \""http:\\/\\/localhost:9080\\/records\\/1236\""\n"" +
				""    }   \n"" +
				""  ]\n"" +
				""}"";
			Map<String, Object> page2 = jsonParser.parse(json);
			assertEquals(""http://localhost:9080/results/3"", page2.get(""oslc_cm:next""));
			assertEquals(3, ((List) page2.get(""oslc_cm:results"")).size());
		});
	}

	@Test
	void testPoint() {
		JsonParser.Defaults.classMetadataName = ""__class"";
		JsonSerializer.Defaults.classMetadataName = ""__class"";

		JsonParsers.forEachParser(jsonParser -> {
			String json = new JsonSerializer().serialize(new Point2D.Float(1.0f, 2.0f));
			Point2D.Float point = jsonParser.parse(json);
			assertEquals(1.0f, point.x, DELTA);
			assertEquals(2.0f, point.y, DELTA);
		});
	}

	@Test
	void testPointWithException() {
		JsonParser.Defaults.classMetadataName = ""__class"";
		JsonSerializer.Defaults.classMetadataName = ""__class"";

		JsonParsers.forEachParser(jsonParser -> {
			jsonParser.allowClass(""notAllowed"");
			final String json = new JsonSerializer().serialize(new Point2D.Float(1.0f, 2.0f));
			assertThrows(JsonException.class, () -> {
				jsonParser.parse(json);
			});
			jsonParser.allowAllClasses();
		});
	}

	@Test
	void testPointWithoutExceptionWhitelisted() {
		JsonParser.Defaults.classMetadataName = ""__class"";
		JsonSerializer.Defaults.classMetadataName = ""__class"";

		JsonParsers.forEachParser(jsonParser -> {
			jsonParser.allowClass(""*.Point?D*"");
			String json = new JsonSerializer().serialize(new Point2D.Float(1.0f, 2.0f));
			Point2D.Float point = jsonParser.parse(json);
			assertEquals(1.0f, point.x, DELTA);
			assertEquals(2.0f, point.y, DELTA);
			jsonParser.allowAllClasses();
		});
	}


	@Test
	void testUnixEpoch() {
		JsonParsers.forEachParser(jsonParser -> {
			Calendar cal = Calendar.getInstance();
			cal.setTimeZone(TimeZone.getTimeZone(""GMT""));

			cal.set(Calendar.YEAR, 1970);
			cal.set(Calendar.MONTH, 0);
			cal.set(Calendar.DAY_OF_MONTH, 1);
			cal.set(Calendar.AM_PM, Calendar.AM);
			cal.set(Calendar.HOUR, 0);
			cal.set(Calendar.MINUTE, 0);
			cal.set(Calendar.SECOND, 0);
			cal.set(Calendar.MILLISECOND, 0);

			Person hank = new Person(""Hank"", ""Paulsen"", cal.getTime(), null, null);

			String json = new JsonSerializer().serialize(hank);
			Person deHank = jsonParser.parse(json, Person.class);

			assertEquals(hank.getFirstname(), deHank.getFirstname());
			assertEquals(hank.getLastname(), deHank.getLastname());
			assertEquals(hank.getBirthdate(), deHank.getBirthdate());
		});
	}

	public static class SimpleClassnameTransformer implements TypeJsonSerializer {
		@Override
		public boolean serialize(JsonContext jsonContext, Object value) {
			String name = value.toString() + ""***"";
			jsonContext.writeString(name);
			return true;
		}
	}

	private void assertHeroHasSuperPowers(Hero hero) {
		for (int i = 0; i < hero.getPowers().size(); i++) {
			assertTrue(hero.getPowers().get(i) instanceof SuperPower);
		}
	}

}
",1
CVE-2019-3558,thrift/lib/cpp/protocol/TProtocolException.cpp,"/*
 * Copyright 2004-present Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <thrift/lib/cpp/protocol/TProtocolException.h>

#include <folly/Format.h>

namespace apache { namespace thrift { namespace protocol {

[[noreturn]] void TProtocolException::throwUnionMissingStop() {
  throw TProtocolException(
      TProtocolException::INVALID_DATA,
      ""missing stop marker to terminate a union"");
}

[[noreturn]] void TProtocolException::throwReportedTypeMismatch() {
  throw TProtocolException(
      TProtocolException::INVALID_DATA,
      ""The reported type of thrift element does not match the serialized type"");
}

[[noreturn]] void TProtocolException::throwNegativeSize() {
  throw TProtocolException(TProtocolException::NEGATIVE_SIZE);
}

[[noreturn]] void TProtocolException::throwExceededSizeLimit() {
  throw TProtocolException(TProtocolException::SIZE_LIMIT);
}

[[noreturn]] void TProtocolException::throwMissingRequiredField(
    folly::StringPiece field,
    folly::StringPiece type) {
  constexpr auto fmt =
      ""Required field '{}' was not found in serialized data! Struct: {}"";
  throw TProtocolException(
      TProtocolException::MISSING_REQUIRED_FIELD,
      folly::sformat(fmt, field, type));
}

[[noreturn]] void TProtocolException::throwBoolValueOutOfRange(uint8_t value) {
  throw TProtocolException(
      TProtocolException::INVALID_DATA,
      folly::sformat(
          ""Attempt to interpret value {} as bool, probably the data is corrupted"",
          value));
}
}}}
",0
CVE-2019-3558,thrift/lib/cpp/protocol/TProtocolException.cpp,"/*
 * Copyright 2004-present Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <thrift/lib/cpp/protocol/TProtocolException.h>

#include <folly/Format.h>

namespace apache { namespace thrift { namespace protocol {

[[noreturn]] void TProtocolException::throwUnionMissingStop() {
  throw TProtocolException(
      TProtocolException::INVALID_DATA,
      ""missing stop marker to terminate a union"");
}

[[noreturn]] void TProtocolException::throwReportedTypeMismatch() {
  throw TProtocolException(
      TProtocolException::INVALID_DATA,
      ""The reported type of thrift element does not match the serialized type"");
}

[[noreturn]] void TProtocolException::throwNegativeSize() {
  throw TProtocolException(TProtocolException::NEGATIVE_SIZE);
}

[[noreturn]] void TProtocolException::throwExceededSizeLimit() {
  throw TProtocolException(TProtocolException::SIZE_LIMIT);
}

[[noreturn]] void TProtocolException::throwMissingRequiredField(
    folly::StringPiece field,
    folly::StringPiece type) {
  constexpr auto fmt =
      ""Required field '{}' was not found in serialized data! Struct: {}"";
  throw TProtocolException(
      TProtocolException::MISSING_REQUIRED_FIELD,
      folly::sformat(fmt, field, type));
}

[[noreturn]] void TProtocolException::throwBoolValueOutOfRange(uint8_t value) {
  throw TProtocolException(
      TProtocolException::INVALID_DATA,
      folly::sformat(
          ""Attempt to interpret value {} as bool, probably the data is corrupted"",
          value));
}

[[noreturn]] void TProtocolException::throwInvalidSkipType(TType type) {
  throw TProtocolException(
      TProtocolException::INVALID_DATA,
      folly::sformat(
          ""Encountered invalid field/element type ({}) during skipping"",
          static_cast<uint8_t>(type)));
}
}}}
",1
CVE-2019-3558,thrift/lib/cpp/protocol/TProtocolException.h,"/*
 * Copyright 2004-present Facebook, Inc.
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#ifndef _THRIFT_PROTOCOL_TPROTOCOLEXCEPTION_H_
#define _THRIFT_PROTOCOL_TPROTOCOLEXCEPTION_H_ 1

#include <thrift/lib/cpp/Thrift.h>

#include <string>

namespace apache { namespace thrift { namespace protocol {

/**
 * Class to encapsulate all the possible types of protocol errors that may
 * occur in various protocol systems. This provides a sort of generic
 * wrapper around the shitty UNIX E_ error codes that lets a common code
 * base of error handling to be used for various types of protocols, i.e.
 * pipes etc.
 *
 */
class TProtocolException : public apache::thrift::TLibraryException {
 public:

  /**
   * Error codes for the various types of exceptions.
   */
  enum TProtocolExceptionType
  { UNKNOWN = 0
  , INVALID_DATA = 1
  , NEGATIVE_SIZE = 2
  , SIZE_LIMIT = 3
  , BAD_VERSION = 4
  , NOT_IMPLEMENTED = 5
  , MISSING_REQUIRED_FIELD = 6
  };

  TProtocolException() :
    apache::thrift::TLibraryException(),
    type_(UNKNOWN) {}

  explicit TProtocolException(TProtocolExceptionType type) :
    apache::thrift::TLibraryException(),
    type_(type) {}

  explicit TProtocolException(const std::string& message) :
    apache::thrift::TLibraryException(message),
    type_(UNKNOWN) {}

  TProtocolException(TProtocolExceptionType type, const std::string& message) :
    apache::thrift::TLibraryException(message),
    type_(type) {}

  ~TProtocolException() throw() override {}

  /**
   * Returns an error code that provides information about the type of error
   * that has occurred.
   *
   * @return Error code
   */
  TProtocolExceptionType getType() const {
    return type_;
  }

  const char* what() const throw() override {
    if (message_.empty()) {
      switch (type_) {
        case UNKNOWN         : return ""TProtocolException: Unknown protocol exception"";
        case INVALID_DATA    : return ""TProtocolException: Invalid data"";
        case NEGATIVE_SIZE   : return ""TProtocolException: Negative size"";
        case SIZE_LIMIT      : return ""TProtocolException: Exceeded size limit"";
        case BAD_VERSION     : return ""TProtocolException: Invalid version"";
        case NOT_IMPLEMENTED : return ""TProtocolException: Not implemented"";
        case MISSING_REQUIRED_FIELD :
          return ""TProtocolException: Missing required field"";
        default              : return ""TProtocolException: (Invalid exception type)"";
      }
    } else {
      return message_.c_str();
    }
  }

  [[noreturn]] static void throwUnionMissingStop();
  [[noreturn]] static void throwReportedTypeMismatch();
  [[noreturn]] static void throwNegativeSize();
  [[noreturn]] static void throwExceededSizeLimit();
  [[noreturn]] static void throwMissingRequiredField(
      folly::StringPiece field,
      folly::StringPiece type);
  [[noreturn]] static void throwBoolValueOutOfRange(uint8_t value);

 protected:
  /**
   * Error code
   */
  TProtocolExceptionType type_;

};

}}} // apache::thrift::protocol

#endif // #ifndef _THRIFT_PROTOCOL_TPROTOCOLEXCEPTION_H_
",0
CVE-2019-3558,thrift/lib/cpp/protocol/TProtocolException.h,"/*
 * Copyright 2004-present Facebook, Inc.
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#ifndef _THRIFT_PROTOCOL_TPROTOCOLEXCEPTION_H_
#define _THRIFT_PROTOCOL_TPROTOCOLEXCEPTION_H_ 1

#include <thrift/lib/cpp/Thrift.h>
#include <thrift/lib/cpp/protocol/TType.h>

#include <string>

namespace apache { namespace thrift { namespace protocol {

/**
 * Class to encapsulate all the possible types of protocol errors that may
 * occur in various protocol systems. This provides a sort of generic
 * wrapper around the shitty UNIX E_ error codes that lets a common code
 * base of error handling to be used for various types of protocols, i.e.
 * pipes etc.
 *
 */
class TProtocolException : public apache::thrift::TLibraryException {
 public:

  /**
   * Error codes for the various types of exceptions.
   */
  enum TProtocolExceptionType
  { UNKNOWN = 0
  , INVALID_DATA = 1
  , NEGATIVE_SIZE = 2
  , SIZE_LIMIT = 3
  , BAD_VERSION = 4
  , NOT_IMPLEMENTED = 5
  , MISSING_REQUIRED_FIELD = 6
  };

  TProtocolException() :
    apache::thrift::TLibraryException(),
    type_(UNKNOWN) {}

  explicit TProtocolException(TProtocolExceptionType type) :
    apache::thrift::TLibraryException(),
    type_(type) {}

  explicit TProtocolException(const std::string& message) :
    apache::thrift::TLibraryException(message),
    type_(UNKNOWN) {}

  TProtocolException(TProtocolExceptionType type, const std::string& message) :
    apache::thrift::TLibraryException(message),
    type_(type) {}

  ~TProtocolException() throw() override {}

  /**
   * Returns an error code that provides information about the type of error
   * that has occurred.
   *
   * @return Error code
   */
  TProtocolExceptionType getType() const {
    return type_;
  }

  const char* what() const throw() override {
    if (message_.empty()) {
      switch (type_) {
        case UNKNOWN         : return ""TProtocolException: Unknown protocol exception"";
        case INVALID_DATA    : return ""TProtocolException: Invalid data"";
        case NEGATIVE_SIZE   : return ""TProtocolException: Negative size"";
        case SIZE_LIMIT      : return ""TProtocolException: Exceeded size limit"";
        case BAD_VERSION     : return ""TProtocolException: Invalid version"";
        case NOT_IMPLEMENTED : return ""TProtocolException: Not implemented"";
        case MISSING_REQUIRED_FIELD :
          return ""TProtocolException: Missing required field"";
        default              : return ""TProtocolException: (Invalid exception type)"";
      }
    } else {
      return message_.c_str();
    }
  }

  [[noreturn]] static void throwUnionMissingStop();
  [[noreturn]] static void throwReportedTypeMismatch();
  [[noreturn]] static void throwNegativeSize();
  [[noreturn]] static void throwExceededSizeLimit();
  [[noreturn]] static void throwMissingRequiredField(
      folly::StringPiece field,
      folly::StringPiece type);
  [[noreturn]] static void throwBoolValueOutOfRange(uint8_t value);
  [[noreturn]] static void throwInvalidSkipType(TType type);

 protected:
  /**
   * Error code
   */
  TProtocolExceptionType type_;

};

}}} // apache::thrift::protocol

#endif // #ifndef _THRIFT_PROTOCOL_TPROTOCOLEXCEPTION_H_
",1
CVE-2019-3558,thrift/lib/cpp2/protocol/Protocol.h,"/*
 * Copyright 2011-present Facebook, Inc.
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#ifndef CPP2_PROTOCOL_PROTOCOL_H_
#define CPP2_PROTOCOL_PROTOCOL_H_ 1

#include <sys/types.h>

#include <map>
#include <memory>
#include <string>
#include <vector>

#include <folly/io/IOBuf.h>
#include <folly/io/IOBufQueue.h>
#include <thrift/lib/cpp/Thrift.h>
#include <thrift/lib/cpp/protocol/TProtocol.h>
#include <thrift/lib/cpp/protocol/TProtocolException.h>
#include <thrift/lib/cpp/protocol/TProtocolTypes.h>
#include <thrift/lib/cpp/util/BitwiseCast.h>
#include <thrift/lib/cpp2/CloneableIOBuf.h>

/**
 * Protocol Readers and Writers are ducktyped in cpp2.
 * This means they have no base class or virtual methods,
 * and you must explicitly choose the correct class to use.
 *
 * This results in a 2x performance increase over a traditional
 * object oriented hierarchy. If you need a base class, you can
 * use the VirtualReader / VitualWriter in VirtualProtocol.h
 */

namespace apache {
namespace thrift {

/**
 * Certain serialization / deserialization operations allow sharing
 * external (user-owned) buffers. This means that the external buffers must
 * remain allocated (and unchanged) until the serialization / deserialization
 * is complete.
 *
 * This is often counter-intuitive; for example, deserializing from a string
 * wouldn't work with a temporary string if sharing is allowed. So sharing
 * external buffers must be requested explicitly.
 *
 * Note that we always share memory that is under IOBuf's control (that is,
 * IOBuf chains for which isManaged() is true). To prevent that, call unshare()
 * on the IOBuf chain as appropriate.
 */
enum ExternalBufferSharing {
  COPY_EXTERNAL_BUFFER,
  SHARE_EXTERNAL_BUFFER,
};

using apache::thrift::protocol::TProtocolException;
using apache::thrift::protocol::TType;
typedef apache::thrift::protocol::PROTOCOL_TYPES ProtocolType;

/*
 * Enumerated definition of the message types that the Thrift protocol
 * supports.
 */
enum MessageType { T_CALL = 1, T_REPLY = 2, T_EXCEPTION = 3, T_ONEWAY = 4 };

/**
 * Helper template for implementing Protocol::skip().
 *
 * Templatized to avoid having to make virtual function calls.
 */
template <class Protocol_>
void skip(Protocol_& prot, TType arg_type) {
  switch (arg_type) {
    case TType::T_BOOL: {
      bool boolv;
      prot.readBool(boolv);
      return;
    }
    case TType::T_BYTE: {
      int8_t bytev;
      prot.readByte(bytev);
      return;
    }
    case TType::T_I16: {
      int16_t i16;
      prot.readI16(i16);
      return;
    }
    case TType::T_I32: {
      int32_t i32;
      prot.readI32(i32);
      return;
    }
    case TType::T_I64: {
      int64_t i64;
      prot.readI64(i64);
      return;
    }
    case TType::T_DOUBLE: {
      double dub;
      prot.readDouble(dub);
      return;
    }
    case TType::T_FLOAT: {
      float flt;
      prot.readFloat(flt);
      return;
    }
    case TType::T_STRING: {
      std::string str;
      prot.readBinary(str);
      return;
    }
    case TType::T_STRUCT: {
      std::string name;
      int16_t fid;
      TType ftype;
      prot.readStructBegin(name);
      while (true) {
        prot.readFieldBegin(name, ftype, fid);
        if (ftype == TType::T_STOP) {
          break;
        }
        apache::thrift::skip(prot, ftype);
        prot.readFieldEnd();
      }
      prot.readStructEnd();
      return;
    }
    case TType::T_MAP: {
      TType keyType;
      TType valType;
      uint32_t i, size;
      prot.readMapBegin(keyType, valType, size);
      for (i = 0; i < size; i++) {
        apache::thrift::skip(prot, keyType);
        apache::thrift::skip(prot, valType);
      }
      prot.readMapEnd();
      return;
    }
    case TType::T_SET: {
      TType elemType;
      uint32_t i, size;
      prot.readSetBegin(elemType, size);
      for (i = 0; i < size; i++) {
        apache::thrift::skip(prot, elemType);
      }
      prot.readSetEnd();
      return;
    }
    case TType::T_LIST: {
      TType elemType;
      uint32_t i, size;
      prot.readListBegin(elemType, size);
      for (i = 0; i < size; i++) {
        apache::thrift::skip(prot, elemType);
      }
      prot.readListEnd();
      return;
    }
    default:
      return;
  }
}

template <class StrType>
struct StringTraits {
  static StrType fromStringLiteral(const char* str) {
    return StrType(str);
  }

  static bool isEmpty(const StrType& str) {
    return str.empty();
  }

  static bool isEqual(const StrType& lhs, const StrType& rhs) {
    return lhs == rhs;
  }

  static bool isLess(const StrType& lhs, const StrType& rhs) {
    return lhs < rhs;
  }
};

template <>
struct StringTraits<folly::IOBuf> {
  // Use with string literals only!
  static folly::IOBuf fromStringLiteral(const char* str) {
    return folly::IOBuf::wrapBufferAsValue(str, strlen(str));
  }

  static bool isEmpty(const folly::IOBuf& str) {
    return str.empty();
  }

  static bool isEqual(const folly::IOBuf& lhs, const folly::IOBuf& rhs) {
    return folly::IOBufEqualTo{}(lhs, rhs);
  }

  static bool isLess(const folly::IOBuf& lhs, const folly::IOBuf& rhs) {
    return folly::IOBufLess{}(lhs, rhs);
  }
};

template <>
struct StringTraits<std::unique_ptr<folly::IOBuf>> {
  // Use with string literals only!
  static std::unique_ptr<folly::IOBuf> fromStringLiteral(const char* str) {
    return (
        str[0] != '\0' ? folly::IOBuf::wrapBuffer(str, strlen(str)) : nullptr);
  }

  static bool isEmpty(const std::unique_ptr<folly::IOBuf>& str) {
    return !str || str->empty();
  }

  static bool isEqual(
      const std::unique_ptr<folly::IOBuf>& lhs,
      const std::unique_ptr<folly::IOBuf>& rhs) {
    return folly::IOBufEqualTo{}(lhs, rhs);
  }

  static bool isLess(
      const std::unique_ptr<folly::IOBuf>& lhs,
      const std::unique_ptr<folly::IOBuf>& rhs) {
    return folly::IOBufLess{}(lhs, rhs);
  }
};

} // namespace thrift
} // namespace apache

#endif
",0
CVE-2019-3558,thrift/lib/cpp2/protocol/Protocol.h,"/*
 * Copyright 2011-present Facebook, Inc.
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#ifndef CPP2_PROTOCOL_PROTOCOL_H_
#define CPP2_PROTOCOL_PROTOCOL_H_ 1

#include <sys/types.h>

#include <map>
#include <memory>
#include <string>
#include <vector>

#include <folly/io/IOBuf.h>
#include <folly/io/IOBufQueue.h>
#include <thrift/lib/cpp/Thrift.h>
#include <thrift/lib/cpp/protocol/TProtocol.h>
#include <thrift/lib/cpp/protocol/TProtocolException.h>
#include <thrift/lib/cpp/protocol/TProtocolTypes.h>
#include <thrift/lib/cpp/util/BitwiseCast.h>
#include <thrift/lib/cpp2/CloneableIOBuf.h>

/**
 * Protocol Readers and Writers are ducktyped in cpp2.
 * This means they have no base class or virtual methods,
 * and you must explicitly choose the correct class to use.
 *
 * This results in a 2x performance increase over a traditional
 * object oriented hierarchy. If you need a base class, you can
 * use the VirtualReader / VitualWriter in VirtualProtocol.h
 */

namespace apache {
namespace thrift {

/**
 * Certain serialization / deserialization operations allow sharing
 * external (user-owned) buffers. This means that the external buffers must
 * remain allocated (and unchanged) until the serialization / deserialization
 * is complete.
 *
 * This is often counter-intuitive; for example, deserializing from a string
 * wouldn't work with a temporary string if sharing is allowed. So sharing
 * external buffers must be requested explicitly.
 *
 * Note that we always share memory that is under IOBuf's control (that is,
 * IOBuf chains for which isManaged() is true). To prevent that, call unshare()
 * on the IOBuf chain as appropriate.
 */
enum ExternalBufferSharing {
  COPY_EXTERNAL_BUFFER,
  SHARE_EXTERNAL_BUFFER,
};

using apache::thrift::protocol::TProtocolException;
using apache::thrift::protocol::TType;
typedef apache::thrift::protocol::PROTOCOL_TYPES ProtocolType;

/*
 * Enumerated definition of the message types that the Thrift protocol
 * supports.
 */
enum MessageType { T_CALL = 1, T_REPLY = 2, T_EXCEPTION = 3, T_ONEWAY = 4 };

/**
 * Helper template for implementing Protocol::skip().
 *
 * Templatized to avoid having to make virtual function calls.
 */
template <class Protocol_>
void skip(Protocol_& prot, TType arg_type) {
  switch (arg_type) {
    case TType::T_BOOL: {
      bool boolv;
      prot.readBool(boolv);
      return;
    }
    case TType::T_BYTE: {
      int8_t bytev;
      prot.readByte(bytev);
      return;
    }
    case TType::T_I16: {
      int16_t i16;
      prot.readI16(i16);
      return;
    }
    case TType::T_I32: {
      int32_t i32;
      prot.readI32(i32);
      return;
    }
    case TType::T_I64: {
      int64_t i64;
      prot.readI64(i64);
      return;
    }
    case TType::T_DOUBLE: {
      double dub;
      prot.readDouble(dub);
      return;
    }
    case TType::T_FLOAT: {
      float flt;
      prot.readFloat(flt);
      return;
    }
    case TType::T_STRING: {
      std::string str;
      prot.readBinary(str);
      return;
    }
    case TType::T_STRUCT: {
      std::string name;
      int16_t fid;
      TType ftype;
      prot.readStructBegin(name);
      while (true) {
        prot.readFieldBegin(name, ftype, fid);
        if (ftype == TType::T_STOP) {
          break;
        }
        apache::thrift::skip(prot, ftype);
        prot.readFieldEnd();
      }
      prot.readStructEnd();
      return;
    }
    case TType::T_MAP: {
      TType keyType;
      TType valType;
      uint32_t i, size;
      prot.readMapBegin(keyType, valType, size);
      for (i = 0; i < size; i++) {
        apache::thrift::skip(prot, keyType);
        apache::thrift::skip(prot, valType);
      }
      prot.readMapEnd();
      return;
    }
    case TType::T_SET: {
      TType elemType;
      uint32_t i, size;
      prot.readSetBegin(elemType, size);
      for (i = 0; i < size; i++) {
        apache::thrift::skip(prot, elemType);
      }
      prot.readSetEnd();
      return;
    }
    case TType::T_LIST: {
      TType elemType;
      uint32_t i, size;
      prot.readListBegin(elemType, size);
      for (i = 0; i < size; i++) {
        apache::thrift::skip(prot, elemType);
      }
      prot.readListEnd();
      return;
    }
    default: {
      TProtocolException::throwInvalidSkipType(arg_type);
    }
  }
}

template <class StrType>
struct StringTraits {
  static StrType fromStringLiteral(const char* str) {
    return StrType(str);
  }

  static bool isEmpty(const StrType& str) {
    return str.empty();
  }

  static bool isEqual(const StrType& lhs, const StrType& rhs) {
    return lhs == rhs;
  }

  static bool isLess(const StrType& lhs, const StrType& rhs) {
    return lhs < rhs;
  }
};

template <>
struct StringTraits<folly::IOBuf> {
  // Use with string literals only!
  static folly::IOBuf fromStringLiteral(const char* str) {
    return folly::IOBuf::wrapBufferAsValue(str, strlen(str));
  }

  static bool isEmpty(const folly::IOBuf& str) {
    return str.empty();
  }

  static bool isEqual(const folly::IOBuf& lhs, const folly::IOBuf& rhs) {
    return folly::IOBufEqualTo{}(lhs, rhs);
  }

  static bool isLess(const folly::IOBuf& lhs, const folly::IOBuf& rhs) {
    return folly::IOBufLess{}(lhs, rhs);
  }
};

template <>
struct StringTraits<std::unique_ptr<folly::IOBuf>> {
  // Use with string literals only!
  static std::unique_ptr<folly::IOBuf> fromStringLiteral(const char* str) {
    return (
        str[0] != '\0' ? folly::IOBuf::wrapBuffer(str, strlen(str)) : nullptr);
  }

  static bool isEmpty(const std::unique_ptr<folly::IOBuf>& str) {
    return !str || str->empty();
  }

  static bool isEqual(
      const std::unique_ptr<folly::IOBuf>& lhs,
      const std::unique_ptr<folly::IOBuf>& rhs) {
    return folly::IOBufEqualTo{}(lhs, rhs);
  }

  static bool isLess(
      const std::unique_ptr<folly::IOBuf>& lhs,
      const std::unique_ptr<folly::IOBuf>& rhs) {
    return folly::IOBufLess{}(lhs, rhs);
  }
};

} // namespace thrift
} // namespace apache

#endif
",1
CVE-2019-3558,thrift/lib/py/protocol/TProtocol.py,"#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# ""License""); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

from thrift.Thrift import *

class TProtocolException(TException):

    """"""Custom Protocol Exception class""""""

    UNKNOWN = 0
    INVALID_DATA = 1
    NEGATIVE_SIZE = 2
    SIZE_LIMIT = 3
    BAD_VERSION = 4
    INVALID_PROTOCOL = 5
    MISSING_REQUIRED_FIELD = 6

    def __init__(self, type=UNKNOWN, message=None):
        TException.__init__(self, message)
        self.type = type

class TProtocolBase:

    """"""Base class for Thrift protocol driver.""""""

    def __init__(self, trans):
        self.trans = trans

    def writeMessageBegin(self, name, ttype, seqid):
        pass

    def writeMessageEnd(self):
        pass

    def writeStructBegin(self, name):
        pass

    def writeStructEnd(self):
        pass

    def writeUnionBegin(self, name):
        self.writeStructBegin(name)

    def writeUnionEnd(self):
        self.writeStructEnd()

    def writeFieldBegin(self, name, type, id):
        pass

    def writeFieldEnd(self):
        pass

    def writeFieldStop(self):
        pass

    def writeMapBegin(self, ktype, vtype, size):
        pass

    def writeMapEnd(self):
        pass

    def writeListBegin(self, etype, size):
        pass

    def writeListEnd(self):
        pass

    def writeSetBegin(self, etype, size):
        pass

    def writeSetEnd(self):
        pass

    def writeBool(self, bool_val):
        pass

    def writeByte(self, byte):
        pass

    def writeI16(self, i16):
        pass

    def writeI32(self, i32):
        pass

    def writeI64(self, i64):
        pass

    def writeDouble(self, dub):
        pass

    def writeFloat(self, flt):
        pass

    def writeString(self, str):
        pass

    def readMessageBegin(self):
        pass

    def readMessageEnd(self):
        pass

    def readStructBegin(self):
        pass

    def readStructEnd(self):
        pass

    def readFieldBegin(self):
        pass

    def readFieldEnd(self):
        pass

    def readMapBegin(self):
        pass

    def readMapEnd(self):
        pass

    def readListBegin(self):
        pass

    def readListEnd(self):
        pass

    def readSetBegin(self):
        pass

    def readSetEnd(self):
        pass

    def readBool(self):
        pass

    def readByte(self):
        pass

    def readI16(self):
        pass

    def readI32(self):
        pass

    def readI64(self):
        pass

    def readDouble(self):
        pass

    def readFloat(self):
        pass

    def readString(self):
        pass

    def skip(self, type):
        if type == TType.STOP:
            return
        elif type == TType.BOOL:
            self.readBool()
        elif type == TType.BYTE:
            self.readByte()
        elif type == TType.I16:
            self.readI16()
        elif type == TType.I32:
            self.readI32()
        elif type == TType.I64:
            self.readI64()
        elif type == TType.DOUBLE:
            self.readDouble()
        elif type == TType.FLOAT:
            self.readFloat()
        elif type == TType.STRING:
            self.readString()
        elif type == TType.STRUCT:
            name = self.readStructBegin()
            while True:
                (name, type, id) = self.readFieldBegin()
                if type == TType.STOP:
                    break
                self.skip(type)
                self.readFieldEnd()
            self.readStructEnd()
        elif type == TType.MAP:
            (ktype, vtype, size) = self.readMapBegin()
            for _ in range(size):
                self.skip(ktype)
                self.skip(vtype)
            self.readMapEnd()
        elif type == TType.SET:
            (etype, size) = self.readSetBegin()
            for _ in range(size):
                self.skip(etype)
            self.readSetEnd()
        elif type == TType.LIST:
            (etype, size) = self.readListBegin()
            for _ in range(size):
                self.skip(etype)
            self.readListEnd()

    def readIntegral(self, type):
        if type == TType.BOOL:
            return self.readBool()
        elif type == TType.BYTE:
            return self.readByte()
        elif type == TType.I16:
            return self.readI16()
        elif type == TType.I32:
            return self.readI32()
        elif type == TType.I64:
            return self.readI64()
        else:
            raise Exception(""Unknown integral type: %s"" % str(type))

    def readFloatingPoint(self, type):
        if type == TType.FLOAT:
            return self.readFloat()
        elif type == TType.DOUBLE:
            return self.readDouble()
        else:
            raise Exception(""Unknown floating point type: %s"" % str(type))

class TProtocolFactory:
    def getProtocol(self, trans):
        pass
",0
CVE-2019-3558,thrift/lib/py/protocol/TProtocol.py,"#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# ""License""); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

from thrift.Thrift import *

class TProtocolException(TException):

    """"""Custom Protocol Exception class""""""

    UNKNOWN = 0
    INVALID_DATA = 1
    NEGATIVE_SIZE = 2
    SIZE_LIMIT = 3
    BAD_VERSION = 4
    INVALID_PROTOCOL = 5
    MISSING_REQUIRED_FIELD = 6

    def __init__(self, type=UNKNOWN, message=None):
        TException.__init__(self, message)
        self.type = type

class TProtocolBase:

    """"""Base class for Thrift protocol driver.""""""

    def __init__(self, trans):
        self.trans = trans

    def writeMessageBegin(self, name, ttype, seqid):
        pass

    def writeMessageEnd(self):
        pass

    def writeStructBegin(self, name):
        pass

    def writeStructEnd(self):
        pass

    def writeUnionBegin(self, name):
        self.writeStructBegin(name)

    def writeUnionEnd(self):
        self.writeStructEnd()

    def writeFieldBegin(self, name, type, id):
        pass

    def writeFieldEnd(self):
        pass

    def writeFieldStop(self):
        pass

    def writeMapBegin(self, ktype, vtype, size):
        pass

    def writeMapEnd(self):
        pass

    def writeListBegin(self, etype, size):
        pass

    def writeListEnd(self):
        pass

    def writeSetBegin(self, etype, size):
        pass

    def writeSetEnd(self):
        pass

    def writeBool(self, bool_val):
        pass

    def writeByte(self, byte):
        pass

    def writeI16(self, i16):
        pass

    def writeI32(self, i32):
        pass

    def writeI64(self, i64):
        pass

    def writeDouble(self, dub):
        pass

    def writeFloat(self, flt):
        pass

    def writeString(self, str):
        pass

    def readMessageBegin(self):
        pass

    def readMessageEnd(self):
        pass

    def readStructBegin(self):
        pass

    def readStructEnd(self):
        pass

    def readFieldBegin(self):
        pass

    def readFieldEnd(self):
        pass

    def readMapBegin(self):
        pass

    def readMapEnd(self):
        pass

    def readListBegin(self):
        pass

    def readListEnd(self):
        pass

    def readSetBegin(self):
        pass

    def readSetEnd(self):
        pass

    def readBool(self):
        pass

    def readByte(self):
        pass

    def readI16(self):
        pass

    def readI32(self):
        pass

    def readI64(self):
        pass

    def readDouble(self):
        pass

    def readFloat(self):
        pass

    def readString(self):
        pass

    def skip(self, type):
        if type == TType.BOOL:
            self.readBool()
        elif type == TType.BYTE:
            self.readByte()
        elif type == TType.I16:
            self.readI16()
        elif type == TType.I32:
            self.readI32()
        elif type == TType.I64:
            self.readI64()
        elif type == TType.DOUBLE:
            self.readDouble()
        elif type == TType.FLOAT:
            self.readFloat()
        elif type == TType.STRING:
            self.readString()
        elif type == TType.STRUCT:
            name = self.readStructBegin()
            while True:
                (name, type, id) = self.readFieldBegin()
                if type == TType.STOP:
                    break
                self.skip(type)
                self.readFieldEnd()
            self.readStructEnd()
        elif type == TType.MAP:
            (ktype, vtype, size) = self.readMapBegin()
            for _ in range(size):
                self.skip(ktype)
                self.skip(vtype)
            self.readMapEnd()
        elif type == TType.SET:
            (etype, size) = self.readSetBegin()
            for _ in range(size):
                self.skip(etype)
            self.readSetEnd()
        elif type == TType.LIST:
            (etype, size) = self.readListBegin()
            for _ in range(size):
                self.skip(etype)
            self.readListEnd()
        else:
            raise TProtocolException(
                TProtocolException.INVALID_DATA,
                ""Unexpected type for skipping {}"".format(type)
            )

    def readIntegral(self, type):
        if type == TType.BOOL:
            return self.readBool()
        elif type == TType.BYTE:
            return self.readByte()
        elif type == TType.I16:
            return self.readI16()
        elif type == TType.I32:
            return self.readI32()
        elif type == TType.I64:
            return self.readI64()
        else:
            raise Exception(""Unknown integral type: %s"" % str(type))

    def readFloatingPoint(self, type):
        if type == TType.FLOAT:
            return self.readFloat()
        elif type == TType.DOUBLE:
            return self.readDouble()
        else:
            raise Exception(""Unknown floating point type: %s"" % str(type))

class TProtocolFactory:
    def getProtocol(self, trans):
        pass
",1
CVE-2016-2166,proton-c/bindings/python/proton/reactor.py,"from __future__ import absolute_import
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# ""License""); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
import logging, os, socket, time, types
from heapq import heappush, heappop, nsmallest
from proton import Collector, Connection, ConnectionException, Delivery, Described, dispatch
from proton import Endpoint, Event, EventBase, EventType, generate_uuid, Handler, Link, Message
from proton import ProtonException, PN_ACCEPTED, PN_PYREF, SASL, Session, SSL, SSLDomain, SSLUnavailable, symbol
from proton import Terminus, Timeout, Transport, TransportException, ulong, Url
from select import select
from proton.handlers import OutgoingMessageHandler
from proton import unicode2utf8, utf82unicode

import traceback
from proton import WrappedHandler, _chandler, secs2millis, millis2secs, timeout2millis, millis2timeout, Selectable
from .wrapper import Wrapper, PYCTX
from cproton import *
from . import _compat

try:
    import Queue
except ImportError:
    import queue as Queue

class Task(Wrapper):

    @staticmethod
    def wrap(impl):
        if impl is None:
            return None
        else:
            return Task(impl)

    def __init__(self, impl):
        Wrapper.__init__(self, impl, pn_task_attachments)

    def _init(self):
        pass

    def cancel(self):
        pn_task_cancel(self._impl)

class Acceptor(Wrapper):

    def __init__(self, impl):
        Wrapper.__init__(self, impl)

    def set_ssl_domain(self, ssl_domain):
        pn_acceptor_set_ssl_domain(self._impl, ssl_domain._domain)

    def close(self):
        pn_acceptor_close(self._impl)

class Reactor(Wrapper):

    @staticmethod
    def wrap(impl):
        if impl is None:
            return None
        else:
            record = pn_reactor_attachments(impl)
            attrs = pn_void2py(pn_record_get(record, PYCTX))
            if attrs and 'subclass' in attrs:
                return attrs['subclass'](impl=impl)
            else:
                return Reactor(impl=impl)

    def __init__(self, *handlers, **kwargs):
        Wrapper.__init__(self, kwargs.get(""impl"", pn_reactor), pn_reactor_attachments)
        for h in handlers:
            self.handler.add(h)

    def _init(self):
        self.errors = []

    def on_error(self, info):
        self.errors.append(info)
        self.yield_()

    def _get_global(self):
        return WrappedHandler.wrap(pn_reactor_get_global_handler(self._impl), self.on_error)

    def _set_global(self, handler):
        impl = _chandler(handler, self.on_error)
        pn_reactor_set_global_handler(self._impl, impl)
        pn_decref(impl)

    global_handler = property(_get_global, _set_global)

    def _get_timeout(self):
        return millis2timeout(pn_reactor_get_timeout(self._impl))

    def _set_timeout(self, secs):
        return pn_reactor_set_timeout(self._impl, timeout2millis(secs))

    timeout = property(_get_timeout, _set_timeout)

    def yield_(self):
        pn_reactor_yield(self._impl)

    def mark(self):
        return pn_reactor_mark(self._impl)

    def _get_handler(self):
        return WrappedHandler.wrap(pn_reactor_get_handler(self._impl), self.on_error)

    def _set_handler(self, handler):
        impl = _chandler(handler, self.on_error)
        pn_reactor_set_handler(self._impl, impl)
        pn_decref(impl)

    handler = property(_get_handler, _set_handler)

    def run(self):
        self.timeout = 3.14159265359
        self.start()
        while self.process(): pass
        self.stop()

    def wakeup(self):
        n = pn_reactor_wakeup(self._impl)
        if n: raise IOError(pn_error_text(pn_io_error(pn_reactor_io(self._impl))))

    def start(self):
        pn_reactor_start(self._impl)

    @property
    def quiesced(self):
        return pn_reactor_quiesced(self._impl)

    def _check_errors(self):
        if self.errors:
            for exc, value, tb in self.errors[:-1]:
                traceback.print_exception(exc, value, tb)
            exc, value, tb = self.errors[-1]
            _compat.raise_(exc, value, tb)

    def process(self):
        result = pn_reactor_process(self._impl)
        self._check_errors()
        return result

    def stop(self):
        pn_reactor_stop(self._impl)
        self._check_errors()
        self.global_handler = None
        self.handler = None

    def schedule(self, delay, task):
        impl = _chandler(task, self.on_error)
        task = Task.wrap(pn_reactor_schedule(self._impl, secs2millis(delay), impl))
        pn_decref(impl)
        return task

    def acceptor(self, host, port, handler=None):
        impl = _chandler(handler, self.on_error)
        aimpl = pn_reactor_acceptor(self._impl, unicode2utf8(host), str(port), impl)
        pn_decref(impl)
        if aimpl:
            return Acceptor(aimpl)
        else:
            raise IOError(""%s (%s:%s)"" % (pn_error_text(pn_io_error(pn_reactor_io(self._impl))), host, port))

    def connection(self, handler=None):
        impl = _chandler(handler, self.on_error)
        result = Connection.wrap(pn_reactor_connection(self._impl, impl))
        pn_decref(impl)
        return result

    def selectable(self, handler=None):
        impl = _chandler(handler, self.on_error)
        result = Selectable.wrap(pn_reactor_selectable(self._impl))
        if impl:
            record = pn_selectable_attachments(result._impl)
            pn_record_set_handler(record, impl)
            pn_decref(impl)
        return result

    def update(self, sel):
        pn_reactor_update(self._impl, sel._impl)

    def push_event(self, obj, etype):
        pn_collector_put(pn_reactor_collector(self._impl), PN_PYREF, pn_py2void(obj), etype.number)

from proton import wrappers as _wrappers
_wrappers[""pn_reactor""] = lambda x: Reactor.wrap(pn_cast_pn_reactor(x))
_wrappers[""pn_task""] = lambda x: Task.wrap(pn_cast_pn_task(x))


class EventInjector(object):
    """"""
    Can be added to a reactor to allow events to be triggered by an
    external thread but handled on the event thread associated with
    the reactor. An instance of this class can be passed to the
    Reactor.selectable() method of the reactor in order to activate
    it. The close() method should be called when it is no longer
    needed, to allow the event loop to end if needed.
    """"""
    def __init__(self):
        self.queue = Queue.Queue()
        self.pipe = os.pipe()
        self._closed = False

    def trigger(self, event):
        """"""
        Request that the given event be dispatched on the event thread
        of the reactor to which this EventInjector was added.
        """"""
        self.queue.put(event)
        os.write(self.pipe[1], _compat.str2bin(""!""))

    def close(self):
        """"""
        Request that this EventInjector be closed. Existing events
        will be dispctahed on the reactors event dispactch thread,
        then this will be removed from the set of interest.
        """"""
        self._closed = True
        os.write(self.pipe[1], _compat.str2bin(""!""))

    def fileno(self):
        return self.pipe[0]

    def on_selectable_init(self, event):
        sel = event.context
        sel.fileno(self.fileno())
        sel.reading = True
        event.reactor.update(sel)

    def on_selectable_readable(self, event):
        os.read(self.pipe[0], 512)
        while not self.queue.empty():
            requested = self.queue.get()
            event.reactor.push_event(requested.context, requested.type)
        if self._closed:
            s = event.context
            s.terminate()
            event.reactor.update(s)


class ApplicationEvent(EventBase):
    """"""
    Application defined event, which can optionally be associated with
    an engine object and or an arbitrary subject
    """"""
    def __init__(self, typename, connection=None, session=None, link=None, delivery=None, subject=None):
        super(ApplicationEvent, self).__init__(PN_PYREF, self, EventType(typename))
        self.connection = connection
        self.session = session
        self.link = link
        self.delivery = delivery
        if self.delivery:
            self.link = self.delivery.link
        if self.link:
            self.session = self.link.session
        if self.session:
            self.connection = self.session.connection
        self.subject = subject

    def __repr__(self):
        objects = [self.connection, self.session, self.link, self.delivery, self.subject]
        return ""%s(%s)"" % (self.type, "", "".join([str(o) for o in objects if o is not None]))

class Transaction(object):
    """"""
    Class to track state of an AMQP 1.0 transaction.
    """"""
    def __init__(self, txn_ctrl, handler, settle_before_discharge=False):
        self.txn_ctrl = txn_ctrl
        self.handler = handler
        self.id = None
        self._declare = None
        self._discharge = None
        self.failed = False
        self._pending = []
        self.settle_before_discharge = settle_before_discharge
        self.declare()

    def commit(self):
        self.discharge(False)

    def abort(self):
        self.discharge(True)

    def declare(self):
        self._declare = self._send_ctrl(symbol(u'amqp:declare:list'), [None])

    def discharge(self, failed):
        self.failed = failed
        self._discharge = self._send_ctrl(symbol(u'amqp:discharge:list'), [self.id, failed])

    def _send_ctrl(self, descriptor, value):
        delivery = self.txn_ctrl.send(Message(body=Described(descriptor, value)))
        delivery.transaction = self
        return delivery

    def send(self, sender, msg, tag=None):
        dlv = sender.send(msg, tag=tag)
        dlv.local.data = [self.id]
        dlv.update(0x34)
        return dlv

    def accept(self, delivery):
        self.update(delivery, PN_ACCEPTED)
        if self.settle_before_discharge:
            delivery.settle()
        else:
            self._pending.append(delivery)

    def update(self, delivery, state=None):
        if state:
            delivery.local.data = [self.id, Described(ulong(state), [])]
            delivery.update(0x34)

    def _release_pending(self):
        for d in self._pending:
            d.update(Delivery.RELEASED)
            d.settle()
        self._clear_pending()

    def _clear_pending(self):
        self._pending = []

    def handle_outcome(self, event):
        if event.delivery == self._declare:
            if event.delivery.remote.data:
                self.id = event.delivery.remote.data[0]
                self.handler.on_transaction_declared(event)
            elif event.delivery.remote_state == Delivery.REJECTED:
                self.handler.on_transaction_declare_failed(event)
            else:
                logging.warning(""Unexpected outcome for declare: %s"" % event.delivery.remote_state)
                self.handler.on_transaction_declare_failed(event)
        elif event.delivery == self._discharge:
            if event.delivery.remote_state == Delivery.REJECTED:
                if not self.failed:
                    self.handler.on_transaction_commit_failed(event)
                    self._release_pending() # make this optional?
            else:
                if self.failed:
                    self.handler.on_transaction_aborted(event)
                    self._release_pending()
                else:
                    self.handler.on_transaction_committed(event)
            self._clear_pending()

class LinkOption(object):
    """"""
    Abstract interface for link configuration options
    """"""
    def apply(self, link):
        """"""
        Subclasses will implement any configuration logic in this
        method
        """"""
        pass
    def test(self, link):
        """"""
        Subclasses can override this to selectively apply an option
        e.g. based on some link criteria
        """"""
        return True

class AtMostOnce(LinkOption):
    def apply(self, link):
        link.snd_settle_mode = Link.SND_SETTLED

class AtLeastOnce(LinkOption):
    def apply(self, link):
        link.snd_settle_mode = Link.SND_UNSETTLED
        link.rcv_settle_mode = Link.RCV_FIRST

class SenderOption(LinkOption):
    def apply(self, sender): pass
    def test(self, link): return link.is_sender

class ReceiverOption(LinkOption):
    def apply(self, receiver): pass
    def test(self, link): return link.is_receiver

class DynamicNodeProperties(LinkOption):
    def __init__(self, props={}):
        self.properties = {}
        for k in props:
            if isinstance(k, symbol):
                self.properties[k] = props[k]
            else:
                self.properties[symbol(k)] = props[k]

    def apply(self, link):
        if link.is_receiver:
            link.source.properties.put_dict(self.properties)
        else:
            link.target.properties.put_dict(self.properties)

class Filter(ReceiverOption):
    def __init__(self, filter_set={}):
        self.filter_set = filter_set

    def apply(self, receiver):
        receiver.source.filter.put_dict(self.filter_set)

class Selector(Filter):
    """"""
    Configures a link with a message selector filter
    """"""
    def __init__(self, value, name='selector'):
        super(Selector, self).__init__({symbol(name): Described(symbol('apache.org:selector-filter:string'), value)})

class DurableSubscription(ReceiverOption):
    def apply(self, receiver):
        receiver.source.durability = Terminus.DELIVERIES
        receiver.source.expiry_policy = Terminus.EXPIRE_NEVER

class Move(ReceiverOption):
    def apply(self, receiver):
        receiver.source.distribution_mode = Terminus.DIST_MODE_MOVE

class Copy(ReceiverOption):
    def apply(self, receiver):
        receiver.source.distribution_mode = Terminus.DIST_MODE_COPY

def _apply_link_options(options, link):
    if options:
        if isinstance(options, list):
            for o in options:
                if o.test(link): o.apply(link)
        else:
            if options.test(link): options.apply(link)

def _create_session(connection, handler=None):
    session = connection.session()
    session.open()
    return session


def _get_attr(target, name):
    if hasattr(target, name):
        return getattr(target, name)
    else:
        return None

class SessionPerConnection(object):
    def __init__(self):
        self._default_session = None

    def session(self, connection):
        if not self._default_session:
            self._default_session = _create_session(connection)
            self._default_session.context = self
        return self._default_session

    def on_session_remote_close(self, event):
        event.connection.close()
        self._default_session = None

class GlobalOverrides(object):
    """"""
    Internal handler that triggers the necessary socket connect for an
    opened connection.
    """"""
    def __init__(self, base):
        self.base = base

    def on_unhandled(self, name, event):
        if not self._override(event):
            event.dispatch(self.base)

    def _override(self, event):
        conn = event.connection
        return conn and hasattr(conn, '_overrides') and event.dispatch(conn._overrides)

class Connector(Handler):
    """"""
    Internal handler that triggers the necessary socket connect for an
    opened connection.
    """"""
    def __init__(self, connection):
        self.connection = connection
        self.address = None
        self.heartbeat = None
        self.reconnect = None
        self.ssl_domain = None
        self.allow_insecure_mechs = True
        self.allowed_mechs = None
        self.sasl_enabled = True
        self.user = None
        self.password = None

    def _connect(self, connection):
        url = self.address.next()
        # IoHandler uses the hostname to determine where to try to connect to
        connection.hostname = ""%s:%s"" % (url.host, url.port)
        logging.info(""connecting to %s..."" % connection.hostname)

        transport = Transport()
        if self.sasl_enabled:
            sasl = transport.sasl()
            sasl.allow_insecure_mechs = self.allow_insecure_mechs
            if url.username:
                connection.user = url.username
            elif self.user:
                connection.user = self.user
            if url.password:
                connection.password = url.password
            elif self.password:
                connection.password = self.password
            if self.allowed_mechs:
                sasl.allowed_mechs(self.allowed_mechs)
        transport.bind(connection)
        if self.heartbeat:
            transport.idle_timeout = self.heartbeat
        if url.scheme == 'amqps' and self.ssl_domain:
            self.ssl = SSL(transport, self.ssl_domain)
            self.ssl.peer_hostname = url.host

    def on_connection_local_open(self, event):
        self._connect(event.connection)

    def on_connection_remote_open(self, event):
        logging.info(""connected to %s"" % event.connection.hostname)
        if self.reconnect:
            self.reconnect.reset()
            self.transport = None

    def on_transport_tail_closed(self, event):
        self.on_transport_closed(event)

    def on_transport_closed(self, event):
        if self.connection and self.connection.state & Endpoint.LOCAL_ACTIVE:
            if self.reconnect:
                event.transport.unbind()
                delay = self.reconnect.next()
                if delay == 0:
                    logging.info(""Disconnected, reconnecting..."")
                    self._connect(self.connection)
                else:
                    logging.info(""Disconnected will try to reconnect after %s seconds"" % delay)
                    event.reactor.schedule(delay, self)
            else:
                logging.info(""Disconnected"")
                self.connection = None

    def on_timer_task(self, event):
        self._connect(self.connection)

    def on_connection_remote_close(self, event):
        self.connection = None

class Backoff(object):
    """"""
    A reconnect strategy involving an increasing delay between
    retries, up to a maximum or 10 seconds.
    """"""
    def __init__(self):
        self.delay = 0

    def reset(self):
        self.delay = 0

    def next(self):
        current = self.delay
        if current == 0:
            self.delay = 0.1
        else:
            self.delay = min(10, 2*current)
        return current

class Urls(object):
    def __init__(self, values):
        self.values = [Url(v) for v in values]
        self.i = iter(self.values)

    def __iter__(self):
        return self

    def next(self):
        try:
            return next(self.i)
        except StopIteration:
            self.i = iter(self.values)
            return next(self.i)

class SSLConfig(object):
    def __init__(self):
        self.client = SSLDomain(SSLDomain.MODE_CLIENT)
        self.server = SSLDomain(SSLDomain.MODE_SERVER)

    def set_credentials(self, cert_file, key_file, password):
        self.client.set_credentials(cert_file, key_file, password)
        self.server.set_credentials(cert_file, key_file, password)

    def set_trusted_ca_db(self, certificate_db):
        self.client.set_trusted_ca_db(certificate_db)
        self.server.set_trusted_ca_db(certificate_db)


class Container(Reactor):
    """"""A representation of the AMQP concept of a 'container', which
       lossely speaking is something that establishes links to or from
       another container, over which messages are transfered. This is
       an extension to the Reactor class that adds convenience methods
       for creating connections and sender- or receiver- links.
    """"""
    def __init__(self, *handlers, **kwargs):
        super(Container, self).__init__(*handlers, **kwargs)
        if ""impl"" not in kwargs:
            try:
                self.ssl = SSLConfig()
            except SSLUnavailable:
                self.ssl = None
            self.global_handler = GlobalOverrides(kwargs.get('global_handler', self.global_handler))
            self.trigger = None
            self.container_id = str(generate_uuid())
            self.allow_insecure_mechs = True
            self.allowed_mechs = None
            self.sasl_enabled = True
            self.user = None
            self.password = None
            Wrapper.__setattr__(self, 'subclass', self.__class__)

    def connect(self, url=None, urls=None, address=None, handler=None, reconnect=None, heartbeat=None, ssl_domain=None, **kwargs):
        """"""
        Initiates the establishment of an AMQP connection. Returns an
        instance of proton.Connection.

        @param url: URL string of process to connect to

        @param urls: list of URL strings of process to try to connect to

        Only one of url or urls should be specified.

        @param reconnect: A value of False will prevent the library
        form automatically trying to reconnect if the underlying
        socket is disconnected before the connection has been closed.

        @param heartbeat: A value in milliseconds indicating the
        desired frequency of heartbeats used to test the underlying
        socket is alive.

        @param ssl_domain: SSL configuration in the form of an
        instance of proton.SSLdomain.

        @param handler: a connection scoped handler that will be
        called to process any events in the scope of this connection
        or its child links

        @param kwargs: sasl_enabled, which determines whether a sasl
        layer is used for the connection; allowed_mechs an optional
        list of SASL mechanisms to allow if sasl is enabled;
        allow_insecure_mechs a flag indicating whether insecure
        mechanisms, such as PLAIN over a non-encrypted socket, are
        allowed. These options can also be set at container scope.

        """"""
        conn = self.connection(handler)
        conn.container = self.container_id or str(generate_uuid())
        
        conn.offered_capabilities = kwargs.get('offered_capabilities')
        conn.desired_capabilities = kwargs.get('desired_capabilities')
        conn.properties = kwargs.get('properties')
        
        connector = Connector(conn)
        connector.allow_insecure_mechs = kwargs.get('allow_insecure_mechs', self.allow_insecure_mechs)
        connector.allowed_mechs = kwargs.get('allowed_mechs', self.allowed_mechs)
        connector.sasl_enabled = kwargs.get('sasl_enabled', self.sasl_enabled)
        connector.user = kwargs.get('user', self.user)
        connector.password = kwargs.get('password', self.password)
        conn._overrides = connector
        if url: connector.address = Urls([url])
        elif urls: connector.address = Urls(urls)
        elif address: connector.address = address
        else: raise ValueError(""One of url, urls or address required"")
        if heartbeat:
            connector.heartbeat = heartbeat
        if reconnect:
            connector.reconnect = reconnect
        elif reconnect is None:
            connector.reconnect = Backoff()
        connector.ssl_domain = ssl_domain or (self.ssl and self.ssl.client)
        conn._session_policy = SessionPerConnection() #todo: make configurable
        conn.open()
        return conn

    def _get_id(self, container, remote, local):
        if local and remote: ""%s-%s-%s"" % (container, remote, local)
        elif local: return ""%s-%s"" % (container, local)
        elif remote: return ""%s-%s"" % (container, remote)
        else: return ""%s-%s"" % (container, str(generate_uuid()))

    def _get_session(self, context):
        if isinstance(context, Url):
            return self._get_session(self.connect(url=context))
        elif isinstance(context, Session):
            return context
        elif isinstance(context, Connection):
            if hasattr(context, '_session_policy'):
                return context._session_policy.session(context)
            else:
                return _create_session(context)
        else:
            return context.session()

    def create_sender(self, context, target=None, source=None, name=None, handler=None, tags=None, options=None):
        """"""
        Initiates the establishment of a link over which messages can
        be sent. Returns an instance of proton.Sender.

        There are two patterns of use. (1) A connection can be passed
        as the first argument, in which case the link is established
        on that connection. In this case the target address can be
        specified as the second argument (or as a keyword
        argument). The source address can also be specified if
        desired. (2) Alternatively a URL can be passed as the first
        argument. In this case a new connection will be establised on
        which the link will be attached. If a path is specified and
        the target is not, then the path of the URL is used as the
        target address.

        The name of the link may be specified if desired, otherwise a
        unique name will be generated.

        Various LinkOptions can be specified to further control the
        attachment.
        """"""
        if isinstance(context, _compat.STRING_TYPES):
            context = Url(context)
        if isinstance(context, Url) and not target:
            target = context.path
        session = self._get_session(context)
        snd = session.sender(name or self._get_id(session.connection.container, target, source))
        if source:
            snd.source.address = source
        if target:
            snd.target.address = target
        if handler != None:
            snd.handler = handler
        if tags:
            snd.tag_generator = tags
        _apply_link_options(options, snd)
        snd.open()
        return snd

    def create_receiver(self, context, source=None, target=None, name=None, dynamic=False, handler=None, options=None):
        """"""
        Initiates the establishment of a link over which messages can
        be received (aka a subscription). Returns an instance of
        proton.Receiver.

        There are two patterns of use. (1) A connection can be passed
        as the first argument, in which case the link is established
        on that connection. In this case the source address can be
        specified as the second argument (or as a keyword
        argument). The target address can also be specified if
        desired. (2) Alternatively a URL can be passed as the first
        argument. In this case a new connection will be establised on
        which the link will be attached. If a path is specified and
        the source is not, then the path of the URL is used as the
        target address.

        The name of the link may be specified if desired, otherwise a
        unique name will be generated.

        Various LinkOptions can be specified to further control the
        attachment.
        """"""
        if isinstance(context, _compat.STRING_TYPES):
            context = Url(context)
        if isinstance(context, Url) and not source:
            source = context.path
        session = self._get_session(context)
        rcv = session.receiver(name or self._get_id(session.connection.container, source, target))
        if source:
            rcv.source.address = source
        if dynamic:
            rcv.source.dynamic = True
        if target:
            rcv.target.address = target
        if handler != None:
            rcv.handler = handler
        _apply_link_options(options, rcv)
        rcv.open()
        return rcv

    def declare_transaction(self, context, handler=None, settle_before_discharge=False):
        if not _get_attr(context, '_txn_ctrl'):
            class InternalTransactionHandler(OutgoingMessageHandler):
                def __init__(self):
                    super(InternalTransactionHandler, self).__init__(auto_settle=True)

                def on_settled(self, event):
                    if hasattr(event.delivery, ""transaction""):
                        event.transaction = event.delivery.transaction
                        event.delivery.transaction.handle_outcome(event)
            context._txn_ctrl = self.create_sender(context, None, name='txn-ctrl', handler=InternalTransactionHandler())
            context._txn_ctrl.target.type = Terminus.COORDINATOR
            context._txn_ctrl.target.capabilities.put_object(symbol(u'amqp:local-transactions'))
        return Transaction(context._txn_ctrl, handler, settle_before_discharge)

    def listen(self, url, ssl_domain=None):
        """"""
        Initiates a server socket, accepting incoming AMQP connections
        on the interface and port specified.
        """"""
        url = Url(url)
        acceptor = self.acceptor(url.host, url.port)
        ssl_config = ssl_domain
        if not ssl_config and url.scheme == 'amqps' and self.ssl:
            ssl_config = self.ssl.server
        if ssl_config:
            acceptor.set_ssl_domain(ssl_config)
        return acceptor

    def do_work(self, timeout=None):
        if timeout:
            self.timeout = timeout
        return self.process()
",0
CVE-2016-2166,proton-c/bindings/python/proton/reactor.py,"from __future__ import absolute_import
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# ""License""); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
import logging, os, socket, time, types
from heapq import heappush, heappop, nsmallest
from proton import Collector, Connection, ConnectionException, Delivery, Described, dispatch
from proton import Endpoint, Event, EventBase, EventType, generate_uuid, Handler, Link, Message
from proton import ProtonException, PN_ACCEPTED, PN_PYREF, SASL, Session, SSL, SSLDomain, SSLUnavailable, symbol
from proton import Terminus, Timeout, Transport, TransportException, ulong, Url
from select import select
from proton.handlers import OutgoingMessageHandler
from proton import unicode2utf8, utf82unicode

import traceback
from proton import WrappedHandler, _chandler, secs2millis, millis2secs, timeout2millis, millis2timeout, Selectable
from .wrapper import Wrapper, PYCTX
from cproton import *
from . import _compat

try:
    import Queue
except ImportError:
    import queue as Queue

class Task(Wrapper):

    @staticmethod
    def wrap(impl):
        if impl is None:
            return None
        else:
            return Task(impl)

    def __init__(self, impl):
        Wrapper.__init__(self, impl, pn_task_attachments)

    def _init(self):
        pass

    def cancel(self):
        pn_task_cancel(self._impl)

class Acceptor(Wrapper):

    def __init__(self, impl):
        Wrapper.__init__(self, impl)

    def set_ssl_domain(self, ssl_domain):
        pn_acceptor_set_ssl_domain(self._impl, ssl_domain._domain)

    def close(self):
        pn_acceptor_close(self._impl)

class Reactor(Wrapper):

    @staticmethod
    def wrap(impl):
        if impl is None:
            return None
        else:
            record = pn_reactor_attachments(impl)
            attrs = pn_void2py(pn_record_get(record, PYCTX))
            if attrs and 'subclass' in attrs:
                return attrs['subclass'](impl=impl)
            else:
                return Reactor(impl=impl)

    def __init__(self, *handlers, **kwargs):
        Wrapper.__init__(self, kwargs.get(""impl"", pn_reactor), pn_reactor_attachments)
        for h in handlers:
            self.handler.add(h)

    def _init(self):
        self.errors = []

    def on_error(self, info):
        self.errors.append(info)
        self.yield_()

    def _get_global(self):
        return WrappedHandler.wrap(pn_reactor_get_global_handler(self._impl), self.on_error)

    def _set_global(self, handler):
        impl = _chandler(handler, self.on_error)
        pn_reactor_set_global_handler(self._impl, impl)
        pn_decref(impl)

    global_handler = property(_get_global, _set_global)

    def _get_timeout(self):
        return millis2timeout(pn_reactor_get_timeout(self._impl))

    def _set_timeout(self, secs):
        return pn_reactor_set_timeout(self._impl, timeout2millis(secs))

    timeout = property(_get_timeout, _set_timeout)

    def yield_(self):
        pn_reactor_yield(self._impl)

    def mark(self):
        return pn_reactor_mark(self._impl)

    def _get_handler(self):
        return WrappedHandler.wrap(pn_reactor_get_handler(self._impl), self.on_error)

    def _set_handler(self, handler):
        impl = _chandler(handler, self.on_error)
        pn_reactor_set_handler(self._impl, impl)
        pn_decref(impl)

    handler = property(_get_handler, _set_handler)

    def run(self):
        self.timeout = 3.14159265359
        self.start()
        while self.process(): pass
        self.stop()

    def wakeup(self):
        n = pn_reactor_wakeup(self._impl)
        if n: raise IOError(pn_error_text(pn_io_error(pn_reactor_io(self._impl))))

    def start(self):
        pn_reactor_start(self._impl)

    @property
    def quiesced(self):
        return pn_reactor_quiesced(self._impl)

    def _check_errors(self):
        if self.errors:
            for exc, value, tb in self.errors[:-1]:
                traceback.print_exception(exc, value, tb)
            exc, value, tb = self.errors[-1]
            _compat.raise_(exc, value, tb)

    def process(self):
        result = pn_reactor_process(self._impl)
        self._check_errors()
        return result

    def stop(self):
        pn_reactor_stop(self._impl)
        self._check_errors()
        self.global_handler = None
        self.handler = None

    def schedule(self, delay, task):
        impl = _chandler(task, self.on_error)
        task = Task.wrap(pn_reactor_schedule(self._impl, secs2millis(delay), impl))
        pn_decref(impl)
        return task

    def acceptor(self, host, port, handler=None):
        impl = _chandler(handler, self.on_error)
        aimpl = pn_reactor_acceptor(self._impl, unicode2utf8(host), str(port), impl)
        pn_decref(impl)
        if aimpl:
            return Acceptor(aimpl)
        else:
            raise IOError(""%s (%s:%s)"" % (pn_error_text(pn_io_error(pn_reactor_io(self._impl))), host, port))

    def connection(self, handler=None):
        impl = _chandler(handler, self.on_error)
        result = Connection.wrap(pn_reactor_connection(self._impl, impl))
        pn_decref(impl)
        return result

    def selectable(self, handler=None):
        impl = _chandler(handler, self.on_error)
        result = Selectable.wrap(pn_reactor_selectable(self._impl))
        if impl:
            record = pn_selectable_attachments(result._impl)
            pn_record_set_handler(record, impl)
            pn_decref(impl)
        return result

    def update(self, sel):
        pn_reactor_update(self._impl, sel._impl)

    def push_event(self, obj, etype):
        pn_collector_put(pn_reactor_collector(self._impl), PN_PYREF, pn_py2void(obj), etype.number)

from proton import wrappers as _wrappers
_wrappers[""pn_reactor""] = lambda x: Reactor.wrap(pn_cast_pn_reactor(x))
_wrappers[""pn_task""] = lambda x: Task.wrap(pn_cast_pn_task(x))


class EventInjector(object):
    """"""
    Can be added to a reactor to allow events to be triggered by an
    external thread but handled on the event thread associated with
    the reactor. An instance of this class can be passed to the
    Reactor.selectable() method of the reactor in order to activate
    it. The close() method should be called when it is no longer
    needed, to allow the event loop to end if needed.
    """"""
    def __init__(self):
        self.queue = Queue.Queue()
        self.pipe = os.pipe()
        self._closed = False

    def trigger(self, event):
        """"""
        Request that the given event be dispatched on the event thread
        of the reactor to which this EventInjector was added.
        """"""
        self.queue.put(event)
        os.write(self.pipe[1], _compat.str2bin(""!""))

    def close(self):
        """"""
        Request that this EventInjector be closed. Existing events
        will be dispctahed on the reactors event dispactch thread,
        then this will be removed from the set of interest.
        """"""
        self._closed = True
        os.write(self.pipe[1], _compat.str2bin(""!""))

    def fileno(self):
        return self.pipe[0]

    def on_selectable_init(self, event):
        sel = event.context
        sel.fileno(self.fileno())
        sel.reading = True
        event.reactor.update(sel)

    def on_selectable_readable(self, event):
        os.read(self.pipe[0], 512)
        while not self.queue.empty():
            requested = self.queue.get()
            event.reactor.push_event(requested.context, requested.type)
        if self._closed:
            s = event.context
            s.terminate()
            event.reactor.update(s)


class ApplicationEvent(EventBase):
    """"""
    Application defined event, which can optionally be associated with
    an engine object and or an arbitrary subject
    """"""
    def __init__(self, typename, connection=None, session=None, link=None, delivery=None, subject=None):
        super(ApplicationEvent, self).__init__(PN_PYREF, self, EventType(typename))
        self.connection = connection
        self.session = session
        self.link = link
        self.delivery = delivery
        if self.delivery:
            self.link = self.delivery.link
        if self.link:
            self.session = self.link.session
        if self.session:
            self.connection = self.session.connection
        self.subject = subject

    def __repr__(self):
        objects = [self.connection, self.session, self.link, self.delivery, self.subject]
        return ""%s(%s)"" % (self.type, "", "".join([str(o) for o in objects if o is not None]))

class Transaction(object):
    """"""
    Class to track state of an AMQP 1.0 transaction.
    """"""
    def __init__(self, txn_ctrl, handler, settle_before_discharge=False):
        self.txn_ctrl = txn_ctrl
        self.handler = handler
        self.id = None
        self._declare = None
        self._discharge = None
        self.failed = False
        self._pending = []
        self.settle_before_discharge = settle_before_discharge
        self.declare()

    def commit(self):
        self.discharge(False)

    def abort(self):
        self.discharge(True)

    def declare(self):
        self._declare = self._send_ctrl(symbol(u'amqp:declare:list'), [None])

    def discharge(self, failed):
        self.failed = failed
        self._discharge = self._send_ctrl(symbol(u'amqp:discharge:list'), [self.id, failed])

    def _send_ctrl(self, descriptor, value):
        delivery = self.txn_ctrl.send(Message(body=Described(descriptor, value)))
        delivery.transaction = self
        return delivery

    def send(self, sender, msg, tag=None):
        dlv = sender.send(msg, tag=tag)
        dlv.local.data = [self.id]
        dlv.update(0x34)
        return dlv

    def accept(self, delivery):
        self.update(delivery, PN_ACCEPTED)
        if self.settle_before_discharge:
            delivery.settle()
        else:
            self._pending.append(delivery)

    def update(self, delivery, state=None):
        if state:
            delivery.local.data = [self.id, Described(ulong(state), [])]
            delivery.update(0x34)

    def _release_pending(self):
        for d in self._pending:
            d.update(Delivery.RELEASED)
            d.settle()
        self._clear_pending()

    def _clear_pending(self):
        self._pending = []

    def handle_outcome(self, event):
        if event.delivery == self._declare:
            if event.delivery.remote.data:
                self.id = event.delivery.remote.data[0]
                self.handler.on_transaction_declared(event)
            elif event.delivery.remote_state == Delivery.REJECTED:
                self.handler.on_transaction_declare_failed(event)
            else:
                logging.warning(""Unexpected outcome for declare: %s"" % event.delivery.remote_state)
                self.handler.on_transaction_declare_failed(event)
        elif event.delivery == self._discharge:
            if event.delivery.remote_state == Delivery.REJECTED:
                if not self.failed:
                    self.handler.on_transaction_commit_failed(event)
                    self._release_pending() # make this optional?
            else:
                if self.failed:
                    self.handler.on_transaction_aborted(event)
                    self._release_pending()
                else:
                    self.handler.on_transaction_committed(event)
            self._clear_pending()

class LinkOption(object):
    """"""
    Abstract interface for link configuration options
    """"""
    def apply(self, link):
        """"""
        Subclasses will implement any configuration logic in this
        method
        """"""
        pass
    def test(self, link):
        """"""
        Subclasses can override this to selectively apply an option
        e.g. based on some link criteria
        """"""
        return True

class AtMostOnce(LinkOption):
    def apply(self, link):
        link.snd_settle_mode = Link.SND_SETTLED

class AtLeastOnce(LinkOption):
    def apply(self, link):
        link.snd_settle_mode = Link.SND_UNSETTLED
        link.rcv_settle_mode = Link.RCV_FIRST

class SenderOption(LinkOption):
    def apply(self, sender): pass
    def test(self, link): return link.is_sender

class ReceiverOption(LinkOption):
    def apply(self, receiver): pass
    def test(self, link): return link.is_receiver

class DynamicNodeProperties(LinkOption):
    def __init__(self, props={}):
        self.properties = {}
        for k in props:
            if isinstance(k, symbol):
                self.properties[k] = props[k]
            else:
                self.properties[symbol(k)] = props[k]

    def apply(self, link):
        if link.is_receiver:
            link.source.properties.put_dict(self.properties)
        else:
            link.target.properties.put_dict(self.properties)

class Filter(ReceiverOption):
    def __init__(self, filter_set={}):
        self.filter_set = filter_set

    def apply(self, receiver):
        receiver.source.filter.put_dict(self.filter_set)

class Selector(Filter):
    """"""
    Configures a link with a message selector filter
    """"""
    def __init__(self, value, name='selector'):
        super(Selector, self).__init__({symbol(name): Described(symbol('apache.org:selector-filter:string'), value)})

class DurableSubscription(ReceiverOption):
    def apply(self, receiver):
        receiver.source.durability = Terminus.DELIVERIES
        receiver.source.expiry_policy = Terminus.EXPIRE_NEVER

class Move(ReceiverOption):
    def apply(self, receiver):
        receiver.source.distribution_mode = Terminus.DIST_MODE_MOVE

class Copy(ReceiverOption):
    def apply(self, receiver):
        receiver.source.distribution_mode = Terminus.DIST_MODE_COPY

def _apply_link_options(options, link):
    if options:
        if isinstance(options, list):
            for o in options:
                if o.test(link): o.apply(link)
        else:
            if options.test(link): options.apply(link)

def _create_session(connection, handler=None):
    session = connection.session()
    session.open()
    return session


def _get_attr(target, name):
    if hasattr(target, name):
        return getattr(target, name)
    else:
        return None

class SessionPerConnection(object):
    def __init__(self):
        self._default_session = None

    def session(self, connection):
        if not self._default_session:
            self._default_session = _create_session(connection)
            self._default_session.context = self
        return self._default_session

    def on_session_remote_close(self, event):
        event.connection.close()
        self._default_session = None

class GlobalOverrides(object):
    """"""
    Internal handler that triggers the necessary socket connect for an
    opened connection.
    """"""
    def __init__(self, base):
        self.base = base

    def on_unhandled(self, name, event):
        if not self._override(event):
            event.dispatch(self.base)

    def _override(self, event):
        conn = event.connection
        return conn and hasattr(conn, '_overrides') and event.dispatch(conn._overrides)

class Connector(Handler):
    """"""
    Internal handler that triggers the necessary socket connect for an
    opened connection.
    """"""
    def __init__(self, connection):
        self.connection = connection
        self.address = None
        self.heartbeat = None
        self.reconnect = None
        self.ssl_domain = None
        self.allow_insecure_mechs = True
        self.allowed_mechs = None
        self.sasl_enabled = True
        self.user = None
        self.password = None

    def _connect(self, connection):
        url = self.address.next()
        # IoHandler uses the hostname to determine where to try to connect to
        connection.hostname = ""%s:%s"" % (url.host, url.port)
        logging.info(""connecting to %s..."" % connection.hostname)

        transport = Transport()
        if self.sasl_enabled:
            sasl = transport.sasl()
            sasl.allow_insecure_mechs = self.allow_insecure_mechs
            if url.username:
                connection.user = url.username
            elif self.user:
                connection.user = self.user
            if url.password:
                connection.password = url.password
            elif self.password:
                connection.password = self.password
            if self.allowed_mechs:
                sasl.allowed_mechs(self.allowed_mechs)
        transport.bind(connection)
        if self.heartbeat:
            transport.idle_timeout = self.heartbeat
        if url.scheme == 'amqps':
            if not self.ssl_domain:
                raise SSLUnavailable(""amqps: SSL libraries not found"")
            self.ssl = SSL(transport, self.ssl_domain)
            self.ssl.peer_hostname = url.host

    def on_connection_local_open(self, event):
        self._connect(event.connection)

    def on_connection_remote_open(self, event):
        logging.info(""connected to %s"" % event.connection.hostname)
        if self.reconnect:
            self.reconnect.reset()
            self.transport = None

    def on_transport_tail_closed(self, event):
        self.on_transport_closed(event)

    def on_transport_closed(self, event):
        if self.connection and self.connection.state & Endpoint.LOCAL_ACTIVE:
            if self.reconnect:
                event.transport.unbind()
                delay = self.reconnect.next()
                if delay == 0:
                    logging.info(""Disconnected, reconnecting..."")
                    self._connect(self.connection)
                else:
                    logging.info(""Disconnected will try to reconnect after %s seconds"" % delay)
                    event.reactor.schedule(delay, self)
            else:
                logging.info(""Disconnected"")
                self.connection = None

    def on_timer_task(self, event):
        self._connect(self.connection)

    def on_connection_remote_close(self, event):
        self.connection = None

class Backoff(object):
    """"""
    A reconnect strategy involving an increasing delay between
    retries, up to a maximum or 10 seconds.
    """"""
    def __init__(self):
        self.delay = 0

    def reset(self):
        self.delay = 0

    def next(self):
        current = self.delay
        if current == 0:
            self.delay = 0.1
        else:
            self.delay = min(10, 2*current)
        return current

class Urls(object):
    def __init__(self, values):
        self.values = [Url(v) for v in values]
        self.i = iter(self.values)

    def __iter__(self):
        return self

    def next(self):
        try:
            return next(self.i)
        except StopIteration:
            self.i = iter(self.values)
            return next(self.i)

class SSLConfig(object):
    def __init__(self):
        self.client = SSLDomain(SSLDomain.MODE_CLIENT)
        self.server = SSLDomain(SSLDomain.MODE_SERVER)

    def set_credentials(self, cert_file, key_file, password):
        self.client.set_credentials(cert_file, key_file, password)
        self.server.set_credentials(cert_file, key_file, password)

    def set_trusted_ca_db(self, certificate_db):
        self.client.set_trusted_ca_db(certificate_db)
        self.server.set_trusted_ca_db(certificate_db)


class Container(Reactor):
    """"""A representation of the AMQP concept of a 'container', which
       lossely speaking is something that establishes links to or from
       another container, over which messages are transfered. This is
       an extension to the Reactor class that adds convenience methods
       for creating connections and sender- or receiver- links.
    """"""
    def __init__(self, *handlers, **kwargs):
        super(Container, self).__init__(*handlers, **kwargs)
        if ""impl"" not in kwargs:
            try:
                self.ssl = SSLConfig()
            except SSLUnavailable:
                self.ssl = None
            self.global_handler = GlobalOverrides(kwargs.get('global_handler', self.global_handler))
            self.trigger = None
            self.container_id = str(generate_uuid())
            self.allow_insecure_mechs = True
            self.allowed_mechs = None
            self.sasl_enabled = True
            self.user = None
            self.password = None
            Wrapper.__setattr__(self, 'subclass', self.__class__)

    def connect(self, url=None, urls=None, address=None, handler=None, reconnect=None, heartbeat=None, ssl_domain=None, **kwargs):
        """"""
        Initiates the establishment of an AMQP connection. Returns an
        instance of proton.Connection.

        @param url: URL string of process to connect to

        @param urls: list of URL strings of process to try to connect to

        Only one of url or urls should be specified.

        @param reconnect: A value of False will prevent the library
        form automatically trying to reconnect if the underlying
        socket is disconnected before the connection has been closed.

        @param heartbeat: A value in milliseconds indicating the
        desired frequency of heartbeats used to test the underlying
        socket is alive.

        @param ssl_domain: SSL configuration in the form of an
        instance of proton.SSLdomain.

        @param handler: a connection scoped handler that will be
        called to process any events in the scope of this connection
        or its child links

        @param kwargs: sasl_enabled, which determines whether a sasl
        layer is used for the connection; allowed_mechs an optional
        list of SASL mechanisms to allow if sasl is enabled;
        allow_insecure_mechs a flag indicating whether insecure
        mechanisms, such as PLAIN over a non-encrypted socket, are
        allowed. These options can also be set at container scope.

        """"""
        conn = self.connection(handler)
        conn.container = self.container_id or str(generate_uuid())
        
        conn.offered_capabilities = kwargs.get('offered_capabilities')
        conn.desired_capabilities = kwargs.get('desired_capabilities')
        conn.properties = kwargs.get('properties')
        
        connector = Connector(conn)
        connector.allow_insecure_mechs = kwargs.get('allow_insecure_mechs', self.allow_insecure_mechs)
        connector.allowed_mechs = kwargs.get('allowed_mechs', self.allowed_mechs)
        connector.sasl_enabled = kwargs.get('sasl_enabled', self.sasl_enabled)
        connector.user = kwargs.get('user', self.user)
        connector.password = kwargs.get('password', self.password)
        conn._overrides = connector
        if url: connector.address = Urls([url])
        elif urls: connector.address = Urls(urls)
        elif address: connector.address = address
        else: raise ValueError(""One of url, urls or address required"")
        if heartbeat:
            connector.heartbeat = heartbeat
        if reconnect:
            connector.reconnect = reconnect
        elif reconnect is None:
            connector.reconnect = Backoff()
        # use container's default client domain if none specified.  This is
        # only necessary of the URL specifies the ""amqps:"" scheme
        connector.ssl_domain = ssl_domain or (self.ssl and self.ssl.client)
        conn._session_policy = SessionPerConnection() #todo: make configurable
        conn.open()
        return conn

    def _get_id(self, container, remote, local):
        if local and remote: ""%s-%s-%s"" % (container, remote, local)
        elif local: return ""%s-%s"" % (container, local)
        elif remote: return ""%s-%s"" % (container, remote)
        else: return ""%s-%s"" % (container, str(generate_uuid()))

    def _get_session(self, context):
        if isinstance(context, Url):
            return self._get_session(self.connect(url=context))
        elif isinstance(context, Session):
            return context
        elif isinstance(context, Connection):
            if hasattr(context, '_session_policy'):
                return context._session_policy.session(context)
            else:
                return _create_session(context)
        else:
            return context.session()

    def create_sender(self, context, target=None, source=None, name=None, handler=None, tags=None, options=None):
        """"""
        Initiates the establishment of a link over which messages can
        be sent. Returns an instance of proton.Sender.

        There are two patterns of use. (1) A connection can be passed
        as the first argument, in which case the link is established
        on that connection. In this case the target address can be
        specified as the second argument (or as a keyword
        argument). The source address can also be specified if
        desired. (2) Alternatively a URL can be passed as the first
        argument. In this case a new connection will be establised on
        which the link will be attached. If a path is specified and
        the target is not, then the path of the URL is used as the
        target address.

        The name of the link may be specified if desired, otherwise a
        unique name will be generated.

        Various LinkOptions can be specified to further control the
        attachment.
        """"""
        if isinstance(context, _compat.STRING_TYPES):
            context = Url(context)
        if isinstance(context, Url) and not target:
            target = context.path
        session = self._get_session(context)
        snd = session.sender(name or self._get_id(session.connection.container, target, source))
        if source:
            snd.source.address = source
        if target:
            snd.target.address = target
        if handler != None:
            snd.handler = handler
        if tags:
            snd.tag_generator = tags
        _apply_link_options(options, snd)
        snd.open()
        return snd

    def create_receiver(self, context, source=None, target=None, name=None, dynamic=False, handler=None, options=None):
        """"""
        Initiates the establishment of a link over which messages can
        be received (aka a subscription). Returns an instance of
        proton.Receiver.

        There are two patterns of use. (1) A connection can be passed
        as the first argument, in which case the link is established
        on that connection. In this case the source address can be
        specified as the second argument (or as a keyword
        argument). The target address can also be specified if
        desired. (2) Alternatively a URL can be passed as the first
        argument. In this case a new connection will be establised on
        which the link will be attached. If a path is specified and
        the source is not, then the path of the URL is used as the
        target address.

        The name of the link may be specified if desired, otherwise a
        unique name will be generated.

        Various LinkOptions can be specified to further control the
        attachment.
        """"""
        if isinstance(context, _compat.STRING_TYPES):
            context = Url(context)
        if isinstance(context, Url) and not source:
            source = context.path
        session = self._get_session(context)
        rcv = session.receiver(name or self._get_id(session.connection.container, source, target))
        if source:
            rcv.source.address = source
        if dynamic:
            rcv.source.dynamic = True
        if target:
            rcv.target.address = target
        if handler != None:
            rcv.handler = handler
        _apply_link_options(options, rcv)
        rcv.open()
        return rcv

    def declare_transaction(self, context, handler=None, settle_before_discharge=False):
        if not _get_attr(context, '_txn_ctrl'):
            class InternalTransactionHandler(OutgoingMessageHandler):
                def __init__(self):
                    super(InternalTransactionHandler, self).__init__(auto_settle=True)

                def on_settled(self, event):
                    if hasattr(event.delivery, ""transaction""):
                        event.transaction = event.delivery.transaction
                        event.delivery.transaction.handle_outcome(event)
            context._txn_ctrl = self.create_sender(context, None, name='txn-ctrl', handler=InternalTransactionHandler())
            context._txn_ctrl.target.type = Terminus.COORDINATOR
            context._txn_ctrl.target.capabilities.put_object(symbol(u'amqp:local-transactions'))
        return Transaction(context._txn_ctrl, handler, settle_before_discharge)

    def listen(self, url, ssl_domain=None):
        """"""
        Initiates a server socket, accepting incoming AMQP connections
        on the interface and port specified.
        """"""
        url = Url(url)
        acceptor = self.acceptor(url.host, url.port)
        ssl_config = ssl_domain
        if not ssl_config and url.scheme == 'amqps':
            # use container's default server domain
            if self.ssl:
                ssl_config = self.ssl.server
            else:
                raise SSLUnavailable(""amqps: SSL libraries not found"")
        if ssl_config:
            acceptor.set_ssl_domain(ssl_config)
        return acceptor

    def do_work(self, timeout=None):
        if timeout:
            self.timeout = timeout
        return self.process()
",1
CVE-2016-4433,xwork-core/src/main/java/com/opensymphony/xwork2/DefaultActionInvocation.java,"/*
 * Copyright 2002-2006,2009 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.opensymphony.xwork2;

import com.opensymphony.xwork2.config.ConfigurationException;
import com.opensymphony.xwork2.config.entities.ActionConfig;
import com.opensymphony.xwork2.config.entities.InterceptorMapping;
import com.opensymphony.xwork2.config.entities.ResultConfig;
import com.opensymphony.xwork2.inject.Container;
import com.opensymphony.xwork2.inject.Inject;
import com.opensymphony.xwork2.interceptor.PreResultListener;
import com.opensymphony.xwork2.ognl.OgnlUtil;
import com.opensymphony.xwork2.util.ValueStack;
import com.opensymphony.xwork2.util.ValueStackFactory;
import com.opensymphony.xwork2.util.logging.Logger;
import com.opensymphony.xwork2.util.logging.LoggerFactory;
import com.opensymphony.xwork2.util.profiling.UtilTimerStack;
import ognl.MethodFailedException;
import ognl.NoSuchPropertyException;
import ognl.OgnlException;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;


/**
 * The Default ActionInvocation implementation
 *
 * @author Rainer Hermanns
 * @author tmjee
 * @version $Date$ $Id$
 * @see com.opensymphony.xwork2.DefaultActionProxy
 */
public class DefaultActionInvocation implements ActionInvocation {

    private static final Logger LOG = LoggerFactory.getLogger(DefaultActionInvocation.class);

    protected Object action;
    protected ActionProxy proxy;
    protected List<PreResultListener> preResultListeners;
    protected Map<String, Object> extraContext;
    protected ActionContext invocationContext;
    protected Iterator<InterceptorMapping> interceptors;
    protected ValueStack stack;
    protected Result result;
    protected Result explicitResult;
    protected String resultCode;
    protected boolean executed = false;
    protected boolean pushAction = true;
    protected ObjectFactory objectFactory;
    protected ActionEventListener actionEventListener;
    protected ValueStackFactory valueStackFactory;
    protected Container container;
    protected UnknownHandlerManager unknownHandlerManager;
    protected OgnlUtil ognlUtil;

    public DefaultActionInvocation(final Map<String, Object> extraContext, final boolean pushAction) {
        this.extraContext = extraContext;
        this.pushAction = pushAction;
    }

    @Inject
    public void setUnknownHandlerManager(UnknownHandlerManager unknownHandlerManager) {
        this.unknownHandlerManager = unknownHandlerManager;
    }

    @Inject
    public void setValueStackFactory(ValueStackFactory fac) {
        this.valueStackFactory = fac;
    }

    @Inject
    public void setObjectFactory(ObjectFactory fac) {
        this.objectFactory = fac;
    }

    @Inject
    public void setContainer(Container cont) {
        this.container = cont;
    }

    @Inject(required=false)
    public void setActionEventListener(ActionEventListener listener) {
        this.actionEventListener = listener;
    }

    @Inject
    public void setOgnlUtil(OgnlUtil ognlUtil) {
        this.ognlUtil = ognlUtil;
    }

    public Object getAction() {
        return action;
    }

    public boolean isExecuted() {
        return executed;
    }

    public ActionContext getInvocationContext() {
        return invocationContext;
    }

    public ActionProxy getProxy() {
        return proxy;
    }

    /**
     * If the DefaultActionInvocation has been executed before and the Result is an instance of ActionChainResult, this method
     * will walk down the chain of ActionChainResults until it finds a non-chain result, which will be returned. If the
     * DefaultActionInvocation's result has not been executed before, the Result instance will be created and populated with
     * the result params.
     *
     * @return a Result instance
     * @throws Exception
     */
    public Result getResult() throws Exception {
        Result returnResult = result;

        // If we've chained to other Actions, we need to find the last result
        while (returnResult instanceof ActionChainResult) {
            ActionProxy aProxy = ((ActionChainResult) returnResult).getProxy();

            if (aProxy != null) {
                Result proxyResult = aProxy.getInvocation().getResult();

                if ((proxyResult != null) && (aProxy.getExecuteResult())) {
                    returnResult = proxyResult;
                } else {
                    break;
                }
            } else {
                break;
            }
        }

        return returnResult;
    }

    public String getResultCode() {
        return resultCode;
    }

    public void setResultCode(String resultCode) {
        if (isExecuted())
            throw new IllegalStateException(""Result has already been executed."");

        this.resultCode = resultCode;
    }


    public ValueStack getStack() {
        return stack;
    }

    /**
     * Register a com.opensymphony.xwork2.interceptor.PreResultListener to be notified after the Action is executed and before the
     * Result is executed. The ActionInvocation implementation must guarantee that listeners will be called in the order
     * in which they are registered. Listener registration and execution does not need to be thread-safe.
     *
     * @param listener to register
     */
    public void addPreResultListener(PreResultListener listener) {
        if (preResultListeners == null) {
            preResultListeners = new ArrayList<PreResultListener>(1);
        }

        preResultListeners.add(listener);
    }

    public Result createResult() throws Exception {
        LOG.trace(""Creating result related to resultCode [#0]"", resultCode);

        if (explicitResult != null) {
            Result ret = explicitResult;
            explicitResult = null;

            return ret;
        }
        ActionConfig config = proxy.getConfig();
        Map<String, ResultConfig> results = config.getResults();

        ResultConfig resultConfig = null;

        try {
            resultConfig = results.get(resultCode);
        } catch (NullPointerException e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Got NPE trying to read result configuration for resultCode [#0]"", resultCode);
            }
        }
        
        if (resultConfig == null) {
            // If no result is found for the given resultCode, try to get a wildcard '*' match.
            resultConfig = results.get(""*"");
        }

        if (resultConfig != null) {
            try {
                return objectFactory.buildResult(resultConfig, invocationContext.getContextMap());
            } catch (Exception e) {
                if (LOG.isErrorEnabled()) {
                    LOG.error(""There was an exception while instantiating the result of type #0"", e, resultConfig.getClassName());
                }
                throw new XWorkException(e, resultConfig);
            }
        } else if (resultCode != null && !Action.NONE.equals(resultCode) && unknownHandlerManager.hasUnknownHandlers()) {
            return unknownHandlerManager.handleUnknownResult(invocationContext, proxy.getActionName(), proxy.getConfig(), resultCode);
        }
        return null;
    }

    /**
     * @throws ConfigurationException If no result can be found with the returned code
     */
    public String invoke() throws Exception {
        String profileKey = ""invoke: "";
        try {
            UtilTimerStack.push(profileKey);

            if (executed) {
                throw new IllegalStateException(""Action has already executed"");
            }

            if (interceptors.hasNext()) {
                final InterceptorMapping interceptor = interceptors.next();
                String interceptorMsg = ""interceptor: "" + interceptor.getName();
                UtilTimerStack.push(interceptorMsg);
                try {
                                resultCode = interceptor.getInterceptor().intercept(DefaultActionInvocation.this);
                            }
                finally {
                    UtilTimerStack.pop(interceptorMsg);
                }
            } else {
                resultCode = invokeActionOnly();
            }

            // this is needed because the result will be executed, then control will return to the Interceptor, which will
            // return above and flow through again
            if (!executed) {
                if (preResultListeners != null) {
                    LOG.trace(""Executing PreResultListeners for result [#0]"", result);

                    for (Object preResultListener : preResultListeners) {
                        PreResultListener listener = (PreResultListener) preResultListener;

                        String _profileKey = ""preResultListener: "";
                        try {
                            UtilTimerStack.push(_profileKey);
                            listener.beforeResult(this, resultCode);
                        }
                        finally {
                            UtilTimerStack.pop(_profileKey);
                        }
                    }
                }

                // now execute the result, if we're supposed to
                if (proxy.getExecuteResult()) {
                    executeResult();
                }

                executed = true;
            }

            return resultCode;
        }
        finally {
            UtilTimerStack.pop(profileKey);
        }
    }

    public String invokeActionOnly() throws Exception {
        return invokeAction(getAction(), proxy.getConfig());
    }

    protected void createAction(Map<String, Object> contextMap) {
        // load action
        String timerKey = ""actionCreate: "" + proxy.getActionName();
        try {
            UtilTimerStack.push(timerKey);
            action = objectFactory.buildAction(proxy.getActionName(), proxy.getNamespace(), proxy.getConfig(), contextMap);
        } catch (InstantiationException e) {
            throw new XWorkException(""Unable to intantiate Action!"", e, proxy.getConfig());
        } catch (IllegalAccessException e) {
            throw new XWorkException(""Illegal access to constructor, is it public?"", e, proxy.getConfig());
        } catch (Exception e) {
            String gripe;

            if (proxy == null) {
                gripe = ""Whoa!  No ActionProxy instance found in current ActionInvocation.  This is bad ... very bad"";
            } else if (proxy.getConfig() == null) {
                gripe = ""Sheesh.  Where'd that ActionProxy get to?  I can't find it in the current ActionInvocation!?"";
            } else if (proxy.getConfig().getClassName() == null) {
                gripe = ""No Action defined for '"" + proxy.getActionName() + ""' in namespace '"" + proxy.getNamespace() + ""'"";
            } else {
                gripe = ""Unable to instantiate Action, "" + proxy.getConfig().getClassName() + "",  defined for '"" + proxy.getActionName() + ""' in namespace '"" + proxy.getNamespace() + ""'"";
            }

            gripe += ((("" -- "" + e.getMessage()) != null) ? e.getMessage() : "" [no message in exception]"");
            throw new XWorkException(gripe, e, proxy.getConfig());
        } finally {
            UtilTimerStack.pop(timerKey);
        }

        if (actionEventListener != null) {
            action = actionEventListener.prepare(action, stack);
        }
    }

    protected Map<String, Object> createContextMap() {
        Map<String, Object> contextMap;

        if ((extraContext != null) && (extraContext.containsKey(ActionContext.VALUE_STACK))) {
            // In case the ValueStack was passed in
            stack = (ValueStack) extraContext.get(ActionContext.VALUE_STACK);

            if (stack == null) {
                throw new IllegalStateException(""There was a null Stack set into the extra params."");
            }

            contextMap = stack.getContext();
        } else {
            // create the value stack
            // this also adds the ValueStack to its context
            stack = valueStackFactory.createValueStack();

            // create the action context
            contextMap = stack.getContext();
        }

        // put extraContext in
        if (extraContext != null) {
            contextMap.putAll(extraContext);
        }

        //put this DefaultActionInvocation into the context map
        contextMap.put(ActionContext.ACTION_INVOCATION, this);
        contextMap.put(ActionContext.CONTAINER, container);

        return contextMap;
    }

    /**
     * Uses getResult to get the final Result and executes it
     *
     * @throws ConfigurationException If not result can be found with the returned code
     */
    private void executeResult() throws Exception {
        result = createResult();

        String timerKey = ""executeResult: "" + getResultCode();
        try {
            UtilTimerStack.push(timerKey);
            if (result != null) {
                result.execute(this);
            } else if (resultCode != null && !Action.NONE.equals(resultCode)) {
                throw new ConfigurationException(""No result defined for action "" + getAction().getClass().getName()
                        + "" and result "" + getResultCode(), proxy.getConfig());
            } else {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""No result returned for action "" + getAction().getClass().getName() + "" at "" + proxy.getConfig().getLocation());
                }
            }
        } finally {
            UtilTimerStack.pop(timerKey);
        }
    }

    public void init(ActionProxy proxy) {
        this.proxy = proxy;
        Map<String, Object> contextMap = createContextMap();

        // Setting this so that other classes, like object factories, can use the ActionProxy and other
        // contextual information to operate
        ActionContext actionContext = ActionContext.getContext();

        if (actionContext != null) {
            actionContext.setActionInvocation(this);
        }

        createAction(contextMap);

        if (pushAction) {
            stack.push(action);
            contextMap.put(""action"", action);
        }

        invocationContext = new ActionContext(contextMap);
        invocationContext.setName(proxy.getActionName());

        createInterceptors(proxy);
    }

    protected void createInterceptors(ActionProxy proxy) {
        // get a new List so we don't get problems with the iterator if someone changes the list
        List<InterceptorMapping> interceptorList = new ArrayList<InterceptorMapping>(proxy.getConfig().getInterceptors());
        interceptors = interceptorList.iterator();
    }

    protected String invokeAction(Object action, ActionConfig actionConfig) throws Exception {
        String methodName = proxy.getMethod();

        if (LOG.isDebugEnabled()) {
            LOG.debug(""Executing action method = #0"", methodName);
        }

        String timerKey = ""invokeAction: "" + proxy.getActionName();
        try {
            UtilTimerStack.push(timerKey);

            Object methodResult;
            try {
                methodResult = ognlUtil.getValue(methodName + ""()"", getStack().getContext(), action);
            } catch (MethodFailedException e) {
                // if reason is missing method, try find version with ""do"" prefix
                if (e.getReason() instanceof NoSuchMethodException) {
                    try {
                        String altMethodName = ""do"" + methodName.substring(0, 1).toUpperCase() + methodName.substring(1) + ""()"";
                        methodResult = ognlUtil.getValue(altMethodName, getStack().getContext(), action);
                    } catch (MethodFailedException e1) {
                        // if still method doesn't exist, try checking UnknownHandlers
                        if (e1.getReason() instanceof NoSuchMethodException) {
                            if (unknownHandlerManager.hasUnknownHandlers()) {
                                try {
                                    methodResult = unknownHandlerManager.handleUnknownMethod(action, methodName);
                                } catch (NoSuchMethodException e2) {
                                    // throw the original one
                                    throw e;
                                }
                            } else {
                                // throw the original one
                                throw e;
                            }
                            // throw the original exception as UnknownHandlers weren't able to handle invocation as well
                            if (methodResult == null) {
                                throw e;
                            }
                        } else {
                            // exception isn't related to missing action method, throw it
                            throw e1;
                        }
                    }
                } else {
                    // exception isn't related to missing action method, throw it
                    throw e;
                }
            }
            return saveResult(actionConfig, methodResult);
        } catch (NoSuchPropertyException e) {
            throw new IllegalArgumentException(""The "" + methodName + ""() is not defined in action "" + getAction().getClass() + """");
        } catch (MethodFailedException e) {
            // We try to return the source exception.
            Throwable t = e.getCause();

            if (actionEventListener != null) {
                String result = actionEventListener.handleException(t, getStack());
                if (result != null) {
                    return result;
                }
            }
            if (t instanceof Exception) {
                throw (Exception) t;
            } else {
                throw e;
            }
        } finally {
            UtilTimerStack.pop(timerKey);
        }
    }

    /**
     * Save the result to be used later.
     * @param actionConfig current ActionConfig
     * @param methodResult the result of the action.
     * @return the result code to process.
     */
    protected String saveResult(ActionConfig actionConfig, Object methodResult) {
        if (methodResult instanceof Result) {
            this.explicitResult = (Result) methodResult;

            // Wire the result automatically
            container.inject(explicitResult);
            return null;
        } else {
            return (String) methodResult;
        }
    }

    /**
     * Version ready to be serialize
     *
     * @return instance without reference to {@link Container}
     */
    public ActionInvocation serialize() {
        DefaultActionInvocation that = this;
        that.container = null;
        return that;
    }

    /**
     * Restoring Container
     *
     * @param actionContext current {@link ActionContext}
     * @return instance which can be used to invoke action
     */
    public ActionInvocation deserialize(ActionContext actionContext) {
        DefaultActionInvocation that = this;
        that.container = actionContext.getContainer();
        return that;
    }

}
",0
CVE-2016-4433,xwork-core/src/main/java/com/opensymphony/xwork2/DefaultActionInvocation.java,"/*
 * Copyright 2002-2006,2009 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.opensymphony.xwork2;

import com.opensymphony.xwork2.config.ConfigurationException;
import com.opensymphony.xwork2.config.entities.ActionConfig;
import com.opensymphony.xwork2.config.entities.InterceptorMapping;
import com.opensymphony.xwork2.config.entities.ResultConfig;
import com.opensymphony.xwork2.inject.Container;
import com.opensymphony.xwork2.inject.Inject;
import com.opensymphony.xwork2.interceptor.PreResultListener;
import com.opensymphony.xwork2.ognl.OgnlUtil;
import com.opensymphony.xwork2.util.ValueStack;
import com.opensymphony.xwork2.util.ValueStackFactory;
import com.opensymphony.xwork2.util.logging.Logger;
import com.opensymphony.xwork2.util.logging.LoggerFactory;
import com.opensymphony.xwork2.util.profiling.UtilTimerStack;
import ognl.MethodFailedException;
import ognl.NoSuchPropertyException;
import ognl.OgnlException;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;


/**
 * The Default ActionInvocation implementation
 *
 * @author Rainer Hermanns
 * @author tmjee
 * @version $Date$ $Id$
 * @see com.opensymphony.xwork2.DefaultActionProxy
 */
public class DefaultActionInvocation implements ActionInvocation {

    private static final Logger LOG = LoggerFactory.getLogger(DefaultActionInvocation.class);

    protected Object action;
    protected ActionProxy proxy;
    protected List<PreResultListener> preResultListeners;
    protected Map<String, Object> extraContext;
    protected ActionContext invocationContext;
    protected Iterator<InterceptorMapping> interceptors;
    protected ValueStack stack;
    protected Result result;
    protected Result explicitResult;
    protected String resultCode;
    protected boolean executed = false;
    protected boolean pushAction = true;
    protected ObjectFactory objectFactory;
    protected ActionEventListener actionEventListener;
    protected ValueStackFactory valueStackFactory;
    protected Container container;
    protected UnknownHandlerManager unknownHandlerManager;
    protected OgnlUtil ognlUtil;

    public DefaultActionInvocation(final Map<String, Object> extraContext, final boolean pushAction) {
        this.extraContext = extraContext;
        this.pushAction = pushAction;
    }

    @Inject
    public void setUnknownHandlerManager(UnknownHandlerManager unknownHandlerManager) {
        this.unknownHandlerManager = unknownHandlerManager;
    }

    @Inject
    public void setValueStackFactory(ValueStackFactory fac) {
        this.valueStackFactory = fac;
    }

    @Inject
    public void setObjectFactory(ObjectFactory fac) {
        this.objectFactory = fac;
    }

    @Inject
    public void setContainer(Container cont) {
        this.container = cont;
    }

    @Inject(required=false)
    public void setActionEventListener(ActionEventListener listener) {
        this.actionEventListener = listener;
    }

    @Inject
    public void setOgnlUtil(OgnlUtil ognlUtil) {
        this.ognlUtil = ognlUtil;
    }

    public Object getAction() {
        return action;
    }

    public boolean isExecuted() {
        return executed;
    }

    public ActionContext getInvocationContext() {
        return invocationContext;
    }

    public ActionProxy getProxy() {
        return proxy;
    }

    /**
     * If the DefaultActionInvocation has been executed before and the Result is an instance of ActionChainResult, this method
     * will walk down the chain of ActionChainResults until it finds a non-chain result, which will be returned. If the
     * DefaultActionInvocation's result has not been executed before, the Result instance will be created and populated with
     * the result params.
     *
     * @return a Result instance
     * @throws Exception
     */
    public Result getResult() throws Exception {
        Result returnResult = result;

        // If we've chained to other Actions, we need to find the last result
        while (returnResult instanceof ActionChainResult) {
            ActionProxy aProxy = ((ActionChainResult) returnResult).getProxy();

            if (aProxy != null) {
                Result proxyResult = aProxy.getInvocation().getResult();

                if ((proxyResult != null) && (aProxy.getExecuteResult())) {
                    returnResult = proxyResult;
                } else {
                    break;
                }
            } else {
                break;
            }
        }

        return returnResult;
    }

    public String getResultCode() {
        return resultCode;
    }

    public void setResultCode(String resultCode) {
        if (isExecuted())
            throw new IllegalStateException(""Result has already been executed."");

        this.resultCode = resultCode;
    }


    public ValueStack getStack() {
        return stack;
    }

    /**
     * Register a com.opensymphony.xwork2.interceptor.PreResultListener to be notified after the Action is executed and before the
     * Result is executed. The ActionInvocation implementation must guarantee that listeners will be called in the order
     * in which they are registered. Listener registration and execution does not need to be thread-safe.
     *
     * @param listener to register
     */
    public void addPreResultListener(PreResultListener listener) {
        if (preResultListeners == null) {
            preResultListeners = new ArrayList<PreResultListener>(1);
        }

        preResultListeners.add(listener);
    }

    public Result createResult() throws Exception {
        LOG.trace(""Creating result related to resultCode [#0]"", resultCode);

        if (explicitResult != null) {
            Result ret = explicitResult;
            explicitResult = null;

            return ret;
        }
        ActionConfig config = proxy.getConfig();
        Map<String, ResultConfig> results = config.getResults();

        ResultConfig resultConfig = null;

        try {
            resultConfig = results.get(resultCode);
        } catch (NullPointerException e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Got NPE trying to read result configuration for resultCode [#0]"", resultCode);
            }
        }
        
        if (resultConfig == null) {
            // If no result is found for the given resultCode, try to get a wildcard '*' match.
            resultConfig = results.get(""*"");
        }

        if (resultConfig != null) {
            try {
                return objectFactory.buildResult(resultConfig, invocationContext.getContextMap());
            } catch (Exception e) {
                if (LOG.isErrorEnabled()) {
                    LOG.error(""There was an exception while instantiating the result of type #0"", e, resultConfig.getClassName());
                }
                throw new XWorkException(e, resultConfig);
            }
        } else if (resultCode != null && !Action.NONE.equals(resultCode) && unknownHandlerManager.hasUnknownHandlers()) {
            return unknownHandlerManager.handleUnknownResult(invocationContext, proxy.getActionName(), proxy.getConfig(), resultCode);
        }
        return null;
    }

    /**
     * @throws ConfigurationException If no result can be found with the returned code
     */
    public String invoke() throws Exception {
        String profileKey = ""invoke: "";
        try {
            UtilTimerStack.push(profileKey);

            if (executed) {
                throw new IllegalStateException(""Action has already executed"");
            }

            if (interceptors.hasNext()) {
                final InterceptorMapping interceptor = interceptors.next();
                String interceptorMsg = ""interceptor: "" + interceptor.getName();
                UtilTimerStack.push(interceptorMsg);
                try {
                                resultCode = interceptor.getInterceptor().intercept(DefaultActionInvocation.this);
                            }
                finally {
                    UtilTimerStack.pop(interceptorMsg);
                }
            } else {
                resultCode = invokeActionOnly();
            }

            // this is needed because the result will be executed, then control will return to the Interceptor, which will
            // return above and flow through again
            if (!executed) {
                if (preResultListeners != null) {
                    LOG.trace(""Executing PreResultListeners for result [#0]"", result);

                    for (Object preResultListener : preResultListeners) {
                        PreResultListener listener = (PreResultListener) preResultListener;

                        String _profileKey = ""preResultListener: "";
                        try {
                            UtilTimerStack.push(_profileKey);
                            listener.beforeResult(this, resultCode);
                        }
                        finally {
                            UtilTimerStack.pop(_profileKey);
                        }
                    }
                }

                // now execute the result, if we're supposed to
                if (proxy.getExecuteResult()) {
                    executeResult();
                }

                executed = true;
            }

            return resultCode;
        }
        finally {
            UtilTimerStack.pop(profileKey);
        }
    }

    public String invokeActionOnly() throws Exception {
        return invokeAction(getAction(), proxy.getConfig());
    }

    protected void createAction(Map<String, Object> contextMap) {
        // load action
        String timerKey = ""actionCreate: "" + proxy.getActionName();
        try {
            UtilTimerStack.push(timerKey);
            action = objectFactory.buildAction(proxy.getActionName(), proxy.getNamespace(), proxy.getConfig(), contextMap);
        } catch (InstantiationException e) {
            throw new XWorkException(""Unable to intantiate Action!"", e, proxy.getConfig());
        } catch (IllegalAccessException e) {
            throw new XWorkException(""Illegal access to constructor, is it public?"", e, proxy.getConfig());
        } catch (Exception e) {
            String gripe;

            if (proxy == null) {
                gripe = ""Whoa!  No ActionProxy instance found in current ActionInvocation.  This is bad ... very bad"";
            } else if (proxy.getConfig() == null) {
                gripe = ""Sheesh.  Where'd that ActionProxy get to?  I can't find it in the current ActionInvocation!?"";
            } else if (proxy.getConfig().getClassName() == null) {
                gripe = ""No Action defined for '"" + proxy.getActionName() + ""' in namespace '"" + proxy.getNamespace() + ""'"";
            } else {
                gripe = ""Unable to instantiate Action, "" + proxy.getConfig().getClassName() + "",  defined for '"" + proxy.getActionName() + ""' in namespace '"" + proxy.getNamespace() + ""'"";
            }

            gripe += ((("" -- "" + e.getMessage()) != null) ? e.getMessage() : "" [no message in exception]"");
            throw new XWorkException(gripe, e, proxy.getConfig());
        } finally {
            UtilTimerStack.pop(timerKey);
        }

        if (actionEventListener != null) {
            action = actionEventListener.prepare(action, stack);
        }
    }

    protected Map<String, Object> createContextMap() {
        Map<String, Object> contextMap;

        if ((extraContext != null) && (extraContext.containsKey(ActionContext.VALUE_STACK))) {
            // In case the ValueStack was passed in
            stack = (ValueStack) extraContext.get(ActionContext.VALUE_STACK);

            if (stack == null) {
                throw new IllegalStateException(""There was a null Stack set into the extra params."");
            }

            contextMap = stack.getContext();
        } else {
            // create the value stack
            // this also adds the ValueStack to its context
            stack = valueStackFactory.createValueStack();

            // create the action context
            contextMap = stack.getContext();
        }

        // put extraContext in
        if (extraContext != null) {
            contextMap.putAll(extraContext);
        }

        //put this DefaultActionInvocation into the context map
        contextMap.put(ActionContext.ACTION_INVOCATION, this);
        contextMap.put(ActionContext.CONTAINER, container);

        return contextMap;
    }

    /**
     * Uses getResult to get the final Result and executes it
     *
     * @throws ConfigurationException If not result can be found with the returned code
     */
    private void executeResult() throws Exception {
        result = createResult();

        String timerKey = ""executeResult: "" + getResultCode();
        try {
            UtilTimerStack.push(timerKey);
            if (result != null) {
                result.execute(this);
            } else if (resultCode != null && !Action.NONE.equals(resultCode)) {
                throw new ConfigurationException(""No result defined for action "" + getAction().getClass().getName()
                        + "" and result "" + getResultCode(), proxy.getConfig());
            } else {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""No result returned for action "" + getAction().getClass().getName() + "" at "" + proxy.getConfig().getLocation());
                }
            }
        } finally {
            UtilTimerStack.pop(timerKey);
        }
    }

    public void init(ActionProxy proxy) {
        this.proxy = proxy;
        Map<String, Object> contextMap = createContextMap();

        // Setting this so that other classes, like object factories, can use the ActionProxy and other
        // contextual information to operate
        ActionContext actionContext = ActionContext.getContext();

        if (actionContext != null) {
            actionContext.setActionInvocation(this);
        }

        createAction(contextMap);

        if (pushAction) {
            stack.push(action);
            contextMap.put(""action"", action);
        }

        invocationContext = new ActionContext(contextMap);
        invocationContext.setName(proxy.getActionName());

        createInterceptors(proxy);
    }

    protected void createInterceptors(ActionProxy proxy) {
        // get a new List so we don't get problems with the iterator if someone changes the list
        List<InterceptorMapping> interceptorList = new ArrayList<InterceptorMapping>(proxy.getConfig().getInterceptors());
        interceptors = interceptorList.iterator();
    }

    protected String invokeAction(Object action, ActionConfig actionConfig) throws Exception {
        String methodName = proxy.getMethod();

        if (LOG.isDebugEnabled()) {
            LOG.debug(""Executing action method = #0"", methodName);
        }

        String timerKey = ""invokeAction: "" + proxy.getActionName();
        try {
            UtilTimerStack.push(timerKey);

            Object methodResult;
            try {
                methodResult = ognlUtil.callMethod(methodName + ""()"", getStack().getContext(), action);
            } catch (MethodFailedException e) {
                // if reason is missing method, try find version with ""do"" prefix
                if (e.getReason() instanceof NoSuchMethodException) {
                    try {
                        String altMethodName = ""do"" + methodName.substring(0, 1).toUpperCase() + methodName.substring(1) + ""()"";
                        methodResult = ognlUtil.callMethod(altMethodName, getStack().getContext(), action);
                    } catch (MethodFailedException e1) {
                        // if still method doesn't exist, try checking UnknownHandlers
                        if (e1.getReason() instanceof NoSuchMethodException) {
                            if (unknownHandlerManager.hasUnknownHandlers()) {
                                try {
                                    methodResult = unknownHandlerManager.handleUnknownMethod(action, methodName);
                                } catch (NoSuchMethodException e2) {
                                    // throw the original one
                                    throw e;
                                }
                            } else {
                                // throw the original one
                                throw e;
                            }
                            // throw the original exception as UnknownHandlers weren't able to handle invocation as well
                            if (methodResult == null) {
                                throw e;
                            }
                        } else {
                            // exception isn't related to missing action method, throw it
                            throw e1;
                        }
                    }
                } else {
                    // exception isn't related to missing action method, throw it
                    throw e;
                }
            }
            return saveResult(actionConfig, methodResult);
        } catch (NoSuchPropertyException e) {
            throw new IllegalArgumentException(""The "" + methodName + ""() is not defined in action "" + getAction().getClass() + """");
        } catch (MethodFailedException e) {
            // We try to return the source exception.
            Throwable t = e.getCause();

            if (actionEventListener != null) {
                String result = actionEventListener.handleException(t, getStack());
                if (result != null) {
                    return result;
                }
            }
            if (t instanceof Exception) {
                throw (Exception) t;
            } else {
                throw e;
            }
        } finally {
            UtilTimerStack.pop(timerKey);
        }
    }

    /**
     * Save the result to be used later.
     * @param actionConfig current ActionConfig
     * @param methodResult the result of the action.
     * @return the result code to process.
     */
    protected String saveResult(ActionConfig actionConfig, Object methodResult) {
        if (methodResult instanceof Result) {
            this.explicitResult = (Result) methodResult;

            // Wire the result automatically
            container.inject(explicitResult);
            return null;
        } else {
            return (String) methodResult;
        }
    }

    /**
     * Version ready to be serialize
     *
     * @return instance without reference to {@link Container}
     */
    public ActionInvocation serialize() {
        DefaultActionInvocation that = this;
        that.container = null;
        return that;
    }

    /**
     * Restoring Container
     *
     * @param actionContext current {@link ActionContext}
     * @return instance which can be used to invoke action
     */
    public ActionInvocation deserialize(ActionContext actionContext) {
        DefaultActionInvocation that = this;
        that.container = actionContext.getContainer();
        return that;
    }

}
",1
CVE-2016-4433,xwork-core/src/main/java/com/opensymphony/xwork2/ognl/OgnlUtil.java,"/*
 * Copyright 2002-2006,2009 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.opensymphony.xwork2.ognl;

import com.opensymphony.xwork2.XWorkConstants;
import com.opensymphony.xwork2.config.ConfigurationException;
import com.opensymphony.xwork2.conversion.impl.XWorkConverter;
import com.opensymphony.xwork2.inject.Container;
import com.opensymphony.xwork2.inject.Inject;
import com.opensymphony.xwork2.ognl.accessor.CompoundRootAccessor;
import com.opensymphony.xwork2.util.CompoundRoot;
import com.opensymphony.xwork2.util.TextParseUtil;
import com.opensymphony.xwork2.util.logging.Logger;
import com.opensymphony.xwork2.util.logging.LoggerFactory;
import com.opensymphony.xwork2.util.reflection.ReflectionException;
import ognl.ClassResolver;
import ognl.Ognl;
import ognl.OgnlContext;
import ognl.OgnlException;
import ognl.OgnlRuntime;
import ognl.SimpleNode;
import ognl.TypeConverter;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.regex.Pattern;


/**
 * Utility class that provides common access to the Ognl APIs for
 * setting and getting properties from objects (usually Actions).
 *
 * @author Jason Carreira
 */
public class OgnlUtil {

    private static final Logger LOG = LoggerFactory.getLogger(OgnlUtil.class);
    private ConcurrentMap<String, Object> expressions = new ConcurrentHashMap<String, Object>();
    private final ConcurrentMap<Class, BeanInfo> beanInfoCache = new ConcurrentHashMap<Class, BeanInfo>();
    private TypeConverter defaultConverter;

    private boolean devMode = false;
    private boolean enableExpressionCache = true;
    private boolean enableEvalExpression;

    private Set<Class<?>> excludedClasses = new HashSet<Class<?>>();
    private Set<Pattern> excludedPackageNamePatterns = new HashSet<Pattern>();
    private Set<String> excludedPackageNames = new HashSet<String>();

    private Container container;
    private boolean allowStaticMethodAccess;

    @Inject
    public void setXWorkConverter(XWorkConverter conv) {
        this.defaultConverter = new OgnlTypeConverterWrapper(conv);
    }

    @Inject(XWorkConstants.DEV_MODE)
    public void setDevMode(String mode) {
        devMode = ""true"".equals(mode);
    }

    @Inject(XWorkConstants.ENABLE_OGNL_EXPRESSION_CACHE)
    public void setEnableExpressionCache(String cache) {
       enableExpressionCache = ""true"".equals(cache);
    }

    @Inject(value = XWorkConstants.ENABLE_OGNL_EVAL_EXPRESSION, required = false)
    public void setEnableEvalExpression(String evalExpression) {
        enableEvalExpression = ""true"".equals(evalExpression);
        if(enableEvalExpression){
            LOG.warn(""Enabling OGNL expression evaluation may introduce security risks "" +
                    ""(see http://struts.apache.org/release/2.3.x/docs/s2-013.html for further details)"");
        }
    }

    @Inject(value = XWorkConstants.OGNL_EXCLUDED_CLASSES, required = false)
    public void setExcludedClasses(String commaDelimitedClasses) {
        Set<String> classes = TextParseUtil.commaDelimitedStringToSet(commaDelimitedClasses);
        for (String className : classes) {
            try {
                excludedClasses.add(Class.forName(className));
            } catch (ClassNotFoundException e) {
                throw new ConfigurationException(""Cannot load excluded class: "" + className, e);
            }
        }
    }

    @Inject(value = XWorkConstants.OGNL_EXCLUDED_PACKAGE_NAME_PATTERNS, required = false)
    public void setExcludedPackageNamePatterns(String commaDelimitedPackagePatterns) {
        Set<String> packagePatterns = TextParseUtil.commaDelimitedStringToSet(commaDelimitedPackagePatterns);
        for (String pattern : packagePatterns) {
            excludedPackageNamePatterns.add(Pattern.compile(pattern));
        }
    }

    @Inject(value = XWorkConstants.OGNL_EXCLUDED_PACKAGE_NAMES, required = false)
    public void setExcludedPackageNames(String commaDelimitedPackageNames) {
        excludedPackageNames = TextParseUtil.commaDelimitedStringToSet(commaDelimitedPackageNames);
    }

    public Set<Class<?>> getExcludedClasses() {
        return excludedClasses;
    }

    public Set<Pattern> getExcludedPackageNamePatterns() {
        return excludedPackageNamePatterns;
    }

    public Set<String> getExcludedPackageNames() {
        return excludedPackageNames;
    }

    @Inject
    public void setContainer(Container container) {
        this.container = container;
    }

    @Inject(value = XWorkConstants.ALLOW_STATIC_METHOD_ACCESS, required = false)
    public void setAllowStaticMethodAccess(String allowStaticMethodAccess) {
        this.allowStaticMethodAccess = Boolean.parseBoolean(allowStaticMethodAccess);
    }

    /**
     * Sets the object's properties using the default type converter, defaulting to not throw
     * exceptions for problems setting the properties.
     *
     * @param props   the properties being set
     * @param o       the object
     * @param context the action context
     */
    public void setProperties(Map<String, ?> props, Object o, Map<String, Object> context) {
        setProperties(props, o, context, false);
    }

    /**
     * Sets the object's properties using the default type converter.
     *
     * @param props                   the properties being set
     * @param o                       the object
     * @param context                 the action context
     * @param throwPropertyExceptions boolean which tells whether it should throw exceptions for
     *                                problems setting the properties
     */
    public void setProperties(Map<String, ?> props, Object o, Map<String, Object> context, boolean throwPropertyExceptions) throws ReflectionException{
        if (props == null) {
            return;
        }

        Ognl.setTypeConverter(context, getTypeConverterFromContext(context));

        Object oldRoot = Ognl.getRoot(context);
        Ognl.setRoot(context, o);

        for (Map.Entry<String, ?> entry : props.entrySet()) {
            String expression = entry.getKey();
            internalSetProperty(expression, entry.getValue(), o, context, throwPropertyExceptions);
        }

        Ognl.setRoot(context, oldRoot);
    }

    /**
     * Sets the properties on the object using the default context, defaulting to not throwing
     * exceptions for problems setting the properties.
     *
     * @param properties
     * @param o
     */
    public void setProperties(Map<String, ?> properties, Object o) {
        setProperties(properties, o, false);
    }

    /**
     * Sets the properties on the object using the default context.
     *
     * @param properties              the property map to set on the object
     * @param o                       the object to set the properties into
     * @param throwPropertyExceptions boolean which tells whether it should throw exceptions for
     *                                problems setting the properties
     */
    public void setProperties(Map<String, ?> properties, Object o, boolean throwPropertyExceptions) {
        Map context = createDefaultContext(o, null);
        setProperties(properties, o, context, throwPropertyExceptions);
    }

    /**
     * Sets the named property to the supplied value on the Object, defaults to not throwing
     * property exceptions.
     *
     * @param name    the name of the property to be set
     * @param value   the value to set into the named property
     * @param o       the object upon which to set the property
     * @param context the context which may include the TypeConverter
     */
    public void setProperty(String name, Object value, Object o, Map<String, Object> context) {
        setProperty(name, value, o, context, false);
    }

    /**
     * Sets the named property to the supplied value on the Object.
     *
     * @param name                    the name of the property to be set
     * @param value                   the value to set into the named property
     * @param o                       the object upon which to set the property
     * @param context                 the context which may include the TypeConverter
     * @param throwPropertyExceptions boolean which tells whether it should throw exceptions for
     *                                problems setting the property
     */
    public void setProperty(String name, Object value, Object o, Map<String, Object> context, boolean throwPropertyExceptions) {
        Ognl.setTypeConverter(context, getTypeConverterFromContext(context));

        Object oldRoot = Ognl.getRoot(context);
        Ognl.setRoot(context, o);

        internalSetProperty(name, value, o, context, throwPropertyExceptions);

        Ognl.setRoot(context, oldRoot);
    }

    /**
     * Looks for the real target with the specified property given a root Object which may be a
     * CompoundRoot.
     *
     * @return the real target or null if no object can be found with the specified property
     */
    public Object getRealTarget(String property, Map<String, Object> context, Object root) throws OgnlException {
        //special keyword, they must be cutting the stack
        if (""top"".equals(property)) {
            return root;
        }

        if (root instanceof CompoundRoot) {
            // find real target
            CompoundRoot cr = (CompoundRoot) root;

            try {
                for (Object target : cr) {
                    if (
                            OgnlRuntime.hasSetProperty((OgnlContext) context, target, property)
                                    ||
                                    OgnlRuntime.hasGetProperty((OgnlContext) context, target, property)
                                    ||
                                    OgnlRuntime.getIndexedPropertyType((OgnlContext) context, target.getClass(), property) != OgnlRuntime.INDEXED_PROPERTY_NONE
                            ) {
                        return target;
                    }
                }
            } catch (IntrospectionException ex) {
                throw new ReflectionException(""Cannot figure out real target class"", ex);
            }

            return null;
        }

        return root;
    }


    /**
     * Wrapper around Ognl.setValue() to handle type conversion for collection elements.
     * Ideally, this should be handled by OGNL directly.
     */
    public void setValue(final String name, final Map<String, Object> context, final Object root, final Object value) throws OgnlException {
        compileAndExecute(name, context, new OgnlTask<Void>() {
            public Void execute(Object tree) throws OgnlException {
                if (isEvalExpression(tree, context)) {
                    throw new OgnlException(""Eval expression/chained expressions cannot be used as parameter name"");
                }
                Ognl.setValue(tree, context, root, value);
                return null;
            }
        });
    }

    private boolean isEvalExpression(Object tree, Map<String, Object> context) throws OgnlException {
        if (tree instanceof SimpleNode) {
            SimpleNode node = (SimpleNode) tree;
            OgnlContext ognlContext = null;

            if (context!=null && context instanceof OgnlContext) {
                ognlContext = (OgnlContext) context;
            }
            return node.isEvalChain(ognlContext) || node.isSequence(ognlContext);
        }
        return false;
    }

    public Object getValue(final String name, final Map<String, Object> context, final Object root) throws OgnlException {
        return compileAndExecute(name, context, new OgnlTask<Object>() {
            public Object execute(Object tree) throws OgnlException {
                return Ognl.getValue(tree, context, root);
            }
        });
    }

    public Object getValue(final String name, final Map<String, Object> context, final Object root, final Class resultType) throws OgnlException {
        return compileAndExecute(name, context, new OgnlTask<Object>() {
            public Object execute(Object tree) throws OgnlException {
                return Ognl.getValue(tree, context, root, resultType);
            }
        });
    }


    public Object compile(String expression) throws OgnlException {
        return compile(expression, null);
    }

    private <T> Object compileAndExecute(String expression, Map<String, Object> context, OgnlTask<T> task) throws OgnlException {
        Object tree;
        if (enableExpressionCache) {
            tree = expressions.get(expression);
            if (tree == null) {
                tree = Ognl.parseExpression(expression);
                checkEnableEvalExpression(tree, context);
            }
        } else {
            tree = Ognl.parseExpression(expression);
            checkEnableEvalExpression(tree, context);
        }

        final T exec = task.execute(tree);
        // if cache is enabled and it's a valid expression, puts it in
        if(enableExpressionCache) {
            expressions.putIfAbsent(expression, tree);
        }
        return exec;
    }

    public Object compile(String expression, Map<String, Object> context) throws OgnlException {
        return compileAndExecute(expression,context,new OgnlTask<Object>() {
            public Object execute(Object tree) throws OgnlException {
                return tree;
            }
        });
    }
    
    private void checkEnableEvalExpression(Object tree, Map<String, Object> context) throws OgnlException {
        if (!enableEvalExpression && isEvalExpression(tree, context)) {
            throw new OgnlException(""Eval expressions/chained expressions have been disabled!"");
        }
    }

    /**
     * Copies the properties in the object ""from"" and sets them in the object ""to""
     * using specified type converter, or {@link com.opensymphony.xwork2.conversion.impl.XWorkConverter} if none
     * is specified.
     *
     * @param from       the source object
     * @param to         the target object
     * @param context    the action context we're running under
     * @param exclusions collection of method names to excluded from copying ( can be null)
     * @param inclusions collection of method names to included copying  (can be null)
     *                   note if exclusions AND inclusions are supplied and not null nothing will get copied.
     */
    public void copy(final Object from, final Object to, final Map<String, Object> context, Collection<String> exclusions, Collection<String> inclusions) {
        if (from == null || to == null) {
            if (LOG.isWarnEnabled()) {
                LOG.warn(""Attempting to copy from or to a null source. This is illegal and is bein skipped. This may be due to an error in an OGNL expression, action chaining, or some other event."");
            }

            return;
        }

        TypeConverter conv = getTypeConverterFromContext(context);
        final Map contextFrom = createDefaultContext(from, null);
        Ognl.setTypeConverter(contextFrom, conv);
        final Map contextTo = createDefaultContext(to, null);
        Ognl.setTypeConverter(contextTo, conv);

        PropertyDescriptor[] fromPds;
        PropertyDescriptor[] toPds;

        try {
            fromPds = getPropertyDescriptors(from);
            toPds = getPropertyDescriptors(to);
        } catch (IntrospectionException e) {
            if (LOG.isErrorEnabled()) {
                LOG.error(""An error occured"", e);
            }
            return;
        }

        Map<String, PropertyDescriptor> toPdHash = new HashMap<String, PropertyDescriptor>();

        for (PropertyDescriptor toPd : toPds) {
            toPdHash.put(toPd.getName(), toPd);
        }

        for (PropertyDescriptor fromPd : fromPds) {
            if (fromPd.getReadMethod() != null) {
                boolean copy = true;
                if (exclusions != null && exclusions.contains(fromPd.getName())) {
                    copy = false;
                } else if (inclusions != null && !inclusions.contains(fromPd.getName())) {
                    copy = false;
                }

                if (copy) {
                    PropertyDescriptor toPd = toPdHash.get(fromPd.getName());
                    if ((toPd != null) && (toPd.getWriteMethod() != null)) {
                        try {
                            compileAndExecute(fromPd.getName(), context, new OgnlTask<Object>() {
                                public Void execute(Object expr) throws OgnlException {
                                    Object value = Ognl.getValue(expr, contextFrom, from);
                                    Ognl.setValue(expr, contextTo, to, value);
                                    return null;
                                }
                            });

                        } catch (OgnlException e) {
                            if (LOG.isDebugEnabled()) {
                                LOG.debug(""Got OGNL exception"", e);
                            }
                        }
                    }

                }

            }

        }
    }


    /**
     * Copies the properties in the object ""from"" and sets them in the object ""to""
     * using specified type converter, or {@link com.opensymphony.xwork2.conversion.impl.XWorkConverter} if none
     * is specified.
     *
     * @param from    the source object
     * @param to      the target object
     * @param context the action context we're running under
     */
    public void copy(Object from, Object to, Map<String, Object> context) {
        copy(from, to, context, null, null);
    }

    /**
     * Get's the java beans property descriptors for the given source.
     *
     * @param source the source object.
     * @return property descriptors.
     * @throws IntrospectionException is thrown if an exception occurs during introspection.
     */
    public PropertyDescriptor[] getPropertyDescriptors(Object source) throws IntrospectionException {
        BeanInfo beanInfo = getBeanInfo(source);
        return beanInfo.getPropertyDescriptors();
    }


    /**
     * Get's the java beans property descriptors for the given class.
     *
     * @param clazz the source object.
     * @return property descriptors.
     * @throws IntrospectionException is thrown if an exception occurs during introspection.
     */
    public PropertyDescriptor[] getPropertyDescriptors(Class clazz) throws IntrospectionException {
        BeanInfo beanInfo = getBeanInfo(clazz);
        return beanInfo.getPropertyDescriptors();
    }

    /**
     * Creates a Map with read properties for the given source object.
     * <p/>
     * If the source object does not have a read property (i.e. write-only) then
     * the property is added to the map with the value <code>here is no read method for property-name</code>.
     *
     * @param source the source object.
     * @return a Map with (key = read property name, value = value of read property).
     * @throws IntrospectionException is thrown if an exception occurs during introspection.
     * @throws OgnlException          is thrown by OGNL if the property value could not be retrieved
     */
    public Map<String, Object> getBeanMap(final Object source) throws IntrospectionException, OgnlException {
        Map<String, Object> beanMap = new HashMap<String, Object>();
        final Map sourceMap = createDefaultContext(source, null);
        PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(source);
        for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {
            final String propertyName = propertyDescriptor.getDisplayName();
            Method readMethod = propertyDescriptor.getReadMethod();
            if (readMethod != null) {
                final Object value = compileAndExecute(propertyName, null, new OgnlTask<Object>() {
                    public Object execute(Object expr) throws OgnlException {
                        return Ognl.getValue(expr, sourceMap, source);
                    }
                });
                beanMap.put(propertyName, value);
            } else {
                beanMap.put(propertyName, ""There is no read method for "" + propertyName);
            }
        }
        return beanMap;
    }

    /**
     * Get's the java bean info for the given source object. Calls getBeanInfo(Class c).
     *
     * @param from the source object.
     * @return java bean info.
     * @throws IntrospectionException is thrown if an exception occurs during introspection.
     */
    public BeanInfo getBeanInfo(Object from) throws IntrospectionException {
        return getBeanInfo(from.getClass());
    }


    /**
     * Get's the java bean info for the given source.
     *
     * @param clazz the source class.
     * @return java bean info.
     * @throws IntrospectionException is thrown if an exception occurs during introspection.
     */
    public BeanInfo getBeanInfo(Class clazz) throws IntrospectionException {
        synchronized (beanInfoCache) {
            BeanInfo beanInfo;
            beanInfo = beanInfoCache.get(clazz);
            if (beanInfo == null) {
                beanInfo = Introspector.getBeanInfo(clazz, Object.class);
                beanInfoCache.putIfAbsent(clazz, beanInfo);
            }
            return beanInfo;
        }
    }

    void internalSetProperty(String name, Object value, Object o, Map<String, Object> context, boolean throwPropertyExceptions) throws ReflectionException{
        try {
            setValue(name, context, o, value);
        } catch (OgnlException e) {
            Throwable reason = e.getReason();
            String msg = ""Caught OgnlException while setting property '"" + name + ""' on type '"" + o.getClass().getName() + ""'."";
            Throwable exception = (reason == null) ? e : reason;

            if (throwPropertyExceptions) {
                throw new ReflectionException(msg, exception);
            } else if (devMode) {
                LOG.warn(msg, exception);
            }
        }
    }

    TypeConverter getTypeConverterFromContext(Map<String, Object> context) {
        /*ValueStack stack = (ValueStack) context.get(ActionContext.VALUE_STACK);
        Container cont = (Container)stack.getContext().get(ActionContext.CONTAINER);
        if (cont != null) {
            return new OgnlTypeConverterWrapper(cont.getInstance(XWorkConverter.class));
        } else {
            throw new IllegalArgumentException(""Cannot find type converter in context map"");
        }
        */
        return defaultConverter;
    }

    protected Map createDefaultContext(Object root) {
        return createDefaultContext(root, null);
    }

    protected Map createDefaultContext(Object root, ClassResolver classResolver) {
        ClassResolver resolver = classResolver;
        if (resolver == null) {
            resolver = container.getInstance(CompoundRootAccessor.class);
        }

        SecurityMemberAccess memberAccess = new SecurityMemberAccess(allowStaticMethodAccess);
        memberAccess.setExcludedClasses(excludedClasses);
        memberAccess.setExcludedPackageNamePatterns(excludedPackageNamePatterns);
        memberAccess.setExcludedPackageNames(excludedPackageNames);

        return Ognl.createDefaultContext(root, resolver, defaultConverter, memberAccess);
    }

    private interface OgnlTask<T> {
        T execute(Object tree) throws OgnlException;
    }

}
",0
CVE-2016-4433,xwork-core/src/main/java/com/opensymphony/xwork2/ognl/OgnlUtil.java,"/*
 * Copyright 2002-2006,2009 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.opensymphony.xwork2.ognl;

import com.opensymphony.xwork2.XWorkConstants;
import com.opensymphony.xwork2.config.ConfigurationException;
import com.opensymphony.xwork2.conversion.impl.XWorkConverter;
import com.opensymphony.xwork2.inject.Container;
import com.opensymphony.xwork2.inject.Inject;
import com.opensymphony.xwork2.ognl.accessor.CompoundRootAccessor;
import com.opensymphony.xwork2.util.CompoundRoot;
import com.opensymphony.xwork2.util.TextParseUtil;
import com.opensymphony.xwork2.util.logging.Logger;
import com.opensymphony.xwork2.util.logging.LoggerFactory;
import com.opensymphony.xwork2.util.reflection.ReflectionException;
import ognl.ClassResolver;
import ognl.Ognl;
import ognl.OgnlContext;
import ognl.OgnlException;
import ognl.OgnlRuntime;
import ognl.SimpleNode;
import ognl.TypeConverter;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.regex.Pattern;


/**
 * Utility class that provides common access to the Ognl APIs for
 * setting and getting properties from objects (usually Actions).
 *
 * @author Jason Carreira
 */
public class OgnlUtil {

    private static final Logger LOG = LoggerFactory.getLogger(OgnlUtil.class);
    private ConcurrentMap<String, Object> expressions = new ConcurrentHashMap<String, Object>();
    private final ConcurrentMap<Class, BeanInfo> beanInfoCache = new ConcurrentHashMap<Class, BeanInfo>();
    private TypeConverter defaultConverter;

    private boolean devMode = false;
    private boolean enableExpressionCache = true;
    private boolean enableEvalExpression;

    private Set<Class<?>> excludedClasses = new HashSet<Class<?>>();
    private Set<Pattern> excludedPackageNamePatterns = new HashSet<Pattern>();
    private Set<String> excludedPackageNames = new HashSet<String>();

    private Container container;
    private boolean allowStaticMethodAccess;

    @Inject
    public void setXWorkConverter(XWorkConverter conv) {
        this.defaultConverter = new OgnlTypeConverterWrapper(conv);
    }

    @Inject(XWorkConstants.DEV_MODE)
    public void setDevMode(String mode) {
        devMode = ""true"".equals(mode);
    }

    @Inject(XWorkConstants.ENABLE_OGNL_EXPRESSION_CACHE)
    public void setEnableExpressionCache(String cache) {
       enableExpressionCache = ""true"".equals(cache);
    }

    @Inject(value = XWorkConstants.ENABLE_OGNL_EVAL_EXPRESSION, required = false)
    public void setEnableEvalExpression(String evalExpression) {
        enableEvalExpression = ""true"".equals(evalExpression);
        if(enableEvalExpression){
            LOG.warn(""Enabling OGNL expression evaluation may introduce security risks "" +
                    ""(see http://struts.apache.org/release/2.3.x/docs/s2-013.html for further details)"");
        }
    }

    @Inject(value = XWorkConstants.OGNL_EXCLUDED_CLASSES, required = false)
    public void setExcludedClasses(String commaDelimitedClasses) {
        Set<String> classes = TextParseUtil.commaDelimitedStringToSet(commaDelimitedClasses);
        for (String className : classes) {
            try {
                excludedClasses.add(Class.forName(className));
            } catch (ClassNotFoundException e) {
                throw new ConfigurationException(""Cannot load excluded class: "" + className, e);
            }
        }
    }

    @Inject(value = XWorkConstants.OGNL_EXCLUDED_PACKAGE_NAME_PATTERNS, required = false)
    public void setExcludedPackageNamePatterns(String commaDelimitedPackagePatterns) {
        Set<String> packagePatterns = TextParseUtil.commaDelimitedStringToSet(commaDelimitedPackagePatterns);
        for (String pattern : packagePatterns) {
            excludedPackageNamePatterns.add(Pattern.compile(pattern));
        }
    }

    @Inject(value = XWorkConstants.OGNL_EXCLUDED_PACKAGE_NAMES, required = false)
    public void setExcludedPackageNames(String commaDelimitedPackageNames) {
        excludedPackageNames = TextParseUtil.commaDelimitedStringToSet(commaDelimitedPackageNames);
    }

    public Set<Class<?>> getExcludedClasses() {
        return excludedClasses;
    }

    public Set<Pattern> getExcludedPackageNamePatterns() {
        return excludedPackageNamePatterns;
    }

    public Set<String> getExcludedPackageNames() {
        return excludedPackageNames;
    }

    @Inject
    public void setContainer(Container container) {
        this.container = container;
    }

    @Inject(value = XWorkConstants.ALLOW_STATIC_METHOD_ACCESS, required = false)
    public void setAllowStaticMethodAccess(String allowStaticMethodAccess) {
        this.allowStaticMethodAccess = Boolean.parseBoolean(allowStaticMethodAccess);
    }

    /**
     * Sets the object's properties using the default type converter, defaulting to not throw
     * exceptions for problems setting the properties.
     *
     * @param props   the properties being set
     * @param o       the object
     * @param context the action context
     */
    public void setProperties(Map<String, ?> props, Object o, Map<String, Object> context) {
        setProperties(props, o, context, false);
    }

    /**
     * Sets the object's properties using the default type converter.
     *
     * @param props                   the properties being set
     * @param o                       the object
     * @param context                 the action context
     * @param throwPropertyExceptions boolean which tells whether it should throw exceptions for
     *                                problems setting the properties
     */
    public void setProperties(Map<String, ?> props, Object o, Map<String, Object> context, boolean throwPropertyExceptions) throws ReflectionException{
        if (props == null) {
            return;
        }

        Ognl.setTypeConverter(context, getTypeConverterFromContext(context));

        Object oldRoot = Ognl.getRoot(context);
        Ognl.setRoot(context, o);

        for (Map.Entry<String, ?> entry : props.entrySet()) {
            String expression = entry.getKey();
            internalSetProperty(expression, entry.getValue(), o, context, throwPropertyExceptions);
        }

        Ognl.setRoot(context, oldRoot);
    }

    /**
     * Sets the properties on the object using the default context, defaulting to not throwing
     * exceptions for problems setting the properties.
     *
     * @param properties
     * @param o
     */
    public void setProperties(Map<String, ?> properties, Object o) {
        setProperties(properties, o, false);
    }

    /**
     * Sets the properties on the object using the default context.
     *
     * @param properties              the property map to set on the object
     * @param o                       the object to set the properties into
     * @param throwPropertyExceptions boolean which tells whether it should throw exceptions for
     *                                problems setting the properties
     */
    public void setProperties(Map<String, ?> properties, Object o, boolean throwPropertyExceptions) {
        Map context = createDefaultContext(o, null);
        setProperties(properties, o, context, throwPropertyExceptions);
    }

    /**
     * Sets the named property to the supplied value on the Object, defaults to not throwing
     * property exceptions.
     *
     * @param name    the name of the property to be set
     * @param value   the value to set into the named property
     * @param o       the object upon which to set the property
     * @param context the context which may include the TypeConverter
     */
    public void setProperty(String name, Object value, Object o, Map<String, Object> context) {
        setProperty(name, value, o, context, false);
    }

    /**
     * Sets the named property to the supplied value on the Object.
     *
     * @param name                    the name of the property to be set
     * @param value                   the value to set into the named property
     * @param o                       the object upon which to set the property
     * @param context                 the context which may include the TypeConverter
     * @param throwPropertyExceptions boolean which tells whether it should throw exceptions for
     *                                problems setting the property
     */
    public void setProperty(String name, Object value, Object o, Map<String, Object> context, boolean throwPropertyExceptions) {
        Ognl.setTypeConverter(context, getTypeConverterFromContext(context));

        Object oldRoot = Ognl.getRoot(context);
        Ognl.setRoot(context, o);

        internalSetProperty(name, value, o, context, throwPropertyExceptions);

        Ognl.setRoot(context, oldRoot);
    }

    /**
     * Looks for the real target with the specified property given a root Object which may be a
     * CompoundRoot.
     *
     * @return the real target or null if no object can be found with the specified property
     */
    public Object getRealTarget(String property, Map<String, Object> context, Object root) throws OgnlException {
        //special keyword, they must be cutting the stack
        if (""top"".equals(property)) {
            return root;
        }

        if (root instanceof CompoundRoot) {
            // find real target
            CompoundRoot cr = (CompoundRoot) root;

            try {
                for (Object target : cr) {
                    if (
                            OgnlRuntime.hasSetProperty((OgnlContext) context, target, property)
                                    ||
                                    OgnlRuntime.hasGetProperty((OgnlContext) context, target, property)
                                    ||
                                    OgnlRuntime.getIndexedPropertyType((OgnlContext) context, target.getClass(), property) != OgnlRuntime.INDEXED_PROPERTY_NONE
                            ) {
                        return target;
                    }
                }
            } catch (IntrospectionException ex) {
                throw new ReflectionException(""Cannot figure out real target class"", ex);
            }

            return null;
        }

        return root;
    }


    /**
     * Wrapper around Ognl.setValue() to handle type conversion for collection elements.
     * Ideally, this should be handled by OGNL directly.
     */
    public void setValue(final String name, final Map<String, Object> context, final Object root, final Object value) throws OgnlException {
        compileAndExecute(name, context, new OgnlTask<Void>() {
            public Void execute(Object tree) throws OgnlException {
                if (isEvalExpression(tree, context)) {
                    throw new OgnlException(""Eval expression/chained expressions cannot be used as parameter name"");
                }
                if (isArithmeticExpression(tree, context)) {
                    throw new OgnlException(""Arithmetic expressions cannot be used as parameter name"");
                }
                Ognl.setValue(tree, context, root, value);
                return null;
            }
        });
    }

    private boolean isEvalExpression(Object tree, Map<String, Object> context) throws OgnlException {
        if (tree instanceof SimpleNode) {
            SimpleNode node = (SimpleNode) tree;
            OgnlContext ognlContext = null;

            if (context!=null && context instanceof OgnlContext) {
                ognlContext = (OgnlContext) context;
            }
            return node.isEvalChain(ognlContext) || node.isSequence(ognlContext);
        }
        return false;
    }

    private boolean isArithmeticExpression(Object tree, Map<String, Object> context) throws OgnlException {
        if (tree instanceof SimpleNode) {
            SimpleNode node = (SimpleNode) tree;
            OgnlContext ognlContext = null;

            if (context!=null && context instanceof OgnlContext) {
                ognlContext = (OgnlContext) context;
            }
            return node.isOperation(ognlContext);
        }
        return false;
    }

    private boolean isSimpleMethod(Object tree, Map<String, Object> context) throws OgnlException {
        if (tree instanceof SimpleNode) {
            SimpleNode node = (SimpleNode) tree;
            OgnlContext ognlContext = null;

            if (context!=null && context instanceof OgnlContext) {
                ognlContext = (OgnlContext) context;
            }
            return node.isSimpleMethod(ognlContext) && !node.isChain(ognlContext);
        }
        return false;
    }

    public Object getValue(final String name, final Map<String, Object> context, final Object root) throws OgnlException {
        return compileAndExecute(name, context, new OgnlTask<Object>() {
            public Object execute(Object tree) throws OgnlException {
                return Ognl.getValue(tree, context, root);
            }
        });
    }

    public Object callMethod(final String name, final Map<String, Object> context, final Object root) throws OgnlException {
        return compileAndExecuteMethod(name, context, new OgnlTask<Object>() {
            public Object execute(Object tree) throws OgnlException {
                return Ognl.getValue(tree, context, root);
            }
        });
    }

    public Object getValue(final String name, final Map<String, Object> context, final Object root, final Class resultType) throws OgnlException {
        return compileAndExecute(name, context, new OgnlTask<Object>() {
            public Object execute(Object tree) throws OgnlException {
                return Ognl.getValue(tree, context, root, resultType);
            }
        });
    }


    public Object compile(String expression) throws OgnlException {
        return compile(expression, null);
    }

    private <T> Object compileAndExecute(String expression, Map<String, Object> context, OgnlTask<T> task) throws OgnlException {
        Object tree;
        if (enableExpressionCache) {
            tree = expressions.get(expression);
            if (tree == null) {
                tree = Ognl.parseExpression(expression);
                checkEnableEvalExpression(tree, context);
            }
        } else {
            tree = Ognl.parseExpression(expression);
            checkEnableEvalExpression(tree, context);
        }

        final T exec = task.execute(tree);
        // if cache is enabled and it's a valid expression, puts it in
        if(enableExpressionCache) {
            expressions.putIfAbsent(expression, tree);
        }
        return exec;
    }

    private <T> Object compileAndExecuteMethod(String expression, Map<String, Object> context, OgnlTask<T> task) throws OgnlException {
        Object tree;
        if (enableExpressionCache) {
            tree = expressions.get(expression);
            if (tree == null) {
                tree = Ognl.parseExpression(expression);
                checkSimpleMethod(tree, context);
            }
        } else {
            tree = Ognl.parseExpression(expression);
            checkSimpleMethod(tree, context);
        }

        final T exec = task.execute(tree);
        // if cache is enabled and it's a valid expression, puts it in
        if(enableExpressionCache) {
            expressions.putIfAbsent(expression, tree);
        }
        return exec;
    }

    public Object compile(String expression, Map<String, Object> context) throws OgnlException {
        return compileAndExecute(expression,context,new OgnlTask<Object>() {
            public Object execute(Object tree) throws OgnlException {
                return tree;
            }
        });
    }
    
    private void checkEnableEvalExpression(Object tree, Map<String, Object> context) throws OgnlException {
        if (!enableEvalExpression && isEvalExpression(tree, context)) {
            throw new OgnlException(""Eval expressions/chained expressions have been disabled!"");
        }
    }

    private void checkSimpleMethod(Object tree, Map<String, Object> context) throws OgnlException {
        if (!isSimpleMethod(tree, context)) {
            throw new OgnlException(""It isn't a simple method which can be called!"");
        }
    }

    /**
     * Copies the properties in the object ""from"" and sets them in the object ""to""
     * using specified type converter, or {@link com.opensymphony.xwork2.conversion.impl.XWorkConverter} if none
     * is specified.
     *
     * @param from       the source object
     * @param to         the target object
     * @param context    the action context we're running under
     * @param exclusions collection of method names to excluded from copying ( can be null)
     * @param inclusions collection of method names to included copying  (can be null)
     *                   note if exclusions AND inclusions are supplied and not null nothing will get copied.
     */
    public void copy(final Object from, final Object to, final Map<String, Object> context, Collection<String> exclusions, Collection<String> inclusions) {
        if (from == null || to == null) {
            if (LOG.isWarnEnabled()) {
                LOG.warn(""Attempting to copy from or to a null source. This is illegal and is bein skipped. This may be due to an error in an OGNL expression, action chaining, or some other event."");
            }

            return;
        }

        TypeConverter conv = getTypeConverterFromContext(context);
        final Map contextFrom = createDefaultContext(from, null);
        Ognl.setTypeConverter(contextFrom, conv);
        final Map contextTo = createDefaultContext(to, null);
        Ognl.setTypeConverter(contextTo, conv);

        PropertyDescriptor[] fromPds;
        PropertyDescriptor[] toPds;

        try {
            fromPds = getPropertyDescriptors(from);
            toPds = getPropertyDescriptors(to);
        } catch (IntrospectionException e) {
            if (LOG.isErrorEnabled()) {
                LOG.error(""An error occured"", e);
            }
            return;
        }

        Map<String, PropertyDescriptor> toPdHash = new HashMap<String, PropertyDescriptor>();

        for (PropertyDescriptor toPd : toPds) {
            toPdHash.put(toPd.getName(), toPd);
        }

        for (PropertyDescriptor fromPd : fromPds) {
            if (fromPd.getReadMethod() != null) {
                boolean copy = true;
                if (exclusions != null && exclusions.contains(fromPd.getName())) {
                    copy = false;
                } else if (inclusions != null && !inclusions.contains(fromPd.getName())) {
                    copy = false;
                }

                if (copy) {
                    PropertyDescriptor toPd = toPdHash.get(fromPd.getName());
                    if ((toPd != null) && (toPd.getWriteMethod() != null)) {
                        try {
                            compileAndExecute(fromPd.getName(), context, new OgnlTask<Object>() {
                                public Void execute(Object expr) throws OgnlException {
                                    Object value = Ognl.getValue(expr, contextFrom, from);
                                    Ognl.setValue(expr, contextTo, to, value);
                                    return null;
                                }
                            });

                        } catch (OgnlException e) {
                            if (LOG.isDebugEnabled()) {
                                LOG.debug(""Got OGNL exception"", e);
                            }
                        }
                    }

                }

            }

        }
    }


    /**
     * Copies the properties in the object ""from"" and sets them in the object ""to""
     * using specified type converter, or {@link com.opensymphony.xwork2.conversion.impl.XWorkConverter} if none
     * is specified.
     *
     * @param from    the source object
     * @param to      the target object
     * @param context the action context we're running under
     */
    public void copy(Object from, Object to, Map<String, Object> context) {
        copy(from, to, context, null, null);
    }

    /**
     * Get's the java beans property descriptors for the given source.
     *
     * @param source the source object.
     * @return property descriptors.
     * @throws IntrospectionException is thrown if an exception occurs during introspection.
     */
    public PropertyDescriptor[] getPropertyDescriptors(Object source) throws IntrospectionException {
        BeanInfo beanInfo = getBeanInfo(source);
        return beanInfo.getPropertyDescriptors();
    }


    /**
     * Get's the java beans property descriptors for the given class.
     *
     * @param clazz the source object.
     * @return property descriptors.
     * @throws IntrospectionException is thrown if an exception occurs during introspection.
     */
    public PropertyDescriptor[] getPropertyDescriptors(Class clazz) throws IntrospectionException {
        BeanInfo beanInfo = getBeanInfo(clazz);
        return beanInfo.getPropertyDescriptors();
    }

    /**
     * Creates a Map with read properties for the given source object.
     * <p/>
     * If the source object does not have a read property (i.e. write-only) then
     * the property is added to the map with the value <code>here is no read method for property-name</code>.
     *
     * @param source the source object.
     * @return a Map with (key = read property name, value = value of read property).
     * @throws IntrospectionException is thrown if an exception occurs during introspection.
     * @throws OgnlException          is thrown by OGNL if the property value could not be retrieved
     */
    public Map<String, Object> getBeanMap(final Object source) throws IntrospectionException, OgnlException {
        Map<String, Object> beanMap = new HashMap<String, Object>();
        final Map sourceMap = createDefaultContext(source, null);
        PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(source);
        for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {
            final String propertyName = propertyDescriptor.getDisplayName();
            Method readMethod = propertyDescriptor.getReadMethod();
            if (readMethod != null) {
                final Object value = compileAndExecute(propertyName, null, new OgnlTask<Object>() {
                    public Object execute(Object expr) throws OgnlException {
                        return Ognl.getValue(expr, sourceMap, source);
                    }
                });
                beanMap.put(propertyName, value);
            } else {
                beanMap.put(propertyName, ""There is no read method for "" + propertyName);
            }
        }
        return beanMap;
    }

    /**
     * Get's the java bean info for the given source object. Calls getBeanInfo(Class c).
     *
     * @param from the source object.
     * @return java bean info.
     * @throws IntrospectionException is thrown if an exception occurs during introspection.
     */
    public BeanInfo getBeanInfo(Object from) throws IntrospectionException {
        return getBeanInfo(from.getClass());
    }


    /**
     * Get's the java bean info for the given source.
     *
     * @param clazz the source class.
     * @return java bean info.
     * @throws IntrospectionException is thrown if an exception occurs during introspection.
     */
    public BeanInfo getBeanInfo(Class clazz) throws IntrospectionException {
        synchronized (beanInfoCache) {
            BeanInfo beanInfo;
            beanInfo = beanInfoCache.get(clazz);
            if (beanInfo == null) {
                beanInfo = Introspector.getBeanInfo(clazz, Object.class);
                beanInfoCache.putIfAbsent(clazz, beanInfo);
            }
            return beanInfo;
        }
    }

    void internalSetProperty(String name, Object value, Object o, Map<String, Object> context, boolean throwPropertyExceptions) throws ReflectionException{
        try {
            setValue(name, context, o, value);
        } catch (OgnlException e) {
            Throwable reason = e.getReason();
            String msg = ""Caught OgnlException while setting property '"" + name + ""' on type '"" + o.getClass().getName() + ""'."";
            Throwable exception = (reason == null) ? e : reason;

            if (throwPropertyExceptions) {
                throw new ReflectionException(msg, exception);
            } else if (devMode) {
                LOG.warn(msg, exception);
            }
        }
    }

    TypeConverter getTypeConverterFromContext(Map<String, Object> context) {
        /*ValueStack stack = (ValueStack) context.get(ActionContext.VALUE_STACK);
        Container cont = (Container)stack.getContext().get(ActionContext.CONTAINER);
        if (cont != null) {
            return new OgnlTypeConverterWrapper(cont.getInstance(XWorkConverter.class));
        } else {
            throw new IllegalArgumentException(""Cannot find type converter in context map"");
        }
        */
        return defaultConverter;
    }

    protected Map createDefaultContext(Object root) {
        return createDefaultContext(root, null);
    }

    protected Map createDefaultContext(Object root, ClassResolver classResolver) {
        ClassResolver resolver = classResolver;
        if (resolver == null) {
            resolver = container.getInstance(CompoundRootAccessor.class);
        }

        SecurityMemberAccess memberAccess = new SecurityMemberAccess(allowStaticMethodAccess);
        memberAccess.setExcludedClasses(excludedClasses);
        memberAccess.setExcludedPackageNamePatterns(excludedPackageNamePatterns);
        memberAccess.setExcludedPackageNames(excludedPackageNames);

        return Ognl.createDefaultContext(root, resolver, defaultConverter, memberAccess);
    }

    private interface OgnlTask<T> {
        T execute(Object tree) throws OgnlException;
    }

}
",1
CVE-2016-4433,xwork-core/src/test/java/com/opensymphony/xwork2/ognl/OgnlUtilTest.java,"/*
 * Copyright 2002-2006,2009 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.opensymphony.xwork2.ognl;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.XWorkException;
import com.opensymphony.xwork2.XWorkTestCase;
import com.opensymphony.xwork2.conversion.impl.XWorkConverter;
import com.opensymphony.xwork2.interceptor.ChainingInterceptor;
import com.opensymphony.xwork2.test.User;
import com.opensymphony.xwork2.util.*;
import com.opensymphony.xwork2.util.reflection.ReflectionContextState;
import ognl.*;

import java.lang.reflect.Method;
import java.util.*;


/**
 * Unit test of {@link ognlUtil}.
 * 
 * @version $Date$ $Id$
 */
public class OgnlUtilTest extends XWorkTestCase {
    
    private OgnlUtil ognlUtil;
    
    @Override
    public void setUp() throws Exception {
        super.setUp();
        ognlUtil = container.getInstance(OgnlUtil.class);
    }
    
    public void testCanSetADependentObject() throws Exception {
        String dogName = ""fido"";

        OgnlRuntime.setNullHandler(Owner.class, new NullHandler() {
            public Object nullMethodResult(Map map, Object o, String s, Object[] objects) {
                return null;
            }

            public Object nullPropertyValue(Map map, Object o, Object o1) {
                String methodName = o1.toString();
                String getter = ""set"" + methodName.substring(0, 1).toUpperCase() + methodName.substring(1);
                Method[] methods = o.getClass().getDeclaredMethods();
                System.out.println(getter);

                for (Method method : methods) {
                    String name = method.getName();

                    if (!getter.equals(name) || (method.getParameterTypes().length != 1)) {
                        continue;
                    } else {
                        Class clazz = method.getParameterTypes()[0];

                        try {
                            Object param = clazz.newInstance();
                            method.invoke(o, new Object[]{param});

                            return param;
                        } catch (Exception e) {
                            throw new RuntimeException(e);
                        }
                    }
                }

                return null;
            }
        });

        Owner owner = new Owner();
        Map context = ognlUtil.createDefaultContext(owner);
        Map props = new HashMap();
        props.put(""dog.name"", dogName);

        ognlUtil.setProperties(props, owner, context);
        assertNotNull(""expected Ognl to create an instance of Dog"", owner.getDog());
        assertEquals(dogName, owner.getDog().getName());
    }

    public void testCacheEnabled() throws OgnlException {
        ognlUtil.setEnableExpressionCache(""true"");
        Object expr0 = ognlUtil.compile(""test"");
        Object expr2 = ognlUtil.compile(""test"");
        assertSame(expr0, expr2);
    }

     public void testCacheDisabled() throws OgnlException {
        ognlUtil.setEnableExpressionCache(""false"");
        Object expr0 = ognlUtil.compile(""test"");
        Object expr2 = ognlUtil.compile(""test"");
        assertNotSame(expr0, expr2);
    }

    public void testCanSetDependentObjectArray() {
        EmailAction action = new EmailAction();
        Map<String, Object> context = ognlUtil.createDefaultContext(action);

        Map<String, Object> props = new HashMap<String, Object>();
        props.put(""email[0].address"", ""addr1"");
        props.put(""email[1].address"", ""addr2"");
        props.put(""email[2].address"", ""addr3"");

        ognlUtil.setProperties(props, action, context);
        assertEquals(3, action.email.size());
        assertEquals(""addr1"", action.email.get(0).toString());
        assertEquals(""addr2"", action.email.get(1).toString());
        assertEquals(""addr3"", action.email.get(2).toString());
    }

    public void testCopySameType() {
        Foo foo1 = new Foo();
        Foo foo2 = new Foo();

        Map context = ognlUtil.createDefaultContext(foo1);

        Calendar cal = Calendar.getInstance();
        cal.clear();
        cal.set(Calendar.MONTH, Calendar.FEBRUARY);
        cal.set(Calendar.DAY_OF_MONTH, 12);
        cal.set(Calendar.YEAR, 1982);

        foo1.setTitle(""blah"");
        foo1.setNumber(1);
        foo1.setPoints(new long[]{1, 2, 3});
        foo1.setBirthday(cal.getTime());
        foo1.setUseful(false);

        ognlUtil.copy(foo1, foo2, context);

        assertEquals(foo1.getTitle(), foo2.getTitle());
        assertEquals(foo1.getNumber(), foo2.getNumber());
        assertEquals(foo1.getPoints(), foo2.getPoints());
        assertEquals(foo1.getBirthday(), foo2.getBirthday());
        assertEquals(foo1.isUseful(), foo2.isUseful());
    }


    public void testIncudeExcludes() {

        Foo foo1 = new Foo();
        Foo foo2 = new Foo();

        Calendar cal = Calendar.getInstance();
        cal.clear();
        cal.set(Calendar.MONTH, Calendar.FEBRUARY);
        cal.set(Calendar.DAY_OF_MONTH, 12);
        cal.set(Calendar.YEAR, 1982);

        foo1.setPoints(new long[]{1, 2, 3});
        foo1.setBirthday(cal.getTime());
        foo1.setUseful(false);


        foo1.setTitle(""foo1 title"");
        foo1.setNumber(1);

        foo2.setTitle(""foo2 title"");
        foo2.setNumber(2);

        Map<String, Object> context = ognlUtil.createDefaultContext(foo1);

        List<String> excludes = new ArrayList<String>();
        excludes.add(""title"");
        excludes.add(""number"");

        ognlUtil.copy(foo1, foo2, context, excludes, null);
        // these values should remain unchanged in foo2
        assertEquals(foo2.getTitle(), ""foo2 title"");
        assertEquals(foo2.getNumber(), 2);

        // these values should be changed/copied
        assertEquals(foo1.getPoints(), foo2.getPoints());
        assertEquals(foo1.getBirthday(), foo2.getBirthday());
        assertEquals(foo1.isUseful(), foo2.isUseful());


        Bar b1 = new Bar();
        Bar b2 = new Bar();

        b1.setTitle(""bar1 title"");
        b1.setSomethingElse(10);


        b1.setId(new Long(1));

        b2.setTitle("""");
        b2.setId(new Long(2));

        context = ognlUtil.createDefaultContext(b1);
        List<String> includes = new ArrayList<String>();
        includes.add(""title"");
        includes.add(""somethingElse"");

        ognlUtil.copy(b1, b2, context, null, includes);
        // includes properties got copied
        assertEquals(b1.getTitle(), b2.getTitle());
        assertEquals(b1.getSomethingElse(), b2.getSomethingElse());

        // id properties did not
        assertEquals(b2.getId(), new Long(2));

    }


    public void testCopyUnevenObjects() {
        Foo foo = new Foo();
        Bar bar = new Bar();

        Map<String, Object> context = ognlUtil.createDefaultContext(foo);

        Calendar cal = Calendar.getInstance();
        cal.clear();
        cal.set(Calendar.MONTH, Calendar.FEBRUARY);
        cal.set(Calendar.DAY_OF_MONTH, 12);
        cal.set(Calendar.YEAR, 1982);

        foo.setTitle(""blah"");
        foo.setNumber(1);
        foo.setPoints(new long[]{1, 2, 3});
        foo.setBirthday(cal.getTime());
        foo.setUseful(false);

        ognlUtil.copy(foo, bar, context);

        assertEquals(foo.getTitle(), bar.getTitle());
        assertEquals(0, bar.getSomethingElse());
    }

    public void testDeepSetting() {
        Foo foo = new Foo();
        foo.setBar(new Bar());

        Map<String, Object> context = ognlUtil.createDefaultContext(foo);

        Map<String, Object> props = new HashMap();
        props.put(""bar.title"", ""i am barbaz"");
        ognlUtil.setProperties(props, foo, context);

        assertEquals(foo.getBar().getTitle(), ""i am barbaz"");
    }

    public void testNoExceptionForUnmatchedGetterAndSetterWithThrowPropertyException() {
        Map<String, Object> props = new HashMap<String, Object>();
        props.put(""myIntegerProperty"", new Integer(1234));

        TestObject testObject = new TestObject();

        //this used to fail in OGNL versions < 2.7
        ognlUtil.setProperties(props, testObject, true);
        assertEquals(1234, props.get(""myIntegerProperty""));
    }

    public void testExceptionForWrongPropertyNameWithThrowPropertyException() {
        Map<String, Object> props = new HashMap<String, Object>();
        props.put(""myStringProperty"", ""testString"");

        TestObject testObject = new TestObject();

        try {
            ognlUtil.setProperties(props, testObject, true);
            fail(""Should rise NoSuchPropertyException because of wrong property name"");
        } catch (Exception e) {
            //expected
        }
    }

    public void testOgnlHandlesCrapAtTheEndOfANumber() {
        Foo foo = new Foo();
        Map<String, Object> context = ognlUtil.createDefaultContext(foo);

        Map<String, Object> props = new HashMap<String, Object>();
        props.put(""aLong"", ""123a"");

        ognlUtil.setProperties(props, foo, context);
        assertEquals(0, foo.getALong());
    }

    /**
     * Test that type conversion is performed on indexed collection properties.
     */
    public void testSetIndexedValue() {
        ValueStack stack = ActionContext.getContext().getValueStack();
        Map<String, Object> stackContext = stack.getContext();
        stackContext.put(ReflectionContextState.CREATE_NULL_OBJECTS, Boolean.TRUE);
        stackContext.put(ReflectionContextState.DENY_METHOD_EXECUTION, Boolean.TRUE);
        stackContext.put(XWorkConverter.REPORT_CONVERSION_ERRORS, Boolean.TRUE);

        User user = new User();
        stack.push(user);

        // indexed string w/ existing array
        user.setList(new ArrayList<String>());
        user.getList().add("""");

        String[] foo = new String[]{""asdf""};
        stack.setValue(""list[0]"", foo);
        assertNotNull(user.getList());
        assertEquals(1, user.getList().size());
        assertEquals(String.class, user.getList().get(0).getClass());
        assertEquals(""asdf"", user.getList().get(0));
    }

    public void testSetPropertiesBoolean() {
        Foo foo = new Foo();

        Map context = ognlUtil.createDefaultContext(foo);

        Map props = new HashMap();
        props.put(""useful"", ""true"");
        ognlUtil.setProperties(props, foo, context);

        assertEquals(true, foo.isUseful());

        props = new HashMap();
        props.put(""useful"", ""false"");
        ognlUtil.setProperties(props, foo, context);

        assertEquals(false, foo.isUseful());
    }

    public void testSetPropertiesDate() {
        Foo foo = new Foo();

        Map context = ognlUtil.createDefaultContext(foo);

        Map props = new HashMap();
        props.put(""birthday"", ""02/12/1982"");
        // US style test
        ognlUtil.setProperties(props, foo, context);

        Calendar cal = Calendar.getInstance();
        cal.clear();
        cal.set(Calendar.MONTH, Calendar.FEBRUARY);
        cal.set(Calendar.DAY_OF_MONTH, 12);
        cal.set(Calendar.YEAR, 1982);

        assertEquals(cal.getTime(), foo.getBirthday());
        
        //UK style test
        props.put(""event"", ""18/10/2006 14:23:45"");
        props.put(""meeting"", ""09/09/2006 14:30"");
        context.put(ActionContext.LOCALE, Locale.UK);

        ognlUtil.setProperties(props, foo, context);
        
        cal = Calendar.getInstance();
        cal.clear();
        cal.set(Calendar.MONTH, Calendar.OCTOBER);
        cal.set(Calendar.DAY_OF_MONTH, 18);
        cal.set(Calendar.YEAR, 2006);
        cal.set(Calendar.HOUR_OF_DAY, 14);
        cal.set(Calendar.MINUTE, 23);
        cal.set(Calendar.SECOND, 45);
        
        assertEquals(cal.getTime(), foo.getEvent());
        
        cal = Calendar.getInstance();
        cal.clear();
        cal.set(Calendar.MONTH, Calendar.SEPTEMBER);
        cal.set(Calendar.DAY_OF_MONTH, 9);
        cal.set(Calendar.YEAR, 2006);
        cal.set(Calendar.HOUR_OF_DAY, 14);
        cal.set(Calendar.MINUTE, 30);
        
        assertEquals(cal.getTime(), foo.getMeeting());
        
        //test RFC 3339 date format for JSON
        props.put(""event"", ""1996-12-19T16:39:57Z"");
        ognlUtil.setProperties(props, foo, context);
        
        cal = Calendar.getInstance();
        cal.clear();
        cal.set(Calendar.MONTH, Calendar.DECEMBER);
        cal.set(Calendar.DAY_OF_MONTH, 19);
        cal.set(Calendar.YEAR, 1996);
        cal.set(Calendar.HOUR_OF_DAY, 16);
        cal.set(Calendar.MINUTE, 39);
        cal.set(Calendar.SECOND, 57);
        
        assertEquals(cal.getTime(), foo.getEvent());
        
        //test setting a calendar property
        props.put(""calendar"", ""1996-12-19T16:39:57Z"");
        ognlUtil.setProperties(props, foo, context);
        assertEquals(cal, foo.getCalendar());
    }

    public void testSetPropertiesInt() {
        Foo foo = new Foo();

        Map context = ognlUtil.createDefaultContext(foo);

        Map props = new HashMap();
        props.put(""number"", ""2"");
        ognlUtil.setProperties(props, foo, context);

        assertEquals(2, foo.getNumber());
    }

    public void testSetPropertiesLongArray() {
        Foo foo = new Foo();

        Map context = ognlUtil.createDefaultContext(foo);

        Map props = new HashMap();
        props.put(""points"", new String[]{""1"", ""2""});
        ognlUtil.setProperties(props, foo, context);

        assertNotNull(foo.getPoints());
        assertEquals(2, foo.getPoints().length);
        assertEquals(1, foo.getPoints()[0]);
        assertEquals(2, foo.getPoints()[1]);
    }

    public void testSetPropertiesString() {
        Foo foo = new Foo();

        Map context = ognlUtil.createDefaultContext(foo);

        Map props = new HashMap();
        props.put(""title"", ""this is a title"");
        ognlUtil.setProperties(props, foo, context);

        assertEquals(foo.getTitle(), ""this is a title"");
    }

    public void testSetProperty() {
        Foo foo = new Foo();
        Map context = ognlUtil.createDefaultContext(foo);
        assertFalse(123456 == foo.getNumber());
        ognlUtil.setProperty(""number"", ""123456"", foo, context);
        assertEquals(123456, foo.getNumber());
    }


    public void testSetList() throws Exception {
        ChainingInterceptor foo = new ChainingInterceptor();
        ChainingInterceptor foo2 = new ChainingInterceptor();

        OgnlContext context = (OgnlContext) ognlUtil.createDefaultContext(null);
        SimpleNode expression = (SimpleNode) Ognl.parseExpression(""{'a','ruby','b','tom'}"");


        Ognl.getValue(expression, context, ""aksdj"");

        final ValueStack stack = ActionContext.getContext().getValueStack();

        Object result = Ognl.getValue(ognlUtil.compile(""{\""foo\"",'ruby','b','tom'}""), context, foo);
        foo.setIncludes((Collection) result);

        assertEquals(4, foo.getIncludes().size());
        assertEquals(""foo"", foo.getIncludes().toArray()[0]);
        assertEquals(""ruby"", foo.getIncludes().toArray()[1]);
        assertEquals(""b"", """" + foo.getIncludes().toArray()[2]);
        assertEquals(""tom"", foo.getIncludes().toArray()[3]);

        Object result2 = Ognl.getValue(ognlUtil.compile(""{\""foo\"",'ruby','b','tom'}""), context, foo2);
        ognlUtil.setProperty(""includes"", result2, foo2, context);

        assertEquals(4, foo.getIncludes().size());
        assertEquals(""foo"", foo.getIncludes().toArray()[0]);
        assertEquals(""ruby"", foo.getIncludes().toArray()[1]);
        assertEquals(""b"", """" + foo.getIncludes().toArray()[2]);
        assertEquals(""tom"", foo.getIncludes().toArray()[3]);

        result = ActionContext.getContext().getValueStack().findValue(""{\""foo\"",'ruby','b','tom'}"");

        foo.setIncludes((Collection) result);
        assertEquals(ArrayList.class, result.getClass());

        assertEquals(4, foo.getIncludes().size());
        assertEquals(""foo"", foo.getIncludes().toArray()[0]);
        assertEquals(""ruby"", foo.getIncludes().toArray()[1]);
        assertEquals(""b"", """" + foo.getIncludes().toArray()[2]);
        assertEquals(""tom"", foo.getIncludes().toArray()[3]);
    }


    public void testStringToLong() {
        Foo foo = new Foo();

        Map context = ognlUtil.createDefaultContext(foo);

        Map props = new HashMap();
        props.put(""ALong"", ""123"");

        ognlUtil.setProperties(props, foo, context);
        assertEquals(123, foo.getALong());

        props.put(""ALong"", new String[]{""123""});

        foo.setALong(0);
        ognlUtil.setProperties(props, foo, context);
        assertEquals(123, foo.getALong());
    }

    public void testNullProperties() {
        Foo foo = new Foo();
        foo.setALong(88);

        Map context = ognlUtil.createDefaultContext(foo);

        ognlUtil.setProperties(null, foo, context);
        assertEquals(88, foo.getALong());

        Map props = new HashMap();
        props.put(""ALong"", ""99"");
        ognlUtil.setProperties(props, foo, context);
        assertEquals(99, foo.getALong());
    }
    
    public void testCopyNull() {
        Foo foo = new Foo();
        Map context = ognlUtil.createDefaultContext(foo);
   		ognlUtil.copy(null, null, context);

   		ognlUtil.copy(foo, null, context);
   		ognlUtil.copy(null, foo, context);
    }
    
    public void testGetTopTarget() throws Exception {
        Foo foo = new Foo();
        Map context = ognlUtil.createDefaultContext(foo);

        CompoundRoot root = new CompoundRoot();
        Object top = ognlUtil.getRealTarget(""top"", context, root);
        assertEquals(root, top); // top should be root
        
        root.push(foo);
        Object val = ognlUtil.getRealTarget(""unknown"", context, root);
        assertNull(val); // not found
    }
    
    public void testGetBeanMap() throws Exception {
    	Bar bar = new Bar();
    	bar.setTitle(""I have beer"");
        
    	Foo foo = new Foo();
        foo.setALong(123);
        foo.setNumber(44);
        foo.setBar(bar);
        foo.setTitle(""Hello Santa"");
        foo.setUseful(true);
        
        // just do some of the 15 tests
        Map beans = ognlUtil.getBeanMap(foo);
        assertNotNull(beans);
        assertEquals(19, beans.size());
        assertEquals(""Hello Santa"", beans.get(""title""));
        assertEquals(new Long(""123""), beans.get(""ALong""));
        assertEquals(new Integer(""44""), beans.get(""number""));
        assertEquals(bar, beans.get(""bar""));
        assertEquals(Boolean.TRUE, beans.get(""useful""));
    }

    public void testGetBeanMapNoReadMethod() throws Exception {
    	MyWriteBar bar = new MyWriteBar();
    	bar.setBar(""Sams"");
    	
    	Map beans = ognlUtil.getBeanMap(bar);
    	assertEquals(2, beans.size());
    	assertEquals(new Integer(""1""), beans.get(""id""));
    	assertEquals(""There is no read method for bar"", beans.get(""bar""));
    }

    /**
	 * XW-281
	 */
    public void testSetBigIndexedValue() {
        ValueStack stack = ActionContext.getContext().getValueStack();
        Map stackContext = stack.getContext();
        stackContext.put(ReflectionContextState.CREATE_NULL_OBJECTS, Boolean.FALSE);
        stackContext.put(ReflectionContextState.DENY_METHOD_EXECUTION, Boolean.TRUE);
        stackContext.put(XWorkConverter.REPORT_CONVERSION_ERRORS, Boolean.TRUE);

        User user = new User();
        stack.push(user);

        // indexed string w/ existing array
        user.setList(new ArrayList());

        String[] foo = new String[]{""asdf""};
        ((OgnlValueStack)stack).setDevMode(""true"");
        try {
            stack.setValue(""list.1114778947765"", foo);
            fail(""non-valid expression: list.1114778947765""); 
        }
        catch(RuntimeException ex) {
            ; // it's oke
        }
        
        try {
            stack.setValue(""1114778947765"", foo);
            fail(""non-valid expression: 1114778947765""); 
        }
        catch(RuntimeException ex) {
            ;
        }
        
        try {
            stack.setValue(""1234"", foo);
            fail(""non-valid expression: 1114778947765""); 
        }
        catch(RuntimeException ex) {
            ;
        }
        
        ((OgnlValueStack)stack).setDevMode(""false"");
        stack.setValue(""list.1114778947765"", foo);
        stack.setValue(""1114778947765"", foo);
        stack.setValue(""1234"", foo);
    }

    public void testAvoidCallingMethodsOnObjectClass() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setExcludedClasses(Object.class.getName());
            ognlUtil.setValue(""class.classLoader.defaultAssertionStatus"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(NoSuchPropertyException.class, expected.getClass());
        assertEquals(""com.opensymphony.xwork2.util.Foo.class"", expected.getMessage());
    }

    public void testAvoidCallingMethodsOnObjectClassUpperCased() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setExcludedClasses(Object.class.getName());
            ognlUtil.setValue(""Class.ClassLoader.DefaultAssertionStatus"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(NoSuchPropertyException.class, expected.getClass());
        assertEquals(""com.opensymphony.xwork2.util.Foo.Class"", expected.getMessage());
    }

    public void testAvoidCallingMethodsOnObjectClassAsMap() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setExcludedClasses(Object.class.getName());
            ognlUtil.setValue(""class['classLoader']['defaultAssertionStatus']"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(NoSuchPropertyException.class, expected.getClass());
        assertEquals(""com.opensymphony.xwork2.util.Foo.class"", expected.getMessage());
    }

    public void testAvoidCallingMethodsOnObjectClassAsMap2() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setValue(""foo['class']['classLoader']['defaultAssertionStatus']"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(NoSuchPropertyException.class, expected.getClass());
        assertEquals(""com.opensymphony.xwork2.util.Foo.foo"", expected.getMessage());
    }

    public void testAvoidCallingMethodsOnObjectClassAsMapWithQuotes() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setExcludedClasses(Object.class.getName());
            ognlUtil.setValue(""class[\""classLoader\""]['defaultAssertionStatus']"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(NoSuchPropertyException.class, expected.getClass());
        assertEquals(""com.opensymphony.xwork2.util.Foo.class"", expected.getMessage());
    }

    public void testAvoidCallingToString() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setValue(""toString"", ognlUtil.createDefaultContext(foo), foo, null);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(OgnlException.class, expected.getClass());
        assertEquals(""toString"", expected.getMessage());
    }

    public void testAvoidCallingMethodsWithBraces() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setValue(""toString()"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(InappropriateExpressionException.class, expected.getClass());
        assertEquals(expected.getMessage(), ""Inappropriate OGNL expression: toString()"");
    }

    public void testAvoidCallingSomeClasses() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setExcludedClasses(Runtime.class.getName());
            ognlUtil.setValue(""@java.lang.Runtime@getRuntime().exec('mate')"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(MethodFailedException.class, expected.getClass());
        assertEquals(expected.getMessage(), ""Method \""getRuntime\"" failed for object class java.lang.Runtime"");
    }

    public void testBlockSequenceOfExpressions() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setValue(""#booScope=@myclass@DEFAULT_SCOPE,#bootScope.init()"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(OgnlException.class, expected.getClass());
        assertEquals(expected.getMessage(), ""Eval expressions/chained expressions have been disabled!"");
    }

    public static class Email {
        String address;

        public void setAddress(String address) {
            this.address = address;
        }

        @Override
        public String toString() {
            return address;
        }
    }

    static class TestObject {
        private Integer myIntegerProperty;
        private Long myLongProperty;
        private String myStrProperty;

        public void setMyIntegerProperty(Integer myIntegerProperty) {
            this.myIntegerProperty = myIntegerProperty;
        }

        public String getMyIntegerProperty() {
            return myIntegerProperty.toString();
        }

        public void setMyLongProperty(Long myLongProperty) {
            this.myLongProperty = myLongProperty;
        }

        public Long getMyLongProperty() {
            return myLongProperty;
        }

        public void setMyStrProperty(String myStrProperty) {
            this.myStrProperty = myStrProperty;
        }

        public String getMyStrProperty() {
            return myStrProperty;
        }
    }

    class EmailAction {
        public List email = new OgnlList(Email.class);

        public List getEmail() {
            return this.email;
        }
    }

    class OgnlList extends ArrayList {
        private Class clazz;

        public OgnlList(Class clazz) {
            this.clazz = clazz;
        }

        @Override
        public synchronized Object get(int index) {
            while (index >= this.size()) {
                try {
                    this.add(clazz.newInstance());
                } catch (Exception e) {
                    throw new XWorkException(e);
                }
            }

            return super.get(index);
        }
    }
    
    private class MyWriteBar {
    	private int id;
    	
    	public int getId() {
    		return id;
    	}
    	
    	public void setBar(String name) {
    		if (""Sams"".equals(name))
    			id = 1;
    		else
    			id = 999;
    	}
    	
    }
}
",0
CVE-2016-4433,xwork-core/src/test/java/com/opensymphony/xwork2/ognl/OgnlUtilTest.java,"/*
 * Copyright 2002-2006,2009 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.opensymphony.xwork2.ognl;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.XWorkException;
import com.opensymphony.xwork2.XWorkTestCase;
import com.opensymphony.xwork2.conversion.impl.XWorkConverter;
import com.opensymphony.xwork2.interceptor.ChainingInterceptor;
import com.opensymphony.xwork2.test.User;
import com.opensymphony.xwork2.util.*;
import com.opensymphony.xwork2.util.reflection.ReflectionContextState;
import ognl.*;

import java.lang.reflect.Method;
import java.util.*;


/**
 * Unit test of {@link ognlUtil}.
 * 
 * @version $Date$ $Id$
 */
public class OgnlUtilTest extends XWorkTestCase {
    
    private OgnlUtil ognlUtil;
    
    @Override
    public void setUp() throws Exception {
        super.setUp();
        ognlUtil = container.getInstance(OgnlUtil.class);
    }
    
    public void testCanSetADependentObject() throws Exception {
        String dogName = ""fido"";

        OgnlRuntime.setNullHandler(Owner.class, new NullHandler() {
            public Object nullMethodResult(Map map, Object o, String s, Object[] objects) {
                return null;
            }

            public Object nullPropertyValue(Map map, Object o, Object o1) {
                String methodName = o1.toString();
                String getter = ""set"" + methodName.substring(0, 1).toUpperCase() + methodName.substring(1);
                Method[] methods = o.getClass().getDeclaredMethods();
                System.out.println(getter);

                for (Method method : methods) {
                    String name = method.getName();

                    if (!getter.equals(name) || (method.getParameterTypes().length != 1)) {
                        continue;
                    } else {
                        Class clazz = method.getParameterTypes()[0];

                        try {
                            Object param = clazz.newInstance();
                            method.invoke(o, new Object[]{param});

                            return param;
                        } catch (Exception e) {
                            throw new RuntimeException(e);
                        }
                    }
                }

                return null;
            }
        });

        Owner owner = new Owner();
        Map context = ognlUtil.createDefaultContext(owner);
        Map props = new HashMap();
        props.put(""dog.name"", dogName);

        ognlUtil.setProperties(props, owner, context);
        assertNotNull(""expected Ognl to create an instance of Dog"", owner.getDog());
        assertEquals(dogName, owner.getDog().getName());
    }

    public void testCacheEnabled() throws OgnlException {
        ognlUtil.setEnableExpressionCache(""true"");
        Object expr0 = ognlUtil.compile(""test"");
        Object expr2 = ognlUtil.compile(""test"");
        assertSame(expr0, expr2);
    }

     public void testCacheDisabled() throws OgnlException {
        ognlUtil.setEnableExpressionCache(""false"");
        Object expr0 = ognlUtil.compile(""test"");
        Object expr2 = ognlUtil.compile(""test"");
        assertNotSame(expr0, expr2);
    }

    public void testCanSetDependentObjectArray() {
        EmailAction action = new EmailAction();
        Map<String, Object> context = ognlUtil.createDefaultContext(action);

        Map<String, Object> props = new HashMap<String, Object>();
        props.put(""email[0].address"", ""addr1"");
        props.put(""email[1].address"", ""addr2"");
        props.put(""email[2].address"", ""addr3"");

        ognlUtil.setProperties(props, action, context);
        assertEquals(3, action.email.size());
        assertEquals(""addr1"", action.email.get(0).toString());
        assertEquals(""addr2"", action.email.get(1).toString());
        assertEquals(""addr3"", action.email.get(2).toString());
    }

    public void testCopySameType() {
        Foo foo1 = new Foo();
        Foo foo2 = new Foo();

        Map context = ognlUtil.createDefaultContext(foo1);

        Calendar cal = Calendar.getInstance();
        cal.clear();
        cal.set(Calendar.MONTH, Calendar.FEBRUARY);
        cal.set(Calendar.DAY_OF_MONTH, 12);
        cal.set(Calendar.YEAR, 1982);

        foo1.setTitle(""blah"");
        foo1.setNumber(1);
        foo1.setPoints(new long[]{1, 2, 3});
        foo1.setBirthday(cal.getTime());
        foo1.setUseful(false);

        ognlUtil.copy(foo1, foo2, context);

        assertEquals(foo1.getTitle(), foo2.getTitle());
        assertEquals(foo1.getNumber(), foo2.getNumber());
        assertEquals(foo1.getPoints(), foo2.getPoints());
        assertEquals(foo1.getBirthday(), foo2.getBirthday());
        assertEquals(foo1.isUseful(), foo2.isUseful());
    }


    public void testIncudeExcludes() {

        Foo foo1 = new Foo();
        Foo foo2 = new Foo();

        Calendar cal = Calendar.getInstance();
        cal.clear();
        cal.set(Calendar.MONTH, Calendar.FEBRUARY);
        cal.set(Calendar.DAY_OF_MONTH, 12);
        cal.set(Calendar.YEAR, 1982);

        foo1.setPoints(new long[]{1, 2, 3});
        foo1.setBirthday(cal.getTime());
        foo1.setUseful(false);


        foo1.setTitle(""foo1 title"");
        foo1.setNumber(1);

        foo2.setTitle(""foo2 title"");
        foo2.setNumber(2);

        Map<String, Object> context = ognlUtil.createDefaultContext(foo1);

        List<String> excludes = new ArrayList<String>();
        excludes.add(""title"");
        excludes.add(""number"");

        ognlUtil.copy(foo1, foo2, context, excludes, null);
        // these values should remain unchanged in foo2
        assertEquals(foo2.getTitle(), ""foo2 title"");
        assertEquals(foo2.getNumber(), 2);

        // these values should be changed/copied
        assertEquals(foo1.getPoints(), foo2.getPoints());
        assertEquals(foo1.getBirthday(), foo2.getBirthday());
        assertEquals(foo1.isUseful(), foo2.isUseful());


        Bar b1 = new Bar();
        Bar b2 = new Bar();

        b1.setTitle(""bar1 title"");
        b1.setSomethingElse(10);


        b1.setId(new Long(1));

        b2.setTitle("""");
        b2.setId(new Long(2));

        context = ognlUtil.createDefaultContext(b1);
        List<String> includes = new ArrayList<String>();
        includes.add(""title"");
        includes.add(""somethingElse"");

        ognlUtil.copy(b1, b2, context, null, includes);
        // includes properties got copied
        assertEquals(b1.getTitle(), b2.getTitle());
        assertEquals(b1.getSomethingElse(), b2.getSomethingElse());

        // id properties did not
        assertEquals(b2.getId(), new Long(2));

    }


    public void testCopyUnevenObjects() {
        Foo foo = new Foo();
        Bar bar = new Bar();

        Map<String, Object> context = ognlUtil.createDefaultContext(foo);

        Calendar cal = Calendar.getInstance();
        cal.clear();
        cal.set(Calendar.MONTH, Calendar.FEBRUARY);
        cal.set(Calendar.DAY_OF_MONTH, 12);
        cal.set(Calendar.YEAR, 1982);

        foo.setTitle(""blah"");
        foo.setNumber(1);
        foo.setPoints(new long[]{1, 2, 3});
        foo.setBirthday(cal.getTime());
        foo.setUseful(false);

        ognlUtil.copy(foo, bar, context);

        assertEquals(foo.getTitle(), bar.getTitle());
        assertEquals(0, bar.getSomethingElse());
    }

    public void testDeepSetting() {
        Foo foo = new Foo();
        foo.setBar(new Bar());

        Map<String, Object> context = ognlUtil.createDefaultContext(foo);

        Map<String, Object> props = new HashMap();
        props.put(""bar.title"", ""i am barbaz"");
        ognlUtil.setProperties(props, foo, context);

        assertEquals(foo.getBar().getTitle(), ""i am barbaz"");
    }

    public void testNoExceptionForUnmatchedGetterAndSetterWithThrowPropertyException() {
        Map<String, Object> props = new HashMap<String, Object>();
        props.put(""myIntegerProperty"", new Integer(1234));

        TestObject testObject = new TestObject();

        //this used to fail in OGNL versions < 2.7
        ognlUtil.setProperties(props, testObject, true);
        assertEquals(1234, props.get(""myIntegerProperty""));
    }

    public void testExceptionForWrongPropertyNameWithThrowPropertyException() {
        Map<String, Object> props = new HashMap<String, Object>();
        props.put(""myStringProperty"", ""testString"");

        TestObject testObject = new TestObject();

        try {
            ognlUtil.setProperties(props, testObject, true);
            fail(""Should rise NoSuchPropertyException because of wrong property name"");
        } catch (Exception e) {
            //expected
        }
    }

    public void testOgnlHandlesCrapAtTheEndOfANumber() {
        Foo foo = new Foo();
        Map<String, Object> context = ognlUtil.createDefaultContext(foo);

        Map<String, Object> props = new HashMap<String, Object>();
        props.put(""aLong"", ""123a"");

        ognlUtil.setProperties(props, foo, context);
        assertEquals(0, foo.getALong());
    }

    /**
     * Test that type conversion is performed on indexed collection properties.
     */
    public void testSetIndexedValue() {
        ValueStack stack = ActionContext.getContext().getValueStack();
        Map<String, Object> stackContext = stack.getContext();
        stackContext.put(ReflectionContextState.CREATE_NULL_OBJECTS, Boolean.TRUE);
        stackContext.put(ReflectionContextState.DENY_METHOD_EXECUTION, Boolean.TRUE);
        stackContext.put(XWorkConverter.REPORT_CONVERSION_ERRORS, Boolean.TRUE);

        User user = new User();
        stack.push(user);

        // indexed string w/ existing array
        user.setList(new ArrayList<String>());
        user.getList().add("""");

        String[] foo = new String[]{""asdf""};
        stack.setValue(""list[0]"", foo);
        assertNotNull(user.getList());
        assertEquals(1, user.getList().size());
        assertEquals(String.class, user.getList().get(0).getClass());
        assertEquals(""asdf"", user.getList().get(0));
    }

    public void testSetPropertiesBoolean() {
        Foo foo = new Foo();

        Map context = ognlUtil.createDefaultContext(foo);

        Map props = new HashMap();
        props.put(""useful"", ""true"");
        ognlUtil.setProperties(props, foo, context);

        assertEquals(true, foo.isUseful());

        props = new HashMap();
        props.put(""useful"", ""false"");
        ognlUtil.setProperties(props, foo, context);

        assertEquals(false, foo.isUseful());
    }

    public void testSetPropertiesDate() {
        Foo foo = new Foo();

        Map context = ognlUtil.createDefaultContext(foo);

        Map props = new HashMap();
        props.put(""birthday"", ""02/12/1982"");
        // US style test
        ognlUtil.setProperties(props, foo, context);

        Calendar cal = Calendar.getInstance();
        cal.clear();
        cal.set(Calendar.MONTH, Calendar.FEBRUARY);
        cal.set(Calendar.DAY_OF_MONTH, 12);
        cal.set(Calendar.YEAR, 1982);

        assertEquals(cal.getTime(), foo.getBirthday());
        
        //UK style test
        props.put(""event"", ""18/10/2006 14:23:45"");
        props.put(""meeting"", ""09/09/2006 14:30"");
        context.put(ActionContext.LOCALE, Locale.UK);

        ognlUtil.setProperties(props, foo, context);
        
        cal = Calendar.getInstance();
        cal.clear();
        cal.set(Calendar.MONTH, Calendar.OCTOBER);
        cal.set(Calendar.DAY_OF_MONTH, 18);
        cal.set(Calendar.YEAR, 2006);
        cal.set(Calendar.HOUR_OF_DAY, 14);
        cal.set(Calendar.MINUTE, 23);
        cal.set(Calendar.SECOND, 45);
        
        assertEquals(cal.getTime(), foo.getEvent());
        
        cal = Calendar.getInstance();
        cal.clear();
        cal.set(Calendar.MONTH, Calendar.SEPTEMBER);
        cal.set(Calendar.DAY_OF_MONTH, 9);
        cal.set(Calendar.YEAR, 2006);
        cal.set(Calendar.HOUR_OF_DAY, 14);
        cal.set(Calendar.MINUTE, 30);
        
        assertEquals(cal.getTime(), foo.getMeeting());
        
        //test RFC 3339 date format for JSON
        props.put(""event"", ""1996-12-19T16:39:57Z"");
        ognlUtil.setProperties(props, foo, context);
        
        cal = Calendar.getInstance();
        cal.clear();
        cal.set(Calendar.MONTH, Calendar.DECEMBER);
        cal.set(Calendar.DAY_OF_MONTH, 19);
        cal.set(Calendar.YEAR, 1996);
        cal.set(Calendar.HOUR_OF_DAY, 16);
        cal.set(Calendar.MINUTE, 39);
        cal.set(Calendar.SECOND, 57);
        
        assertEquals(cal.getTime(), foo.getEvent());
        
        //test setting a calendar property
        props.put(""calendar"", ""1996-12-19T16:39:57Z"");
        ognlUtil.setProperties(props, foo, context);
        assertEquals(cal, foo.getCalendar());
    }

    public void testSetPropertiesInt() {
        Foo foo = new Foo();

        Map context = ognlUtil.createDefaultContext(foo);

        Map props = new HashMap();
        props.put(""number"", ""2"");
        ognlUtil.setProperties(props, foo, context);

        assertEquals(2, foo.getNumber());
    }

    public void testSetPropertiesLongArray() {
        Foo foo = new Foo();

        Map context = ognlUtil.createDefaultContext(foo);

        Map props = new HashMap();
        props.put(""points"", new String[]{""1"", ""2""});
        ognlUtil.setProperties(props, foo, context);

        assertNotNull(foo.getPoints());
        assertEquals(2, foo.getPoints().length);
        assertEquals(1, foo.getPoints()[0]);
        assertEquals(2, foo.getPoints()[1]);
    }

    public void testSetPropertiesString() {
        Foo foo = new Foo();

        Map context = ognlUtil.createDefaultContext(foo);

        Map props = new HashMap();
        props.put(""title"", ""this is a title"");
        ognlUtil.setProperties(props, foo, context);

        assertEquals(foo.getTitle(), ""this is a title"");
    }

    public void testSetProperty() {
        Foo foo = new Foo();
        Map context = ognlUtil.createDefaultContext(foo);
        assertFalse(123456 == foo.getNumber());
        ognlUtil.setProperty(""number"", ""123456"", foo, context);
        assertEquals(123456, foo.getNumber());
    }


    public void testSetList() throws Exception {
        ChainingInterceptor foo = new ChainingInterceptor();
        ChainingInterceptor foo2 = new ChainingInterceptor();

        OgnlContext context = (OgnlContext) ognlUtil.createDefaultContext(null);
        SimpleNode expression = (SimpleNode) Ognl.parseExpression(""{'a','ruby','b','tom'}"");


        Ognl.getValue(expression, context, ""aksdj"");

        final ValueStack stack = ActionContext.getContext().getValueStack();

        Object result = Ognl.getValue(ognlUtil.compile(""{\""foo\"",'ruby','b','tom'}""), context, foo);
        foo.setIncludes((Collection) result);

        assertEquals(4, foo.getIncludes().size());
        assertEquals(""foo"", foo.getIncludes().toArray()[0]);
        assertEquals(""ruby"", foo.getIncludes().toArray()[1]);
        assertEquals(""b"", """" + foo.getIncludes().toArray()[2]);
        assertEquals(""tom"", foo.getIncludes().toArray()[3]);

        Object result2 = Ognl.getValue(ognlUtil.compile(""{\""foo\"",'ruby','b','tom'}""), context, foo2);
        ognlUtil.setProperty(""includes"", result2, foo2, context);

        assertEquals(4, foo.getIncludes().size());
        assertEquals(""foo"", foo.getIncludes().toArray()[0]);
        assertEquals(""ruby"", foo.getIncludes().toArray()[1]);
        assertEquals(""b"", """" + foo.getIncludes().toArray()[2]);
        assertEquals(""tom"", foo.getIncludes().toArray()[3]);

        result = ActionContext.getContext().getValueStack().findValue(""{\""foo\"",'ruby','b','tom'}"");

        foo.setIncludes((Collection) result);
        assertEquals(ArrayList.class, result.getClass());

        assertEquals(4, foo.getIncludes().size());
        assertEquals(""foo"", foo.getIncludes().toArray()[0]);
        assertEquals(""ruby"", foo.getIncludes().toArray()[1]);
        assertEquals(""b"", """" + foo.getIncludes().toArray()[2]);
        assertEquals(""tom"", foo.getIncludes().toArray()[3]);
    }


    public void testStringToLong() {
        Foo foo = new Foo();

        Map context = ognlUtil.createDefaultContext(foo);

        Map props = new HashMap();
        props.put(""ALong"", ""123"");

        ognlUtil.setProperties(props, foo, context);
        assertEquals(123, foo.getALong());

        props.put(""ALong"", new String[]{""123""});

        foo.setALong(0);
        ognlUtil.setProperties(props, foo, context);
        assertEquals(123, foo.getALong());
    }

    public void testNullProperties() {
        Foo foo = new Foo();
        foo.setALong(88);

        Map context = ognlUtil.createDefaultContext(foo);

        ognlUtil.setProperties(null, foo, context);
        assertEquals(88, foo.getALong());

        Map props = new HashMap();
        props.put(""ALong"", ""99"");
        ognlUtil.setProperties(props, foo, context);
        assertEquals(99, foo.getALong());
    }
    
    public void testCopyNull() {
        Foo foo = new Foo();
        Map context = ognlUtil.createDefaultContext(foo);
   		ognlUtil.copy(null, null, context);

   		ognlUtil.copy(foo, null, context);
   		ognlUtil.copy(null, foo, context);
    }
    
    public void testGetTopTarget() throws Exception {
        Foo foo = new Foo();
        Map context = ognlUtil.createDefaultContext(foo);

        CompoundRoot root = new CompoundRoot();
        Object top = ognlUtil.getRealTarget(""top"", context, root);
        assertEquals(root, top); // top should be root
        
        root.push(foo);
        Object val = ognlUtil.getRealTarget(""unknown"", context, root);
        assertNull(val); // not found
    }
    
    public void testGetBeanMap() throws Exception {
    	Bar bar = new Bar();
    	bar.setTitle(""I have beer"");
        
    	Foo foo = new Foo();
        foo.setALong(123);
        foo.setNumber(44);
        foo.setBar(bar);
        foo.setTitle(""Hello Santa"");
        foo.setUseful(true);
        
        // just do some of the 15 tests
        Map beans = ognlUtil.getBeanMap(foo);
        assertNotNull(beans);
        assertEquals(19, beans.size());
        assertEquals(""Hello Santa"", beans.get(""title""));
        assertEquals(new Long(""123""), beans.get(""ALong""));
        assertEquals(new Integer(""44""), beans.get(""number""));
        assertEquals(bar, beans.get(""bar""));
        assertEquals(Boolean.TRUE, beans.get(""useful""));
    }

    public void testGetBeanMapNoReadMethod() throws Exception {
    	MyWriteBar bar = new MyWriteBar();
    	bar.setBar(""Sams"");
    	
    	Map beans = ognlUtil.getBeanMap(bar);
    	assertEquals(2, beans.size());
    	assertEquals(new Integer(""1""), beans.get(""id""));
    	assertEquals(""There is no read method for bar"", beans.get(""bar""));
    }

    /**
	 * XW-281
	 */
    public void testSetBigIndexedValue() {
        ValueStack stack = ActionContext.getContext().getValueStack();
        Map stackContext = stack.getContext();
        stackContext.put(ReflectionContextState.CREATE_NULL_OBJECTS, Boolean.FALSE);
        stackContext.put(ReflectionContextState.DENY_METHOD_EXECUTION, Boolean.TRUE);
        stackContext.put(XWorkConverter.REPORT_CONVERSION_ERRORS, Boolean.TRUE);

        User user = new User();
        stack.push(user);

        // indexed string w/ existing array
        user.setList(new ArrayList());

        String[] foo = new String[]{""asdf""};
        ((OgnlValueStack)stack).setDevMode(""true"");
        try {
            stack.setValue(""list.1114778947765"", foo);
            fail(""non-valid expression: list.1114778947765""); 
        }
        catch(RuntimeException ex) {
            ; // it's oke
        }
        
        try {
            stack.setValue(""1114778947765"", foo);
            fail(""non-valid expression: 1114778947765""); 
        }
        catch(RuntimeException ex) {
            ;
        }
        
        try {
            stack.setValue(""1234"", foo);
            fail(""non-valid expression: 1114778947765""); 
        }
        catch(RuntimeException ex) {
            ;
        }
        
        ((OgnlValueStack)stack).setDevMode(""false"");
        stack.setValue(""list.1114778947765"", foo);
        stack.setValue(""1114778947765"", foo);
        stack.setValue(""1234"", foo);
    }

    public void testAvoidCallingMethodsOnObjectClass() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setExcludedClasses(Object.class.getName());
            ognlUtil.setValue(""class.classLoader.defaultAssertionStatus"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(NoSuchPropertyException.class, expected.getClass());
        assertEquals(""com.opensymphony.xwork2.util.Foo.class"", expected.getMessage());
    }

    public void testAvoidCallingMethodsOnObjectClassUpperCased() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setExcludedClasses(Object.class.getName());
            ognlUtil.setValue(""Class.ClassLoader.DefaultAssertionStatus"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(NoSuchPropertyException.class, expected.getClass());
        assertEquals(""com.opensymphony.xwork2.util.Foo.Class"", expected.getMessage());
    }

    public void testAvoidCallingMethodsOnObjectClassAsMap() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setExcludedClasses(Object.class.getName());
            ognlUtil.setValue(""class['classLoader']['defaultAssertionStatus']"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(NoSuchPropertyException.class, expected.getClass());
        assertEquals(""com.opensymphony.xwork2.util.Foo.class"", expected.getMessage());
    }

    public void testAvoidCallingMethodsOnObjectClassAsMap2() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setValue(""foo['class']['classLoader']['defaultAssertionStatus']"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(NoSuchPropertyException.class, expected.getClass());
        assertEquals(""com.opensymphony.xwork2.util.Foo.foo"", expected.getMessage());
    }

    public void testAvoidCallingMethodsOnObjectClassAsMapWithQuotes() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setExcludedClasses(Object.class.getName());
            ognlUtil.setValue(""class[\""classLoader\""]['defaultAssertionStatus']"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(NoSuchPropertyException.class, expected.getClass());
        assertEquals(""com.opensymphony.xwork2.util.Foo.class"", expected.getMessage());
    }

    public void testAvoidCallingToString() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setValue(""toString"", ognlUtil.createDefaultContext(foo), foo, null);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(OgnlException.class, expected.getClass());
        assertEquals(""toString"", expected.getMessage());
    }

    public void testAvoidCallingMethodsWithBraces() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setValue(""toString()"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(InappropriateExpressionException.class, expected.getClass());
        assertEquals(expected.getMessage(), ""Inappropriate OGNL expression: toString()"");
    }

    public void testAvoidCallingSomeClasses() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setExcludedClasses(Runtime.class.getName());
            ognlUtil.setValue(""@java.lang.Runtime@getRuntime().exec('mate')"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(MethodFailedException.class, expected.getClass());
        assertEquals(expected.getMessage(), ""Method \""getRuntime\"" failed for object class java.lang.Runtime"");
    }

    public void testBlockSequenceOfExpressions() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.setValue(""#booScope=@myclass@DEFAULT_SCOPE,#bootScope.init()"", ognlUtil.createDefaultContext(foo), foo, true);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(OgnlException.class, expected.getClass());
        assertEquals(expected.getMessage(), ""Eval expressions/chained expressions have been disabled!"");
    }

    public void testCallMethod() throws Exception {
        Foo foo = new Foo();

        Exception expected = null;
        try {
            ognlUtil.callMethod(""#booScope=@myclass@DEFAULT_SCOPE,#bootScope.init()"", ognlUtil.createDefaultContext(foo), foo);
            fail();
        } catch (OgnlException e) {
            expected = e;
        }
        assertNotNull(expected);
        assertSame(OgnlException.class, expected.getClass());
        assertEquals(expected.getMessage(), ""It isn't a simple method which can be called!"");
    }

    public static class Email {
        String address;

        public void setAddress(String address) {
            this.address = address;
        }

        @Override
        public String toString() {
            return address;
        }
    }

    static class TestObject {
        private Integer myIntegerProperty;
        private Long myLongProperty;
        private String myStrProperty;

        public void setMyIntegerProperty(Integer myIntegerProperty) {
            this.myIntegerProperty = myIntegerProperty;
        }

        public String getMyIntegerProperty() {
            return myIntegerProperty.toString();
        }

        public void setMyLongProperty(Long myLongProperty) {
            this.myLongProperty = myLongProperty;
        }

        public Long getMyLongProperty() {
            return myLongProperty;
        }

        public void setMyStrProperty(String myStrProperty) {
            this.myStrProperty = myStrProperty;
        }

        public String getMyStrProperty() {
            return myStrProperty;
        }
    }

    class EmailAction {
        public List email = new OgnlList(Email.class);

        public List getEmail() {
            return this.email;
        }
    }

    class OgnlList extends ArrayList {
        private Class clazz;

        public OgnlList(Class clazz) {
            this.clazz = clazz;
        }

        @Override
        public synchronized Object get(int index) {
            while (index >= this.size()) {
                try {
                    this.add(clazz.newInstance());
                } catch (Exception e) {
                    throw new XWorkException(e);
                }
            }

            return super.get(index);
        }
    }
    
    private class MyWriteBar {
    	private int id;
    	
    	public int getId() {
    		return id;
    	}
    	
    	public void setBar(String name) {
    		if (""Sams"".equals(name))
    			id = 1;
    		else
    			id = 999;
    	}
    	
    }
}
",1
CVE-2016-8738,core/src/main/java/com/opensymphony/xwork2/validator/validators/URLValidator.java,"/*
 * Copyright 2002-2006,2009 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.opensymphony.xwork2.validator.validators;

import com.opensymphony.xwork2.validator.ValidationException;
import org.apache.commons.lang3.StringUtils;

import java.util.regex.Pattern;

/**
 * URLValidator checks that a given field is a String and a valid URL
 *
 * <pre>
 * &lt;validators&gt;
 *      &lt;!-- Plain Validator Syntax --&gt;
 *      &lt;validator type=""url""&gt;
 *          &lt;param name=""fieldName""&gt;myHomePage&lt;/param&gt;
 *          &lt;message&gt;Invalid homepage url&lt;/message&gt;
 *      &lt;/validator&gt;
 *
 *      &lt;!-- Field Validator Syntax --&gt;
 *      &lt;field name=""myHomepage""&gt;
 *          &lt;field-validator type=""url""&gt;
 *              &lt;message&gt;Invalid homepage url&lt;/message&gt;
 *          &lt;/field-validator&gt;
 *      &lt;/field&gt;
 * &lt;/validators&gt;
 * </pre>
 */
public class URLValidator extends FieldValidatorSupport {

    private String urlRegex;
    private String urlRegexExpression;

    public void validate(Object object) throws ValidationException {
        String fieldName = getFieldName();
        Object value = this.getFieldValue(fieldName, object);

        // if there is no value - don't do comparison
        // if a value is required, a required validator should be added to the field
        if (value == null || value.toString().length() == 0) {
            return;
        }

        if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex(), Pattern.CASE_INSENSITIVE).matcher(String.valueOf(value)).matches()) {
            addFieldError(fieldName, object);
        }
    }

    /**
     * This is used to support client-side validation, it's based on
     * http://stackoverflow.com/questions/161738/what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url
     *
     * @return regex to validate URLs
     */
    public String getUrlRegex() {
        if (StringUtils.isNotEmpty(urlRegexExpression)) {
            return (String) parse(urlRegexExpression, String.class);
        } else if (StringUtils.isNotEmpty(urlRegex)) {
            return urlRegex;
        } else {
            return ""^(https?|ftp):\\/\\/"" +
                    ""(([a-z0-9$_\\.\\+!\\*\\'\\(\\),;\\?&=-]|%[0-9a-f]{2})+"" +
                    ""(:([a-z0-9$_\\.\\+!\\*\\'\\(\\),;\\?&=-]|%[0-9a-f]{2})+)?"" +
                    ""@)?(#?"" +
                    "")((([a-z0-9]\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\.)*"" +
                    ""[a-z][a-z0-9-]*[a-z0-9]"" +
                    ""|((\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])\\.){3}"" +
                    ""(\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])"" +
                    "")(:\\d+)?"" +
                    "")(((\\/{0,1}([a-z0-9$_\\.\\+!\\*\\'\\(\\),;:@&=-]|%[0-9a-f]{2})*)*"" +
                    ""(\\?([a-z0-9$_\\.\\+!\\*\\'\\(\\),;:@&=-]|%[0-9a-f]{2})*)"" +
                    ""?)?)?"" +
                    ""(#([a-z0-9$_\\.\\+!\\*\\'\\(\\),;:@&=-]|%[0-9a-f]{2})*)?"" +
                    ""$"";
        }
    }

    public void setUrlRegex(String urlRegex) {
        this.urlRegex = urlRegex;
    }

    public void setUrlRegexExpression(String urlRegexExpression) {
        this.urlRegexExpression = urlRegexExpression;
    }

}
",0
CVE-2016-8738,core/src/main/java/com/opensymphony/xwork2/validator/validators/URLValidator.java,"/*
 * Copyright 2002-2006,2009 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.opensymphony.xwork2.validator.validators;

import com.opensymphony.xwork2.validator.ValidationException;
import org.apache.commons.lang3.StringUtils;

import java.util.regex.Pattern;

/**
 * URLValidator checks that a given field is a String and a valid URL
 *
 * <pre>
 * &lt;validators&gt;
 *      &lt;!-- Plain Validator Syntax --&gt;
 *      &lt;validator type=""url""&gt;
 *          &lt;param name=""fieldName""&gt;myHomePage&lt;/param&gt;
 *          &lt;message&gt;Invalid homepage url&lt;/message&gt;
 *      &lt;/validator&gt;
 *
 *      &lt;!-- Field Validator Syntax --&gt;
 *      &lt;field name=""myHomepage""&gt;
 *          &lt;field-validator type=""url""&gt;
 *              &lt;message&gt;Invalid homepage url&lt;/message&gt;
 *          &lt;/field-validator&gt;
 *      &lt;/field&gt;
 * &lt;/validators&gt;
 * </pre>
 */
public class URLValidator extends FieldValidatorSupport {

    private String urlRegex;
    private String urlRegexExpression;

    public void validate(Object object) throws ValidationException {
        String fieldName = getFieldName();
        Object value = this.getFieldValue(fieldName, object);

        // if there is no value - don't do comparison
        // if a value is required, a required validator should be added to the field
        if (value == null || value.toString().length() == 0) {
            return;
        }

        if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex(), Pattern.CASE_INSENSITIVE).matcher(String.valueOf(value).trim()).matches()) {
            addFieldError(fieldName, object);
        }
    }

    /**
     * This is used to support client-side validation, it's based on
     * http://stackoverflow.com/questions/161738/what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url
     *
     * @return regex to validate URLs
     */
    public String getUrlRegex() {
        if (StringUtils.isNotEmpty(urlRegexExpression)) {
            return (String) parse(urlRegexExpression, String.class);
        } else if (StringUtils.isNotEmpty(urlRegex)) {
            return urlRegex;
        } else {
            return ""^(https?|ftp):\\/\\/"" +
                    ""(([a-z0-9$_\\.\\+!\\*\\'\\(\\),;\\?&=-]|%[0-9a-f]{2})+"" +
                    ""(:([a-z0-9$_\\.\\+!\\*\\'\\(\\),;\\?&=-]|%[0-9a-f]{2})+)?"" +
                    ""@)?(#?"" +
                    "")((([a-z0-9]\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\.)*"" +
                    ""[a-z][a-z0-9-]*[a-z0-9]"" +
                    ""|((\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])\\.){3}"" +
                    ""(\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])"" +
                    "")(:\\d+)?"" +
                    "")(((\\/{0,1}([a-z0-9$_\\.\\+!\\*\\'\\(\\),;:@&=-]|%[0-9a-f]{2})*)*"" +
                    ""(\\?([a-z0-9$_\\.\\+!\\*\\'\\(\\),;:@&=-]|%[0-9a-f]{2})*)"" +
                    ""?)?)?"" +
                    ""(#([a-z0-9$_\\.\\+!\\*\\'\\(\\),;:@&=-]|%[0-9a-f]{2})*)?"" +
                    ""$"";
        }
    }

    public void setUrlRegex(String urlRegex) {
        this.urlRegex = urlRegex;
    }

    public void setUrlRegexExpression(String urlRegexExpression) {
        this.urlRegexExpression = urlRegexExpression;
    }

}
",1
